C  XFLASH.F - COMPOSITIONAL MODEL FLASH CALCULATIONS 
C  CODE HISTORY:

C  RICK DEAN     03/13/2001   INITIAL CODE
C  S. G. THOMAS  09/01/2007   ADDED MODS FOR THERMAL, VISCOSITY ARRAY

C***********************************************************************
      SUBROUTINE EOS_WORK(XNCINPH,XINITIAL,XIWRT,XNHC,XNC,XNPH,XICINPH,
     &                    N_TCOFX,N_TCOFY,N_TCOFZ,N_MDENX,XKUPDATE,
     &                    XRESTART,XLRESTART,IFTCALC)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xarydat.h'
      INCLUDE 'xbaldat.h'
      INCLUDE 'xthermal.h'
$POWER      INCLUDE 'msjunk.h'
C***********************************************************************
C     INTERFACE FOR COMPOSITIONAL ROUTINES FOR GRID-BASED DATA
C
C  INPUT:
C        XNCINPH =   NUMBER OF COMPONENTS SUMMED OVER ALL PHASES
C        XINITIAL =  .TRUE.; FLASH AT INITIALIZATION (adjust fluid amounts)
C                    .FALSE.; REGULAR FLASH
C        XIWRT =     UNIT NUMBER FOR PRINTING
C        XNHC =      NUMBER OF HYDROCARBON COMPONENTS         
C        XNP =       NUMBER OF POINTS TO FLASH
C        XNC =       NUMBER OF COMPONENTS
C        XNPH =      MAXIMUM NUMBER OF PHASES
C        XICINPH($MXCOMP+1,$MXPHASE) = COMPONENTS ALLOWED IN EACH PHASE
C        N_TCOFX =    POINTER FOR TRANSMISSIBILITY 
C        N_TCOFY =    POINTER FOR TRANSMISSIBILITY 
C        N_TCOFZ =    POINTER FOR TRANSMISSIBILITY 
C        N_MDENX =    POINTER FOR FLUID DENSITY
C        XRESTART =  .TRUE.; FIRST CALL TO FLASH FOR RESTART RUN
C        XLRESTART = .TRUE.; FLASH DERIVATIVES SAVED TO RESTART FILE
C        IFTCALC =   .TRUE.; INTERFACIAL TENSIONS CALCULATED
C        
C-----------------------------------------------------------------------
C     Arguments for Named Common
C---------------------------------------------------------------------
      INTEGER NPH,IWRT,NHC,NCINPH,NC,NP,ICINPH($MXCOMP+1,$MXPHASE)
      LOGICAL INITIAL,VIS_CALC,GRID,KUPDATE,RESTART,LRESTART,IFTCALC
      INTEGER XNPH,XIWRT,XNHC,XNCINPH,XNC,XICINPH($MXCOMP+1,$MXPHASE)
      LOGICAL XINITIAL,XKUPDATE,XRESTART,XLRESTART,JIFT
      COMMON/PASSCOMP/NPH,IWRT,NHC,NCINPH,NP,NC,ICINPH,
     &                INITIAL,VIS_CALC,GRID,KUPDATE,RESTART,LRESTART,
     &                JIFT
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER N_TCOFX,N_TCOFY,N_TCOFZ,N_MDENX
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      LOGICAL ONCEONLY
      INTEGER I,IC,IVEC(25)
      EXTERNAL EOS_DRIVE
      DATA ONCEONLY/.TRUE./
      SAVE IVEC

C-------set values for named common
      CALL TIMON(20)
      NPH = XNPH
      IWRT = XIWRT
      NHC = XNHC
      NCINPH = XNCINPH
      NP = 0
      NC = XNC
      DO I = 1,NPH
         DO IC = 1,NC
            ICINPH(IC,I) = XICINPH(IC,I)
         END DO
      END DO
      INITIAL = XINITIAL
      RESTART = XRESTART
      LRESTART = XLRESTART
      VIS_CALC = .TRUE.
      GRID = .TRUE.
      KUPDATE = XKUPDATE
      JIFT = IFTCALC

      IF(ONCEONLY) THEN
         ONCEONLY = .FALSE.
         IVEC(1) = 24
         IVEC(2) = N_PRES
         IVEC(3) = N_CONC
         IVEC(4) = N_DSTDP
         IVEC(5) = N_DSTDN
         IVEC(6) = N_SAT
         IVEC(8) = N_MOB
         IVEC(9) = N_XVISC
         IVEC(10) = N_PMD
         IVEC(11) = N_FLDPNT
         IVEC(12) = N_CTAB
         IVEC(13) = N_TEMPR
         IVEC(14) = N_FLZ
         IVEC(15) = N_FLV
         IVEC(16) = N_FLOLDZP
         IVEC(17) = N_FLDERIV
         IVEC(18) = N_FLFUG
         IVEC(19) = N_FLRR
         IVEC(20) = N_FLK
         IVEC(21) = N_TCOFX
         IVEC(22) = N_TCOFY
         IVEC(23) = N_TCOFZ
         IVEC(24) = N_ERRSAT
         IVEC(25) = N_TENS
      ENDIF
      IVEC(7) = N_MDENX

      CALL CALLWORK(EOS_DRIVE,IVEC)

      CALL TIMOFF(20)
      END

C***********************************************************************
      SUBROUTINE EOS(P,CONC,SAT,MDEN,INVISC,PMD,XNCINPH,
     &               XVIS_CALC,XIWRT,XNHC,IFLPNT,IEOSTL,
     &               XNC,XNPH,XICINPH,TEMPR,FLZF,FLV,FLK)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
      INCLUDE 'xarydat.h'
$POWER      INCLUDE 'msjunk.h'
C***********************************************************************
C     INTERFACE FOR COMPOSITIONAL ROUTINES FOR NONGRID-BASED DATA
C
C  INPUT:
C        P =     PRESSURE 
C        XNCINPH =   NUMBER OF COMPONENTS SUMMED OVER ALL PHASES
C        XVIS_CALC = .TRUE.; VISCOSITIES CALCULATED
C                    .FALSE.; VISCOSITIES NOT CALCULATED
C        XIWRT =     UNIT NUMBER FOR PRINTING
C        XNHC =      NUMBER OF HYDROCARBON COMPONENTS         
C        IEOSTL = TABLE ASSIGNMENT 
C        TEMPR =  TEMPERATURE 
C        XNC =       NUMBER OF COMPONENTS
C        XNPH =      MAXIMUM NUMBER OF PHASES
C        XICINPH($MXCOMP+1,$MXPHASE) = COMPONENTS ALLOWED IN EACH PHASE
C
C  INPUT/OUTPUT:
C        CONC(NC) = COMPOSITION CONCENTRATIONS (mod. for initialization)
C        SAT(NPH) = SATURATIONS (Sw input for initialization)
C        IFLPNT =  POINTER FOR FLUID TYPE
C                  SET TO IFLINIT TO FORCE STABILITY TEST
C        FLZF(3) =  Z-FACTORS FOR TWO HYDROCARBON PHASES
C        FLK(NHC) =  K-VALUES 
C
C  OUTPUT:
C        MDEN(NPH) = MASS DENSITIES OF PHASES 
C        INVISC(NPH) =  VISCOSITIES (if XVIS_CALC = true)
C        PMD(NICINPH) = PRODUCT OF MOLE FRACTIONS AND MOLAR DENSITIES
C        
C-----------------------------------------------------------------------
C     Arguments for Named Common
C---------------------------------------------------------------------
      INTEGER NPH,IWRT,NHC,NCINPH,NC,NP,ICINPH($MXCOMP+1,$MXPHASE)
      LOGICAL INITIAL,VIS_CALC,GRID
      INTEGER XNPH,XIWRT,XNHC,XNCINPH,XNC,
     &        XICINPH($MXCOMP+1,$MXPHASE)
      LOGICAL XVIS_CALC,KUPDATE,RESTART,LRESTART,JIFT
      COMMON/PASSCOMP/NPH,IWRT,NHC,NCINPH,NP,NC,ICINPH,
     &                INITIAL,VIS_CALC,GRID,KUPDATE,RESTART,LRESTART,
     &                JIFT
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER IFLPNT,IEOSTL
      REAL*8 P,PMD(NCINPH),MDEN(NPH),CONC(NC),TEMPR,SAT(NPH),
     &       INVISC(NPH),FLZF(3),FLV(2),FLK(NHC)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER I,IC
      REAL*8 DUM,DSTDN(NC),DSTDP,ERRSAT
 
C     FOLLOWING VARIABLES SAVED TO SPEED UP FLASH FOR REPEATED CALLS
      INTEGER NEXTDIM,NEXTDIM1,NEXTDIM2
      PARAMETER (NEXTDIM1 = $MXCOMP**2+5*$MXCOMP+1)
      PARAMETER (NEXTDIM2 = ($MXCOMP+1)*$MXCOMP/2)
      PARAMETER (NEXTDIM = NEXTDIM1+NEXTDIM2)
      REAL*8  FLOLDZP($MXCOMP+1),FLRR($MXCOMP+1),FLDERIV(NEXTDIM),
     &        FLFUG($MXCOMP)
      SAVE FLOLDZP,FLRR,FLDERIV,FLFUG

C-------set values for named common
      NPH = XNPH
      IWRT = XIWRT
      NHC = XNHC
      NCINPH = XNCINPH
      NP = 1
      NC = XNC
      KUPDATE = .FALSE.
      JIFT = .FALSE.
      DO I = 1,NPH
         DO IC = 1,NC
            ICINPH(IC,I) = XICINPH(IC,I)
         END DO
      END DO
      INITIAL = .FALSE.
      RESTART = .FALSE.
      LRESTART = .FALSE.
      VIS_CALC = XVIS_CALC
      GRID = .FALSE.
      DUM = ONE
      CALL EOS_DRIVE(1,1,1,1,1,1,1,1,1,1,1,1,P,CONC,DSTDP,
     &               DSTDN,SAT,MDEN,INVISC,DUM,PMD,IFLPNT,
     &               IEOSTL,TEMPR,FLZF,FLV,FLOLDZP,FLDERIV,
     &               FLFUG,FLRR,FLK,DUM,DUM,DUM,ERRSAT,DUM)
      END

C***********************************************************************
      SUBROUTINE EOS_DRIVE(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
     &                     KL2,KEYOUT,NBLK,P,CONC,DSTDP,DSTDN,SAT,MDEN,
     &                     INVISC,XVISC,PMD,IFLPNT,IEOSTL,TEMPR,FLZF,
     &                     FLV,FLOLDZP,FLDERIV,FLFUG,FLRR,EK,TCOFX,
     &                     TCOFY,TCOFZ,ERRSAT,TENS)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'xiter.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xresprop.h'
      INTEGER NPH,IWRT,NHC,NCINPH,NC,NP,ICINPH($MXCOMP+1,$MXPHASE)
      LOGICAL INITIAL,VIS_CALC,GRID,KUPDATE,RESTART,LRESTART,JIFT
      COMMON/PASSCOMP/NPH,IWRT,NHC,NCINPH,NP,NC,ICINPH,
     &                INITIAL,VIS_CALC,GRID,KUPDATE,RESTART,LRESTART,
     &                JIFT
C----------------------------------------------------------------------- 
C Definitions
C----------------------------------------------------------------------- 
C P(I)      = PRESSURE IN CELL I (PSI). (INPUT)
C CONC(I,K) = CONC OF COMPONENT K IN CELL I. FOR WELL CALCULATIONS, CONC(I,K)
C             IS THE CONC RATE OF COMPONENT K IN WELL I. (INPUT)
C DSTDP(I)   = DERIV. OF TOTAL SATURATION WITH RESPECT TO PRESSURE IN CELL I.
C                (OUTPUT)
C DSTDN(I,K) = DERIV. OF TOTAL SATURATION WITH RESPECT TO CONC K IN CELL I.
C                (OUTPUT)
C SAT(I,K)     = SATURATION OF PHASE K IN CELL I. (OUTPUT, BUT ALSO INPUT WHEN
C                INITIAL IS TRUE)
C MDEN(I,K)    = DENSITY GRADIENT FOR PHASE K IN CELL I (PSI/FT). (OUTPUT)
C INVISC(I,K)  = 1 / VISCOSITY FOR PHASE K. ONLY CALCULATES INVISC IF VIS_CALC
C                IS TRUE (1/CP) (OUTPUT)
C                ONLY CALCULATE FOR MULTIPLE_CELL CALCULATIONS
C XVISC(I,K)   = VISCOSITY FOR PHASE K. (CP) (OUTPUT). ONLY FOR GRID-BASED.
C PMD(I,L)     = PARTIAL MOLAR DENSITY OF MASS IN PHASE FOR CELL I.
C                L VALUE IS DETERMINED BY ICINPH POINTER. UNITS FOR PMD
C                ARE MOLE/RCF  (OUTPUT)
C NPH     = NUMBER OF PHASES IN SYSTEM (MAX 3).
C NCINPH =  SUM OF NUMBER OF NUMBER OF COMPONENTS IN ALL PHASES (INPUT)
C NDIM   = LEADING DIMENSION FOR RESERVOIR OR WELL VARIABLES (INPUT).
C INITIAL = TRUE FOR MULTIPLE_CELL INITIALIZATION, FALSE OTHERWISE (INPUT)
C VIS_CALC = TRUE FOR VISCOSITY CALCULATION, FALSE OTHERWISE  (INPUT)
C KUPDATE = TRUE IF K-VALUES UPDATED FOR PRESSURE AND CONCENTRATION CHANGES
C IWRT    = UNIT NUMBER FOR PRINTING DEBUGGING INFORMATION.
C JIFT = TRUE IF INTERFACIAL TENSIONS CALCULATED.
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,IL1,IL2,KL1,KL2,JL1V(KDIM),JL2V(KDIM),
     &        IFLPNT(IDIM*JDIM*KDIM),IEOSTL(IDIM*JDIM*KDIM),
     &        KEYOUT(IDIM*JDIM*KDIM),NBLK,LDIM,IERR
      REAL*8 P(IDIM*JDIM*KDIM),
     &       PMD(IDIM*JDIM*KDIM,NCINPH),TEMPR(IDIM*JDIM*KDIM),
     &       DSTDP(IDIM*JDIM*KDIM),CONC(IDIM*JDIM*KDIM,NC),
     &       DSTDN(IDIM*JDIM*KDIM,NC),FLZF(IDIM*JDIM*KDIM,*),
     &       SAT(IDIM*JDIM*KDIM,NPH),MDEN(IDIM*JDIM*KDIM,NPH),
     &       INVISC(IDIM*JDIM*KDIM,NPH),XVISC(IDIM*JDIM*KDIM,NPH),
     &       FLDERIV(IDIM*JDIM*KDIM,*),FLV(IDIM*JDIM*KDIM,*),
     &       FLOLDZP(IDIM*JDIM*KDIM,*),FLFUG(IDIM*JDIM*KDIM,*),
     &       FLRR(IDIM*JDIM*KDIM,*),ERRSAT(IDIM*JDIM*KDIM),
     &       TCOFX(IDIM*JDIM*KDIM),TCOFY(IDIM*JDIM*KDIM),
     &       TCOFZ(IDIM*JDIM*KDIM),EK(IDIM*JDIM*KDIM,*),
     &       TENS(IDIM*JDIM*KDIM)
C-----------------------------------------------------------------------
C     Local Arguments
C----------------------------------------------------------------------- 
      LOGICAL TEST_ALL_TEMP,NBR_K_TEMP
      INTEGER IHC,NDIM,FLTYPE(MXFLTYPE),I,J,NDIM1,NDIM2
!     INTEGER IFLD(IDIM*JDIM*KDIM)
!      REAL*8 Z(IDIM*JDIM*KDIM,NHC),HCTOTL(IDIM*JDIM*KDIM),
!     &       WTOTL(IDIM*JDIM*KDIM)

! bag8
      INTEGER, ALLOCATABLE :: IFLD(:)
      REAL*8, ALLOCATABLE :: Z(:,:),HCTOTL(:),WTOTL(:)
! bag8
C-----------------------------------------------------------------------

! bag8
      ALLOCATE(IFLD(IDIM*JDIM*KDIM),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate IFLD'
      ALLOCATE(Z(IDIM*JDIM*KDIM,NHC),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate Z'
      ALLOCATE(HCTOTL(IDIM*JDIM*KDIM),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate HCTOTL'
      ALLOCATE(WTOTL(IDIM*JDIM*KDIM),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate WTOTL'
! bag8

C-------make local copies of various flags
      NDIM = IDIM*JDIM*KDIM
      IF(NP == 0 .OR. NBLK > 1) NP = NDIM
      TEST_ALL_TEMP = (TESTALL .OR. .NOT.GRID .OR. INITIAL)
      NBR_K_TEMP = (BORROW_K .AND. GRID .AND. NP > 1)

C-------stability test all points
      IF ( NDIM <= 1 ) TEST_ALL_TEMP = .TRUE.

      IF(TEST_ALL_TEMP) NBR_K_TEMP = .FALSE.

C-------perform initial processing
C       set up Z, HCTOTL, WTOTL, and IFLD
      CALL EOS_START(INITIAL,CONC,Z,NHC,KEYOUT,NP,HCTOTL,WTOTL,
     &               IFLPNT,IFLD,FLTYPE,NC,NDIM,SAT,TEMPR)

C-------perform calculations
      IHC = MAX(ICINPH(2,2),1)
      NDIM1 = 1
      NDIM2 = 1
      IF(NPH > 2) NDIM1 = NP
      IF(NPH > 1) NDIM2 = NP

      CALL EOS_EXEC(P,Z,PMD,PMD(1,IHC),SAT,MDEN,INVISC,XVISC,DSTDP,
     &              DSTDN,MDENH,IFLD,IEOSTL,TEMPR,FLZF,FLV,
     &              FLOLDZP,FLDERIV,FLFUG,FLRR,HCTOTL,WTOTL,NC,NDIM,
     &              NCINPH,NPH,NHC,NP,INITIAL,VIS_CALC,
     &              TEST_ALL_TEMP,NBR_K_TEMP,IWRT,LTCOMP,FLTYPE,
     &              NEG_FLASH,TOL_FLASH,TOL_RR,TOL_TRIV,PARTIALJAC,
     &              TOL_ZFAC,TOL_SAT,MAXFLITS,NWRKSZE,IWRK,IDIM,JDIM,
     &              KDIM,IL1,IL2,KL1,KL2,JL1V,JL2V,TCOFX,TCOFY,TCOFZ,
     &              ERRSAT,EK,CONC,NBLK,KUPDATE,RESTART,LRESTART,
     &              NDIM1,NDIM2,TENS,JIFT)

C-------perform final processing
      CALL EOS_FINISH(P,FLTYPE,DSTDP,DSTDN,PMD,SAT,MDEN,INVISC,
     &                XVISC,VIS_CALC,NHC,NPH,NCINPH,NC,NP,NDIM,
     &                IFLPV0,IFLD,TEMPR,IFLPNT,TENS,JIFT)

      IF(TIM >= DUMPTIME1 .AND. NDIM >= IDUMP .AND.
     &   TIM <= DUMPTIME2 .AND. IDUMP > 0) THEN
         I = IDUMP  
         WRITE(NFBUG,*) ' DUMP CELL ',I,' AT TIME ',TIM
         WRITE(NFBUG,*) '    DSTDN ',(DSTDN(I,IHC),IHC=1,NPH)
         WRITE(NFBUG,*) '    SAT ',(SAT(I,IHC),IHC=1,NPH)
         WRITE(NFBUG,*) '    P ',P(I)
         WRITE(NFBUG,*) '    CONC ',(CONC(I,IHC),IHC=1,NC)
         WRITE(NFBUG,*) '    ERRSAT ',ERRSAT(I)
         IF(NPH > 2) THEN
            WRITE(NFBUG,*) '    V ',(FLV(I,IHC),IHC=1,2)
            WRITE(NFBUG,*) '    ZF ',(FLZF(I,IHC),IHC=1,3)
            WRITE(NFBUG,*) '    EK ',(EK(I,IHC),IHC=1,NHC)
            WRITE(NFBUG,*) '    FUG ',(FLFUG(I,IHC),IHC=1,NHC)
            WRITE(NFBUG,*) '    RR ',(FLRR(I,IHC),IHC=1,NHC+1)
         ELSEIF(NPH > 1) THEN
            WRITE(NFBUG,*) '    ZF ',FLZF(I,1)
         ENDIF
      ENDIF

! bag8
      DEALLOCATE(IFLD)
      DEALLOCATE(Z)
      DEALLOCATE(HCTOTL)
      DEALLOCATE(WTOTL)
! bag8
      END
 
C***********************************************************************
      SUBROUTINE EOS_START(INITIAL,CONC,Z,NHC,KEYOUT,NP,HCTOTL,WTOTL,
     &                     IFLPNT,IFLD,FLTYPE,NC,NDIM,WSAT,TEMPR)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      LOGICAL INITIAL
      INTEGER NHC,NP,NDIM,NC,FLTYPE(MXFLTYPE),IFLPNT(NDIM),IFLD(NP),
     &        KEYOUT(NDIM)
      REAL*8 CONC(NDIM,NC),Z(NDIM,NHC),WSAT(NDIM),TEMPR(NDIM),
     &       HCTOTL(NP),WTOTL(NP)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER I,MM,I2,I3,I5,I6,I7,IC,LC,J,IERR
!      REAL*8 SCR(NP)
!      INTEGER IPNT3(NP),IPNT5(NP),IPNT6(NP),IPNT7(NP)

! bag8
      REAL*8, ALLOCATABLE :: SCR(:)
      INTEGER, ALLOCATABLE :: IPNT3(:),IPNT5(:),IPNT6(:),IPNT7(:)
! bag8

C ----------------------------------------------------------------------
C  SETS UP FLUID VECTOR IFLD USING GRID-BASED IFLPNT
C  OUTPUT: Z -      HC MOLE FRACTION FOR A CELL
C          FLTYPE - NUMBER OF CELLS IN EACH FLUID TYPE
C          IFLD -   POINTER FROM FLUID ORDER TO GRID ORDER
C          HCTOTL - TOTAL HC MOLES FOR A CELL
C          WTOTL -  TOTAL MOLES OF WATER FOR A CELL 
C ----------------------------------------------------------------------

! bag8
      ALLOCATE(SCR(NP),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate SCR'
      ALLOCATE(IPNT3(NP),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate IPNT3'
      ALLOCATE(IPNT5(NP),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate IPNT5'
      ALLOCATE(IPNT6(NP),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate IPNT6'
      ALLOCATE(IPNT7(NP),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate IPNT7'
! bag8

C-------setup fluid types
      DO I = 1,10
         FLTYPE(I) = 0
      END DO
      I2 = 0
      I3 = 0
      I5 = 0
      I6 = 0
      I7 = 0
      DO I = 1,NP
         IF(KEYOUT(I) == 1) THEN
            IF(IFLPNT(I) == 2) THEN
               I2 = I2 + 1
               IFLD(I2) = I
            ELSEIF(IFLPNT(I) == 3) THEN
               I3 = I3 + 1
               IPNT3(I3) = I
            ELSEIF(IFLPNT(I) == 5) THEN
               I5 = I5 + 1
               IPNT5(I5) = I
            ELSE
               I6 = I6 + 1
               IPNT6(I6) = I
            ENDIF
            TEMPR(I) = TEMPR(I) + TRF
         ELSE
            I7 = I7 + 1
            IPNT7(I7) = I
         ENDIF
      END DO
      FLTYPE(2) = I2
      FLTYPE(3) = I3
      FLTYPE(5) = I5
      FLTYPE(6) = I6
      FLTYPE(7) = I7
      MM = I2
      DO I = 1,I3
         MM = MM + 1
         IFLD(MM) = IPNT3(I)
      END DO
      DO I = 1,I5
         MM = MM + 1
         IFLD(MM) = IPNT5(I)
      END DO
      DO I = 1,I6
         MM = MM + 1
         IFLD(MM) = IPNT6(I)
      END DO
      DO I = 1,I7
         MM = MM + 1
         IFLD(MM) = IPNT7(I)
      END DO
      IF(INITIAL) THEN
         DO I = 1,I7
            J = IPNT7(I)
            IFLPNT(J) = 7
         END DO
      ENDIF

      IF(NHC > 0) THEN
         DO I = 1,NP
            IF(KEYOUT(I) == 1) THEN
               HCTOTL(I) = CONC(I,2)
            ELSE
               HCTOTL(I) = ONE
            ENDIF
         END DO
      ELSE
         DO I = 1,NP
            HCTOTL(I) = ONE
         END DO
      ENDIF
      DO IC = 3,NC
         DO I = 1,NP
            IF(KEYOUT(I) == 1) THEN
               HCTOTL(I) = HCTOTL(I) + CONC(I,IC)
            ENDIF
         END DO
      END DO

c-------setup z as mole fraction of HC
      DO I = 1,NP
         SCR(I) = ONE/MAX(HCTOTL(I),SMALL)
      END DO
      DO IC = 1,NHC
         LC = IC + 1
         DO I = 1,NP
            Z(I,IC) = MAX(CONC(I,LC)*SCR(I),SMALL)
         END DO
      END DO

      IF (.NOT.INITIAL) THEN
         DO I = 1,NP
            IF(KEYOUT(I) == 1) THEN
               WTOTL(I) = CONC(I,1)
            END IF
         END DO
      ELSE
         DO I = 1,NP
            WTOTL(I) = WSAT(I)
            IF (WTOTL(I) > 0.999D0)   THEN
               WTOTL(I)  = ONE
               HCTOTL(I) = ZERO
            ELSE
               HCTOTL(I) = ONE
            ENDIF
         END DO
      ENDIF

C-------set values for zero pv cells
      MM = FLTYPE(2) + FLTYPE(3) + FLTYPE(5) + FLTYPE(6) + 1
      DO I = MM,MM+FLTYPE(7)-1
         J = IFLD(I)
         HCTOTL(J) = ZERO
         WTOTL(J)  = ZERO
      END DO

! bag8
      DEALLOCATE(SCR)
      DEALLOCATE(IPNT3)
      DEALLOCATE(IPNT5)
      DEALLOCATE(IPNT6)
      DEALLOCATE(IPNT7)
! bag8

      END
 
C***********************************************************************
      SUBROUTINE EOS_EXEC(P,Z,PMDW,PMD,SAT,MDEN,INVISC,XVISC,DSTDP,
     &                    DSTDN,MDENH,IFLD,IEOSTL,TEMPR,FLZF,FLV,
     &                    FLOLDZP,FLDERIV,FLFUG,FLRR,HCTOTL,WTOTL,NC,
     &                    NDIM,NCINPH,NPH,NHC,NP,INITIAL,VIS_CALC,
     &                    TEST_GLOBAL,NBR_K,IWRT,LTCOMP,FLTYPE,
     &                    NEG_FLASH,TOL_FLASH,TOL_RR,TOL_TRIV,
     &                    PARTIALJAC,TOL_ZFAC,TOL_SAT,MAXFLITS,NWRKSZE,
     &                    IWRK,IDIM,JDIM,KDIM,IL1,IL2,KL1,KL2,JL1V,
     &                    JL2V,TCOFX,TCOFY,TCOFZ,ERRSAT,EK,CONC,NBLK,
     &                    KUPDATE,RESTART,LRESTART,NDIM1,NDIM2,TENS,
     &                    IFTCALC)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
      INCLUDE 'xresprop.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NP,NPH,NC,NCOUNT,NBLK,NDIM,IWRT,NCINPH,
     &        FLTYPE(MXFLTYPE),
     &        MAXFLITS,NWRKSZE,IWRK(12),LTCOMP,NDIM1,NDIM2,
     &        IDIM,JDIM,KDIM,IL1,IL2,KL1,KL2,JL1V(KDIM),JL2V(KDIM)
      PARAMETER (NCOUNT = 500)
      LOGICAL INITIAL,VIS_CALC,TEST_GLOBAL,NBR_K,NEG_FLASH,PARTIALJAC,
     &        KUPDATE,RESTART,LRESTART,IFTCALC
      REAL*8 MDENH,TCOFX(NDIM),TCOFY(NDIM),TCOFZ(NDIM)
      INTEGER IEOSTL(NP),IFLD(NP)
      REAL*8 TOL_FLASH,TOL_RR,TOL_TRIV,TOL_ZFAC,TOL_SAT
      REAL*8 FLZF(NDIM,3),FLV(NDIM,2),FLOLDZP(NDIM,NHC+1),
     &       FLRR(NDIM,NHC+1),FLFUG(NDIM,NHC),EK(NDIM,NHC),
     &       FLDERIV(NDIM,NHC**2+((NHC+1)*NHC)/2+5*NHC+1)
      REAL*8 DSTDP(NDIM),P(NDIM),TEMPR(NDIM),CONC(NDIM,NC),
     &       Z(NDIM,NHC),DSTDN(NDIM,NC),PMDW(NDIM),PMD(NDIM,*),
     &       SAT(NDIM,NPH),INVISC(NDIM,NPH),XVISC(NDIM,NPH),
     &       MDEN(NDIM,NPH),ERRSAT(NDIM),HCTOTL(NDIM),WTOTL(NDIM),
     &       TENS(NDIM)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER I,IP,N2PH,NUM,L,NFLASH,NSMALL,NEW1P,NEW2P,KK,IC,
     &     NMOV,NEGUP,N1PH,NAQF,NFUL2P,NPAR2P,NTEST,
     &     NCON1P,M,NUPD1P,NEW,NACT,NMOV1,NMOV5,NUPD2P,NDUM,NTOP,NBOT,
     &     NUPDATE,NCP1,NC2,NHCP,JNORM,JV,JVOLD,
     &     JXDZ,JSBINV,JDFUGDN,JDFUGDP,JEJAC,JDIAG,
     &     JHJAC,JCOEFN,JCOEFW,JADOIL,JAPOIL,
     &     JBPOIL,JCPOIL,JPRLOGO,JADGAS,JAPGAS,JBPGAS,
     &     JCPGAS,JPRLOGG,ICOUNT_EOSEXEC,IERR
      LOGICAL TEST_ALL,FIRST_PASS
      REAL*8 DUM,EPS
!      REAL*8 VOIL(NDIM1),WORK(NP,NWRKSZE),VGAS(NDIM1),VHC(NDIM2)

! bag8
      REAL*8, ALLOCATABLE :: VOIL(:),WORK(:,:),VGAS(:),VHC(:)
! bag8

      DATA ICOUNT_EOSEXEC/0/
      SAVE ICOUNT_EOSEXEC
C ----------------------------------------------------------------------
C  THIS IS A DRIVER ROUTINE FOR EOS FLUID PROPERTY CALCULATIONS
C ----------------------------------------------------------------------
C  DEFINITION OF INPUT/OUTPUT:
C     IFLD  - POINTER TO GRID POINT ASSOCIATED WITH FLUID TYPE
C             ALL FLTYPE(1) ORDERED FIRST, ETC.
C             EXCEPT FLTYPE(8) COMES AFTER FLTYPE(4) AND BEFORE FLTYPE(5)
C     HCTOTL- TOTAL HYDROCARBON MOLES
C     WTOTL - INPUT VALUES ARE THE MOLES OF WATER PHASE COMPONENTS
C     Z     - OVERALL HYDROCARBON MOLE FRACTIONS
C     P     - PRESSURE
C     ZF(1) - Z-FACTOR FOR LIQUID 
C     ZF(2) - Z-FACTOR FOR VAPOR
C     ZF(3) - Z-FACTOR FROM STABILITY TEST VALUE
C     V     - CURRENT MOLE FRACTION OF VAPOR PHASE
C     VOLD  - PREVIOUS MOLE FRACTION OF VAPOR PHASE
C     EK    - EQUILIBRIUM CONSTANTS
C     XDZ   - X(I)/Z(I)
C     SBINV -  DERIVATIVE OF RACHFORD-RICE EQUATION
C     EJAC  - SYMMETRIC PART OF JACOBIAN CORRESPONDING TO DERIVATIVES
C             OF FUGACITIES W.R.T. LOG(K(I)).
C     DFUGDN- DERIVATIVES OF FUGACITIES W.R.T. N(I)
C     DFUGDP- DERIVATIVES OF FUGACITIES W.R.T. P
C     COEFW - DERIVATIVES OF SATURATION CONSTRAINT W.R.T. LOG(K(I)) AND V.
C     RES   - RESIDUES OF FUGACITY EQUATIONS
C     INVISC- INVERSE OF VISCOSITY ARRAYS
C     XVISC - VISCOSITY ARRAYS
C     MDEN  - MASS DENSITY ARRAYS
C     SAT   - SATURATION ARRAYS
C     X     - MOLE FRACTION OF LIQUID (PASSED AS PMD)
C     Y     - MOLE FRACTION OF VAPOR (PASSED AS PMD)
C     FLTYPE(I)- IS THE NUMBER OF POINTS OF TYPE I, I=1,..,10
C                1. TWO-PHASE JACOBIAN CONSTANT (WILL NOT UPDATE)
C                2. TWO-PHASE JACOBIAN WILL BE UPDATED
C                3. ONE PHASE CHECKED BY NEGATIVE FLASH
C                4. ONE-PHASE CHECKED BY STABILITY TEST CALCULATION
C                8. ONE PHASE CELLS  (CONVERGED FROM STABILITY TEST)
C                5. ONE-PHASE NOT TESTED (WAS SINGLE-PHASE LAST CALL AND
C                   DO NOT HAVE TWO-PHASE NEIGHBOR)
C                6. AQUIFER CELLS
C                7. ZERO PV CELLS 
C                9. TEMPORARY RECLASSIFICATION IN EOS_CHECK_NEBR
C                10. TEMPORARY RECLASSIFICATION IN EOS_CHECK_NEBR
C     NOTE: ONLY NONZERO VALUES OF FLTYPE AT START OF EOS_EXEC ARE 2,3,5,6,7
C           FLTYPE(2) MERGED INTO FLTYPE(3) IF FIRST PASS
C           FLYTPE(4) MERGED INTO FLTYPE(3) IF PREDICTED TO BE 2-PHASE
C           FLASH ROUTINE PERFORMED ONLY FOR FLTYPE(3) CELLS
C     TOL_FLASH - TOLERANCE FOR FUGACITY CALCULATION (EOS_FLASH)
C     TOL_RR    - TOLERANCE FOR RACHFORD_RICE EQUATION (EOS_RR)
C     TOL_TRIV  - TOLERANCE FOR TRIVIAL SOLUTION
C     TOL_ZFAC  - TOLERANCE FOR N_R SOLUTION IN SOLVING FOR ZF
C     PARTIALJAC- FLAG FOR JACOBIAN UPDATE
C     TESTALL -   DETERMINES TESTING PROCEDURE FOR 1-PHASE POINTS:
C                 TRUE: TEST ALL CELLS
C                 FALSE: TEST SELECTED CELLS
C     NEG_FLASH - TRUE :  NEGATIVE FLASH IS ALLOWED TEST
C     NBR_K = TRUE IF K-VALUES OF NEIGHBORING CELLS CAN BE BORROWED
C ----------------------------------------------------------------------

! bag8
      ALLOCATE(VOIL(NDIM1),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate VOIL'
      ALLOCATE(WORK(NP,NWRKSZE),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate WORK'
      ALLOCATE(VGAS(NDIM1),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate VGAS'
      ALLOCATE(VHC(NDIM2),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate VHC'
! bag8

C-------FLV vector
      JV = 1
      IF(NPH > 2) THEN
         JVOLD = 2
      ELSE
         JVOLD = 1
      ENDIF

C-------FLDERIV vector
C       NOTE: JCOEFN is only storage used if NPH=2
      JEJAC = 1
      IF(NPH > 2) THEN
         JDIAG = JEJAC + (NHC+1)*NHC/2
         JHJAC = JDIAG + NHC
         JCOEFN = JHJAC + 2*NHC
         JDFUGDP = JCOEFN + NHC+1
         JDFUGDN = JDFUGDP + NHC
      ELSE
         JDIAG = 1
         JHJAC = 1
         JCOEFN = 1
         JDFUGDP = 1
         JDFUGDN = 1
      ENDIF

C-------FLRR vector
      JXDZ = 1
      IF(NPH > 2) THEN
         JSBINV = JXDZ + NHC
      ELSE
         JSBINV = 1
      ENDIF

C-------WORK vector
      JNORM = IWRK(1)
      JCOEFW = IWRK(2)
      JADOIL = IWRK(3)
      JAPOIL = IWRK(4)
      JBPOIL = IWRK(5)
      JCPOIL = IWRK(6)
      JPRLOGO = IWRK(7)
      JADGAS = IWRK(8)
      JAPGAS = IWRK(9)
      JBPGAS = IWRK(10)
      JCPGAS = IWRK(11)
      JPRLOGG = IWRK(12)

      IF(NPH > 2) THEN
         NCP1 = NHC + 1
      ELSE
         NCP1 = 1
      ENDIF
      TEST_ALL = TEST_GLOBAL
      NC2 = 2*NHC
C ======================================================================
C  STEP 1: MOVES NEW AQUIFER POINTS TO FLTYPE 6
C          NEW HC POINTS ARE MOVED UP AND RECLASSIFIED AS TYPE 5
C ======================================================================
      NACT = FLTYPE(2) + FLTYPE(3) + FLTYPE(5) + FLTYPE(6)
      IF(.NOT.RESTART) THEN
         CALL EOS_MVAQ(WTOTL,HCTOTL,FLTYPE,FLZF,FLV(1,JVOLD),
     &                 FLV(1,JV),NDIM,TOL_SAT,NACT,IFLD,NPH)
      ENDIF
      N1PH = FLTYPE(5)
      NAQF = FLTYPE(6)
      N2PH = NACT - N1PH - NAQF 
      NUPD2P = 0 
      NUPD1P = N1PH 
C ==============================================================================
C  STEP 2: RESTORE NEGATIVE FLASH VAPOR FRACTIONS AND Z-FACTORS FOR TYPE 3 CELLS
C ==============================================================================
C-------save values for 2-phase cells
      DO KK = 1,FLTYPE(2)
         IP = IFLD(KK)
         FLV(IP,JVOLD) = FLV(IP,JV)
      END DO
C-------switch values for 1-phase cells using negative flash
      DO KK = FLTYPE(2)+1,FLTYPE(2)+FLTYPE(3)
         IP = IFLD(KK)
         DUM = FLV(IP,JVOLD)
         FLV(IP,JVOLD) = FLV(IP,JV)
         FLV(IP,JV) = DUM
         FLZF(IP,1) = FLZF(IP,3)
      END DO
C-------save values for 1-phase cells
      NDUM = FLTYPE(2) + FLTYPE(3) + FLTYPE(5)
      L = FLTYPE(2) + FLTYPE(3) + 1
      DO KK = L,NDUM
         IP = IFLD(KK)
         FLV(IP,JVOLD) = FLV(IP,JV)
      END DO
      FIRST_PASS = .TRUE.

C ======================================================================
C  STEP 3:  AS LONG AS ANY TYPE 4 CELLS STILL EXIST OR 
C           NEW 2_PH CELLS FROM TYPE 5, GO TO 1000 AT END OF STEP 6
C           MAKES REPEATED CALLS TO: EOS_CHECK_NEBR
C                                    EOS_STAB
C                                    EOS_FLASH
C           SKIP FLASH ITERATIONS IF BEGINNING OF RESTART RUN
C ======================================================================
      IF(RESTART) THEN
         N2PH = FLTYPE(2)
         N1PH = FLTYPE(3) + FLTYPE(5)
         NAQF = FLTYPE(6)
         NFLASH = N2PH + FLTYPE(3)
         CALL EOS_RESTART(TEMPR,P,IFLD,WORK(1,JNORM),FLZF,Z,FLV(1,JV),
     &                    FLRR(1,JXDZ),FLRR(1,JSBINV),
     &                    FLDERIV(1,JDFUGDN),FLDERIV(1,JDFUGDP),
     &                    FLDERIV(1,JEJAC),FLDERIV(1,JDIAG),
     &                    FLDERIV(1,JHJAC),FLFUG,WORK(1,JADOIL),
     &                    WORK(1,JAPOIL),WORK(1,JBPOIL),WORK(1,JCPOIL),
     &                    WORK(1,JPRLOGO),WORK(1,JADGAS),
     &                    WORK(1,JAPGAS),WORK(1,JBPGAS),WORK(1,JCPGAS),
     &                    WORK(1,JPRLOGG),EK,IEOSTL,PMD,PMD(1,NCP1),
     &                    NHC,NFLASH,NDIM,NP)
         GO TO 2000
      ENDIF

      IF (NACT > 1) CALL TIMON(21)
1000  CONTINUE

C ======================================================================
C  STEP 4:  FIND UNTESTED 1-PHASE CELLS BESIDE 2-PHASE CELLS 
C           IF A NEGATIVE FLASH APPROACH IS USED, BORROW K-VALUES 
C           AND ZF IF VALID K-VALUES CAN BE FOUND FROM NEIGHBORING CELLS
C ======================================================================
         NHCP = FLTYPE(1) + FLTYPE(2) + FLTYPE(3) 
     &        + FLTYPE(4) + FLTYPE(8) + FLTYPE(5)
         IF(NHCP > 0 .AND. NPH > 2) THEN
            CALL EOS_CHECK_NEBR(IFLD,FLV(1,JV),EK,FLZF,Z,NEG_FLASH,
     &                          TEST_ALL,NBR_K,FIRST_PASS,NUPDATE,NDIM,
     &                          NHC,FLTYPE,NP,NHCP,IDIM,JDIM,KDIM,IL1,
     &                          IL2,KL1,KL2,JL1V,JL2V,TCOFX,TCOFY,
     &                          TCOFZ,NBLK)
         ENDIF
         IF(.NOT.KUPDATE) NUPDATE = 0
C----------NEW cells to be flashed based upon neighbors or FIRST_PASS
         NEW = FLTYPE(3)
C ======================================================================
C  STEP 5:  DO STABILITY TEST ON SINGLE-PHASE POINTS(TYPE 4):
C ======================================================================
         NTEST = FLTYPE(4)
         IF(NTEST /= 0) THEN
C-------------adds 2-phase cells to type 3 and 1-phase to type 8
            CALL EOS_STAB(Z,P,FLZF,EK,FLV(1,JV),
     &           FLDERIV(1,JDFUGDN),WORK(1,JPRLOGG),
     &           FLDERIV(1,JDIAG),WORK(1,JAPGAS),FLDERIV(1,JEJAC),
     &           FLDERIV(1,JDFUGDP),
     &           FLDERIV(1,JHJAC),WORK(1,JCOEFW),WORK(1,JBPGAS),
     &           WORK(1,JCPGAS),FLTYPE,
     &           TEMPR,WORK(1,JAPOIL),WORK(1,JBPOIL),
     &           WORK(1,JCPOIL),WORK(1,JADOIL),FLRR(1,JXDZ),
     &           FLRR(1,JSBINV),IEOSTL,NHC,NDIM,NTEST,
     &           TOL_FLASH,TOL_ZFAC,TOL_TRIV,IFLD,NP)
         ENDIF
C ======================================================================
C  STEP 6: AFTER ALL POINTS HAVE BEEN STABILITY-TESTED, FLASH NEW 2-PHASE
C          CELLS (USE ESTIMATES FOR V, ZF AND K(I))
C ======================================================================
         N2PH  = FLTYPE(1) + FLTYPE(2)
         NFLASH = FLTYPE(3)
         NEW1P = 0
         NSMALL = 0
         NEW2P = 0
         IF (NFLASH > 0)THEN
            L = N2PH + 1
C           PMD used as X and Y in EOS_FLASH
            CALL EOS_FLASH(TEMPR,P,IFLD(L),WORK(1,JNORM),
     &                 FLZF,Z,FLV(1,JV),FLV(1,JVOLD),
     &                 FLRR(1,JXDZ),FLRR(1,JSBINV),
     &                 FLDERIV(1,JDFUGDN),FLDERIV(1,JDFUGDP),
     &                 FLDERIV(1,JEJAC),FLDERIV(1,JDIAG),
     &                 FLDERIV(1,JHJAC),FLFUG(1,1),WORK(1,JADOIL),
     &                 WORK(1,JAPOIL),WORK(1,JBPOIL),WORK(1,JCPOIL),
     &                 WORK(1,JPRLOGO),WORK(1,JADGAS),
     &                 WORK(1,JAPGAS),WORK(1,JBPGAS),WORK(1,JCPGAS),
     &                 WORK(1,JPRLOGG),EK,FLOLDZP,
     &                 IEOSTL,PMD,PMD(1,NCP1),NEG_FLASH,LTCOMP,
     &                 NUPDATE,NHC,NEW1P,NEW2P,NSMALL,
     &                 NFLASH,NDIM,NP,IWRT,MAXFLITS,TOL_FLASH,
     &                 TOL_RR,TOL_TRIV,TOL_ZFAC)
            FLTYPE(1) = FLTYPE(1) + NSMALL
            FLTYPE(2) = FLTYPE(2) + NEW2P - NSMALL
            FLTYPE(3) = 0
            FLTYPE(4) = FLTYPE(4) + NEW1P
            N2PH = FLTYPE(1) + FLTYPE(2)
            FIRST_PASS = .FALSE.
         ENDIF 

C ======================================================================
C     NEW is nonzero if there was untested 1-phase cell by 2-phase cell
C     when calling EOS_CHECK_NEBR
C     FLTYPE(4) is nonzero if flash says some cells are 1-phase. This does 
C     not count single phase cells that converged with L < 0 or V > 1 if
C     the NEG_FLASH option is turned on.
C     NEW2P is nonzero if new 2-phase cells occurred.
C     FLTYPE(5) is nonzero if there are still untested 1-phase cells.
      IF ((NEW > 0   .AND. FLTYPE(4) > 0) .OR.  
     &    (NEW2P > 0 .AND. FLTYPE(5) > 0) ) GO TO 1000
      IF (NACT > 1) CALL TIMOFF(21)
C ======================================================================

C ======================================================================
C  STEP 7: MERGE TYPES 4 AND 8 WITH TYPE 5
C ======================================================================
      L = FLTYPE(1) + FLTYPE(2) + FLTYPE(3) + 1
      IF (FLTYPE(4) > 0)   THEN
         ICOUNT_EOSEXEC = ICOUNT_EOSEXEC + 1
         IF (ICOUNT_EOSEXEC < NCOUNT .AND. IWRT > 0)   THEN
            DO IP = L,L+FLTYPE(4)-1
               WRITE(IWRT,2001)   IFLD(IP)
            END DO
         ENDIF 
      ENDIF
2001  FORMAT('C'/'C WARNING MESSAGE: CELL',I6,
     &          2X,'IS PREDICTED TO BE ', 
     &          ' 2-PHASE FROM STABILITY TEST BUT IS PREDICTED TO BE ', 
     &          ' SINGLE PHASE FROM FLASH CALC.')
      NUM = L + FLTYPE(4) + FLTYPE(8) - 1
      DO KK = L,NUM
         IP = IFLD(KK)
         FLV(IP,JV) = FLV(IP,JVOLD)
      END DO
      FLTYPE(5) = FLTYPE(4) + FLTYPE(5) + FLTYPE(8)
      FLTYPE(4) = 0
      FLTYPE(8) = 0
C ======================================================================
C  STEP 8: MOVE NEGATIVE FLASH CELLS FROM TYPES 1 AND 2 TO TYPE 3
C ======================================================================
      NEGUP = 0
      IF (NEG_FLASH)   THEN
         NTOP = 0
         IF (FLTYPE(1) > 0)  THEN
            L = 1
            DO KK = 1,FLTYPE(1)
               I = IFLD(KK)
               VHC(I) = FLV(I,JV)*(ONE-FLV(I,JV))
            END DO
            CALL EOS_MOVE(VHC,ZERO,3,NTOP,NMOV,IFLD(L),NP,FLTYPE(1))
         ENDIF 
         NBOT = FLTYPE(1) - NTOP
         FLTYPE(1) = NTOP
         FLTYPE(2) = FLTYPE(2) + NBOT
         L = FLTYPE(1) + 1
         IP = FLTYPE(1)+FLTYPE(2)
         NTOP = 0
         IF (IP > 0)   THEN
            DO KK = L,IP
               I = IFLD(KK)
               VHC(I) = FLV(I,JV)*(ONE-FLV(I,JV))
            END DO
            NDUM = FLTYPE(2)
            IF (NDUM > 0)   THEN
               CALL EOS_MOVE(VHC,ZERO,3,NTOP,NMOV,IFLD(L),NP,NDUM)
            ENDIF 
         ENDIF
         NBOT = FLTYPE(2) - NTOP
         FLTYPE(2) = NTOP
         FLTYPE(3) = FLTYPE(3) + NBOT
         NEGUP = NBOT
      ENDIF 
      N2PH = FLTYPE(1) + FLTYPE(2)
      N1PH = FLTYPE(3) + FLTYPE(4) + FLTYPE(5)
      NAQF = FLTYPE(6)
C ======================================================================
C  STEP 9: SORT PREVIOUS NEGATIVE FLASH CELLS (BASED ON VOLD) FROM TYPE 1
C           TO TYPE 2
C ======================================================================
      IF (NEG_FLASH .AND. FLTYPE(1) > 0)THEN
        CALL EOS_MOVE(FLV(1,JVOLD),DUM,5,NUM,NMOV5,IFLD,NDIM,FLTYPE(1))
        FLTYPE(2) = N2PH - NUM
        FLTYPE(1) = NUM
      ENDIF
C ======================================================================
C  STEP 10:  CALCULATE TWO-PHASE SATURATION ERROR
C ======================================================================
 2000 IF (N2PH > 0)THEN
        CALL EOS_V2PH(P,FLZF,FLV(1,JV),HCTOTL,TEMPR,ERRSAT,WTOTL,NDIM,
     &                NP,IEOSTL,N2PH,IFLD)
      ENDIF
C ======================================================================
C  STEP 11:  SET UP AND CALCULATE NEW JACOBIANS FOR TYPES 2 AND 3
C ======================================================================
      IF(RESTART) THEN
         NEGUP = FLTYPE(3)
         IF(LRESTART) THEN
            NPAR2P = FLTYPE(2)
            NFUL2P = 0
         ELSE
            NPAR2P = 0
            NFUL2P = FLTYPE(2)
         ENDIF
      ELSEIF(PARTIALJAC) THEN
         NPAR2P = FLTYPE(1)
         NFUL2P = FLTYPE(2)
      ELSE
         NPAR2P = 0
         NFUL2P = FLTYPE(2) + FLTYPE(1)
      ENDIF
      NUPD2P = NPAR2P + NFUL2P
      FLTYPE(1) = 0
      FLTYPE(2) = NUPD2P
      IF (NUPD2P+NEGUP > 0)THEN
C        PMD used as X and Y in EOS_JAC_UP
         CALL EOS_JAC_UP(P,FLV(1,JV),FLZF,PMD(1,1),PMD(1,NCP1),
     &                   EK,FLRR(1,JXDZ),
     &                   WORK(1,JAPOIL),WORK(1,JBPOIL),WORK(1,JCPOIL),
     &                   WORK(1,JADOIL),WORK(1,JAPGAS),WORK(1,JBPGAS),
     &                   WORK(1,JCPGAS),WORK(1,JADGAS),
     &                   WORK(1,JPRLOGO),WORK(1,JPRLOGG),IEOSTL,
     &                   TEMPR,FLRR(1,JSBINV),
     &                   FLDERIV(1,JEJAC),FLDERIV(1,JDIAG),
     &                   FLDERIV(1,JHJAC),FLDERIV(1,JDFUGDN),
     &                   FLDERIV(1,JDFUGDP),WORK(1,JCOEFW),
     &                   FLDERIV(1,JCOEFN),NHC,NDIM,NP,
     &                   NPAR2P,NFUL2P,NEGUP,IFLD)
      ENDIF  
C ======================================================================
C  STEP 12:  CALCULATE 2-PHASE MOLAR VOLUMES AND CORRECT THE SATURATION ERROR
C ======================================================================
      IF (N2PH > 0)THEN
         CALL EOS_2PH_UP(P,FLZF,VOIL,VGAS,FLV(1,JV),HCTOTL,VHC,
     &                   ERRSAT,WORK(1,JCOEFW),FLFUG,TEMPR,
     &                   NDIM,NP,NHC,N2PH,IFLD)
      ENDIF  
C ======================================================================
C  STEP 13: COPY V TO VOLD AND RESET V FOR TYPE 3 CELLS
C ======================================================================
      NDUM = FLTYPE(1) + FLTYPE(2)
      NUM = NDUM + FLTYPE(3)
      IF (FLTYPE(3) > 0)THEN
         DO KK = NDUM+1, NUM
            IP = IFLD(KK)
            FLV(IP,JVOLD) = FLV(IP,JV)
         END DO
         DO KK = NDUM+1,NUM
            IP = IFLD(KK)
            FLZF(IP,3) = FLZF(IP,1)
            IF (FLV(IP,JV) >= HALF) THEN
               FLV(IP,JV) = ONE
            ELSE
               FLV(IP,JV) = ZERO
            ENDIF
         END DO
      ENDIF 
      IF(NPH > 2) THEN
         L  = FLTYPE(1) + FLTYPE(2) + FLTYPE(3) + 1 
         DO KK = L,L+FLTYPE(5)-1
            IP = IFLD(KK)
            IF (FLV(IP,JV) >= HALF) THEN
               FLV(IP,JV) = ONE
            ELSE
               FLV(IP,JV) = ZERO
            ENDIF
         END DO
      ENDIF
C ======================================================================
C  STEP 14:  CALCULATE SINGLE-PHASE SATURATION ERRORS
C ======================================================================
      IF (N1PH + NAQF > 0) THEN
         L = N2PH + 1
         CALL EOS_V1PH(Z,P,FLZF,HCTOTL,WTOTL,
     &                 ERRSAT,WORK(1,JADOIL),WORK(1,JAPOIL),
     &                 WORK(1,JBPOIL),WORK(1,JCPOIL),IEOSTL,TEMPR,
     &                 NHC,NDIM,NP,N1PH,NAQF,TOL_ZFAC,IFLD(L)) 
      ENDIF 
      NCON1P = 0
      NUPD1P = N1PH - NCON1P
C ======================================================================
C  STEP 15:  CALCULATE SINGLE-PHASE MOLAR VOLUMES
C ======================================================================
      IF (N1PH > 0)THEN
         L = N2PH + 1
         CALL EOS_1PH_UP(P,FLZF,VHC,FLDERIV(1,JCOEFN+NHC),
     &             FLDERIV(1,JCOEFN),WORK(1,JADOIL),WORK(1,JAPOIL),
     &             WORK(1,JBPOIL),WORK(1,JCPOIL),IEOSTL,TEMPR,
     &             NHC,NDIM,NP,N1PH,N2PH,IFLD(L))
      ENDIF
C ======================================================================
C  STEP 16: FINALIZE THE SATURATION CONSTRAINT AND CALCULATING THE PHASE
C           DENSITIES, VISCOSITIES AND SATURATIONS
C ======================================================================
      CALL EOS_FINAL(HCTOTL,WTOTL,Z,P,FLV(1,JV),VOIL,VGAS,VHC,MDEN,SAT,
     &               PMDW,PMD(1,1),PMD(1,NCP1),FLDERIV(1,JCOEFN),
     &               DSTDP,DSTDN,CONC,INVISC,XVISC,MDENH,TEMPR,IEOSTL,
     &               NPH,NC,NHC,NDIM,NP,NCINPH,NUPD2P,NUPD1P,NAQF,
     &               INITIAL,VIS_CALC,IFLD,ERRSAT,TENS,IFTCALC) 
C ======================================================================
C  STEP 17: SAVE OLD P AND Z FOR TYPES 1 THROUGH 3
C ======================================================================
      NDUM = FLTYPE(1) + FLTYPE(2) + FLTYPE(3)
      I = 1 + NHC
      DO KK = 1,NDUM
         IP = IFLD(KK)
         FLOLDZP(IP,I) = P(IP)
      END DO
      DO IC = 1,NHC
         DO KK = 1,NDUM
            IP = IFLD(KK)
            FLOLDZP(IP,IC) = Z(IP,IC)
         END DO
      END DO
C ======================================================================
C  STEP 18: MERGE TYPE 1 INTO TYPE 2 AND TYPE 4 INTO TYPE 5
C ======================================================================
      FLTYPE(2) = FLTYPE(1) + FLTYPE(2)
      FLTYPE(1) = 0
      FLTYPE(5) = FLTYPE(4) + FLTYPE(5)
      FLTYPE(4) = 0

! bag8
      DEALLOCATE(VOIL)
      DEALLOCATE(WORK)
      DEALLOCATE(VGAS)
      DEALLOCATE(VHC)
! bag8

      END 
 
C***********************************************************************
      SUBROUTINE EOS_FINISH(P,FLTYPE,DSTDP,DSTDN,PMD,SAT,MDEN,INVISC,
     &                      XVISC,VIS_CALC,NHC,NPH,NCINPH,NC,NP,NDIM,
     &                      IFLPV0,IFLD,TEMPR,IFLPNT,TENS,IFTCALC)
C***********************************************************************
C ----------------------------------------------------------------------
C     SET VALUES FOR ZERO PV CELLS
C     SET IFLPNT VECTOR
C ----------------------------------------------------------------------
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NPH,NP,NDIM,NC,NCINPH,NHC,FLTYPE(MXFLTYPE),IFLPV0,
     &        IFLD(NP),IFLPNT(NDIM)
      LOGICAL VIS_CALC,IFTCALC
      REAL*8 HCTOTL(NDIM),WTOTL(NDIM),DSTDP(NDIM),TEMPR(NDIM),
     &       P(NDIM),DSTDN(NDIM,NC),PMD(NDIM,NCINPH),TENS(NDIM),
     &       SAT(NDIM,NPH),MDEN(NDIM,NPH),INVISC(NDIM,NPH),
     &       XVISC(NDIM,NPH)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER NACT,NACT1,NCNPH,L,I,M,KK,ll
      REAL*8 SATCON
C-----------------------------------------------------------------------
      NACT = 0
      DO I = 1, IFLPV0-1
         NACT = NACT + FLTYPE(I)
      END DO
      NACT1 = NACT + 1
      DO KK = 1,NACT
         L = IFLD(KK)
         TEMPR(L) = TEMPR(L) - TRF
      END DO
      M = 0
      DO I = 1,IFLPV0-1
         DO KK = 1,FLTYPE(I)
            M = M + 1
            L = IFLD(M)
            IFLPNT(L) = I
         END DO
      END DO

C-------store some sensible results for the zero-pv cells
      IF ( NP > NACT ) THEN
         DO I = 1,NPH
            SATCON = ZERO
            IF ( I == 1 ) SATCON = ONE
            DO KK = NACT1,NP
               L = IFLD(KK)
               SAT(L,I) = SATCON
               MDEN(L,I) = ZERO
            END DO
         END DO
         DO KK = NACT1,NP
            L = IFLD(KK)
            DSTDP(L) = ZERO
         END DO
         DO I = 1,NC
            DO KK = NACT1, NP
               L = IFLD(KK)
               DSTDN(L,I) = ONE
            END DO
         END DO
         DO I = 1,NCINPH
            DO KK = NACT1,NP
               L = IFLD(KK)
               PMD(L,I) = ZERO
            END DO
         END DO
         IF(IFTCALC) THEN
            DO KK = NACT1,NP
               L = IFLD(KK)
               TENS(L) = ZERO
            END DO
         ENDIF
      ENDIF
      IF ( VIS_CALC ) THEN
         DO I = 1,NPH
            DO KK = NACT1,NP
               L = IFLD(KK)
               INVISC(L,I) = ONE
               XVISC(L,I) = ONE
            END DO
         END DO
      ENDIF
      END 
 
C***********************************************************************
      SUBROUTINE EOS_AQPR(WTOTL,P,TEMPR,DSTDP,DSTDN,DN,MDEN,SAT,INVISC,
     &                    XVISC,NC,NPH,NHC,NDIM,NP,VIS_CALC,N,IFLD)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
      INCLUDE 'xresprop.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NDIM,NP,N,NPH,NC,NHC,IFLD(NP)
      LOGICAL VIS_CALC
      REAL*8 P(NDIM),TEMPR(NDIM),WTOTL(NP),DN(NP,NPH),
     &       MDEN(NDIM,3),INVISC(NDIM,3),XVISC(NDIM,3),DSTDP(NDIM),
     &       SAT(NDIM,3),DSTDN(NDIM,NC)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER L,KK
      REAL*8 DWB_FVF, DWB_FVF_CW, VW, WDEN, TK, TKREF, DK2F
      PARAMETER (DK2F=1.8D0)
C ----------------------------------------------------------------------
C  THIS ROUTINE CALCULATES WATER PROPERTIES.  VALUES FOR THE OIL AND
C  GAS SATURATION ARE ALSO CALCULATED.  THIS ROUTINE ASSUMES THAT ONLY
C  WATER RESIDES IN THE AQUEOUS PHASE, AND THAT WATER DOES NOT VAPORIZE
C  INTO THE HYDROCARBON PHASES.
C     WTOTL - TOTAL MOLES OF WATER
C     P  - PRESSURE
C     DSTDP - SATURATION CONSTRAINT COEFFICIENT FOR PRESSURE
C     MDEN  - MASS DENSITY OF WATER
C     SAT   - SATURATION OF WATER,OIL & GAS
C     ND    - LEADING DIMENSION OF ARRAYS
C     N    - NUMBER OF POINTS TO CALCULATE
C ----------------------------------------------------------------------
      DWB_FVF = WATDEN/WATFVF 
      DWB_FVF_CW = DWB_FVF*WATCOMP
      DO KK = 1,N
         L = IFLD(KK)
         WDEN = DWB_FVF + DWB_FVF_CW * (P(L)-WAT_REFP)
         MDEN(L,1)  = WDEN * WATMOLW
         DN(L,1)  = WDEN
         DSTDP(L) = -DWB_FVF_CW * WTOTL(L) / (WDEN*WDEN)
         DSTDN(L,1) = ONE/WDEN
         SAT(L,1) =  WTOTL(L)/WDEN
      END DO

      IF (VIS_CALC)   THEN
         TKREF = WAT_REFT
         DO KK = 1,N
            L = IFLD(KK)
            TK = TEMPR(L)/DK2F
            IF(TK <= ZERO) STOP 'NON-PHYSICAL ABSOLUTE TEMPERATURE !!'
            VW = WATVISC*EXP(WVISCMP*(ONE/TK - ONE/TKREF))
            INVISC(L,1) = ONE/VW
            XVISC(L,1) = VW
         END DO 
      ENDIF 

      END 
 
C***********************************************************************
      SUBROUTINE EOS_CHECK(EK,NHC,NUM1,NUM2,NPOINT,NDIM,NP,IFLD)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C ----------------------------------------------------------------------
C  THIS ROUTINE CHECKS 2-PHASE OR NEGATIVE FLASH CELLS TO MAKE SURE
C  THEY ARE NOT INVERTED (OIL LABELED GAS AND VICE VERSA). UP TO TWO
C  GROUPS OF CONTIGUOUS CELLS CAN BE CHECKED. ALL INVERTED CELLS ARE
C  MOVED TO THE BEGINNING OF THE SECOND GROUP. REQUIRES THAT LIGHT 
C  COMPONENT HAVE K VALUE GREATER THAN ONE.
C     EK   - THE K-VALUES
C     NUM1 - THE NUMBER OF CELLS IN GROUP 1 
C     NUM2 - THE NUMBER OF CELLS IN GROUP 2
C     NDIM - THE FIRST DIMENSION OF THE ARRAYS
C     NPOINT - THE NUMBER OF CELLS THAT MET THE TEST
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,NPOINT,NUM2,NUM1,NP,IFLD(NP)
      REAL*8 EK(NDIM)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER L,NMOV,NN,NRMV

      NPOINT = 0
C-------MOVE CELLS FROM GROUP 2 TO THE BEGINNING OF GROUP 2
      IF(NUM2 > 0)THEN
         L  = NUM1 + 1
         CALL EOS_MOVE(EK,ONE,1,NPOINT,NMOV,IFLD(L),NDIM,NUM2)
      ENDIF
C-------MOVE CELLS FROM GROUP 1 TO THE BEGINNING OF GROUP 2
      IF(NUM1 > 0)THEN
         L  = 1
         NN = NUM1
         CALL EOS_MOVE(EK,ONE,4,NUM1,NMOV,IFLD(L),NDIM,NN)
         NRMV = NN - NUM1
         NPOINT = NPOINT + NRMV
         NUM2 = NUM2 + NRMV
      ENDIF
      END 
 
C***********************************************************************
      SUBROUTINE EOS_DFDP(DPHIDP,P,ZF,AP,BP,AD,IEOSTL,SUBPHI,NHC,NDIM,N,
     &                    IFLD,NP)
C***********************************************************************
      USE xgendat
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,N,NP,IEOSTL(NDIM),IFLD(N)
      LOGICAL SUBPHI
      REAL*8 P(NP),ZF(NP),AP(NP),BP(NP),AD(NP,NHC),DPHIDP(NP,NHC)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER I,L,IT,KK
      REAL*8 C4,AKK,BKK,BIKK,ZB,ZBM1,TEMP,HUPBKK,HZINVKK,ZBINVKK,HBBP,
     &       GPKK,GPAKK,GPBKK
C ----------------------------------------------------------------------
C  THIS ROUTINE CALCULATES THE DERIVATIVES OF LOG(PHI) W.R.T. PRESSURE.
C ----------------------------------------------------------------------
      C4=TWO
      DO I=1,NHC
         DO KK = 1,N
            L = IFLD(KK)
            IT = IEOSTL(L)
C      THIS IS TRUE ONLY FOR PR EOS
            AKK  = AP(L)*P(L)
            BKK  = BP(L)*P(L)
            BIKK = ONE/BP(L)
            ZB   = ZF(L)-BKK
            ZBM1 = ZB - ONE
            TEMP = ZB/(ZBM1*ZBM1*(TWO*ZF(L)+C4*BKK)-AKK)
            HUPBKK = -TEMP*ZBM1*P(L)
            HZINVKK = TEMP*ZB*AKK
            ZBINVKK = ONE/ZB
C
            HBBP = (HZINVKK+ZF(L))/P(L)
            GPKK = (BP(L)-HBBP)*ZBINVKK
            GPAKK = HZINVKK*(ZBINVKK-ONE)/AKK
            GPBKK = BIKK*(HBBP-GPAKK*AP(L))
            IF(SUBPHI)THEN
               DPHIDP(L,I) = GPKK + GPAKK*AD(L,I)
     &                     + GPBKK*EOS_BP(I,IT) - DPHIDP(L,I)
            ELSE
               DPHIDP(L,I) = GPKK + GPAKK*AD(L,I)
     &                     + GPBKK*EOS_BP(I,IT)
            ENDIF
         END DO 
      END DO 
      END 
 
C***********************************************************************
      SUBROUTINE EOS_DFDN(DPHIDN,P,ZF,AP,BP,AD,PRLOG,IEOSTL,SYM_PACK,
     &                    NHC,NDIM,N,IFLD,NP)
C***********************************************************************
      USE xgendat
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,NP,N,IEOSTL(NDIM),IFLD(N)
      LOGICAL SYM_PACK
      REAL*8 PRLOG(NP),P(NP),ZF(NP),AP(NP),BP(NP),AD(NP,NHC),
     &       DPHIDN(NP,NHC*NHC)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER I,J,L,IT,II,IJ1,IJ2,IJ3,JP1,JP2,ISTART,K,KP,KP1,KP2,KK
      REAL*8 HUPBKK,HBBZP1,HUBZ,HUBA,HUBAZ
      REAL*8 AKK,BKK,GKK,GAKK,GBKK,GAAKK,GABKK,GBBKK,CKK
      REAL*8 C4,BIKK,ZB,ZBM1,TEMP,HZINVKK,ZBINVKK
C ----------------------------------------------------------------------
C  THIS ROUTINE CALCULATES THE DERIVATIVES OF LOG(PHI) W.R.T. N(I).
C ----------------------------------------------------------------------
      C4 = TWO
      DO KK = 1,N
         L = IFLD(KK)
         IT = IEOSTL(L)
C        THIS IS TRUE ONLY FOR PR EOS
         AKK  = AP(L)*P(L)
         BKK  = BP(L)*P(L)
         BIKK = ONE/BP(L)
         ZB   = ZF(L)-BKK
         ZBM1 = ZB - ONE
         TEMP = ZB/(ZBM1*ZBM1*(TWO*ZF(L)+C4*BKK)-AKK)
         HUPBKK  = -TEMP*ZBM1*P(L)
         HZINVKK = TEMP*ZB*AKK
         ZBINVKK = ONE/ZB
C
         HBBZP1 = HZINVKK+ONE
         HUBZ   = HUPBKK*ZBINVKK
         HUBA   = HUPBKK*AP(L)
         HUBAZ  = HUBA*ZBINVKK
         GKK    = HUBAZ+HUBA+HBBZP1
         GAKK   = -HUBZ
         GBKK   = BIKK*(HUBAZ-HUBA-HBBZP1)
         GAAKK  = (HUBZ-HUPBKK)/AP(L)
         GABKK  = BIKK*(TWO*HUPBKK-HUBZ+PRLOG(L))
         GBBKK  = BIKK*BIKK*(HBBZP1+HUBAZ-THREE*HUBA- 
     &            TWO*AP(L)*PRLOG(L))

         II = 0
         DO I = 1,NHC
            ISTART=1+MOD(I,3)
            IJ1=II+1
            IJ2=IJ1+1
            AKK = GAKK + GAAKK*AD(L,I) + GABKK*EOS_BP(I,IT)
            BKK = GBKK + GABKK*AD(L,I) + GBBKK*EOS_BP(I,IT)
            CKK = GKK + GAKK*AD(L,I) + GBKK*EOS_BP(I,IT)
            IF(ISTART == 2)THEN
               DPHIDN(L,IJ1) = CKK + AKK*AD(L,1)  
     &                       + BKK*EOS_BP(1,IT) 
     &                       - PRLOG(L)*EOS_BIN(I,IT)
            ELSEIF(ISTART == 3)THEN
               DPHIDN(L,IJ1) = CKK + AKK*AD(L,1)
     &                       + BKK*EOS_BP(1,IT) 
     &                       - PRLOG(L)*EOS_BIN(I,IT)
               DPHIDN(L,IJ2) = CKK + AKK*AD(L,2) 
     &                       + BKK*EOS_BP(2,IT) 
     &                       - PRLOG(L)*EOS_BIN(I+NHC,IT)
            ENDIF
            K = I - ISTART
            IF (K >= 0)   THEN
               DO J=ISTART,I,3
                  IJ1=II+J
                  IJ2=IJ1+1
                  IJ3=IJ2+1
                  JP1=J+1
                  JP2=J+2
                  KP=NHC*(J-1)
                  KP1=KP+NHC
                  KP2=KP1+NHC
                  DPHIDN(L,IJ1)= CKK + AKK*AD(L,J) 
     &                         + BKK*EOS_BP(J,IT) 
     &                         - PRLOG(L)*EOS_BIN(I+KP,IT)
                  DPHIDN(L,IJ2)= CKK + AKK*AD(L,JP1) 
     &                         + BKK*EOS_BP(JP1,IT)  
     &                         - PRLOG(L)*EOS_BIN(I+KP1,IT)
                  DPHIDN(L,IJ3)= CKK + AKK*AD(L,JP2)  
     &                         + BKK*EOS_BP(JP2,IT)  
     &                         - PRLOG(L)*EOS_BIN(I+KP2,IT)
               END DO 
            ENDIF  
            IF(SYM_PACK)THEN
              II=II+I
            ELSE
              II=II+NHC
            ENDIF
         END DO 
      END DO
      END 

C***********************************************************************
      SUBROUTINE EOS_DLNK(RES,EJAC,DIAG,HJAC,DFUGDP,DFUGDN,DZDP,
     &                    JAC_UPDATE,NDIM,NHC,N,IFLD)
C***********************************************************************
      IMPLICIT NONE
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,N,IFLD(N)
      LOGICAL JAC_UPDATE
      REAL*8 DZDP(NDIM,NHC+1),EJAC(NDIM,NHC*(NHC+1)/2),DIAG(NDIM,NHC),
     &       HJAC(NDIM,NHC,2),DFUGDP(NDIM,NHC),DFUGDN(NDIM,NHC,NHC),
     &       RES(NDIM,NHC)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER NCP1,I,J,K,KK,IERR
!      REAL*8 COEFN_TEMP(N,NHC,NHC+1)

! bag8
      REAL*8, ALLOCATABLE :: COEFN_TEMP(:,:,:)
! bag8

! bag8
      ALLOCATE(COEFN_TEMP(N,NHC,NHC+1),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate COEFN_TEMP'
! bag8

C ----------------------------------------------------------------------
C  THIS ROUTINE PERFORMS BACK SUBSTITUTIONS FOR CHANGES IN PRESSURE,
C  MOLE FRACTIONS AND LOG(K(I))
C ----------------------------------------------------------------------
      NCP1=NHC+1
      IF(JAC_UPDATE)THEN
C---------back substitution for delta z(i) and p
        DO I = 1,NHC
           DO J = 1,NHC
              DO KK = 1,N
                 K = IFLD(KK)
                 COEFN_TEMP(KK,J,I) = DFUGDN(K,J,I)
              END DO 
           END DO 
           DO KK = 1,N
              J = IFLD(KK)
              COEFN_TEMP(KK,I,NCP1) = DFUGDP(J,I)
           END DO 
        END DO 
        CALL EOS_RMAB(NDIM,N,NDIM,RES,COEFN_TEMP,DZDP,NHC,NCP1,N,IFLD)
      ENDIF
C-------Back substitution for delta(log(k(i))) 
      CALL EOS_JAC_DLNK(RES,EJAC,DIAG,HJAC,NDIM,NHC,N,IFLD)

! bag8
      DEALLOCATE(COEFN_TEMP)
! bag8

      END 
 
C***********************************************************************
      SUBROUTINE EOS_DVDP(DVFDP,P,TEMPR,ZF,AP,BP,NP,N,IFLD)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NP,N,IFLD(N)
      REAL*8  P(NP),ZF(NP),TEMPR(NP),AP(NP),BP(NP),DVFDP(NP)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER L,KK
      REAL*8  C4,ZB,ZBM1,TEMP,AKK,BKK,HZINVKK
C ----------------------------------------------------------------------
C  THIS ROUTINE CALCULATES THE DERIVATIVES OF MOLAR VOLUME W.R.T. PRESSURE.
C ----------------------------------------------------------------------
      C4=TWO
      DO KK = 1,N
         L = IFLD(KK)
C      THIS IS TRUE ONLY FOR PR EOS
         AKK  = AP(L)*P(L)
         BKK  = BP(L)*P(L)
         ZB   = ZF(L)-BKK
         ZBM1 = ZB - ONE
         TEMP = ZB/(ZBM1*ZBM1*(TWO*ZF(L)+C4*BKK)-AKK)
         HZINVKK = TEMP*ZB*AKK
C
         DVFDP(L) = GASCON*TEMPR(L)*HZINVKK/(P(L)*P(L))
      END DO 
      END 
 
C***********************************************************************
      SUBROUTINE EOS_DVDN(DVFDN,P,TEMPR,ZF,AP,BP,AD,IEOSTL,NHC,NDIM,N,
     &                    IFLD,NP)
C***********************************************************************
      USE xgendat
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,NP,N,IFLD(N)
      INTEGER IEOSTL(NDIM)
      REAL*8 P(NP),TEMPR(NP),ZF(NP),AP(NP),BP(NP),AD(NP,NHC),
     &       DVFDN(NP,NHC)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER I,L,IT,KK
      REAL*8 C4,UHU,RTP,AKK,BKK,BIKK,ZB,ZBM1,TEMP,HUPBKK,HZINVKK,
     &       S1,S2,S3,S4
C ----------------------------------------------------------------------
C  THIS ROUTINE CALCULATES PARTIAL MOLAR VOLUME
C ----------------------------------------------------------------------
      C4=TWO
      DO KK = 1,N
         L = IFLD(KK)
         IT = IEOSTL(L)
C      THIS IS TRUE ONLY FOR PR EOS
         AKK  = AP(L)*P(L)
         BKK  = BP(L)*P(L)
         BIKK = ONE/BP(L)
         ZB   = ZF(L)-BKK
         ZBM1 = ZB - ONE
         TEMP = ZB/(ZBM1*ZBM1*(TWO*ZF(L)+C4*BKK)-AKK)
         HUPBKK = -TEMP*ZBM1*P(L)
         HZINVKK = TEMP*ZB*AKK
C
         UHU = HUPBKK*AP(L)
         S4 = GASCON*TEMPR(L)
         RTP = S4/P(L)
         S1 = -RTP*(HZINVKK+UHU)
         S2 = RTP*HUPBKK
         S3 = RTP*BIKK*(HZINVKK+ZF(L)-UHU)
         DO I=1,NHC
            DVFDN(L,I) = S1 + S2*AD(L,I) + S3*EOS_BP(I,IT)
     &                 - S4*EOS_CP(I,IT)
         END DO
      END DO
      END
 
C***********************************************************************
      SUBROUTINE EOS_FINAL(HCTOTL,WTOTL,Z,P,VAP,VOIL,VGAS,VHC,MDEN,SAT,
     &                     PMDW,X,Y,COEFN,DSTDP,DSTDN,CONC,INVISC,XVISC,
     &                     MDENH,TEMPR,IEOSTL,NPH,NC,NHC,NDIM,NP,NCINPH,
     &                     NUPD2P,NUPD1P,NAQF,INITIAL,VIS_CALC,IFLD,
     &                     ERRSAT,TENS,IFTCALC) 
C***********************************************************************
      USE xgendat
      IMPLICIT NONE
      INCLUDE 'xparam.h'
      INCLUDE 'xresprop.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,NP,NUPD2P,NUPD1P,NPH,NAQF,IEOSTL(NDIM), 
     &        NC,NCINPH,IFLD(NP)
      LOGICAL INITIAL,VIS_CALC,IFTCALC
      REAL*8 MDENH,VHC(NP),P(NDIM),TEMPR(NDIM),
     &   HCTOTL(NP),WTOTL(NP),VAP(NDIM),COEFN(NDIM,NHC+1),
     &   Z(NDIM,NHC),SAT(NDIM,NPH),
     &   MDEN(NDIM,NPH),DSTDN(NDIM,NC),INVISC(NDIM,NPH),XVISC(NDIM,NPH),
     &   Y(NDIM,NHC),VGAS(NDIM),VOIL(NDIM),DSTDP(NDIM),ERRSAT(NDIM),
     &   PMDW(NDIM),X(NDIM,NHC),CONC(NDIM,NC),TENS(NDIM)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER NCP1,N2PH,N1PH,I1PH,NHCP,IAQF,KK,NACT,II,
     &        L,I,J,IP1,NEXP,NCSQ,IX,IY,IJX,IJY,M,M1,M2,LMM,IERR
      REAL*8 DUM,DUMV,PCH
!      REAL*8 DN(NP,NPH)

! bag8
      REAL*8, ALLOCATABLE :: DN(:,:)
! bag8

C ----------------------------------------------------------------------
C  THIS ROUTINE FINISHES THE FLUID PROPERTY CALCULATIONS
C
C     VOIL,VGAS- PHASE MOLAR VOLUME
C     MDEN     - MASS DENSITY OF PHASE
C     SAT      - SATURATION
C     X        - LIQUID PHASE MOLE FRACTIONS
C     Y        - GAS PHASE MOLE FRACTIONS
C     VHC      - OVERALL HC MOLAR VOLUME
C     NHC       - NUMBER OF HYDROCARBON COMPONENTS
C     NUPD2P    - NUMBER OF 2-PHASE CELLS WITH UPDATED JACOBIANS
C     NUPD1P    - NUMBER OF 1-PHASE CELLS WITH UPDATED LINEARIZATIONS
C     NAQF     - NUMBER OF AQUIFER CELLS
C     N2PH     - NUMBER OF TWO HYDROCARBON PHASE CELLS
C     N1PH     - NUMBER OF ONE HYDROCARBON PHASE CELLS
C     I1PH     - THE FIRST ONE PHASE POINT
C     NHCP     - THE NUMBER OF HYDROCARBON PHASE CELLS
C     IAQF     - THE FIRST AQUIFER POINT
C ----------------------------------------------------------------------

! bag8
      ALLOCATE(DN(NP,NPH),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate DN'
! bag8

      NCP1 = NHC + 1
      NCSQ = NHC*NHC
      N2PH = NUPD2P
      N1PH = NUPD1P
      I1PH = N2PH + 1
      NHCP = N2PH + N1PH
      IAQF = NHCP + 1
      NACT = NHCP + NAQF
      IF ( N2PH > 0 ) THEN
         DO KK = 1, N2PH
            L = IFLD(KK)
            DN(L,2) = ONE/VOIL(L)
            DN(L,3) = ONE/VGAS(L)
         END DO
      ENDIF
      IF ( N1PH > 0 ) THEN
         DO KK = I1PH, NHCP
            L = IFLD(KK)
            DN(L,2) = ONE/VHC(L)
         END DO
      ENDIF
C ==========================================================================
C  CALCULATE TOTAL NUMBER OF MOLES (HC AND WATER) IF INITIAL = .TRUE.
C ==========================================================================
      IF ( INITIAL ) THEN
          DO KK = 1, NHCP    
             L = IFLD(KK)
             HCTOTL(L) = (ONE-WTOTL(L))/VHC(L)
          END DO
          DUM = WATDEN/WATFVF
          DO KK = 1,NACT
             L = IFLD(KK)
             WTOTL(L) = WTOTL(L)*DUM*(ONE+WATCOMP*(P(L)-WAT_REFP))
             ERRSAT(L) = ZERO
          END DO
      ENDIF
C ==========================================================================
C  CALCULATE TOTAL FLUID VOLUME, WATER PROPERTIES AND AQUIFER CELLS
C ==========================================================================

      DO KK = 1, N2PH
         L = IFLD(KK)
         SAT(L,2) = (ONE-VAP(L))*VOIL(L)*HCTOTL(L)
         SAT(L,3) = VAP(L)*VGAS(L)*HCTOTL(L)
      END DO
      IF (NPH > 2) THEN
         DO KK = I1PH, NHCP
            L = IFLD(KK)
            SAT(L,2) = (ONE-VAP(L))*VHC(L)*HCTOTL(L)
            SAT(L,3) = VAP(L)*VHC(L)*HCTOTL(L)
         END DO
      ELSE
         DO KK = I1PH, NHCP
            L = IFLD(KK)
            SAT(L,2) = VHC(L)*HCTOTL(L)
         END DO
      ENDIF
      IF(NPH > 2) THEN
         DO KK = IAQF,NACT
            L = IFLD(KK)
            SAT(L,2) = ZERO
            SAT(L,3) = ZERO
         END DO
      ELSEIF(NPH > 1) THEN
         DO KK = IAQF,NACT
            L = IFLD(KK)
            SAT(L,2) = ZERO
         END DO
      ENDIF
      CALL EOS_AQPR(WTOTL,P,TEMPR,DSTDP,DSTDN,DN,MDEN,SAT,INVISC,XVISC,
     &              NC,NPH,NHC,NDIM,NP,VIS_CALC,NACT,IFLD)
C ======================================================================
C  CALCULATE DSTDP, DSTDN ADDING FUGACITY CONTRIBUTION
C ======================================================================
      DO KK = 1, NHCP
         L = IFLD(KK)
         DSTDP(L) = HCTOTL(L)*COEFN(L,NCP1) + DSTDP(L)
      END DO
      DO I = 1, NHC
         IP1 = I + 1
         DO KK = 1, NHCP
            L = IFLD(KK)
            DSTDN(L,IP1) = COEFN(L,I) 
         END DO
         DO KK = IAQF,NACT
            L = IFLD(KK)
            DSTDN(L,IP1) = ZERO
         END DO
      END DO
C ======================================================================
C  CALCULATE VISCOSITIES AND MASS DENSITIES
C ======================================================================
C     2-PHASE CELLS
      IF ( N2PH > 0 ) THEN
         NEXP = N2PH
         IF ( NEXP > 0 ) THEN
            IF ( VIS_CALC ) THEN
               CALL EOS_VISCH(X,DN(1,2),INVISC(1,2),XVISC(1,2),IEOSTL,
     &                        NDIM,NP,NHC,NEXP,IFLD)
               CALL EOS_VISCH(Y,DN(1,3),INVISC(1,3),XVISC(1,3),IEOSTL,
     &                        NDIM,NP,NHC,NEXP,IFLD)
            ENDIF   
            CALL EOS_MASDNH(X,DN(1,2),MDEN(1,2),NHC,NDIM,
     &                      NP,NEXP,IFLD)
            CALL EOS_MASDNH(Y,DN(1,3),MDEN(1,3),NHC,NDIM,
     &                      NP,NEXP,IFLD)
         ENDIF  
      ENDIF  
C     SINGLE-PHASE CELLS
      IF ( N1PH > 0 ) THEN
         L = I1PH
         NEXP = NHCP - L + 1
         IF ( NEXP > 0 ) THEN
            IF ( VIS_CALC ) THEN
               CALL EOS_VISCH(Z,DN(1,2),INVISC(1,2),XVISC(1,2),IEOSTL,
     &                        NDIM,NP,NHC,NEXP,IFLD(L))
            ENDIF
            CALL EOS_MASDNH(Z,DN(1,2),MDEN(1,2),
     &                      NHC,NDIM,NP,NEXP,IFLD(L))
         ENDIF  
      ENDIF  
C     AQUIFER CELLS
      IF ( NAQF > 0 ) THEN
         DO I = 2,NPH
            DO KK = IAQF,NACT
               L = IFLD(KK)
               DN(L,I) = ZERO
               MDEN(L,I) = ZERO
            END DO
            IF ( VIS_CALC ) THEN
               DO KK = IAQF,NACT
                  L = IFLD(KK)
                  INVISC(L,I) = ONE
                  XVISC(L,I) = ONE
               END DO
            ENDIF
         END DO
      ENDIF  
C ======================================================================
C  MOVE SINGLE PHASE DATA TO THE APPROPRIATE PHASE
C ======================================================================
      IF (NPH > 2) THEN
         IF (MDENH > ZERO)   THEN
            DO KK = I1PH, NHCP 
               L = IFLD(KK)
               IF (MDEN(L,2) >= MDENH)   THEN
                  VAP(L) = ZERO
               ELSE 
                  VAP(L) = ONE
               ENDIF 
            END DO  
         ENDIF 
         DO KK = I1PH, NHCP
            L = IFLD(KK)
            DUM = DN(L,2)
            DN(L,2) = (ONE-VAP(L))*DUM
            DN(L,3) = VAP(L)*DUM
            DUM = MDEN(L,2)
            MDEN(L,2) = (ONE-VAP(L))*DUM
            MDEN(L,3) = VAP(L)*DUM
            DUM = MAX(SAT(L,2),SAT(L,3))
            SAT(L,2) = (ONE-VAP(L))*DUM
            SAT(L,3) = VAP(L)*DUM
         END DO
         IF (VIS_CALC) THEN
            DO KK = I1PH, NHCP
               L = IFLD(KK)
               DUM = INVISC(L,2)
               DUMV = XVISC(L,2)
               INVISC(L,2) = (ONE-VAP(L))*DUM
               XVISC(L,2) = (ONE-VAP(L))*DUMV
               INVISC(L,3) = VAP(L)*DUM
               XVISC(L,3) = VAP(L)*DUMV
            END DO
         ENDIF
      ENDIF 
C ======================================================================
C  COMPLETE THE PARTIAL MOLAR DENSITY CALCULATIONS
C ======================================================================
      DO I = 1, NHC
         DO KK = 1, N2PH
            L = IFLD(KK)
            X(L,I) = DN(L,2)*X(L,I)
            Y(L,I) = DN(L,3)*Y(L,I)
         END DO
         IF (NPH > 2) THEN
            DO KK = I1PH, NHCP
               L = IFLD(KK)
               X(L,I) = DN(L,2)*Z(L,I)
               Y(L,I) = DN(L,3)*Z(L,I)
            END DO
            DO KK = IAQF,NACT
               L = IFLD(KK)
               X(L,I) = ZERO
               Y(L,I) = ZERO
            END DO
         ELSE
            DO KK = I1PH, NHCP
               L = IFLD(KK)
               X(L,I) = DN(L,2)*Z(L,I)
            END DO
            DO KK = IAQF,NACT
               L = IFLD(KK)
               X(L,I) = ZERO
            END DO
         ENDIF
      END DO
C ======================================================================
C  CALCULATE INTERFACIAL TENSIONS
C ======================================================================
      IF(IFTCALC) THEN
         DO KK = 1,NACT 
            L = IFLD(KK)
            TENS(L) = ZERO
         END DO
         DO I = 1, NHC-1
            PCH = PCHOR(I)
            DO KK = 1, N2PH
               L = IFLD(KK)
               TENS(L) = TENS(L) + PCH*(X(L,I)-Y(L,I))
            END DO
         END DO
         PCH = PCHOR(NHC)
         DO KK = 1, N2PH
            L = IFLD(KK)
            DUM = TENS(L) + PCH*(X(L,NHC)-Y(L,NHC))
            DUM = DUM*DUM
            TENS(L) = DUM*DUM
         END DO
      ENDIF
C ==========================================================================
C  CALCULATE CONCENTRATIONS IF INITIAL = .TRUE.
C ==========================================================================
      IF ( INITIAL ) THEN
         DO I = 1, NHC
            II = I + 1
            DO KK = 1, N2PH
               L = IFLD(KK)
               CONC(L,II) = X(L,I)*SAT(L,2) + Y(L,I)*SAT(L,3)
            END DO
            IF (NPH > 2) THEN
               DO KK = I1PH, NHCP
                  L = IFLD(KK)
                  CONC(L,II) = X(L,I)*SAT(L,2) + Y(L,I)*SAT(L,3)
               END DO
            ELSE
               DO KK = I1PH, NHCP
                  L = IFLD(KK)
                  CONC(L,II) = X(L,I)*SAT(L,2)
               END DO
            ENDIF
            DO KK = IAQF,NACT
               L = IFLD(KK)
               CONC(L,II) = ZERO
            END DO
         END DO
         DO KK = 1,NACT
            L = IFLD(KK)
            CONC(L,1) = DN(L,1)*SAT(L,1)
         END DO
      ENDIF
C
      DO KK = 1,NACT
         L = IFLD(KK)
         PMDW(L) = DN(L,1)
      END DO

! bag8
      DEALLOCATE(DN)
! bag8

      END 
 
C***********************************************************************
      SUBROUTINE EOS_FLASH(TEMPR,P,IFLD,NORM,ZF,Z,V,VOLD,
     &                     XDZ,SBINV,DFUGDN,DFUGDP,EJAC,DIAG,HJAC,RES,
     &                     ADOIL,APOIL,BPOIL,CPOIL,PRLOGO,ADGAS,
     &                     APGAS,BPGAS,CPGAS,PRLOGG,EK,OLDZP,
     &                     IEOSTL,X,Y,NEG_FLASH,LTCOMP,NUPDATE,
     &                     NHC,N1P,N2P,NSMALL,NFLASH,NDIM,NP,IWRT,
     &                     ITMAX,TOL_FLASH,TOL_RR,TOL_TRIV,TOL_ZFAC)
C***********************************************************************
      IMPLICIT NONE
ctemporary
      include 'control.h'
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,NP,LTCOMP,IWRT,ITMAX,NCOUNT,
     &        IEOSTL(NDIM),N1P,N2P,NSMALL,NFLASH,NUPDATE
      INTEGER IFLD(NP)
      PARAMETER (NCOUNT = 500)
      LOGICAL NEG_FLASH
      REAL*8 TOL_FLASH,TOL_RR,TOL_TRIV,TOL_ZFAC
      REAL*8 TEMPR(NDIM),VOLD(NDIM),P(NDIM),X(NDIM,NHC),
     &       Y(NDIM,NHC),Z(NDIM,NHC),EK(NDIM,NHC),XDZ(NDIM,NHC),
     &       ADGAS(NP,NHC),ADOIL(NP,NHC),OLDZP(NDIM,NHC+1),
     &       DFUGDP(NDIM,NHC),RES(NDIM,NHC),EJAC(NDIM,NHC*(NHC+1)/2),
     &       HJAC(NDIM,NHC,2),DFUGDN(NDIM,NHC,NHC),DIAG(NDIM,NHC)
      REAL*8 ZF(NDIM,3),NORM(NP),V(NDIM),APOIL(NP),BPOIL(NP),
     &       CPOIL(NP),APGAS(NP),BPGAS(NP),CPGAS(NP),PRLOGO(NP),
     &       PRLOGG(NP),SBINV(NP)
                                                       
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER NCP1,I,IP,ITER,L,LAST,NUM1,NUM2,NUM,NMOV2,NMOV3,KK,
     &         NUM_TRIVIAL,LP,NFNUM1,NBIG,NINV,ICOUNT_EOSFLASH,IERR
      LOGICAL FUG_CALC,JAC_UPDATE,SUBPHI
      REAL*8 VNFTOL,DUM
!      REAL*8 SCR(NP)

! bag8
      REAL*8, ALLOCATABLE :: SCR(:)
! bag8

      SAVE ICOUNT_EOSFLASH
      DATA ICOUNT_EOSFLASH/0/
C ----------------------------------------------------------------------
C  THIS ROUTINE PERFORMS 2-PHASE FLASH CALCULATIONS 
C     NUPDATE = THE NUMBER OF POINTS TO UPDATE
C     JAC_UPDATE = .FALSE. FLASH CALCULATION ONLY, DONT LINEARIZE W.R.T. Z & P
C     JAC_UPDATE = .TRUE. FULL LINEARIZATION
C     IFLD  - GRID POINT INDEX
C     NORM  - RESIDUAL NORM
C     Z     - OVERALL HYDROCARBON MOLE FRACTIONS
C     P     - PRESSURE
C     ZF    - COMPRESSIBILITY FACTOR FOR LIQUID & GAS
C     EK    - EQUILIBRIUM K-VALUES
C     XDZ   - X(I)/Z(I) 
C     V     - MOLE FRACTION OF VAPOR PHASE
C     EJAC   - SYMMETRIC PART OF JACOBIAN CORRESPONDING TO DERIVATIVES
C             OF FUGACITIES W.R.T. LOG(K(I)).
C     DFUGDN   - DERIVATIVES OF FUGACITIES W.R.T. N(I) 
C     DFUGDP   - DERIVATIVES OF FUGACITIES W.R.T. P
C     RES    - RESIDUES OF FUGACITY EQUATIONS
C     X     - MOLE FRACTIONS FOR LIQUID
C     Y     - MOLE FRACITONS FOR GAS
C     N1P   - NUMBER OF SINGLE-PHASE CELLS
C     N2P   - NUMBER OF REMAINING 2-PHASE CELLS
C     NSMALL  - NUMBER OF POINTS WITH SMALL STARTING RESIDUAL (CONSTANT  
C               JACOBIAN CANDIDATE) 
C     NFLASH - NUMBER OF POINTS TO FLASH
C     ITMAX - MAXIMUM NUMBER OF ITERATIONS
C ----------------------------------------------------------------------

      N1P = 0
      N2P = 0
      NSMALL = 0
      IF (NFLASH == 0) RETURN

! bag8
      ALLOCATE(SCR(NP),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate SCR'
! bag8

C     TOLERANCE FOR L*V SINGLE PHASE CHECK
      VNFTOL = -TEN_P2
      IF (.NOT.NEG_FLASH) VNFTOL = ZERO

      NUM_TRIVIAL = 0
      NCP1 = NHC+1

C     CALCULATE FUGACITIES AT THE SAME TIME Z IS CALCULATED
      FUG_CALC = .TRUE.

C     INITIAL BOUNDS FOR FLASH CALCULATIONS
      L = 1
      LAST = NFLASH
C ======================================================================
C  STEP 1:  CALCULATE CHANGE IN Z AND P (IF NUPDATE > 0)
C           CHANGES IN Z AND P REQUIRED FOR UPDATING ln(K) FOR TIMESTEP
C ======================================================================
      IF(NUPDATE > 0)THEN
         JAC_UPDATE = .TRUE.
         DO I = 1,NHC
            DO KK = 1,NUPDATE
               IP = IFLD(KK)
               OLDZP(IP,I) = Z(IP,I)-OLDZP(IP,I)
            END DO 
         END DO 
         DO KK = 1,NUPDATE
            IP = IFLD(KK)
            OLDZP(IP,NCP1) = P(IP)-OLDZP(IP,NCP1)
         END DO 
      ELSE
         JAC_UPDATE = .FALSE.
      ENDIF

C***********************************************************************
C  STEP 2:  BEGINNING OF ITERATION LOOP FOR UPDATING K-VALUES 
      ITER=0
 1000 CONTINUE
C***********************************************************************

      IF(NFLASH > 0 .AND. ITER < ITMAX)THEN
         ITER=ITER+1
         IF(NUPDATE > 0)THEN
C ======================================================================
C  STEP 3:  BACK SUBSTITUTE TO UPDATE THE K-VALUES
C ======================================================================
            CALL EOS_DLNK(RES,EJAC,DIAG,HJAC,DFUGDP,DFUGDN,OLDZP,
     &                    JAC_UPDATE,NDIM,NHC,NUPDATE,IFLD(L))
            CALL EOS_KUP(EK,RES,NDIM,NHC,NUPDATE,IFLD(L))
         ENDIF
C ======================================================================
C  STEP 4:  CHECK ANY CELLS WITH TRIVIAL K-VALUES
C ======================================================================
         DO KK = L, LAST
            IP = IFLD(KK)
            DUM = LOG(EK(IP,1))
            Y(IP,1) = DUM
            SCR(IP) = DUM*DUM
         END DO 
         DO I = 2, NHC
            DO KK = L, LAST
               IP = IFLD(KK)
               DUM = LOG(EK(IP,I))
               Y(IP,I) = DUM
               SCR(IP) = SCR(IP) + DUM*DUM
            END DO 
         END DO 
         DO KK = L,LAST
            IP = IFLD(KK)
            IF(SCR(IP) < TOL_TRIV) THEN
               V(IP) = HALF
            ENDIF
         END DO
         NUM1 = 0
         IF(NUPDATE > 0)THEN
            CALL EOS_MOVE(SCR,TOL_TRIV,3,NUM1,NMOV3,IFLD(L),NP,NUPDATE)
         ENDIF
         NUM2 = 0
         IF(NUPDATE < NFLASH)THEN
           LP = L + NUM1
           NFNUM1 = NFLASH - NUM1
           CALL EOS_MOVE(SCR,TOL_TRIV,3,NUM2,NMOV3,IFLD(LP),NP,NFNUM1)
         ENDIF
         NUPDATE = NUM1
         NUM = NUM1 + NUM2
         N1P = N1P + NFLASH - NUM
         NFLASH = NUM
         LAST = L + NFLASH - 1
C ======================================================================
C  STEP 5: UPDATE V BY CONSTANT K FLASH
C ======================================================================
         CALL EOS_RR(Z,EK,V,XDZ,SBINV,TOL_RR,NDIM,NP,NHC,
     &               NFLASH,IFLD(L))
C ======================================================================
C  STEP 6:  MOVE BACK SINGLE-PHASE CELLS WITH VAPOR FRACTIONS OUT OF RANGE 
C ======================================================================
         DO KK = L, LAST
            IP = IFLD(KK)
            NORM(IP) = V(IP)*(ONE-V(IP))
         END DO 
         NUM1 = 0
         IF(NUPDATE > 0)THEN
           CALL EOS_MOVE(NORM,VNFTOL,3,NUM1,NMOV3,IFLD(L),NDIM,NUPDATE)
         ENDIF
         NUM2 = 0
         IF(NUPDATE < NFLASH)THEN
           LP = L + NUM1
           NFNUM1 = NFLASH - NUM1
           CALL EOS_MOVE(NORM,VNFTOL,3,NUM2,NMOV3,IFLD(LP),NP,NFNUM1)
         ENDIF
         NUPDATE = NUM1
         NUM = NUM1 + NUM2
         NUM_TRIVIAL = NFLASH - NUM
         N1P = N1P + NFLASH - NUM
         NFLASH = NUM
         LAST = L + NFLASH - 1
C ======================================================================
C  STEP 7:  CALCULATE NEW RESIDUALS AND NORM
C ======================================================================
         IF(NFLASH > 0)THEN
            DO I = 1,NHC
               DO KK = L,LAST
                  IP = IFLD(KK)
                  X(IP,I) = Z(IP,I)*XDZ(IP,I)
               END DO 
            END DO 
            SUBPHI=.FALSE.
            CALL EOS_PROP(P,X,ZF,RES,ADOIL,APOIL,BPOIL,CPOIL,PRLOGO,
     &                    IEOSTL,FUG_CALC,SUBPHI,TOL_ZFAC,NHC,
     &                    NDIM,NP,NFLASH,IFLD(L))
C           Y(ic) is ln(Kic) before modification below
            DO I = 1,NHC
               DO KK = L,LAST
                  IP = IFLD(KK)
                  RES(IP,I) = RES(IP,I)-Y(IP,I)
                  Y(IP,I) = EK(IP,I)*X(IP,I)
               END DO 
            END DO 
            SUBPHI=.TRUE.
            CALL EOS_PROP(P,Y,ZF(1,2),RES,ADGAS,APGAS,BPGAS,CPGAS,
     &                    PRLOGG,IEOSTL,FUG_CALC,SUBPHI,
     &                    TOL_ZFAC,NHC,NDIM,NP,NFLASH,IFLD(L))
            CALL EOS_RESIDUE(RES,NORM,SBINV,SCR,NDIM,NP,NHC,NFLASH,
     &                       IFLD(L))
C ======================================================================
C  STEP 8:  MOVE CONVERGED CELLS UP, UNCONVERGED CELLS DOWN 
C ======================================================================
            NUM1 = 0
            IF(NUPDATE > 0)THEN
               CALL EOS_MOVE(NORM,TOL_FLASH,2,NUM1,NMOV2,IFLD(L),
     &                       NP,NUPDATE)
            ENDIF
            NUM2 = 0
            IF(NUPDATE < NFLASH)THEN
               LP = L + NUM1
               NFNUM1 = NFLASH-NUM1
               CALL EOS_MOVE(NORM,TOL_FLASH,2,NUM2,NMOV2,IFLD(LP),
     &                       NP,NFNUM1)
            ENDIF
C           CELLS THAT HAVE CONVERGED ON THE FIRST ITERATION
            IF(ITER == 1) NSMALL = NUM1
            NUM = NUM1 + NUM2
            N2P = N2P + NUM
            L = L + NUM
            NFLASH = NFLASH - NUM
            NUPDATE = NFLASH
         ENDIF
C ======================================================================
C  STEP 9:  CALCULATE JACOBIANS FOR UNCONVERGED CELLS 
C ======================================================================
         IF(NFLASH > 0 .AND. ITER < ITMAX)THEN
            JAC_UPDATE = .FALSE.
            CALL EOS_JACK(P,V,ZF,X,Y,EK,XDZ,ADOIL,ADGAS,APOIL,BPOIL,
     &                    CPOIL,APGAS,BPGAS,CPGAS,PRLOGO,PRLOGG,IEOSTL,
     &                    TEMPR,EJAC,DIAG,HJAC,NHC,
     &                    NDIM,NP,NFLASH,IFLD(L))
         ENDIF

C***********************************************************************
C        END OF ITERATION LOOP FOR UPDATING K-VALUES 
         GO TO 1000
C***********************************************************************

      ENDIF
C ======================================================================
C  STEP 10:  PRINT ERROR MESSAGE FOR UNCONVERGED CELLS
C ======================================================================
      IF (NFLASH > 0)   THEN
         ICOUNT_EOSFLASH = ICOUNT_EOSFLASH + 1
         IF (ICOUNT_EOSFLASH < NCOUNT .AND. IWRT > 0)   THEN
            DO KK = L,L+NFLASH-1
               IP = IFLD(KK)
               WRITE(IWRT,2001) IP,ITMAX
            END DO
         ENDIF
      ENDIF
2001  FORMAT('C'/'C WARNING MESSAGE: IN EOS_FLASH CELL',I6,2X,'IS NOT ',
     &       '  CONVERGED IN ',I5,2X,' ITERATIONS !!!')
C     ADD UNCONVERGED CELLS BACK TO 2-PHASE
      N2P = N2P + NFLASH
      NFLASH = 0
C ======================================================================
C  STEP 11:  FIX PHASE INVERSIONS FOR TWO-PHASE AND NEGATIVE FLASH CELLS 
C            PHASE CHECK REQUIRES K VALUE OF LIGHT COMPONENT > 1
C ======================================================================
      IF(N2P > 0)THEN
         NBIG = N2P - NSMALL
         CALL EOS_CHECK(EK(1,LTCOMP),NHC,NSMALL,NBIG,NINV,NDIM,NP,IFLD)
         IF(NINV > 0)THEN
            L = NSMALL + 1
            CALL EOS_PHSWAP(X,Y,XDZ,EK,V,ZF,RES,APOIL,APGAS,BPOIL,
     &                      BPGAS,CPOIL,CPGAS,ADOIL,ADGAS,
     &                      PRLOGO,PRLOGG,NHC,NDIM,NP,NINV,IFLD(L))
         ENDIF
      ENDIF
C ======================================================================
C  STEP 12:  ADJUST V FOR SINGLE-PHASE, AND TRIVIAL CELLS 
C ======================================================================
      IF(N1P > 0)THEN
        DO KK = N2P+1,N2P+N1P
           IP = IFLD(KK)
           IF(V(IP) > HALF) THEN
              V(IP) = ONE
           ELSEIF(V(IP) < HALF) THEN
              V(IP) = ZERO
           ELSE
              V(IP) = ZERO
              IF(VOLD(IP) >= HALF) V(IP) = ONE
           ENDIF
        END DO 
      ENDIF


! bag8
      DEALLOCATE(SCR)
! bag8

      END 

C***********************************************************************
      SUBROUTINE EOS_CHECK_NEBR(IFLD,V,EK,ZF,Z,NEG_FLASH,TEST_ALL,
     &                          NEIGHBOR_K,FIRST_PASS,NUPDATE,
     &                          NDIM,NHC,FLTYPE,ND,NHCP,
     &                          IDIM,JDIM,KDIM,IL1,IL2,KL1,KL2,JL1V,
     &                          JL2V,TCOFX,TCOFY,TCOFZ,NBLK)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NUPDATE,ND,NDIM,NHC,NHCP,NBLK,
     &        IDIM,JDIM,KDIM,IL1,IL2,KL1,KL2,JL1V(KDIM),JL2V(KDIM)
      LOGICAL NEG_FLASH,TEST_ALL,NEIGHBOR_K,FIRST_PASS
      INTEGER IFLD(ND),FLTYPE(MXFLTYPE)
      REAL*8 V(ND),Z(NDIM,NHC),EK(NDIM,NHC),ZF(NDIM,3),TCOFX(NDIM),
     &       TCOFY(NDIM),TCOFZ(NDIM)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER N2PH,L,NTOP,NMOV,NBOT,NTEST,IP,IC,IDUM,KK,LL,IERR
!      INTEGER LOCATION(NDIM),IVAL(NDIM)

! bag8
      INTEGER, ALLOCATABLE :: LOCATION(:),IVAL(:)
! bag8

C-----------------------------------------------------------------------
C  THIS ROUTINE PERFORMS THE FOLLOWING FUNCTIONS:
C     1. IT FLAGS SINGLE-PHASE CELLS FOR 2-PHASE TESTING.
C     2. IT MOVES CELLS NOT NEEDING TESTING TO THE BOTTOM OF TYPE 5.
C     3. IF POSSIBLE, IT FINDS NEIGHBORING K-VALUES FOR SOME OF THE CELLS
C        THAT NEED TESTING, AND MOVES THOSE CELLS TO TYPE 3.
C     4. IT MOVES THE REST OF THE CELLS NEEDING TESTING TO TYPE 4.
C     IF(FIRST_PASS) THEN
C        FLTYPE(4) = 0 WHEN ENTERING THIS ROUTINE
C     ELSE
C        FLTYPE(3) = 0 WHEN ENTERING THIS ROUTINE
C     ENDIF
C  IT TAKES AS INPUT:
C     EK(I,J)    : THE K-VALUE OF COMPONENT J AT FLUID POINT I
C                  (NEEDED ONLY IF NEIGHBOR_K IS TRUE).
C     ZF(I,J)    : THE Z-FACTOR OF PHASE J AT FLUID POINT I
C                  (NEEDED ONLY IF NEIGHBOR_K IS TRUE).
C     TEST_ALL   : TRUE, IF ALL 1-PHASE POINTS MUST BE TESTED
C                  (SHOULD ALWAYS BE TRUE FOR NON-GRID-BASED CALCULATIONS).
C     NEIGHBOR_K : TRUE, IF CELLS ARE ALLOWED TO GET K-VALUES FROM NEIGHBORS
C                  (SHOULD ALWAYS BE FALSE FOR NON-GRID-BASED CALCULATIONS)
C     FIRST_PASS : TRUE, IF THIS IS THE FIRST CALL FROM EOS_EXEC.
C     NDIM      : THE LEADING DIMENSION OF THE GRID-BASED ARRAYS.
C     NHC         : THE NUMBER OF HYDROCARBON COMPONENTS.
C     FLTYPE(I)  : THE NUMBER OF CELLS IN FLUID TYPE I.
C     ND         : THE LEADING DIMENSION OF THE FLUID ARRAYS.
C     NOTES:
C        ON FIRST_PASS INPUT, CELLS CAN BE OF TYPES 2, 3, 5, 6
C        ON SUBSEQUENT INPUT, CELLS CAN BE OF TYPES 1, 2, 4, 8, 5, 6
C  IT RETURNS AS OUTPUT:
C     EK(I,J)    : THE NEW K-VALUE OF COMPONENT J AT FLUID POINT I
C                  (MODIFIED ONLY IF NEIGHBOR_K IS TRUE).
C     ZF(I,J)    : THE NEW Z-FACTOR OF PHASE J AT FLUID POINT I
C                  (MODIFIED ONLY IF NEIGHBOR_K IS TRUE).
C     NUPDATE    : THE NUMBER OF CELLS TO INCLUDE DEL(P) AND DEL(NIC).
C     FLTYPE(I)  : THE NEW NUMBER OF CELLS IN FLUID TYPE I.
C  THE REMAINING VARIABLES ARE ONLY USED BY EOS_FLAG
C  (ONLY CALLED IF NEIGHBOR_K IS TRUE OR TEST_ALL IS FALSE)

! bag8
      ALLOCATE(LOCATION(NDIM),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate LOCATION'
      ALLOCATE(IVAL(NDIM),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate IVAL'
! bag8

C-----------------------------------------------------------------------
C     STEP 1: SET NUPDATE AND N2PH
C-----------------------------------------------------------------------
      N2PH = FLTYPE(1) + FLTYPE(2)
C-----------------------------------------------------------------------
C     STEP 2: IF TEST_ALL, RECLASSIFY TYPE 5 AS TYPE 9
C     FLTYPE(9) RESET TO ZERO AT END OF ROUTINE
C-----------------------------------------------------------------------
      IF (TEST_ALL)   THEN
         FLTYPE(9) = FLTYPE(5)
         FLTYPE(5) = 0
      ENDIF
C-----------------------------------------------------------------------
C     STEP 3: FLAG ALL CELLS FOR TESTING AND FOR NEIGHBOR K-VALUES
C             SET IVAL > 0 IF CELL SHOULD BE TESTED
C             SET LOCATION TO NEIGHBOR VALUE IF NEIGHBOR IS 2-PHASE
C-----------------------------------------------------------------------
      IF ((FLTYPE(3)+FLTYPE(5) > 0 .AND. .NOT.TEST_ALL) .OR. 
     &    (FLTYPE(5) > 0 .AND. NEIGHBOR_K)) THEN
         CALL EOS_FLAG(IVAL,LOCATION,IFLD,V,TCOFX,TCOFY,TCOFZ,
     &                 IDIM,JDIM,KDIM,IL1,IL2,KL1,KL2,JL1V,JL2V,
     &                 NBLK,NEG_FLASH,FIRST_PASS,FLTYPE,
     &                 NDIM,Z,ND,NHC)
      ENDIF
C-----------------------------------------------------------------------
C     STEP 4: SORT TYPE 3 INTO NTOP (NEEDING TESTING) AND NBOT (NOT NEEDING
C             TESTING). FLTYPE(3)=0 IF NOT FIRST_PASS.
C-----------------------------------------------------------------------
      IF (FLTYPE(3)  > 0 .AND. .NOT.TEST_ALL)   THEN
         L = N2PH + 1
         NTEST = FLTYPE(3)
         CALL EOS_MOVE_INT(IVAL,0,3,NTOP,NMOV,IFLD(L),NDIM,NTEST)
         NBOT = FLTYPE(3) - NTOP
C----------move the nbot cells to the bottom of type 5
         IF (NBOT > 0 .AND. FLTYPE(4) + FLTYPE(5) > 0)   THEN
            L = L + NTOP
            NTEST = FLTYPE(4) + FLTYPE(5) + NBOT
            CALL EOS_MOVE_INT(IDUM,0,6,NBOT,NMOV,IFLD(L),NDIM,NTEST)
         ENDIF
C----------reclassify the nbot cells as type 10 (merge to type 5 later)
C          FLTYPE(10) do not require testing
C          FLTYPE(10) IS AFTER FLTYPE(5) AT THIS POINT
         FLTYPE(10) = NBOT
         FLTYPE(3) = FLTYPE(3) - NBOT
      ENDIF
C-----------------------------------------------------------------------
C     STEP 5: SORT TYPE 5 INTO NTOP (NEEDING TESTING) AND 
C             NBOT (NOT NEEDING TESTING)
C             FLYTPE(8) COMES AFTER FLTYPE(4) BUT BEFORE FLTYPE(5)
C-----------------------------------------------------------------------
      L = N2PH + FLTYPE(3) + FLTYPE(4) + FLTYPE(8) + 1
      IF (FLTYPE(5) > 0)   THEN
         NTEST = FLTYPE(5)
         CALL EOS_MOVE_INT(IVAL,0,3,NTOP,NMOV,IFLD(L),NDIM,NTEST)
C----------reclassify the ntop cells as FLTYPE(9) (merge to type 3 or 4)
C          FLTYPE(9) require testing
C          FLTYPE(9) IS BEFORE FLTYPE(5) AT THIS POINT
         FLTYPE(9) = NTOP
         FLTYPE(5) = FLTYPE(5) - NTOP
      ENDIF
C-----------------------------------------------------------------------
C     STEP 6: MOVE TYPE 9 ABOVE TYPE 8 AND MERGE TYPE 10 INTO TYPE 5
C-----------------------------------------------------------------------
      L = L - FLTYPE(8)
      IF (FLTYPE(8) > 0 .AND. FLTYPE(9) > 0)   THEN
         NTEST = FLTYPE(8) + FLTYPE(9)
         NTOP = FLTYPE(9)
         CALL EOS_MOVE_INT(IDUM,0,6,NTOP,NMOV,IFLD(L),NDIM,NTEST)
      ENDIF
      FLTYPE(5) = FLTYPE(5) + FLTYPE(10)
      FLTYPE(10) = 0
C-----------------------------------------------------------------------
C     STEP 7: SORT TYPE 9 INTO NTOP CELLS (WITH NEIGHBORING K-VALUES)
C             AND NBOT CELLS (W/O NEIGHBORING K-VALUES)
C-----------------------------------------------------------------------
      IF (NEIGHBOR_K .AND. FLTYPE(9) > 0)   THEN
         NTEST = FLTYPE(9)
         CALL EOS_MOVE_INT(LOCATION,0,3,NTOP,NMOV,IFLD(L),NDIM,NTEST)
         NBOT = FLTYPE(9) - NTOP
         DO KK = L, L+NTOP-1
            IP = IFLD(KK)
            LL = LOCATION(IP)
            IVAL(KK) = LL
            ZF(IP,1) = ZF(LL,1)
            ZF(IP,2) = ZF(LL,2)
         END DO
         DO IC = 1, NHC
            DO KK = L, L+NTOP-1
               IP = IFLD(KK)
               EK(IP,IC) = EK(IVAL(KK),IC)
            END DO
         END DO
C----------move ntop cells to the top of type 4 and change to type 3
         IF (FLTYPE(4) > 0 .AND. NTOP > 0)   THEN
            L = L - FLTYPE(4)
            NTEST = FLTYPE(4) + NTOP
            CALL EOS_MOVE_INT(IDUM,0,6,NTOP,NMOV,IFLD(L),NDIM,NTEST)
         ENDIF
         FLTYPE(3) = FLTYPE(3) + NTOP
         FLTYPE(4) = FLTYPE(4) + NBOT
         FLTYPE(9) = 0
      ELSE
C----------merge type 9 into type 4
         FLTYPE(4) = FLTYPE(4) + FLTYPE(9)
         FLTYPE(9) = 0
      ENDIF
C-----------------------------------------------------------------------
C     STEP 8: MERGE TYPE 2 INTO TYPE 3 (FIRST_PASS ONLY)
C-----------------------------------------------------------------------
      IF (FIRST_PASS)   THEN
         FLTYPE(3) = FLTYPE(3) + FLTYPE(2)
         NUPDATE = FLTYPE(3)
         FLTYPE(2) = 0
      ELSE
         NUPDATE = 0
      ENDIF

! bag8
      DEALLOCATE(LOCATION)
      DEALLOCATE(IVAL)
! bag8

      END 

C***********************************************************************
      SUBROUTINE EOS_JACINV(EJAC,HJAC,V,Y,X,YMXDZ,NDIM,NP,NHC,N,IFLD)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,NP,N,IFLD(NP)
      REAL*8 V(NDIM),X(NDIM,NHC),Y(NDIM,NHC),YMXDZ(N,NHC),
     &       EJAC(NDIM,NHC*(NHC+1)/2),HJAC(NDIM,NHC,2)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER IP,I,KK
      REAL*8 S(N,2)
C-----------------------------------------------------------------------
C  THIS ROUTINE CALCULATES LDLT FORM OF EJAC AND HJAC 
C   INPUT:
C     EJAC : THE SYMMETRIC PART OF THE JACOBIAN, IN PACKED FORM.
C     YMXDZ : (Y-X)/Z
C     NHC  : THE NUMBER OF HYDROCARBON COMPONENTS.
C     NP  : THE NUMBER OF CELLS 
C   OUTPUT:
C     EJAC : THE LDLT FACTORED FORM OF THE ORIGINAL EJAC.
C     HJAC : THE VECTOR ((EJAC**(-1))*HJAC-S)/(UT*(EJAC**(-1))*HJAC),
C-----------------------------------------------------------------------
      CALL EOS_FORM(EJAC,NDIM,NHC,N,IFLD)
C     SOLVE FOR (EJAC**(-1))*HJAC
      CALL EOS_SOLV(EJAC,HJAC(1,1,1),NDIM,NHC,1,N,IFLD)
      CALL EOS_SOLV(EJAC,HJAC(1,1,2),NDIM,NHC,1,N,IFLD)
C     SUM OVER EJAC**(-1)*HJAC
      DO KK = 1,N
         IP = IFLD(KK)
         S(KK,1) = HJAC(IP,1,1)
         S(KK,2) = HJAC(IP,1,2)
      END DO 
      DO I = 2, NHC
         DO KK = 1, N
            IP = IFLD(KK)
            S(KK,1) = S(KK,1) + HJAC(IP,I,1)
            S(KK,2) = S(KK,2) + HJAC(IP,I,2)
         END DO 
      END DO 
C     INVERT
      DO KK = 1,N
         IP = IFLD(KK)
         IF(V(IP) > ZERO .AND. V(IP) < ONE)THEN
            S(KK,1) = ABS(S(KK,1))
            S(KK,2) = ABS(S(KK,2))
         ENDIF
         IF(S(KK,1) /= ZERO) S(KK,1) = ONE/S(KK,1)
         IF(S(KK,2) /= ZERO) S(KK,2) = ONE/S(KK,2)
      END DO 
C     CALCULATE (EJAC**(-1)*HJAC-S)/SUM(HJAC)
      DO I = 1,NHC
         DO KK = 1,N
            IP = IFLD(KK)
            IF( (ONE-V(IP))*X(IP,I) > V(IP)*Y(IP,I) )THEN
               HJAC(IP,I,1) = S(KK,1)*(HJAC(IP,I,1) 
     &                      - Y(IP,I)*YMXDZ(KK,I))
            ELSE
               HJAC(IP,I,1) = S(KK,2)*(HJAC(IP,I,2) 
     &                      + X(IP,I)*YMXDZ(KK,I))
            ENDIF
         END DO 
      END DO 
      END 
 
C***********************************************************************
      SUBROUTINE EOS_JAC_DLNK(DLNK,EJAC,DIAG,HJAC,NDIM,NHC,N,IFLD)
C***********************************************************************
      IMPLICIT NONE
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,N,IFLD(N)
      REAL*8 EJAC(NDIM,NHC*(NHC+1)/2),DIAG(NDIM,NHC),HJAC(NDIM,NHC,2),
     &       DLNK(NDIM,NHC)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER I1,I2,I3,I4,ISTART,NCM1,NCM2,IP,J,KK
      REAL*8 S(N)
C-----------------------------------------------------------------------
C  THIS ROUTINE SOLVES FOR THE CHANGE IN LOG K(I).
C
C  IT TAKES AS INPUT:
C     DLNK  : RESIDUES OF FUGACITY EQUATIONS
C     EJAC : THE LDLT FACTORIZATION OF THE MATRIX E
C     DIAG : THE DIAGONAL OF D-INVERSE 
C     HJAC : THE VECTOR ((E**(-1))*H-S)/UT*(E**(-1))*H
C     ND  : LEADING DIMENSION OF EJAC, DIAG AND HJAC.
C     NHC  : NUMBER OF COMPONENTS.
C     NP  : NUMBER OF CELLS.
C  AND RETURNS AS OUTPUT:
C     DLNK  : THE CHANGE IN LOG K(I).
C-----------------------------------------------------------------------
      NCM1 = NHC - 1
      NCM2 = NHC - 2
      CALL EOS_SOLV(EJAC,DLNK,NDIM,NHC,1,N,IFLD)
      ISTART = MOD(NCM1,4) + 2
      IF(ISTART == 2)THEN
         DO KK = 1, N
            IP = IFLD(KK)
            S(KK) = DLNK(IP,1)
         END DO 
      ELSEIF(ISTART == 3)THEN
         DO KK = 1, N
            IP = IFLD(KK)
            S(KK) = DLNK(IP,1) + DLNK(IP,2)
         END DO 
      ELSEIF(ISTART == 4)THEN
         DO KK = 1, N
            IP = IFLD(KK)
            S(KK) = DLNK(IP,1) + DLNK(IP,2) + DLNK(IP,3)
         END DO 
      ELSEIF(ISTART == 5)THEN
         DO KK = 1, N
            IP = IFLD(KK)
            S(KK) = DLNK(IP,1) + DLNK(IP,2) + DLNK(IP,3) + DLNK(IP,4)
         END DO 
      ENDIF
      J = NHC - ISTART
      IF (J >= 0)   THEN
         DO I1 = ISTART, NHC, 4
            I2 = I1 + 1
            I3 = I2 + 1
            I4 = I3 + 1
            DO KK = 1, N
               IP = IFLD(KK)
               S(KK) = S(KK) + DLNK(IP,I1) + DLNK(IP,I2)
     &               + DLNK(IP,I3) + DLNK(IP,I4)
            END DO 
         END DO  
      ENDIF 
      DO I1 = 1, NHC
         DO KK = 1, N
            IP = IFLD(KK)
            DLNK(IP,I1) = DIAG(IP,I1)*(DLNK(IP,I1)-S(KK)*HJAC(IP,I1,1))
         END DO 
      END DO 
      END 
 
C***********************************************************************
      SUBROUTINE EOS_JACK(P,V,ZF,X,Y,EK,XDZ,ADOIL,ADGAS,APOIL,BPOIL,
     &                    CPOIL,APGAS,BPGAS,CPGAS,PRLOGO,PRLOGG,IEOSTL,
     &                    TEMPR,EJAC,DIAG,HJAC,NHC,NDIM,NP,N,IFLD)
C***********************************************************************
      IMPLICIT NONE
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,NP,N,IEOSTL(NDIM),IFLD(NP)
      REAL*8 P(NDIM),V(NDIM),TEMPR(NDIM),APOIL(NP),HJAC(NDIM,NHC,2),
     &       APGAS(NP),BPOIL(NP),BPGAS(NP),CPOIL(NP),CPGAS(NP),
     &       PRLOGO(NP),PRLOGG(NP),ZF(NDIM,3),X(NDIM,NHC),
     &       Y(NDIM,NHC),EK(NDIM,NHC),XDZ(NDIM,NHC),ADOIL(NP,NHC),
     &       ADGAS(NP,NHC),DIAG(NDIM,NHC),EJAC(NDIM,NHC*(NHC+1)/2)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER IERR
      REAL*8 ADM
!      REAL*8 DPHIGDN(NDIM,NHC*(NHC+1)/2)

! bag8
      REAL*8, ALLOCATABLE :: DPHIGDN(:,:)
! bag8

C ----------------------------------------------------------------------
C  THIS ROUTINE CALCULATES AND INVERTS THE JACOBIAN FOR TWO-PHASE
C     K-VALUE UPDATES AT CONSTANT P AND Z(I) 
C     XDZ(I)- X(I)/Z(I) 
C     EJAC   - DERIVATIVE OF PHIO W.R.T. N (INPUT FOR EOS_JAVK)
C     EJAC   - SYMMETRIC PART OF JACOBIAN CORRESPONDING TO DERIVATIVES
C             OF FUGACITIES W.R.T. LOG(K(I)) (OUTPUT OF EOS_JACK)
C     DPHIGDN   - DERIVATIVE OF PHIG W.R.T. N (INPUT FOR EOS_JAVK)
C     DIAG  : THE DIAGONAL OF D-INVERSE (OUTPUT OF EOS_JACK) 
C     HJAC(IP,I,1) : ((E**(-1))*H-S)/UT*(E**(-1))*H (OUTPUT OF EOS_JACK)
C     HJAC(IP,I,2) : (EJAC**(-1)*U) (OUTPUT OF EOS_JACK) 
C ----------------------------------------------------------------------

! bag8
      ALLOCATE(DPHIGDN(NDIM,NHC*(NHC+1)/2),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate DPHIGDN'
! bag8

      CALL EOS_PROP_DR(P,ZF(1,1),ADM,ADM,ADM,EJAC,ADOIL,APOIL,BPOIL,
     &          CPOIL,PRLOGO,IEOSTL,TEMPR,1,N,1,0,1,0,1,0,.FALSE.,
     &          .TRUE.,NHC,NDIM,NP,N,IFLD)
      CALL EOS_PROP_DR(P,ZF(1,2),ADM,ADM,ADM,DPHIGDN,ADGAS,APGAS,BPGAS,
     &          CPGAS,PRLOGG,IEOSTL,TEMPR,1,N,1,0,1,0,1,0,.FALSE.,
     &          .TRUE.,NHC,NDIM,NP,N,IFLD)
C  ASSEMBLE AND INVERT THE JACOBIAN 
      CALL EOS_JAVK(V,XDZ,X,Y,EK,DPHIGDN,EJAC,DIAG,HJAC,NDIM,NP,NHC,
     &              N,IFLD)

! bag8
      DEALLOCATE(DPHIGDN)
! bag8

      END 
 
C***********************************************************************
      SUBROUTINE EOS_JAC_RMK(COEFW,COEFN,EJAC,DIAG,HJAC,DFUGDN,DFUGDP,
     &                       NDIM,NP,NHC,N,IFLD)
C***********************************************************************
      IMPLICIT NONE
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,NP,N,IFLD(NP)
      REAL*8 DIAG(NDIM,NHC),DFUGDP(NDIM,NHC),EJAC(NDIM,NHC*(NHC+1)/2),
     &       HJAC(NDIM,NHC,2),DFUGDN(NDIM,NHC,NHC),COEFW(NP,NHC+1),
     &       COEFN(NDIM,NHC+1)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER I,J,IP,IERR(10),NCP1,KK,I1,I2,I3,I4,JCHECK,ISTART
      REAL*8 S(N)
C-----------------------------------------------------------------------
C  THIS ROUTINE USES THE FUGACITY EQUATIONS TO REDUCE SATURATION CONSTRAINT 
C  EQUATION OF LOG(K), Z, AND P TO ONE OF Z AND P.
C
C  IT TAKES AS INPUT:
C     COEFW(IP,I)    : DERIVATIVE OF SAT W.R.T. LOG(K(I)) AT CONSTANT Z AND P.
C     COEFN(IP,I)    : DERIVATIVE OF SAT W.R.T. N(I) AT CONSTANT K AND P.
C     COEFN(IP,NHC+1) : DERIVATIVE OF SAT W.R.T. P AT CONSTANT K, V AND Z.
C     EJAC          : THE LDLT FACTORIZATION OF THE MATRIX E
C     DIAG          : THE DIAGONAL OF D-INVERSE 
C     HJAC(IP,I,1)  : THE VECTOR ((E**(-1))*H-S)/UT*(E**(-1))*H
C     HJAC(IP,I,2)  : (E**(-1)*U) 
C     DFUGDN(IP,I,J)  : DERIVATIVE OF I-TH FUGACITY EQUATION W.R.T. THE
C                    J-TH MOLE FRACTION 
C     DFUGDP(IP,I)  : DERIVATIVE OF I-TH FUGACITY EQUATION W.R.T. THE
C                     PRESSURE 
C     NHC           : NUMBER OF COMPONENTS.
C     N             : NUMBER OF CELLS.
C  AND RETURNS AS OUTPUT:
C     COEFN(IP,I)    : DERIVATIVE OF SAT W.R.T. N(I) AT CONSTANT P.
C     COEFN(IP,NHC+1) : DERIVATIVE OF SAT W.R.T. P AT CONSTANT Z.
C-----------------------------------------------------------------------
      NCP1 = NHC + 1
      DO KK = 1,N
         IP = IFLD(KK)
         COEFW(IP,1) = COEFW(IP,1)*DIAG(IP,1)
         S(KK) = HJAC(IP,1,1)*COEFW(IP,1)
      END DO 
      DO I = 2,NHC
         DO KK = 1,N
            IP = IFLD(KK)
            COEFW(IP,I) = COEFW(IP,I)*DIAG(IP,I)
            S(KK) = S(KK) + HJAC(IP,I,1)*COEFW(IP,I)
         END DO 
      END DO 
      CALL EOS_SOLV(EJAC,COEFW,NDIM,NHC,1,N,IFLD)
      DO I = 1,NHC
         DO KK = 1, N
            IP = IFLD(KK)
            COEFW(IP,I) = COEFW(IP,I) - S(KK)*HJAC(IP,I,2)
         END DO 
      END DO 
      ISTART = MOD(NHC,4) + 1
      IF(ISTART==2)THEN
         DO J = 1,NHC
            DO KK = 1,N
               IP = IFLD(KK)
               COEFN(IP,J) = COEFN(IP,J) - COEFW(IP,1)*DFUGDN(IP,1,J)
            END DO  
         END DO
         DO KK = 1,N
            IP = IFLD(KK)
            COEFN(IP,NCP1) = COEFN(IP,NCP1) - COEFW(IP,1)*DFUGDP(IP,1)
         END DO  
      ELSEIF(ISTART==3)THEN
         DO J = 1,NHC
            DO KK = 1,N
               IP = IFLD(KK)
               COEFN(IP,J) = COEFN(IP,J)-COEFW(IP,1)*DFUGDN(IP,1,J)
     &                     - COEFW(IP,2)*DFUGDN(IP,2,J)
            END DO  
         END DO
         DO KK = 1,N
            IP = IFLD(KK)
            COEFN(IP,NCP1) = COEFN(IP,NCP1)-COEFW(IP,1)*DFUGDP(IP,1) 
     &                     - COEFW(IP,2)*DFUGDP(IP,2)
         END DO  
      ELSEIF(ISTART==4)THEN
         DO J = 1,NHC
            DO KK = 1,N
               IP = IFLD(KK)
               COEFN(IP,J) = COEFN(IP,J) - COEFW(IP,1)*DFUGDN(IP,1,J) 
     &                     - COEFW(IP,2)*DFUGDN(IP,2,J)
     &                     - COEFW(IP,3)*DFUGDN(IP,3,J)
            END DO  
         END DO
         DO KK = 1,N
            IP = IFLD(KK)
            COEFN(IP,NCP1) = COEFN(IP,NCP1) - COEFW(IP,1)*DFUGDP(IP,1) 
     &                     - COEFW(IP,2)*DFUGDP(IP,2)
     &                     - COEFW(IP,3)*DFUGDP(IP,3)
         END DO  
      ENDIF
      JCHECK = NHC-ISTART
      IF (JCHECK >= 0)   THEN
         DO J = 1,NHC
            DO I1 = ISTART,NHC,4
               I2 = I1 + 1
               I3 = I2 + 1
               I4 = I3 + 1
               DO KK = 1,N
                  IP = IFLD(KK)
                  COEFN(IP,J) = COEFN(IP,J)-COEFW(IP,I1)*DFUGDN(IP,I1,J) 
     &                        - COEFW(IP,I2)*DFUGDN(IP,I2,J)
     &                        - COEFW(IP,I3)*DFUGDN(IP,I3,J)
     &                        - COEFW(IP,I4)*DFUGDN(IP,I4,J)
               END DO  
            END DO 
         END DO
         DO I1 = ISTART,NHC,4
            I2 = I1 + 1
            I3 = I2 + 1
            I4 = I3 + 1
            DO KK = 1,N
               IP = IFLD(KK)
               COEFN(IP,NCP1)=COEFN(IP,NCP1)-COEFW(IP,I1)*DFUGDP(IP,I1) 
     &                       - COEFW(IP,I2)*DFUGDP(IP,I2)
     &                       - COEFW(IP,I3)*DFUGDP(IP,I3)
     &                       - COEFW(IP,I4)*DFUGDP(IP,I4)
            END DO  
         END DO 
      ENDIF 
      END 
 
C***********************************************************************
      SUBROUTINE EOS_JAC_RMV(COEFW,COEFN,XDZ,Y,EK,SBINV,NDIM,
     &                       NP,NHC,N,IFLD)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,NP,N,IFLD(NP)
      REAL*8 SBINV(NDIM),Y(NDIM,NHC),EK(NDIM,NHC),XDZ(NDIM,NHC),
     &       COEFW(NP,NHC+1),COEFN(NDIM,NHC+1)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER I,IP,NCP1,KK
      REAL*8 TEMP
C-----------------------------------------------------------------------
C  THIS ROUTINE REDUCE SATURATION CONSTRAINT EQUATION OF LOG(K), V, P AND Z 
C  TO ONE OF LOG(K(I)), P AND Z.
C  IT TAKES AS INPUT:
C     COEFW(IP,I)    : DERIV OF SAT W.R.T. LOG(K(I)) AT CONSTANT V, P AND Z.
C     COEFW(IP,NCP1) : DERIVATIVE OF SAT W.R.T. V AT CONSTANT K, P AND Z.
C     COEFN(IP,I)    : DERIVATIVE OF SAT W.R.T. N(I) AT CONSTANT K, P AND V.
C     XDZ(IP,I)    : X(I)/Z(I).
C     SBINV(IP) : -1/SUM((Y-X)**2/Z).
C     NHC           : NUMBER OF COMPONENTS.
C     N             : NUMBER OF CELLS.
C
C  AND RETURNS AS OUTPUT:
C     COEFW(IP,I)    : DERIVATIVE OF SAT W.R.T. LOG(K(I)) AT CONSTANT Z AND P.
C     COEFW(IP,NCP1) : DERIVATIVE W.R.T. V
C     COEFN(IP,I)    : DERIVATIVE OF SAT W.R.T. N(I) AT CONSTANT K.
C-----------------------------------------------------------------------
      NCP1 = NHC + 1
      DO KK = 1, N
         IP = IFLD(KK)
         COEFW(IP,NCP1) = COEFW(IP,NCP1)*SBINV(IP)
         TEMP = COEFW(IP,NCP1)*XDZ(IP,1)
         COEFW(IP,1) = COEFW(IP,1) - TEMP*Y(IP,1)
         COEFN(IP,1) = COEFN(IP,1) - TEMP*(EK(IP,1)-ONE)
      END DO 
      DO I = 2, NHC
         DO KK = 1, N
            IP = IFLD(KK)
            TEMP = COEFW(IP,NCP1)*XDZ(IP,I)
            COEFW(IP,I) = COEFW(IP,I) - TEMP*Y(IP,I)
            COEFN(IP,I) = COEFN(IP,I) - TEMP*(EK(IP,I)-ONE)
         END DO 
      END DO 
      END 
 
C***********************************************************************
      SUBROUTINE EOS_JAC_UP(P,V,ZF,X,Y,EK,XDZ,APOIL,BPOIL,CPOIL,
     &           ADOIL,APGAS,BPGAS,CPGAS,ADGAS,PRLOGO,PRLOGG,IEOSTL,
     &           TEMPR,SBINV,EJAC,DIAG,HJAC,DFUGDN,DFUGDP,COEFW,COEFN,
     &           NHC,NDIM,NP,NPAR2P,NFUL2P,NNEG,IFLD)
C***********************************************************************
      IMPLICIT NONE
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,NP,NPAR2P,NFUL2P,NNEG,IEOSTL(NDIM),
     &        IFLD(NP)
      REAL*8 P(NDIM),V(NDIM),TEMPR(NDIM),APOIL(NP),
     &       APGAS(NP),BPOIL(NP),BPGAS(NP),CPOIL(NP),CPGAS(NP),
     &       PRLOGO(NP),PRLOGG(NP),SBINV(NDIM),ZF(NDIM,3),
     &       X(NDIM,NHC),Y(NDIM,NHC),EK(NDIM,NHC),XDZ(NDIM,NHC),
     &       ADGAS(NP,NHC),DIAG(NP,NHC),EJAC(NP,NHC*(NHC+1)/2),
     &       HJAC(NP,NHC,2),DFUGDP(NDIM,NHC),ADOIL(NP,NHC),
     &       DFUGDN(NDIM,NHC,NHC),COEFW(NP,NHC+1),COEFN(NDIM,NHC+1)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER N,IPAR2P,LPAR2P,IFUL2P,LFUL2P,LNEG,L,I,LIMP,
     &        IERR(10),JERR
      LOGICAL SUBPHI,SYM_PACK
!      REAL*8 DVODP(NP),DVGDP(NP),DVODN(NP,NHC),DVGDN(NP,NHC)

! bag8
      REAL*8, ALLOCATABLE :: DVODP(:),DVGDP(:),DVODN(:,:),DVGDN(:,:)
! bag8

C ----------------------------------------------------------------------
C  THIS ROUTINE CALCULATES AND INVERTS THE FULL TWO-PHASE JACOBIAN.
C     XDZ(I)- X(I)/Z(I) FOR COMPONENT I, I=1,..,NHC
C     COEFW   - DERIVATIVES OF SATURATION CONSTRAINT W.R.T. LOG(K(I)) AND V.
C     COEFN   - DERIVATIVES OF SATURATION CONSTRAINT W.R.T. N(I) AND P.
C     EJAC    - MOLAR DERIVATIVE OF OIL FUGACITY ( OUTPUT FROM EOS_PROP_DR) 
C     EJAC    - SYMMETRIC PART OF JACOBIAN CORRESPONDING TO DERIVATIVES
C               OF FUGACITIES W.R.T. LOG(K(I)) (OUTPUT FROM THIS SUBROUTINE)
C     DFUGDN   - DERIVATIVES OF FUGACITIES W.R.T. N(I) (OUTPUT FROM THIS
C              - SUBROUTINE) 
C     DFUGDP   - DERIVATIVES OF FUGACITIES W.R.T. P.
C ----------------------------------------------------------------------

! bag8
      ALLOCATE(DVODP(NP),STAT=JERR)
      IF (JERR.NE.0) STOP 'Could not allocate DVODP'
      ALLOCATE(DVGDP(NP),STAT=JERR)
      IF (JERR.NE.0) STOP 'Could not allocate DVGDP'
      ALLOCATE(DVODN(NP,NHC),STAT=JERR)
      IF (JERR.NE.0) STOP 'Could not allocate DVODN'
      ALLOCATE(DVGDN(NP,NHC),STAT=JERR)
      IF (JERR.NE.0) STOP 'Could not allocate DVGDN'
! bag8

      IPAR2P = 1
      LPAR2P = NPAR2P
      IFUL2P = LPAR2P + 1
      LFUL2P = LPAR2P + NFUL2P
      LNEG = LFUL2P + NNEG
      SYM_PACK = .TRUE.
      SUBPHI = .FALSE.
      CALL EOS_PROP_DR(P,ZF,DVODP,DVODN,DFUGDP,EJAC,ADOIL,APOIL,
     &            BPOIL,CPOIL,PRLOGO,IEOSTL,TEMPR,
     &            IFUL2P,LNEG,IFUL2P,LNEG,IPAR2P,LFUL2P,IPAR2P,
     &            LFUL2P,SUBPHI,SYM_PACK,
     &            NHC,NDIM,NP,LNEG,IFLD)
      SUBPHI = .TRUE.
      SYM_PACK = .FALSE.
      CALL EOS_PROP_DR(P,ZF(1,2),DVGDP,DVGDN,DFUGDP,DFUGDN,ADGAS,APGAS,
     &            BPGAS,CPGAS,PRLOGG,IEOSTL,TEMPR,
     &            IFUL2P,LNEG,IFUL2P,LNEG,IPAR2P,LFUL2P,IPAR2P,
     &            LFUL2P,SUBPHI,SYM_PACK,
     &            NHC,NDIM,NP,LNEG,IFLD)

C-------assemble and invert the full jacobian 
      N = NFUL2P + NNEG
      IF(N > 0)THEN
         L = IFUL2P
         CALL EOS_JEDH(V,XDZ,X,Y,EK,EJAC,DIAG,DFUGDN,
     &                 HJAC,SBINV,NDIM,NP,NHC,N,IFLD(L))
      ENDIF
      N = NPAR2P + NFUL2P
      IF(N > 0)THEN
         L = IPAR2P
         CALL EOS_JWZ(V,XDZ,Y,EK,EJAC,DIAG,HJAC,SBINV,DFUGDN,DFUGDP,
     &                DVODN,DVGDN,DVODP,DVGDP,COEFW,COEFN,NDIM,NP,NHC,
     &                N,IFLD(L))
      ENDIF

! bag8
      DEALLOCATE(DVODP)
      DEALLOCATE(DVGDP)
      DEALLOCATE(DVODN)
      DEALLOCATE(DVGDN)
! bag8

      END 
 
C***********************************************************************
      SUBROUTINE EOS_JAVK(V,XDZ,X,Y,EK,DPHIGDN,EJAC,DIAG,HJAC,
     &                    NDIM,NP,NHC,N,IFLD)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,NP,N,IFLD(NP)
      REAL*8 V(NDIM),X(NDIM,NHC),Y(NDIM,NHC),EK(NDIM,NHC),
     &       DPHIGDN(NDIM,NHC*(NHC+1)/2),DIAG(NDIM,NHC),
     &       EJAC(NDIM,NHC*(NHC+1)/2),XDZ(NDIM,NHC),HJAC(NDIM,NHC,2)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER I,J,ID,K,IP,IM,KK,IERR
      REAL*8 DFGDZ
!      REAL*8 YMXDZ(N,NHC)

! bag8
      REAL*8, ALLOCATABLE :: YMXDZ(:,:)
! bag8

C-----------------------------------------------------------------------
C  THIS ROUTINE ASSEMBLES PARTIAL JACOBIAN REQUIRED FOR
C  CONSTANT-COMPOSITION, CONSTANT-PRESSURE FLASH CALCULATIONS. IT THEN
C  INVERT THAT PORTION OF JACOBIAN TO UPDATE LOG(K(I))
C
C     XDZ(IP,I) : THE VALUE OF X(I)/Z(I) AT POINT IP 
C     EJAC : THE DERIVATIVES OF LOG(PHIO(I)) W.R.T.
C            OIL N(J) AT IP (INPUT) 
C     EJAC : THE LDLT FACTORIZATION OF THE MATRIX ( OUTPUT ) 
C     DFUGDN : THE DERIVATIVES OF LOG(PHIG(I)) W.R.T.
C                       GAS N(J) AT IP (INPUT)
C     DIAG  : THE DIAGONAL OF D-INVERSE 
C     HJAC(IP,I,1) :  ((E**(-1))*H-S)/UT*(E**(-1))*H
C     HJAC(IP,I,2) : (EJAC**(-1)*U) 
C     NHC           : THE NUMBER OF COMPONENTS.
C     NP           : THE NUMBER OF CELLS.
C-----------------------------------------------------------------------

! bag8
      ALLOCATE(YMXDZ(N,NHC),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate YMXDZ'
! bag8

C  DIAG AND DIAGONAL EJAC AND HJAC 
      ID = 0
      DO I = 1, NHC
         ID = ID + I
         DO KK = 1, N
            IP = IFLD(KK)
            YMXDZ(KK,I) = XDZ(IP,I)*(EK(IP,I) - ONE)
            DIAG(IP,I) = ONE/(XDZ(IP,I)*Y(IP,I))
            DFGDZ = DPHIGDN(IP,ID)
            HJAC(IP,I,1)= Y(IP,I)*(EJAC(IP,ID) + YMXDZ(KK,I)*DIAG(IP,I))
            HJAC(IP,I,2) = X(IP,I)*(DFGDZ - YMXDZ(KK,I)*DIAG(IP,I))
            EJAC(IP,ID) = V(IP)*EJAC(IP,ID) + (ONE-V(IP))*DFGDZ + 
     &                    DIAG(IP,I)
         END DO 
      END DO 
C OFF-DIAGONALS OF EJAC AND HJAC 
      K = 0
C     PROCESS ROW I
      DO I = 2, NHC
         K = K + 1
         IM = I - 1
C        PROCESS COLUMN J
         DO J = 1, IM
            K = K + 1
            DO KK = 1, N
               IP = IFLD(KK)
               DFGDZ = DPHIGDN(IP,K)
               HJAC(IP,I,1) = HJAC(IP,I,1) + Y(IP,J)*EJAC(IP,K)
               HJAC(IP,J,1) = HJAC(IP,J,1) + Y(IP,I)*EJAC(IP,K)
               HJAC(IP,I,2) = HJAC(IP,I,2) + X(IP,J)*DFGDZ
               HJAC(IP,J,2) = HJAC(IP,J,2) + X(IP,I)*DFGDZ
               EJAC(IP,K)  = V(IP)*EJAC(IP,K) + (ONE-V(IP))*DFGDZ
            END DO  
         END DO 
      END DO 
C INVERT EJAC 
      CALL EOS_JACINV(EJAC,HJAC,V,Y,X,YMXDZ,NDIM,NP,NHC,N,IFLD)

! bag8
      DEALLOCATE(YMXDZ)
! bag8

      END 
 
C***********************************************************************
      SUBROUTINE EOS_JEDH(V,XDZ,X,Y,EK,EJAC,DIAG,DFUGDN,HJAC,
     &                    SBINV,NDIM,NP,NHC,N,IFLD)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,NP,N,IFLD(N)
      REAL*8 V(NDIM),SBINV(NDIM),X(NDIM,NHC),Y(NDIM,NHC),
     &       EK(NDIM,NHC),XDZ(NDIM,NHC),DIAG(NDIM,NHC),HJAC(NDIM,NHC,2),
     &       EJAC(NDIM,NHC*(NHC+1)/2),DFUGDN(NDIM,NHC,NHC)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER IP,I,J,ID,K,IM,IERR(10),KK,JERR
      REAL*8 DFGDZ
!      REAL*8 SUM(NP),YMXDZ(N,NHC),BYMXDZ(N,NHC)

! bag8
      REAL*8, ALLOCATABLE :: SUM(:),YMXDZ(:,:),BYMXDZ(:,:)
! bag8

C-----------------------------------------------------------------------
C  THIS ROUTINE ASSEMBLES THE FULL JACOBIAN REQUIRED FOR
C  FULL LINEARIZATION OF THE FUGACITY EQUATIONS. IT THEN INVERTS THE
C  PORTION CORRESPONDING TO THE DERIVATIVES W.R.T. THE K-VALUES 
C
C     XDZ(IP,I) : THE VALUE OF X(I)/Z(I) AT POINT IP 
C     SBINV(IP) : -1/SUM((Y-X)**2/Z) 
C     EJAC : THE DERIVATIVES OF LOG(PHIO(I)) W.R.T.
C            OIL N(J) AT IP (INPUT) 
C     EJAC : THE LDLT FACTORIZATION OF THE MATRIX ( OUTPUT ) 
C     DFUGDN : THE DERIVATIVES OF LOG(PHIG(I)) W.R.T.
C                       GAS N(J) AT IP (INPUT)
C     DFUGDN(IP,I,J) : DERIVATIVE OF I-TH FUGACITY EQUATION W.R.T. THE
C                   J-TH MOLE FRACTION. ( OUTPUT)
C     DIAG  : THE DIAGONAL OF D-INVERSE 
C     HJAC(IP,I,1) :  ((E**(-1))*H-S)/UT*(E**(-1))*H
C     HJAC(IP,I,2) : (EJAC**(-1)*U) 
C     NHC           : THE NUMBER OF COMPONENTS.
C     NP           : THE NUMBER OF CELLS.
C-----------------------------------------------------------------------

! bag8
      ALLOCATE(SUM(NP),STAT=JERR)
      IF (JERR.NE.0) STOP 'Could not allocate SUM'
      ALLOCATE(YMXDZ(N,NHC),STAT=JERR)
      IF (JERR.NE.0) STOP 'Could not allocate YMXDZ'
      ALLOCATE(BYMXDZ(N,NHC),STAT=JERR)
      IF (JERR.NE.0) STOP 'Could not allocate BYMXDZ'
! bag8

C  DIAG AND DIAGONAL OF EJAC,HJAC AND DFUGDN 
      ID = 0
      DO I = 1, NHC
         ID = ID + I
         DO KK = 1, N
            IP = IFLD(KK)
            YMXDZ(KK,I) = XDZ(IP,I)*(EK(IP,I) - ONE)
            DIAG(IP,I) = ONE/(XDZ(IP,I)*Y(IP,I))
            DFGDZ = DFUGDN(IP,I,I)
            HJAC(IP,I,1)= Y(IP,I)*(EJAC(IP,ID) + YMXDZ(KK,I)*DIAG(IP,I))
            HJAC(IP,I,2) = X(IP,I)*(DFGDZ - YMXDZ(KK,I)*DIAG(IP,I))
            DFUGDN(IP,I,I) = (EK(IP,I)*DFGDZ - EJAC(IP,ID))*XDZ(IP,I)
            EJAC(IP,ID) = V(IP)*EJAC(IP,ID) + (ONE-V(IP))*DFGDZ +  
     &                    DIAG(IP,I)
         END DO 
      END DO 
C-------off-diagonals of ejac,hjac and DFUGDN 
      K = 0
      DO I = 2, NHC
         K = K + 1
         IM = I - 1
         DO J = 1, IM
            K = K + 1
            DO KK = 1, N
               IP = IFLD(KK)
               DFGDZ = DFUGDN(IP,J,I)
               HJAC(IP,I,1) = HJAC(IP,I,1) + Y(IP,J)*EJAC(IP,K)
               HJAC(IP,J,1) = HJAC(IP,J,1) + Y(IP,I)*EJAC(IP,K)
               HJAC(IP,I,2) = HJAC(IP,I,2) + X(IP,J)*DFGDZ
               HJAC(IP,J,2) = HJAC(IP,J,2) + X(IP,I)*DFGDZ
               DFUGDN(IP,I,J) = (EK(IP,J)*DFGDZ - EJAC(IP,K))*XDZ(IP,J)
               DFUGDN(IP,J,I) = (EK(IP,I)*DFGDZ - EJAC(IP,K))*XDZ(IP,I)
               EJAC(IP,K)  = V(IP)*EJAC(IP,K) + (ONE-V(IP))*DFGDZ
            END DO 
         END DO 
      END DO 
C INVERT EJAC 
      CALL EOS_JACINV(EJAC,HJAC,V,Y,X,YMXDZ,NDIM,NP,NHC,N,IFLD)
      DO I = 1, NHC
         DO KK = 1, N
            IP = IFLD(KK)
            BYMXDZ(KK,I) = YMXDZ(KK,I)*SBINV(IP)
            YMXDZ(KK,I) = Y(IP,I)-X(IP,I)
            HJAC(IP,I,2) = ONE
         END DO 
      END DO 
      DO I = 1, NHC
         DO KK = 1, N
            IP = IFLD(KK)
            SUM(IP) = DFUGDN(IP,I,1)*YMXDZ(KK,1)
         END DO 
         DO J = 2, NHC
            DO KK = 1, N
               IP = IFLD(KK)
               SUM(IP) = SUM(IP) + DFUGDN(IP,I,J)*YMXDZ(KK,J)
            END DO 
         END DO 
         DO J = 1, NHC
            DO KK = 1, N
               IP = IFLD(KK)
               DFUGDN(IP,I,J) = DFUGDN(IP,I,J) + SUM(IP)*BYMXDZ(KK,J)
            END DO 
         END DO  
      END DO  
C   CALCULATE EJAC**(-1)*UT 
      CALL EOS_SOLV(EJAC,HJAC(1,1,2),NDIM,NHC,1,N,IFLD)

! bag8
      DEALLOCATE(SUM)
      DEALLOCATE(YMXDZ)
      DEALLOCATE(BYMXDZ)
! bag8

      END 
 
C***********************************************************************
      SUBROUTINE EOS_JWZ(V,XDZ,Y,EK,EJAC,DIAG,HJAC,
     &                   SBINV,DFUGDN,DFUGDP,DVODN,DVGDN,DVODP,
     &                   DVGDP,COEFW,COEFN,NDIM,NP,NHC,N,IFLD)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,NP,N,IFLD(NP)
      REAL*8 V(NDIM),SBINV(NDIM),DVODP(NP),DVGDP(NP),
     &       Y(NDIM,NHC),XDZ(NDIM,NHC),EK(NDIM,NHC),DIAG(NDIM,NHC),
     &       DFUGDP(NDIM,NHC),EJAC(NDIM,NHC*(NHC+1)/2),
     &       COEFW(NP,NHC+1),COEFN(NDIM,NHC+1),DFUGDN(NDIM,NHC,NHC),
     &       DVODN(NP,NHC),DVGDN(NP,NHC),HJAC(NDIM,NHC,2)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER I,IP,NCP1,KK
      REAL*8 TEMP,LIQ
C-----------------------------------------------------------------------
C  THIS ROUTINE LINEARIZES THE SATURATION CONSTRAINT EQUATION AND REDUCES
C  IT TO A FUNCTION OF N(I) AND P.
C
C     XDZ(IP,I) : THE VALUE OF X(I)/Z(I) AT POINT IP 
C     SBINV(IP) : -1/SUM((Y-X)**2/Z) 
C     EJAC       : THE LDLT FACTORIZATION OF THE MATRIX E
C     DIAG       : THE DIAGONAL OF D-INVERSE 
C     HJAC(IP,I,1) : THE VECTOR ((E**(-1))*H-S)/UT*(E**(-1))*H
C     HJAC(IP,I,2) : (E**(-1)*U) 
C     DFUGDN(IP,I,J) : DERIVATIVE OF I-TH FUGACITY EQUATION W.R.T. THE
C                   J-TH MOLE FRACTION.
C     DVODN : THE DERIVATIVES OF THE OIL PHASE MOLAR VOLUME W.R.T. N(I)
C     DVODP : THE DERIVATIVE OF THE OIL PHASE MOLAR VOLUME W.R.T. PRESSURE.
C     DVGDN : THE DERIVATIVES OF THE GAS PHASE MOLAR VOLUME W.R.T. N(I)
C     DVODP : THE DERIVATIVE OF THE GAS PHASE MOLAR VOLUME W.R.T. PRESSURE.
C     NHC  : THE NUMBER OF COMPONENTS.
C     NP  : THE NUMBER OF CELLS.
C     COEFW : AN ARRAY NEEDED LATER TO REDUCE THE R.H.S. OF SAT. CONSTRAINTS
C     COEFN : THE SATURATION CONSTRAINT COEFFICIENTS.
C-----------------------------------------------------------------------
      NCP1 = NHC + 1
      DO KK = 1, N
         IP = IFLD(KK)
         LIQ = ONE - V(IP)
         TEMP = (DVGDN(IP,1)-DVODN(IP,1))*Y(IP,1)*XDZ(IP,1)
         COEFN(IP,NCP1) = LIQ*DVODP(IP)+V(IP)*DVGDP(IP)
         COEFW(IP,NCP1) = TEMP
         COEFN(IP,1) = ( LIQ*DVODN(IP,1) 
     &                 + EK(IP,1)*V(IP)*DVGDN(IP,1) ) * XDZ(IP,1)
         COEFW(IP,1) = LIQ*V(IP)*TEMP
      END DO 
      DO I = 2, NHC
         DO KK = 1, N
            IP = IFLD(KK)
            LIQ = ONE - V(IP)
            TEMP = (DVGDN(IP,I)-DVODN(IP,I))*Y(IP,I)*XDZ(IP,I)
            COEFW(IP,NCP1) = COEFW(IP,NCP1) + TEMP
            COEFN(IP,I)=( LIQ*DVODN(IP,I)
     &                  + EK(IP,I)*V(IP)*DVGDN(IP,I) ) * XDZ(IP,I)
            COEFW(IP,I) = LIQ*V(IP)*TEMP
         END DO 
      END DO 
C     REMOVE DEPENDENCE OF V 
      CALL EOS_JAC_RMV(COEFW,COEFN,XDZ,Y,EK,SBINV,NDIM,NP,NHC,N,
     &                 IFLD)
C     REMOVE DEPENDENCE OF LOG(K(I)) 
      CALL EOS_JAC_RMK(COEFW,COEFN,EJAC,DIAG,HJAC,DFUGDN,DFUGDP,NDIM,
     &                 NP,NHC,N,IFLD)
      END 
 
C***********************************************************************
      SUBROUTINE EOS_KUP(EK,RES,NDIM,NHC,N,IFLD)
C***********************************************************************
C-----------------------------------------------------------------------
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,N,IFLD(N)
      REAL*8 RES(NDIM,NHC),EK(NDIM,NHC)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER I,IP,KK
      REAL*8 EKMAX,EKMIN,DLNK
C-----------------------------------------------------------------------
C  THIS ROUTINE UPDATES THE K-VALUES 
C-----------------------------------------------------------------------
      EKMAX = BIG
      EKMIN = SMALL
      DO I = 1, NHC
         DO KK = 1, N
            IP = IFLD(KK)
            DLNK = MAX( MIN(RES(IP,I),TEN), -TEN )
            EK(IP,I) = MIN( MAX(EK(IP,I)*EXP(DLNK),EKMIN), EKMAX)
         END DO 
      END DO 
      END 
 
C***********************************************************************
      SUBROUTINE EOS_FORM(A,NDIM,NHC,N,IFLD)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,N,IFLD(N)
      REAL*8 A(NDIM,NHC*(NHC+1)/2)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER I,J,K,L,IM1,JP1,JP2,JM1,II,JJ,KSTRT,IK1,JK1,IK2,JK2,IK3,
     &        JK3,IJ,IK0,JK0,ID,JSTRT,IJ1,IJ2,IJ0,JCHECK,KK,IERR
      REAL*8 T0,T1,T2
!      REAL*8 D(NDIM,NHC)

! bag8
      REAL*8, ALLOCATABLE :: D(:,:)
! bag8

C-----------------------------------------------------------------------
C  THIS ROUTINE PERFORMS AN L-D-LT FACTORIZATION OF N SYMMETRIC
C  MATRICES, EACH OF ORDER NHC.
C
C  IT TAKES AS INPUT:
C     A(L,IJ) : THE IJ ELEMENT (PACKED FORM) OF THE L-TH MATRIX.
C     ND      : THE LEADING DIMENSION OF A OR D.
C     NHC      : THE ORDER OF THE MATRICES.
C     N      : THE NUMBER OF MATRICES.
C
C  IT RETURNS AS OUTPUT:
C     A(L,IJ) : ON THE DIAGONAL, D-INVERSE. OFF-DIAGONAL, THE L-MATRIX.
C     D       : D-INVERSE.
C-----------------------------------------------------------------------

! bag8
      ALLOCATE(D(NDIM,NHC),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate D'
! bag8

      DO KK = 1,N
         L = IFLD(KK)
         D(L,1) = ZERO
         IF(A(L,1) /= ZERO) D(L,1) = ONE/A(L,1)
      END DO 
      II=0
      DO I = 2,NHC
         IM1=I-1
         II=II+IM1
         JJ=0
         DO J = 2,IM1
            JM1=J-1
            JJ=JJ+JM1
            IJ=II+J
            KSTRT=1+MOD(JM1,4)
            IF(KSTRT == 2)THEN
               JK1=JJ+1
               IK1=II+1
               DO KK = 1,N
                  L = IFLD(KK)
                  A(L,IJ)=A(L,IJ)-A(L,IK1)*A(L,JK1)
               END DO 
            ELSEIF(KSTRT == 3)THEN
               JK1=JJ+1
               IK1=II+1
               JK2=JK1+1
               IK2=IK1+1
               DO KK = 1,N
                  L = IFLD(KK)
                  A(L,IJ)=A(L,IJ)-A(L,IK1)*A(L,JK1)-A(L,IK2)*A(L,JK2)
               END DO 
            ELSEIF(KSTRT == 4)THEN
               JK1=JJ+1
               IK1=II+1
               JK2=JK1+1
               IK2=IK1+1
               JK3=JK2+1
               IK3=IK2+1
               DO KK = 1,N
                  L = IFLD(KK)
                  A(L,IJ)=A(L,IJ)-A(L,IK1)*A(L,JK1)-A(L,IK2)*A(L,JK2) 
     &                   -A(L,IK3)*A(L,JK3)
               END DO 
            ENDIF
            JCHECK =JM1 - KSTRT
            IF (JCHECK >= 0)   THEN
               DO K = KSTRT,JM1,4
                  JK0=JJ+K
                  IK0=II+K
                  JK1=JK0+1
                  IK1=IK0+1
                  JK2=JK1+1
                  IK2=IK1+1
                  JK3=JK2+1
                  IK3=IK2+1
                  DO KK = 1,N
                     L = IFLD(KK)
                     A(L,IJ)=A(L,IJ)-A(L,IK0)*A(L,JK0)-A(L,IK1)*A(L,JK1)
     &                      -A(L,IK2)*A(L,JK2)-A(L,IK3)*A(L,JK3)
                  END DO 
               END DO 
            ENDIF 
         END DO 
         ID=II+I
         JSTRT=1+MOD(IM1,3)
         IF(JSTRT == 2)THEN
            IJ1=II+1
            DO KK = 1,N
               L = IFLD(KK)
               T1=A(L,IJ1)
               A(L,IJ1)=T1*D(L,1)
               A(L,ID)=A(L,ID)-T1*A(L,IJ1)
            END DO 
         ELSEIF(JSTRT == 3)THEN
            IJ1=II+1
            IJ2=II+2
            DO KK = 1,N
               L = IFLD(KK)
               T1=A(L,IJ1)
               A(L,IJ1)=T1*D(L,1)
               T2=A(L,IJ2)
               A(L,IJ2)=T2*D(L,2)
               A(L,ID)=A(L,ID)-T1*A(L,IJ1)-T2*A(L,IJ2)
            END DO 
         ENDIF
         JCHECK = IM1 - JSTRT
         IF (JCHECK >= 0)   THEN
            DO J = JSTRT,IM1,3
               IJ0=II+J
               IJ1=IJ0+1
               IJ2=IJ0+2
               JP1=J+1
               JP2=J+2
               DO KK = 1,N
                  L = IFLD(KK)
                  T0=A(L,IJ0)
                  A(L,IJ0)=T0*D(L,J)
                  T1=A(L,IJ1)
                  A(L,IJ1)=T1*D(L,JP1)
                  T2=A(L,IJ2)
                  A(L,IJ2)=T2*D(L,JP2)
                  A(L,ID)=A(L,ID)-T0*A(L,IJ0)-T1*A(L,IJ1)-T2*A(L,IJ2)
               END DO  
            END DO 
         ENDIF 
         DO KK = 1,N
            L = IFLD(KK)
            D(L,I)=ZERO
            IF(A(L,ID) /= ZERO) D(L,I)=ONE/A(L,ID)
         END DO  
      END DO  
      II=0
      DO I = 1,NHC
         II=II+I
         DO KK = 1,N
            L = IFLD(KK)
            A(L,II)=D(L,I)
         END DO 
      END DO

! bag8
      DEALLOCATE(D)
! bag8
  
      END 
 
C***********************************************************************
      SUBROUTINE EOS_SOLV(A,X,NDIM,NHC,NCOL,N,IFLD)
C***********************************************************************
      IMPLICIT NONE
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NCOL,NDIM,N,IFLD(N)
      REAL*8 A(NDIM,NHC*(NHC+1)/2),X(NDIM,NHC,NCOL)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER I,J,K,L,IM1,JP1,JP2,II,JJ,I2,I1,J1,J2,J0,JP3,KK,
     &        JSTRT,IJ0,IJ1,IJ2,IJ3,IP1,IP2,IP3,ISTART
C-----------------------------------------------------------------------
C  THIS ROUTINE SOLVES NP*NCOL SYSTEMS OF NHC EQUATIONS, GIVEN NP LDLT
C  MATRIX FACTORIZATIONS WITH NCOL RIGHT-HAND-SIDES FOR EACH.
C
C  IT TAKES AS INPUT:
C     A(L,IJ) : THE IJ ELEMENT (PACKED FORM) OF THE LDLT FACTORIZATION
C               OF THE L-TH MATRIX.
C     X(L,I,J): THE I-J ELEMENT OF THE L-TH NHC*NCOL RIGHT-HAND-SIDE
C               MATRIX.
C     NDIM    : THE LEADING DIMENSION OF VECTORS.
C     NHC      : THE ORDER OF THE A AND THE NUMBER OF ROWS OF X.
C     NCOL    : THE NUMBER OF COLUMNS OF X.
C     NP      : THE NUMBER OF MATRICES.
C
C  IT RETURNS AS OUTPUT:
C     X       : THE SOLUTION MATRIX.
C-----------------------------------------------------------------------
C  .. FORWARD ELIMINATION
      II=0
      DO I = 2,NHC
         IM1=I-1
         II=II+IM1
         JSTRT=1+MOD(IM1,4)
         IF(JSTRT == 2)THEN
            IJ1=II+1
            DO K = 1,NCOL
               DO KK = 1,N
                  L = IFLD(KK)
                  X(L,I,K)=X(L,I,K)-A(L,IJ1)*X(L,1,K)
               END DO 
            END DO 
         ELSEIF(JSTRT == 3)THEN
            IJ1=II+1
            IJ2=II+2
            DO K = 1,NCOL
               DO KK = 1,N
                  L = IFLD(KK)
                  X(L,I,K)=X(L,I,K)-A(L,IJ1)*X(L,1,K)
     &                     -A(L,IJ2)*X(L,2,K)
               END DO 
            END DO 
         ELSEIF(JSTRT == 4)THEN
            IJ1=II+1
            IJ2=II+2
            IJ3=II+3
            DO K = 1,NCOL
               DO KK = 1,N
                  L = IFLD(KK)
                  X(L,I,K)=X(L,I,K)-A(L,IJ1)*X(L,1,K)-A(L,IJ2)*X(L,2,K)
     &                    -A(L,IJ3)*X(L,3,K)
               END DO 
            END DO 
         ENDIF 
         IF (IM1 >= JSTRT)   THEN
            DO J = JSTRT,IM1,4
               IJ0=II+J
               IJ1=IJ0+1
               IJ2=IJ0+2
               IJ3=IJ0+3
               JP1=J+1
               JP2=J+2
               JP3=J+3
               DO K = 1,NCOL
                  DO KK = 1,N
                     L = IFLD(KK)
                     X(L,I,K) = X(L,I,K)-A(L,IJ0)*X(L,J,K)
     &                        - A(L,IJ1)*X(L,JP1,K) 
     &                        - A(L,IJ2)*X(L,JP2,K)-A(L,IJ3)*X(L,JP3,K)
                  END DO 
               END DO 
            END DO 
         ENDIF 
      END DO
C  .. MULTIPLY BY (INVERSE) DIAGONAL
      I2=0
      ISTART=1+MOD(NHC,2)
      IF(ISTART == 2)THEN
         I2=1
         DO K = 1,NCOL
            DO KK = 1,N
               L = IFLD(KK)
               X(L,1,K) = X(L,1,K)*A(L,I2)
            END DO 
         END DO 
      ENDIF
      IF (NHC >= ISTART)   THEN
         DO I = ISTART,NHC,2
            IP1=I+1
            I1=I2+I
            I2=I1+IP1
            DO K = 1,NCOL
               DO KK =1,N
                  L = IFLD(KK)
                  X(L,I,K) = X(L,I,K)*A(L,I1)
                  X(L,IP1,K) = X(L,IP1,K)*A(L,I2)
               END DO 
            END DO 
         END DO 
      ENDIF 
C  .. BACK SUBSTITUTION
      II=I2
      DO I = NHC-1,1,-1
         IP1=I+1
         IP2=I+2
         IP3=I+3
         II=II-I-1
         JJ=II
         JSTRT=1+MOD(NHC-I,4)
         IF(JSTRT == 2)THEN
            JJ=JJ+I
            DO K = 1,NCOL
               DO KK = 1,N
                  L = IFLD(KK)
                  X(L,I,K) = X(L,I,K)-A(L,JJ)*X(L,IP1,K)
               END DO 
            END DO 
         ELSEIF(JSTRT == 3)THEN
            J1=JJ+I
            JJ=J1+I+1
            DO K = 1,NCOL
               DO KK = 1,N
                  L = IFLD(KK)
                  X(L,I,K) = X(L,I,K)-A(L,J1)*X(L,IP1,K)
     &                     - A(L,JJ)*X(L,IP2,K)
               END DO 
            END DO 
         ELSEIF(JSTRT == 4)THEN
            J1=JJ+I
            J2=J1+IP1
            JJ=J2+IP2
            DO K = 1,NCOL
               DO KK = 1,N
                  L = IFLD(KK)
                  X(L,I,K) = X(L,I,K)-A(L,J1)*X(L,IP1,K)
     &                     - A(L,J2)*X(L,IP2,K)
     &                     - A(L,JJ)*X(L,IP3,K)
               END DO 
            END DO 
         ENDIF
         IF (NHC >= (I+JSTRT))   THEN
            DO J = I+JSTRT,NHC,4
               JP1=J+1
               JP2=J+2
               JP3=J+3
               J0=JJ+J-1
               J1=J0+J
               J2=J1+JP1
               JJ=J2+JP2
               DO K = 1,NCOL
                  DO KK = 1,N
                     L = IFLD(KK)
                     X(L,I,K) = X(L,I,K)-A(L,J0)*X(L,J,K)
     &                        - A(L,J1)*X(L,JP1,K)
     &                        - A(L,J2)*X(L,JP2,K) - A(L,JJ)*X(L,JP3,K)
                  END DO 
               END DO 
            END DO
         ENDIF 
      END DO 
      END
  
C***********************************************************************
      SUBROUTINE EOS_MASDNH(Z,DN,DM,NHC,NDIM,NP,N,IFLD) 
C***********************************************************************
      USE xgendat
      IMPLICIT NONE
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER  NP,NHC,NDIM,N,IFLD(N)
      REAL*8 Z(NDIM,NHC),DN(NP),DM(NDIM) 
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER  IP, IC, JC, L, KK
      REAL*8 MW
C-----------------------------------------------

C  CALCULATE AVERAGE MOLECULAR WEIGHT
      DO KK = 1, N 
         IP = IFLD(KK)
         DM(IP) = WMOL(1)*Z(IP,1) 
      END DO 
      DO IC = 2, NHC 
         MW = WMOL(IC)
         DO KK = 1, N 
            IP = IFLD(KK)
            DM(IP) = DM(IP) + MW*Z(IP,IC) 
         END DO 
      END DO 
C
C  CALCULATE DM
      DO KK = 1, N 
         IP = IFLD(KK)
         DM(IP) =  DN(IP)*DM(IP) 
      END DO 
      END 
 
C***********************************************************************
      SUBROUTINE EOS_MVAQ(WTOTL,HCTOTL,FLTYPE,FLZF,VOLD,V,ND,TOL_SAT,
     &                    NACT,IFLD,NPH)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER ND,FLTYPE(MXFLTYPE),NACT,IFLD(ND)            
      REAL*8 TOL_SAT,HCTOTL(ND),WTOTL(ND),FLZF(ND,3),VOLD(ND),V(ND)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER NTOP,NBOT,IP,NMOV,MM,M,KK,NPH,IERR
      REAL*8 EPS,EPS1,EPS2
      PARAMETER (EPS1 = TEN_M4)
      PARAMETER (EPS2 = TEN_M6)
!      REAL*8 TEMP(ND)

! bag8
      REAL*8, ALLOCATABLE :: TEMP(:)
! bag8

C ----------------------------------------------------------------------
C  THIS ROUTINE CHECKS FOR AND HANDLES THE APPEARANCE AND DISAPPEARANCE
C  OF AQUIFER POINTS, I.E. NO HYDROCARBON PRESENT
C  NEW HC POINTS ARE RECLASSIFIED AS TESTED POINTS, I.E. TYPE 5 POINTS.
C  NEW AQUIFER POINTS ARE MOVED IN A WAY WHICH DOES NOT PRESERVE ANY
C  DISTINCTION BETWEEN POINTS OF TYPES 1, 2, AND 3
C     NHCP - NUMBER OF HYDROCARBON POINTS
C ----------------------------------------------------------------------

      ALLOCATE(TEMP(ND),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate TEMP'

      IF(NPH > 1) THEN
         DO KK = 1,NACT
            IP = IFLD(KK)
            TEMP(IP)=HCTOTL(IP)/(HCTOTL(IP)+WTOTL(IP))
         END DO 
      ENDIF

C-------identify cells with hc mole fraction larger than EPS
      EPS = MIN(EPS2, EPS1*TOL_SAT)

C-------move hydrocarbon cells to the top for type 2
      M = 1
      MM = FLTYPE(2)
      NTOP = 0
      IF (MM > 0) THEN
         CALL EOS_MOVE(TEMP,EPS,3,NTOP,NMOV,IFLD(M),ND,MM)
         NBOT = FLTYPE(2) - NTOP 
         FLTYPE(2) = NTOP
         FLTYPE(3) = FLTYPE(3) + NBOT
      ENDIF

C-------move hydrocarbon cells to the top for type 3
      M = M + FLTYPE(2) 
      MM = FLTYPE(3)
      NTOP = 0
      IF (MM > 0) THEN
         CALL EOS_MOVE(TEMP,EPS,3,NTOP,NMOV,IFLD(M),ND,MM)
         NBOT = FLTYPE(3) - NTOP 
         FLTYPE(3) = NTOP
         FLTYPE(5) = FLTYPE(5) + NBOT
      ENDIF 

C-------move hydrocarbon cells to the top for type 5
      M = M + FLTYPE(3) 
      MM = FLTYPE(5)
      NTOP = 0
      IF (MM > 0) THEN
         CALL EOS_MOVE(TEMP,EPS,3,NTOP,NMOV,IFLD(M),ND,MM)
         NBOT = FLTYPE(5) - NTOP 
         FLTYPE(5) = NTOP
         FLTYPE(6) = FLTYPE(6) + NBOT
      ENDIF 

C-------move hydrocarbon cells to the top for type 6
      M = M + FLTYPE(5) 
      MM = FLTYPE(6)
      NTOP = 0
      IF (MM > 0 .AND. NPH > 1)   THEN
         CALL EOS_MOVE(TEMP,EPS,3,NTOP,NMOV,IFLD(M),ND,MM)
         FLTYPE(5) = FLTYPE(5) + NTOP
         FLTYPE(6) = FLTYPE(6) - NTOP
      ENDIF 

C-------initialize vectors for new hc points
      IF(NPH > 2) THEN
         DO KK = M,M+NTOP-1
            IP = IFLD(KK)
            FLZF(IP,1)=ONE
            FLZF(IP,2)=ONE
            VOLD(IP)=ZERO
            V(IP)=ZERO
         END DO 
      ELSE
         DO KK = M,M+NTOP-1
            IP = IFLD(KK)
            FLZF(IP,1)=ONE
         END DO 
      ENDIF

! bag8
      DEALLOCATE(TEMP)
! bag8

      END

C***********************************************************************
      SUBROUTINE EOS_FLAG(IVAL_OUT,LOC,IFLD,V,TCOFX,TCOFY,TCOFZ,
     &                    IDIM,JDIM,KDIM,IL1,IL2,KL1,KL2,JL1V,JL2V,
     &                    NBLK,NEG_FLASH,FIRST_PASS,FLTYPE,
     &                    NDIM,Z,ND,NHC)
C***********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'xparam.h'
      INCLUDE 'control.h'
      INCLUDE 'wells.h'
      INCLUDE 'xwells.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,IL1,IL2,KL1,KL2,JL1V(KDIM),JL2V(KDIM)     
      INTEGER NDIM,ND,NHC,NBLK
      INTEGER IFLD(NDIM),FLTYPE(MXFLTYPE),LOC(NDIM),IVAL_OUT(NDIM)
      LOGICAL NEG_FLASH,FIRST_PASS
      REAL*8 V(NDIM)
      REAL*8 TCOFX(NDIM),TCOFY(NDIM),TCOFZ(NDIM),Z(NDIM,NHC)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER I,K,L,IP,N2PH,NHCP,KK,IJDIM,IOFF,JOFF,KOFF,MERR
!      INTEGER IVAL(NDIM)

! bag8
      INTEGER, ALLOCATABLE :: IVAL(:)
! bag8

C-----------------------------------------------------------------------
C  IT TAKES AS INPUT:
C     V(I)      - VAPOR FRACTION AT FLUID POINT I.
C     IFLD(I)   - GRID-POINT NUMBER OF FLUID POINT I.
C     NEG_FLASH - WHETHER OR NOT THERE MIGHT BE NEGATIVE-FLASH POINTS
C                 (WITH VAPOR FRACTIONS OUTSIDE THE RANGE 0 TO 1)
C                  WITHIN THE TWO-PHASE POINTS.
C     N2PH      - NUMBER OF TWO-PHASE POINTS.
C     NHCP      - NUMBER OF HYDROCARBON POINTS.
C  THIS ROUTINE WORKS AS FOLLOWS:
C     IVAL IS SET TO:
C        0  - FOR SINGLE PHASE LIQUID 
C        1  - FOR SINGLE PHASE VAPOR 
C        3  - FOR 2-PHASE POINTS 
C       10  - FOR AQUIFER AND ZERO PV POINTS 
C     EOS_NEBR SETS IVAL_OUT TO NONZERO IF TESTING REQUIRED
C              SETS LOC TO CELL LOCATION IF 2-PHASE CELL NEAR 1-PHASE CELL
C     IVAL_OUT ALSO SET TO NONZERO FOR WELL CELLS AND BOUNDARY CELLS
C  IVAL_OUT() = 0, NO ACTION REQUIRED
C               1, SINGLE PHASE LIQUID BESIDE SINGLE PHASE VAPOR
C               2, SINGLE PHASE BESIDE TWO PHASE CELL
C               3, BOUNDARY CELL WITH NONZERO TRANSMISSIBILITY
C              15, WELL CELL
C  LOC() = LOCATION FOR BORROWING K-VALUES AND ZF (CLOSEST COMPOSITION)
C-----------------------------------------------------------------------

! bag8
      ALLOCATE(IVAL(NDIM),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate IVAL'
! bag8

      N2PH = FLTYPE(1) + FLTYPE(2) + FLTYPE(3)
      NHCP = N2PH + FLTYPE(4) + FLTYPE(8) + FLTYPE(9) + FLTYPE(5)
      IF(NEG_FLASH)THEN
         DO KK = 1, N2PH
            IP = IFLD(KK)
            IF (V(IP) <= ZERO)   THEN
               IVAL(IP) = 0
            ELSEIF (V(IP) >= ONE) THEN
               IVAL(IP) = 1
            ELSE
               IVAL(IP) = 3
            ENDIF
         END DO 
      ELSE
         DO KK = 1, N2PH
            IP = IFLD(KK)
            IVAL(IP) = 3
         END DO 
      ENDIF
      DO KK = N2PH+1, NHCP
         IP = IFLD(KK)
         IVAL(IP) = V(IP)
      END DO 
      DO KK = NHCP+1, NDIM
         IP = IFLD(KK)
         IVAL(IP) = 10
      END DO
      CALL EOS_NEBR(IVAL,IVAL_OUT,LOC,NDIM,IDIM,JDIM,KDIM,IL1,IL2,
     &              KL1,KL2,JL1V,JL2V,TCOFX,TCOFY,TCOFZ,Z,ND,NHC)
      
C ------FLAG WELL CELLS, BOUNDARY CELLS, AND INTERFACE CELLS
      IF(FIRST_PASS)THEN
         CALL EOS_BNDRY(IVAL_OUT,IDIM,JDIM,KDIM,IL1,IL2,
     &                  KL1,KL2,JL1V,JL2V,TCOFX,TCOFY,TCOFZ)

$DUAL         CALL DUAL_BNDRY(IVAL_OUT,IDIM,JDIM,KDIM,NBLK)

C        GET LOCAL TO GLOBAL INDEX OFFSETS
         CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,MERR)

         IJDIM = IDIM*JDIM
         JOFF = JOFF + 1
         KOFF = KOFF + 1
         DO IW = 1,NUMWEL
            IF(MODWEL(IW) /= MODACT) CYCLE
            IF(IWTYPE(IW) == 0) CYCLE
            DO  L = 1,NUMELE(IW)
               IF (LOCWEL(6,L,IW) /= MYPRC) CYCLE
               IF (LOCWEL(1,L,IW) /= NBLK) CYCLE
               IF(ELECONS(L,IW) == ZERO) CYCLE
               K = LOCWEL(3,L,IW)-IOFF + IDIM*(LOCWEL(4,L,IW)-JOFF)
     &           + IJDIM*(LOCWEL(5,L,IW)-KOFF)
               IVAL_OUT(K) = 15
            END DO   
         END DO
      ENDIF

! bag8
      DEALLOCATE(IVAL)
! bag8

      END 
 
C***********************************************************************
      SUBROUTINE EOS_MOVE(VAL,TOL,IMODE,NPOINT,NMOV,IPNT,NDIM,N)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER IMODE,NDIM,N,NPOINT,NMOV,IPNT(N)
      REAL*8  TOL,VAL(NDIM)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER I,KK,IERR
!      INTEGER ISTART(N),IEND(N)

! bag8
      INTEGER, ALLOCATABLE :: ISTART(:),IEND(:)
! bag8

C     THIS ROUTINE REORDERS ELEMENTS IN IPNT VECTOR BASED UPON VAL VALUES
C     VAL   - IS AN ARRAY OF VALUES ASSOCIATED WITH THE POINTS
C     TOL   - IS A TARGET VALUE OF VAL
C     IMODE = 1 MOVES UP POINTS WITH VAL(I) < TOL
C     IMODE = 2 MOVES UP POINTS WITH VAL(I) <= TOL
C     IMODE = 3 MOVES UP POINTS WITH VAL(I) > TOL
C     IMODE = 4 MOVES UP POINTS WITH VAL(I) >= TOL
C     IMODE = 5 MOVES UP POINTS WITH 0.0 < VAL(I) < 1.0
C     IMODE = 6 UNCONDITIONAL MOVE OF NPOINT POINTS FROM BACK TO FRONT
C               (VALUE OF NPOINT SUPPLIED)
C     NPOINT  = THE NUMBER OF POINTS SATISFYING CRITERION
C               (CALCULATED EXCEPT IMODE = 6)
C     NMOV  = NUMBER OF POINTS WHICH MUST BE MOVED
C     IPNT  - ARRAY OF POINTERS TO BE REARRANGED
C     NDIM    - DIMENSION OF VECTOR VAL
C     N    - NUMBER OF TOTAL POINTS IN THE IPNT

! bag8
      ALLOCATE(ISTART(N),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate ISTART'
      ALLOCATE(IEND(N),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate IEND'
! bag8

C-------val < tol 
      IF(IMODE == 1)THEN
C        identify points satisfying criterion
         NPOINT = 0
         NMOV = 0
         DO KK = 1,N
            I = IPNT(KK)
            IF(VAL(I) < TOL)THEN
               NPOINT = NPOINT + 1
               ISTART(NPOINT) = I
            ELSE
               NMOV = NMOV + 1
               IEND(NMOV) = I
            ENDIF
         END DO 
         IF(NPOINT == N .OR. NPOINT == 0) GOTO 123

C-------val <= tol
      ELSEIF(IMODE == 2)THEN
         NPOINT = 0
         NMOV = 0
         DO KK = 1,N
            I = IPNT(KK)
            IF(VAL(I) <= TOL)THEN
               NPOINT = NPOINT + 1
               ISTART(NPOINT) = I
            ELSE
               NMOV = NMOV + 1
               IEND(NMOV) = I
            ENDIF
         END DO 
         IF(NPOINT == N .OR. NPOINT == 0) GOTO 123

C-------val > tol
      ELSEIF(IMODE == 3)THEN
         NPOINT = 0
         NMOV = 0
         DO KK = 1,N
            I = IPNT(KK)
            IF(VAL(I) > TOL)THEN
               NPOINT = NPOINT + 1
               ISTART(NPOINT) = I
            ELSE
               NMOV = NMOV + 1
               IEND(NMOV) = I
            ENDIF
         END DO 
         IF(NPOINT == N .OR. NPOINT == 0) GOTO 123

C-------val >= tol
      ELSEIF(IMODE == 4)THEN
         NPOINT = 0
         NMOV = 0
         DO KK = 1,N
            I = IPNT(KK)
            IF(VAL(I) >= TOL)THEN
               NPOINT = NPOINT + 1
               ISTART(NPOINT) = I
            ELSE
               NMOV = NMOV + 1
               IEND(NMOV) = I
            ENDIF
         END DO 
         IF(NPOINT == N .OR. NPOINT == 0) GOTO 123

C-------0.0 < val >= one
      ELSEIF(IMODE == 5)THEN
         NPOINT = 0
         NMOV = 0
         DO KK = 1,N
            I = IPNT(KK)
            IF(VAL(I) > ZERO .AND. VAL(I) < ONE) THEN
               NPOINT = NPOINT + 1
               ISTART(NPOINT) = I
            ELSE
               NMOV = NMOV + 1
               IEND(NMOV) = I
            ENDIF
         END DO 
         IF(NPOINT == N .OR. NPOINT == 0) GOTO 123

C-------move npoint values from back to front
      ELSEIF(IMODE == 6)THEN
         IF(NPOINT == N .OR. NPOINT == 0) GOTO 123
         NMOV = NPOINT
         KK = N-NPOINT
         DO I = 1,NMOV
            ISTART(I) = IPNT(KK+I)
         END DO
         DO I = N,NMOV+1,-1
            IPNT(I) = IPNT(I-NMOV)
         END DO
         DO I = 1,NMOV
            IPNT(I) = ISTART(I)
         END DO
         GOTO 123
      ENDIF

      DO I = 1,NPOINT
         IPNT(I) = ISTART(I)
      END DO
      DO I = 1,NMOV
         IPNT(NPOINT+I) = IEND(I)
      END DO

! bag8
 123  CONTINUE
      DEALLOCATE(ISTART)
      DEALLOCATE(IEND)
! bag8

      END 
 
C***********************************************************************
      SUBROUTINE EOS_MOVE_INT(VAL,TOL,IMODE,NPOINT,NMOV,IPNT,NDIM,NP)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER IMODE,NP,NDIM,NPOINT,NMOV,IPNT(NP),VAL(NDIM),TOL
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER I,KK,IERR
!      INTEGER ISTART(NP),IEND(NP)

! bag8
      INTEGER, ALLOCATABLE :: ISTART(:),IEND(:)
! bag8

C     THIS ROUTINE REORDERS ELEMENTS IN IPNT VECTOR BASED UPON VAL VALUES
C     SAME AS EOS_MOVE ROUTINE EXCEPT FOR INTEGER
C     VAL   - IS AN ARRAY OF VALUES ASSOCIATED WITH THE POINTS
C     TOL   - IS A TARGET VALUE OF VAL
C     IMODE = 1 MOVES UP POINTS WITH VAL(I) < TOL
C     IMODE = 2 MOVES UP POINTS WITH VAL(I) <= TOL
C     IMODE = 3 MOVES UP POINTS WITH VAL(I) > TOL
C     IMODE = 4 MOVES UP POINTS WITH VAL(I) >= TOL
C     IMODE = 5 NOT VALID 
C     IMODE = 6 UNCONDITIONAL MOVE OF NPOINT POINTS FROM BACK TO FRONT
C               (VALUE OF NPOINT SUPPLIED)
C     NPOINT  = THE NUMBER OF POINTS SATISFYING CRITERION
C               (CALCULATED EXCEPT IMODE = 6)
C     NMOV  = NUMBER OF POINTS WHICH MUST BE MOVED
C     IPNT  - ARRAY OF POINTERS TO BE REARRANGED
C     ND    - DIMENSION OF VECTOR VAL
C     NP    - NUMBER OF TOTAL POINTS IN THE IPNT

! bag8
      ALLOCATE(ISTART(NP),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate ISTART'
      ALLOCATE(IEND(NP),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate IEND'
! bag8

C-------val < tol 
      IF(IMODE == 1)THEN
C        identify points satisfying criterion
         NPOINT = 0
         NMOV = 0
         DO KK = 1,NP
            I = IPNT(KK)
            IF(VAL(I) < TOL)THEN
               NPOINT = NPOINT + 1
               ISTART(NPOINT) = I
            ELSE
               NMOV = NMOV + 1
               IEND(NMOV) = I
            ENDIF
         END DO 
         IF(NPOINT == NP .OR. NPOINT == 0) GOTO 123

C-------val <= tol
      ELSEIF(IMODE == 2)THEN
         NPOINT = 0
         NMOV = 0
         DO KK = 1,NP
            I = IPNT(KK)
            IF(VAL(I) <= TOL)THEN
               NPOINT = NPOINT + 1
               ISTART(NPOINT) = I
            ELSE
               NMOV = NMOV + 1
               IEND(NMOV) = I
            ENDIF
         END DO 
         IF(NPOINT == NP .OR. NPOINT == 0) GOTO 123

C-------val > tol
      ELSEIF(IMODE == 3)THEN
         NPOINT = 0
         NMOV = 0
         DO KK = 1,NP
            I = IPNT(KK)
            IF(VAL(I) > TOL)THEN
               NPOINT = NPOINT + 1
               ISTART(NPOINT) = I
            ELSE
               NMOV = NMOV + 1
               IEND(NMOV) = I
            ENDIF
         END DO 
         IF(NPOINT == NP .OR. NPOINT == 0) GOTO 123

C-------val >= tol
      ELSEIF(IMODE == 4)THEN
         NPOINT = 0
         NMOV = 0
         DO KK = 1,NP
            I = IPNT(KK)
            IF(VAL(I) >= TOL)THEN
               NPOINT = NPOINT + 1
               ISTART(NPOINT) = I
            ELSE
               NMOV = NMOV + 1
               IEND(NMOV) = I
            ENDIF
         END DO 
         IF(NPOINT == NP .OR. NPOINT == 0) GOTO 123

C-------0.0 < val >= one
      ELSEIF(IMODE == 5) THEN
         NPOINT = 0
         NMOV = 0
         GOTO 123

C-------move npoint values from back to front
      ELSEIF(IMODE == 6) THEN
         IF(NPOINT == NP .OR. NPOINT == 0) GOTO 123
         NMOV = NPOINT
         KK = NP-NPOINT
         DO I = 1,NMOV
            ISTART(I) = IPNT(KK+I)
         END DO
         DO I = NP,NMOV+1,-1
            IPNT(I) = IPNT(I-NMOV)
         END DO
         DO I = 1,NMOV
            IPNT(I) = ISTART(I)
         END DO
         GOTO 123
      ENDIF

      DO I = 1,NPOINT
         IPNT(I) = ISTART(I)
      END DO
      DO I = 1,NMOV
         IPNT(NPOINT+I) = IEND(I)
      END DO

! bag8
 123  CONTINUE
      DEALLOCATE(ISTART)
      DEALLOCATE(IEND)
! bag8

      END 
 
C***********************************************************************
      SUBROUTINE EOS_BNDRY(IVAL_OUT,IDIM,JDIM,KDIM,IL1,IL2,
     &                     KL1,KL2,JL1V,JL2V,TCOFX,TCOFY,TCOFZ)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,IL1,IL2,KL1,KL2,JL1V(KDIM),JL2V(KDIM),
     &        IVAL_OUT(IDIM,JDIM,KDIM)
      REAL*8 TCOFX(IDIM,JDIM,KDIM),TCOFY(IDIM,JDIM,KDIM),
     &       TCOFZ(IDIM,JDIM,KDIM)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER I,J,K,J1,J2,L
C-----------------------------------------------------------------------
C  THIS ROUTINE TAGS ALL BOUNDARY CELLS FOR TESTING
C  ASSUMES THAT IDIM > IL2, JDIM > JL2V, AND KDIM > KL2
C-----------------------------------------------------------------------
C-------JK planes
      L = IL2 + 1
      DO K = KL1,KL2
         DO J = JL1V(KL1),JL2V(KL1)
            IF(TCOFX(IL1,J,K) > ZERO) IVAL_OUT(IL1,J,K) = 3
            IF(TCOFX(L,J,K) > ZERO) IVAL_OUT(IL2,J,K) = 3
         END DO
      END DO
C-------IK planes
      DO K = KL1,KL2
         J1 = JL1V(K)
         J2 = JL2V(K)
         L = J2 + 1
         DO I = IL1,IL2
            IF(TCOFY(I,J1,K) > ZERO) IVAL_OUT(I,J1,K) = 3
            IF(TCOFY(I,L,K) > ZERO) IVAL_OUT(I,J2,K) = 3
         END DO
      END DO
C-------IJ planes
C     K-MINUS FACE AT KL1
      L = KL1 + 1
      DO J = JL1V(KL1),JL2V(KL1)
         DO I = IL1,IL2
            IF(TCOFZ(I,J,KL1) > ZERO) IVAL_OUT(I,J,KL1) = 3
         END DO
      END DO
C     K-PLUS FACES
      DO K = KL1,KL2-1
         L = K + 1
         DO J = JL1V(K),JL1V(L)-1
            DO I = IL1,IL2
               IF(TCOFZ(I,J,L) > ZERO) IVAL_OUT(I,J,K) = 3
            END DO
         END DO
         DO J = JL2V(L)+1,JL2V(K)
            DO I = IL1,IL2
               IF(TCOFZ(I,J,L) > ZERO) IVAL_OUT(I,J,K) = 3
            END DO
         END DO
      END DO
C     K-MINUS FACES
      DO K = KL1+1,KL2
         L = K - 1
         DO J = JL1V(K),JL1V(L)-1
            DO I = IL1,IL2
               IF(TCOFZ(I,J,K) > ZERO) IVAL_OUT(I,J,K) = 3
            END DO
         END DO
         DO J = JL2V(L)+1,JL2V(K)
            DO I = IL1,IL2
               IF(TCOFZ(I,J,K) > ZERO) IVAL_OUT(I,J,K) = 3
            END DO
         END DO
      END DO
C     K-PLUS FACE AT KL2
      L = KL2 + 1
      DO J = JL1V(KL2),JL2V(KL2)
         DO I = IL1,IL2
            IF(TCOFZ(I,J,L) > ZERO) IVAL_OUT(I,J,KL2) = 3
         END DO
      END DO
      END
 
C***********************************************************************
      SUBROUTINE EOS_NEBR(IVAL,IVAL_OUT,LOC,NDIM,IDIM,JDIM,KDIM,IL1,IL2,
     &                    KL1,KL2,JL1V,JL2V,TCOFX,TCOFY,TCOFZ,
     &                    Z,ND,NHC)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,IL1,IL2,KL1,KL2,JL1V(KDIM),JL2V(KDIM),
     &        NDIM,IVAL(NDIM),IVAL_OUT(NDIM),NHC,ND,LOC(NDIM)
      REAL*8 TCOFX(NDIM),TCOFY(NDIM),TCOFZ(NDIM),Z(NDIM,NHC)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER K,J,I,IDELTA,IDIF,J1,J2,L1,L2,IJDIM,IJKDIM,IC,IJ,IERR
      REAL*8 U
!      REAL*8 ZVAL(NDIM)

! bag8
      REAL*8, ALLOCATABLE :: ZVAL(:)
! bag8

C-----------------------------------------------------------------------
C  THIS ROUTINE SCANS THE GRID AND SETS VALUES OF LOC AND IVAL_OUT 
C  BASED UPON IVAL DIFFERENCES 
C  TEST 1-PHASE CELLS FOR 2-PHASE IF:
C           (1) 1-PHASE CELL BESIDE 2-PHASE CELL
C           (2) VAPOR PHASE CELL BESIDE LIQUID PHASE CELL
C  LOC SET FOR CELLS THAT ARE 1-PHASE AND BESIDE A 2-PHASE CELL
C  BORROW K-VALUES FROM CONNECTED 2-PHASE CELL WITH CLOSEST COMPOSITION
C
C  TCOFX(I,J,K) IS CONNECTION BETWEEN (I,J,K) AND (I-1,J,K)
C  TCOFY(I,J,K) IS CONNECTION BETWEEN (I,J,K) AND (I,J-1,K)
C  TCOFZ(I,J,K) IS CONNECTION BETWEEN (I,J,K) AND (I,J,K-1)
C  TCOFX(L1)=TCOFX(I,J,K) WHERE L1 = I + (J-1)*IDIM + (K-1)*IDIM*JDIM
C  IVAL_OUT() = 0, NO ACTION REQUIRED
C               1, SINGLE PHASE LIQUID BESIDE SINGLE PHASE VAPOR
C               2, SINGLE PHASE BESIDE TOW PHASE CELL
C  LOC() = LOCATION FOR BORROWING K-VALUES AND ZF (CLOSEST COMPOSITION)
C-----------------------------------------------------------------------

! bag8
      ALLOCATE(ZVAL(NDIM),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate ZVAL'
! bag8

C-------set up ZVAL so K values will be chosen from closest composition
      IJ = IDIM*JDIM
      DO K = KL1,KL2
         IJDIM = (K-1) * IJ
         DO J = JL1V(K),JL2V(K)
            L1 = (J-1)*IDIM + IJDIM + IL1 
            DO I = IL1,IL2
               ZVAL(L1) = TEN
               LOC(L1) = 0
               IVAL_OUT(L1) = 0
               L1 = L1 + 1
            END DO
         END DO
      END DO
C-----------------------------------------------------------------------
C     X-DIRECTION
C-----------------------------------------------------------------------
      DO K = KL1,KL2
         IJDIM = (K-1) * IJ
         DO J = JL1V(K),JL2V(K)
            IJKDIM = (J-1)*IDIM + IJDIM
            DO I = IL1+1,IL2
               L1 = I + IJKDIM
               L2 = L1 - 1
               IF (TCOFX(L1) == ZERO) CYCLE
               IDELTA = IVAL(L1)-IVAL(L2)
               IDIF = ABS(IDELTA)

C----------------cells of same type or one cell is zero pv or aquifer
               IF (IDELTA == 0 .OR. IDIF > 5) CYCLE

C----------------cell L1 is two-phase while cell L2 is one-phase
               IF (IDELTA > 1) THEN
                  U = ABS(Z(L1,1)-Z(L2,1))
                  DO IC = 2,NHC
                     U = U + ABS(Z(L1,IC)-Z(L2,IC))
                  END DO
                  IF (U < ZVAL(L2)) THEN
                     ZVAL(L2) = U
                     LOC(L2) = L1
                     IVAL_OUT(L2) = 2
                  ENDIF

C----------------cell L2 is two-phase while cell L1 is one-phase
               ELSEIF (IDELTA < -1) THEN
                  U = ABS(Z(L1,1)-Z(L2,1))
                  DO IC = 2,NHC
                     U = U + ABS(Z(L1,IC)-Z(L2,IC))
                  END DO
                  IF (U < ZVAL(L1)) THEN
                     ZVAL(L1) = U
                     LOC(L1) = L2
                     IVAL_OUT(L1) = 2
                  ENDIF

C----------------vapor phase beside liquid phase
               ELSE
                  IVAL_OUT(L1) = MAX(1,IVAL_OUT(L1))
                  IVAL_OUT(L2) = MAX(1,IVAL_OUT(L2))
               ENDIF
            END DO
         END DO
      END DO
C-----------------------------------------------------------------------
C     Y-DIRECTION
C-----------------------------------------------------------------------
      DO K = KL1,KL2
         IJDIM = (K-1) * IJ
         DO J = JL1V(K)+1,JL2V(K)
            IJKDIM = (J-1)*IDIM + IJDIM
            DO I = IL1,IL2
               L1 = I + IJKDIM
               L2 = L1 - IDIM
               IF (TCOFY(L1) == ZERO) CYCLE
               IDELTA = IVAL(L1)-IVAL(L2)
               IDIF = ABS(IDELTA)

C----------------cells of same type or one cell is zero pv or aquifer
               IF (IDELTA == 0 .OR. IDIF > 5) CYCLE

C----------------cell L1 is two-phase while cell L2 is one-phase
               IF (IDELTA > 1) THEN
                  U = ABS(Z(L1,1)-Z(L2,1))
                  DO IC = 2,NHC
                     U = U + ABS(Z(L1,IC)-Z(L2,IC))
                  END DO
                  IF (U < ZVAL(L2)) THEN
                     ZVAL(L2) = U
                     LOC(L2) = L1
                     IVAL_OUT(L2) = 2
                  ENDIF

C----------------cell L2 is two-phase while cell L1 is one-phase
               ELSEIF (IDELTA < -1) THEN
                  U = ABS(Z(L1,1)-Z(L2,1))
                  DO IC = 2,NHC
                     U = U + ABS(Z(L1,IC)-Z(L2,IC))
                  END DO
                  IF (U < ZVAL(L1)) THEN
                     ZVAL(L1) = U
                     LOC(L1) = L2
                     IVAL_OUT(L1) = 2
                  ENDIF

C----------------vapor phase beside liquid phase
               ELSE
                  IVAL_OUT(L1) = MAX(1,IVAL_OUT(L1))
                  IVAL_OUT(L2) = MAX(1,IVAL_OUT(L2))
               ENDIF
            END DO
         END DO
      END DO
C-----------------------------------------------------------------------
C     Z-DIRECTION
C-----------------------------------------------------------------------
      DO K = KL1+1,KL2
         IJDIM = (K-1)*IJ
         J1 = MIN( JL1V(K), JL1V(K-1) )
         J2 = MIN( JL2V(K), JL2V(K-1) )
         DO J = J1,J2
            IJKDIM = (J-1)*IDIM + IJDIM
            DO I = IL1,IL2
               L1 = I + IJKDIM
               L2 = L1 - IJ
               IF (TCOFZ(L1) == ZERO) CYCLE
               IDELTA = IVAL(L1)-IVAL(L2)
               IDIF = ABS(IDELTA)

C-----------------cells of same type or one cell is zero pv or aquifer
               IF (IDELTA == 0 .OR. IDIF > 5) CYCLE

C-------------------cell L1 is two-phase while cell L2 is one-phase
               IF (IDELTA > 1) THEN
                  U = ABS(Z(L1,1)-Z(L2,1))
                  DO IC = 2,NHC
                     U = U + ABS(Z(L1,IC)-Z(L2,IC))
                  END DO
                  IF (U < ZVAL(L2)) THEN
                     ZVAL(L2) = U
                     LOC(L2) = L1
                     IVAL_OUT(L2) = 2
                  ENDIF

C-------------------cell L2 is two-phase while cell L1 is one-phase
               ELSEIF (IDELTA < -1) THEN
                  U = ABS(Z(L1,1)-Z(L2,1))
                  DO IC = 2,NHC
                     U = U + ABS(Z(L1,IC)-Z(L2,IC))
                  END DO
                  IF (U < ZVAL(L1)) THEN
                     ZVAL(L1) = U
                     LOC(L1) = L2
                     IVAL_OUT(L1) = 2
                  ENDIF
               ELSE
                  IVAL_OUT(L1) = MAX(1,IVAL_OUT(L1))
                  IVAL_OUT(L2) = MAX(1,IVAL_OUT(L2))
               ENDIF
            END DO
         END DO
      END DO

! bag8
      DEALLOCATE(ZVAL)
! bag8

      END 
 
C***********************************************************************
      SUBROUTINE EOS_1PH_UP(P,ZF,VMOL,DVDP,DVDN,AD,AP,BP,CP,IEOSTL,
     &                      TEMPR,NHC,NDIM,NP,N1PH,N2PH,IFLD)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,NP,N1PH,N2PH,IEOSTL(NDIM),IFLD(NP)
      REAL*8 P(NDIM),TEMPR(NDIM),AP(NDIM),BP(NP),CP(NP),ZF(NDIM),
     &       AD(NP,NHC),VMOL(NP),DVDP(NDIM),DVDN(NDIM,NHC)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER IP,I,J,K,LIMP,KK
      REAL*8 DUM
C-----------------------------------------------------------------------
      CALL EOS_PROP_DR(P,ZF,DVDP,DVDN,DUM,DUM,AD,AP,BP,CP,DUM,
     &            IEOSTL,TEMPR,1,0,1,0,1,N1PH,1,N1PH,.FALSE.,.FALSE.,
     &            NHC,NDIM,NP,N1PH,IFLD)
      DO KK = 1, N1PH
         IP = IFLD(KK)
         VMOL(IP) = GASCON*TEMPR(IP)*ZF(IP)/P(IP)
      END DO 
      END 

C***********************************************************************
      SUBROUTINE EOS_PHSWAP(X,Y,XDZ,EK,V,ZF,RES,APOIL,APGAS,BPOIL,
     &                BPGAS,CPOIL,CPGAS,ADOIL,ADGAS,PRLOGO,
     &                PRLOGG,NHC,NDIM,NP,N,IFLD)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,NP,N,IFLD(NP)
      REAL*8 V(NDIM),APOIL(NP),APGAS(NP),BPOIL(NP),BPGAS(NP),CPOIL(NP),
     &       CPGAS(NP),PRLOGO(NP),PRLOGG(NP),
     &       ZF(NDIM,3),X(NDIM,NHC),Y(NDIM,NHC),EK(NDIM,NHC),
     &       XDZ(NDIM,NHC),RES(NDIM,NHC),ADOIL(NP,NHC),ADGAS(NP,NHC)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER I,IP,KK
      REAL*8 TEMP1,TEMP2,TEMP3,TEMP4,TEMP5,TEMP6,TEMP7,TEMP8
C ----------------------------------------------------------------------
C  THIS ROUTINE SWAPS THE EQUILIBRIUM PHASES IF IT IS NECESSARY 
C     X   - MOLE FRACTIONS FOR LIQUID
C     Y   - MOLE FRACITONS FOR GAS
C     XDZ - X(I)/Z(I)
C     EK  - EQUILIBRIUM K-VALUES
C     V   - VAPOR MOLAR QUALITY
C     ZF  - COMPRESSIBILITY FACTOR FOR LIQUID & GAS
C     RES  - RESIDUES OF FUGACITY EQUATIONS
C     NDIM  - LEADING DIMENSION
C     N   - THE NUMBER OF POINTS TO SWAP
C ----------------------------------------------------------------------
      DO KK = 1, N
         IP = IFLD(KK)
         V(IP) = ONE-V(IP) 
         TEMP2 = ZF(IP,1)
         ZF(IP,1) = ZF(IP,2)
         ZF(IP,2) = TEMP2
         TEMP5 = APOIL(IP)
         APOIL(IP) = APGAS(IP)
         APGAS(IP) = TEMP5
         TEMP6 = BPOIL(IP)
         BPOIL(IP) = BPGAS(IP)
         BPGAS(IP) = TEMP6
         TEMP7 = CPOIL(IP)
         CPOIL(IP) = CPGAS(IP)
         CPGAS(IP) = TEMP7
         TEMP8 = PRLOGO(IP)
         PRLOGO(IP) = PRLOGG(IP)
         PRLOGG(IP) = TEMP8
      END DO 
      DO I = 1, NHC
         DO KK = 1, N
            IP = IFLD(KK)
            XDZ(IP,I) = EK(IP,I)*XDZ(IP,I)
            EK(IP,I) = ONE/EK(IP,I)
            RES(IP,I) = -RES(IP,I)
            TEMP3 = X(IP,I)
            X(IP,I) = Y(IP,I)
            Y(IP,I) = TEMP3
            TEMP4 = ADOIL(IP,I)
            ADOIL(IP,I) = ADGAS(IP,I)
            ADGAS(IP,I) = TEMP4
         END DO 
      END DO 
      END 

C***********************************************************************
      SUBROUTINE EOS_PROP(P,X,ZF,PHI,AD,AP,BP,CP,PRLOG,IEOSTL,FUG_CALC,
     &                    SUBPHI,TOL_ZFAC,NHC,NDIM,NP,N,IFLD)
C***********************************************************************
      USE xgendat
      IMPLICIT NONE
      INCLUDE 'xparam.h'
      INCLUDE 'control.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,NP,IEOSTL(NDIM),N,IFLD(N)
      LOGICAL FUG_CALC,SUBPHI
      REAL*8 TOL_ZFAC,P(NDIM),ZF(NDIM),X(NDIM,NHC),AD(NP,NHC),
     &       AP(NP),BP(NP),CP(NP),PRLOG(NP),PHI(NDIM,NHC)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
C     C1 TO C7 ARE EOS PARAMETERS FOR P-R
      REAL*8 C1,C2,C3,C4,C5,C6,C7,C8,C9
      PARAMETER (C1 = ONE+SQRT_2)
      PARAMETER (C2 = ONE-SQRT_2)
      PARAMETER (C3 = ONE)
      PARAMETER (C4 = TWO)
      PARAMETER (C5 = THREE)
      PARAMETER (C6 = ONE)
      PARAMETER (C7 = ONE/(TWO*SQRT_2))
      PARAMETER (C8 = THIRD*NINTH)
      PARAMETER (C9 = FOUR+HALF)
      INTEGER I,J,IP1,IP2,ITER,IP,K,KK,ITMAX,NCM1,NODD,MCM2,ISTART,
     &        JP1,JP2,IT,L,KP,KP1,KP2,NBAD,JCHECK,NCM2,IERR
      PARAMETER (ITMAX = 10)
      REAL*8 A1,B1,X1,X2,Z1,Z2,D0,D1,D2,D22,FP,DZ,A,B,BI,TZF,TEMP

!      REAL*8 LOGZ(N),FACT(N)

! bag8
      REAL*8, ALLOCATABLE :: LOGZ(:),FACT(:)
! bag8

C-----------------------------------------------------------------------
C  THIS ROUTINE PERFORMS THE CALCULATIONS OF ZF AND PHI :
C  CURRENTLY THIS ROUTINE IS WRITTEN BASED ON PR-79 EOS
C  THE FOLLOWING CONTROL VARIABLES ARE USED:
C     FUG_CALC = FALSE CALCULATE ZF ONLY AND RETURN
C     FUG_CALC = TRUE CALCULATE ZF AND PHI 
C  IEOSTL(IP) = EOS TABLE ASSIGNMENT AT POINT IP 
C  P(IP)    = PRESSURE AT POINT IP
C  X(IP,I)  = MOLE FRACTION OF COMPONENT I AT POINT IP
C  ZF(IP)   = COMPRESSIBILITY FACTOR AT POINT IP
C  PHI(IP,I)= LOG OF THE FUGACITY COEFFICIENT OF COMPONENT I
C  A    = EQUATION OF STATE PARAMETER A 
C  B    = EQUATION OF STATE PARAMETER B 
C  AP(IP)   = A/P 
C  BP(IP)   = B/P 
C  BP(IP)   = B/P 
C  CP(IP) = C/P 
C  AD(IP,I) = DERIVATIVE OF AP W.R.T. X(I)
C  EOS_BP= EOS PARAMETER 'B'
C  EOS_CP= EOS PARAMETER 'C'
C  TOL_ZFAC= TOLERANCE FOR SOLVING ZF BY USING N_R 
C  PRLOG= SCRATCH FOR ZF CALCULATION AND LOG OF RATIO OF Z VALUES 
C         FOR FUGACITY 
C  EOS_BIN= BINARY INTERACTION COEFFICIENT 
C  SUBPHI= TRUE IF DIFFERENCE OF FUGACITY IS REQUIRED 
C  NDIM= STARTING DIMENSION FOR SOME ARRAYS 
C  NP= STARTING DIMENSION FOR SOME ARRAYS
C  N= NUMBER OF POINTS 
C-----------------------------------------------------------------------

! bag8
      ALLOCATE(LOGZ(N),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate LOGZ'
      ALLOCATE(FACT(N),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate FACT'
! bag8

      NCM1=NHC-1
      NODD=MOD(NHC,2)
      NCM2=NHC-2
      ISTART=2+MOD(NCM1,3)
C***********************************************************************
C STEP 1: CALCULATE EOS PARAMETERS A,B,AD,AP,BP
C***********************************************************************
C---------- EOS PARAMETERS FOR NO INTERACTION PARAMETERS ON B ----------
C     CALCULATE AD
      IF(ISTART == 2)THEN
         DO I = 1,NHC
            J = NHC*(I-1)+1
            DO KK = 1,N
               IP = IFLD(KK)
               IT = IEOSTL(IP)
               AD(IP,I) = X(IP,1)*EOS_BIN(J,IT)
            END DO 
         END DO 
      ELSEIF(ISTART == 3)THEN
         DO I = 1,NHC
            J = NHC*(I-1)+1
            JP1 = J+1
            DO KK = 1,N
               IP = IFLD(KK)
               IT = IEOSTL(IP)
               AD(IP,I) = X(IP,1)*EOS_BIN(J,IT)+X(IP,2)*EOS_BIN(JP1,IT)
            END DO 
         END DO 
      ELSE
         DO I = 1,NHC
            J = NHC*(I-1)+1
            JP1 = J+1
            JP2 = JP1 + 1
            DO KK = 1,N
               IP = IFLD(KK)
               IT = IEOSTL(IP)
               AD(IP,I) = X(IP,1)*EOS_BIN(J,IT)+X(IP,2)*EOS_BIN(JP1,IT)
     &                  + X(IP,3)*EOS_BIN(JP2,IT)
            END DO 
         END DO 
      ENDIF
      JCHECK = NCM2 - ISTART
      IF (JCHECK >= 0)   THEN
         DO I = 1,NHC
            K = NHC*(I-1)
            DO J = ISTART,NCM2,3
               JP1 = J + 1
               JP2 = J + 2
               KP = J + K
               KP1 = KP + 1
               KP2 = KP1 + 1
               DO KK = 1,N
                  IP = IFLD(KK)
                  IT = IEOSTL(IP)
                  AD(IP,I) = AD(IP,I)+X(IP,J)*EOS_BIN(KP,IT)
     &                     + X(IP,JP1)*EOS_BIN(KP1,IT)
     &                     + X(IP,JP2)*EOS_BIN(KP2,IT)
               END DO 
            END DO 
         END DO 
      ENDIF 

C-------calculate ap,bp
      IF(ISTART == 2)THEN
         DO KK = 1,N
            IP = IFLD(KK)
            IT = IEOSTL(IP)
            AP(IP) = X(IP,1)*AD(IP,1)
            BP(IP) = X(IP,1)*EOS_BP(1,IT)
            CP(IP) = X(IP,1)*EOS_CP(1,IT)
         END DO 
      ELSEIF(ISTART == 3)THEN
         DO KK = 1,N
            IP = IFLD(KK)
            IT = IEOSTL(IP)
            AP(IP) = X(IP,1)*AD(IP,1)+X(IP,2)*AD(IP,2)
            BP(IP) = X(IP,1)*EOS_BP(1,IT)+X(IP,2)*EOS_BP(2,IT)
            CP(IP) = X(IP,1)*EOS_CP(1,IT)+X(IP,2)*EOS_CP(2,IT)
         END DO 
      ELSE
         DO KK = 1,N
            IP = IFLD(KK)
            IT = IEOSTL(IP)
            AP(IP) = X(IP,1)*AD(IP,1)+X(IP,2)*AD(IP,2)+X(IP,3)*AD(IP,3)
            BP(IP) = X(IP,1)*EOS_BP(1,IT)+X(IP,2)*EOS_BP(2,IT)
     &             + X(IP,3)*EOS_BP(3,IT)
            CP(IP) = X(IP,1)*EOS_CP(1,IT)+X(IP,2)*EOS_CP(2,IT)
     &             + X(IP,3)*EOS_CP(3,IT)
         END DO 
      ENDIF
      JCHECK = NCM2 - ISTART
      IF (JCHECK >= 0)   THEN
         DO I = ISTART,NCM2,3
            IP1 = I + 1 
            IP2 = I + 2 
            DO KK = 1,N
               IP = IFLD(KK)
               IT = IEOSTL(IP)
               AP(IP) = AP(IP)+X(IP,I)*AD(IP,I)
     &                + X(IP,IP1)*AD(IP,IP1)+X(IP,IP2)*AD(IP,IP2)
               BP(IP) = BP(IP)+X(IP,I)*EOS_BP(I,IT)
     &                + X(IP,IP1)*EOS_BP(IP1,IT)
     &                + X(IP,IP2)*EOS_BP(IP2,IT)
               CP(IP) = CP(IP)+X(IP,I)*EOS_CP(I,IT)
     &                + X(IP,IP1)*EOS_CP(IP1,IT)
     &                + X(IP,IP2)*EOS_CP(IP2,IT)
            END DO 
         END DO 
      ENDIF 
C***********************************************************************
C STEP 2: SOLVE FOR Z BY NEWTON-RAPHSON ITERATION
C         SKIP ITERATIONS IF RESTART RUN
C         SET UP AP, A, B
C         ONLY FAILED CELLS NEED TO BE SOLVED ANALYTICALLY
C         f(Z) = Z**3 + D2*Z**2 + D1*Z + D0 = 0
C         fp(Z) = 3*Z**2 + D22*Z + D1
C***********************************************************************
      IF(TOL_ZFAC == ZERO) THEN
         DO KK = 1,N
            IP = IFLD(KK)
            ZF(IP) = ZF(IP) + CP(IP)*P(IP)
            AP(IP) = HALF*AP(IP)
         END DO 
      ELSE
         DO KK = 1,N
           IP = IFLD(KK)

C----------setup a,ap,b,bi
            AP(IP) = HALF*AP(IP)
            A = AP(IP)*P(IP)
            B = BP(IP)*P(IP)
            BI = ONE/BP(IP)

C----------solve for new ZF (offset by volumetric shift)
            TZF = MAX( ZF(IP)+CP(IP)*P(IP), B )
            D2 = C3*B - ONE
            D22 = TWO*D2
            D1 = A - B*(C4+C5*B)
            D0 = ( C6*B*(ONE+B) - A ) * B
            NBAD = 1
            DO I = 1,ITMAX
               FP = D1 + TZF * ( D22 + THREE*TZF )
C              skip to analytical solution if in negative slope region
               IF(FP <= ZERO) EXIT
C              f(Z)/fp(Z)
               DZ = ( D0 + TZF * ( D1 + TZF * ( D2 + TZF ) ) ) / FP
               TZF = TZF - DZ
               IF (ABS(DZ) < TOL_ZFAC) THEN
                  NBAD = 0
                  EXIT
               ENDIF 
            END DO
C           solve analytically if problems encountered
            IF(NBAD == 1) THEN
               X1 = THIRD * (D1 - THIRD*D2**2)
               X2 = D2*(C9*D1-D2**2)*C8 - HALF*D0
               TEMP = X2**2 + X1**3
               IF(TEMP >= ZERO) THEN
                  TEMP = SQRT(TEMP)
                  TZF = SIGN(ABS(X2+TEMP)**THIRD,X2+TEMP) +
     &                  SIGN(ABS(X2-TEMP)**THIRD,X2-TEMP) - THIRD*D2
               ELSE
                  TEMP = SQRT(-X1)
                  X1 = ACOS(X2/TEMP**3)
                  TZF = TWO*TEMP*COS(THIRD*X1) - THIRD*D2
               ENDIF
            ENDIF

C --------- check for multiple roots
C           f(z) = (Z-TZF) * (Z**2 + X2*z + X1)
C           we also have D2 = -(Z1 + Z2 + Z3)
            X2 = D2 + TZF
            X1 = D1 + X2*TZF

            A1 = -HALF*X2
            B1 = A1**2 - X1
            Z2 = ZERO
            IF(B1 >= ZERO) Z2 = A1 + SQRT(B1)

C---------- if there are multiple roots for zf > b, find the right root
C           check only minimum and maximum values of Z
C           pick the root with minimum gibbs free energy
            IF(Z2 > B)THEN
C              we have Z1 < Z2 because +sqrt used above for Z2
               Z1 = -D2 - TZF - Z2
               B1 = C7 * AP(IP) * BI
           
C              check TZF and Z1
               IF(TZF >= Z2) THEN
                  IF(Z1 > B) THEN
                     DZ = (TZF-Z1) - LOG((TZF-B)/(Z1-B)) - B1 *
     &                    LOG( ((TZF+C1*B)*(Z1+C2*B)) /
     &                         ((TZF+C2*B)*(Z1+C1*B)) )
                     IF(DZ > ZERO) TZF = Z1
                  ENDIF
           
C              check TZF and Z2
               ELSEIF(TZF <= Z1) THEN
                  IF(TZF > B) THEN
                     DZ = (TZF-Z2) - LOG((TZF-B)/(Z2-B)) - B1 *
     &                    LOG( ((TZF+C1*B)*(Z2+C2*B)) /
     &                         ((TZF+C2*B)*(Z2+C1*B)) )
                     IF(DZ > ZERO) TZF = Z2
                  ELSE
                     TZF = Z2
                  ENDIF
           
C              check Z1 and Z2
               ELSE
                  IF(Z1 > B) THEN
                     DZ = (Z1-Z2) - LOG((Z1-B)/(Z2-B)) - B1 *
     &                    LOG( ((Z1+C1*B)*(Z2+C2*B)) /
     &                         ((Z1+C2*B)*(Z2+C1*B)) )
                     IF(DZ > ZERO) THEN
                        TZF = Z2
                     ELSE
                        TZF = Z1
                     ENDIF
                  ELSE
                     TZF = Z2
                  ENDIF
               ENDIF
            ENDIF
            ZF(IP) = TZF
         END DO
      ENDIF

      IF(.NOT.FUG_CALC) THEN
C----------adjust for volumetric shift and return
         DO KK = 1,N
           IP = IFLD(KK)
           ZF(IP) = ZF(IP) - CP(IP)*P(IP)
         END DO 
         GOTO 123
      ENDIF
C***********************************************************************
C STEP 3: CALCULATE THE LOGARITHM OF FUGACITY COEFFICIENT
C         FUGACITY DIFFERENCE CALCULATED IF SUBPHI IS TRUE
C         DOES NOT INCLUDE C(IP)*P TERM IN PHI
C***********************************************************************
      DO KK = 1,N
         IP = IFLD(KK)
         B = BP(IP)*P(IP)
         BI = ONE/ BP(IP)
         PRLOG(IP) = C7*BI*LOG((ZF(IP)+C1*B)/(ZF(IP)+C2*B))
         FACT(KK) = (AP(IP)*PRLOG(IP)+ZF(IP)-ONE)*BI
         LOGZ(KK) = LOG(ZF(IP)-B)
      END DO 
      IF (.NOT.SUBPHI)   THEN
         DO I = 1,NCM1,2
            IP1 = I + 1
            DO KK = 1,N
               IP = IFLD(KK)
               IT = IEOSTL(IP)
               PHI(IP,I) = FACT(KK)*EOS_BP(I,IT)
     &                   - PRLOG(IP)*AD(IP,I) - LOGZ(KK)
               PHI(IP,IP1) = FACT(KK)*EOS_BP(IP1,IT)
     &                     - PRLOG(IP)*AD(IP,IP1) - LOGZ(KK)
            END DO 
         END DO 
         IF(NODD == 1)THEN
           DO KK = 1,N
              IP = IFLD(KK)
              IT = IEOSTL(IP)
              PHI(IP,NHC) = FACT(KK)*EOS_BP(NHC,IT)
     &                    - PRLOG(IP)*AD(IP,NHC) - LOGZ(KK)
           END DO 
         ENDIF
      ELSE 
         DO I = 1,NCM1,2
            IP1 = I + 1
            DO KK = 1,N
               IP = IFLD(KK)
               IT = IEOSTL(IP)
               PHI(IP,I) = -FACT(KK)*EOS_BP(I,IT) + PRLOG(IP)*AD(IP,I)
     &                   + LOGZ(KK) + PHI(IP,I)
               PHI(IP,IP1) = -FACT(KK)*EOS_BP(IP1,IT)
     &                     + PRLOG(IP)*AD(IP,IP1)
     &                     + LOGZ(KK) + PHI(IP,IP1)
            END DO 
         END DO 
         IF(NODD == 1)THEN
           DO KK = 1,N
              IP = IFLD(KK)
              IT = IEOSTL(IP)
              PHI(IP,NHC) = -FACT(KK)*EOS_BP(NHC,IT)
     &                    + PRLOG(IP)*AD(IP,NHC)
     &                    + LOGZ(KK) + PHI(IP,NHC)
           END DO 
         ENDIF
      ENDIF 

C-------adjust for volumetric shift
      DO KK = 1,N
        IP = IFLD(KK)
        ZF(IP)=ZF(IP)-CP(IP)*P(IP)
      END DO 


! bag8
 123  CONTINUE
      DEALLOCATE(LOGZ)
      DEALLOCATE(FACT)
! bag8

      END
       
C***********************************************************************
      SUBROUTINE EOS_PROP_DR(P,ZF,DVFDP,DVFDN,DPHIDP,DPHIDN,AD,AP,BP,
     &                       CP,PRLOG,IEOSTL,TEMPR,
     &                       IDPHIDN,LDPHIDN,IDPHIDP,LDPHIDP,
     &                       IDVFDN,LDVFDN,IDVFDP,LDVFDP,
     &                       SUBPHI,SYM_PACK,NHC,NDIM,NP,N,IFLD)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,N,IDVFDP,IDVFDN,IDPHIDP,IDPHIDN,NP,IFLD(NP),KK,
     &        LDVFDP,LDVFDN,LDPHIDP,LDPHIDN,IEOSTL(NDIM)
      LOGICAL SUBPHI,SYM_PACK
      REAL*8 P(NDIM),TEMPR(NDIM),PRLOG(NP),AP(NP),BP(NP),CP(NP),
     &       AD(NP,NHC),ZF(NDIM),DVFDP(NP),DPHIDP(NDIM,NHC),
     &       DVFDN(NP,NHC),DPHIDN(NDIM,NHC*NHC)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER N1,N2,NDVFDP,NDVFDN,NDPHIDP,NDPHIDN,L,IP
      LOGICAL DFUGACITYDP,DFUGACITYDN,DVOLDP,DVOLDN
C ----------------------------------------------------------------------
C  THIS ROUTINE PERFORMS THE FOLLOWING EQUATION OF STATE CALCULATIONS:
C     1. CALCULATE THE DERIVATIVES OF MOLAR VOLUME W.R.T. PRESSURE
C     2. CALCULATE THE PARTIAL MOLAR VOLUME
C     3. CALCULATE THE DERIVATIVES OF LOG(PHI) W.R.T. PRESSURE
C     4. CALCULATE THE DERIVATIVES OF LOG(PHI) W.R.T. N(I)
C     5. APPLY VOLUME TRANSLATION
C
C  THE FOLLOWING CONTROL VARIABLES ARE USED:
C     SUBPHI = FALSE DPHIDP ARE CALCULATED & STORED DIRECTLY
C     SUBPHI = TRUE PREVIOUS DPHIDP IS SUBTRACTED FROM CALCULATED DPHIDP
C
C  P(IP)     = PRESSURE AT POINT IP
C  ZF(IP)    = COMPRESSIBILITY FACTOR AT POINT IP
C  DVFDN(IP,I) = DERIVATIVE OF MOLAR VOLUME W.R.T N(I) FOR I=1,..,NHC
C  DVFDP(IP) = DERIVATIVE OF MOLAR VOLUME W.R.T. PRESSURE
C  DPHIDN(IP,IJ)  = DERIVATIVE OF LOG OF ITH FUGACITY COEFFICIENT W.R.T.
C                 N(J), WHERE I >= J.
C                 IF PACKED, IJ = I*(I-1)/2 + J.
C                 IF NOT PACKED, IJ = NHC*(I-1) + J.
C  DPHIDP(IP,I)   = DERIVATIVE OF LOG OF ITH FUGACITY COEFFICIENT W.R.T.
C                 PRESSURE
C  IDPHIDN = THE FIRST POINT FOR WHICH DPHIDN IS TO BE CALCULATED.
C  LDPHIDN = THE LAST  POINT FOR WHICH DPHIDN IS TO BE CALCULATED.
C  IDPHIDP = THE FIRST POINT FOR WHICH DPHIDP IS TO BE CALCULATED.
C  LDPHIDP = THE LAST  POINT FOR WHICH DPHIDP IS TO BE CALCULATED.
C  IDVFDZ = THE FIRST POINT FOR WHICH DVFDZ IS TO BE CALCULATED.
C  LDVFDZ = THE LAST  POINT FOR WHICH DVFDZ IS TO BE CALCULATED.
C  IDVFDP = THE FIRST POINT FOR WHICH DVFDP IS TO BE CALCULATED.
C  LDVFDP = THE LAST  POINT FOR WHICH DVFDP IS TO BE CALCULATED.
C
C ======================================================================
C STEP 1: SET UP FLAGS 
C ======================================================================
      DO KK = 1,N
         IP = IFLD(KK)
         ZF(IP)=ZF(IP)+CP(IP)*P(IP)
      END DO 
      DFUGACITYDN = (LDPHIDN >= IDPHIDN)
      DFUGACITYDP = (LDPHIDP >= IDPHIDP)
      DVOLDN = (LDVFDN >= IDVFDN)
      DVOLDP = (LDVFDP >= IDVFDP)
      N1 = NDIM + 1
      N2 = 0
      IF(DFUGACITYDN)THEN
         N1 = MIN(N1,IDPHIDN)
         N2 = MAX(N2,LDPHIDN)
         NDPHIDN = LDPHIDN - IDPHIDN + 1
      ENDIF
      IF(DFUGACITYDP)THEN
         N1 = MIN(N1,IDPHIDP)
         N2 = MAX(N2,LDPHIDP)
         NDPHIDP = LDPHIDP - IDPHIDP + 1
      ENDIF
      IF(DVOLDN)THEN
         N1 = MIN(N1,IDVFDN)
         N2 = MAX(N2,LDVFDN)
         NDVFDN = LDVFDN - IDVFDN + 1
      ENDIF
      IF(DVOLDP)THEN
         N1 = MIN(N1,IDVFDP)
         N2 = MAX(N2,LDVFDP)
         NDVFDP = LDVFDP - IDVFDP + 1
      ENDIF

C ======================================================================
C STEP 2: CALCULATE DERIVATIVES OF MOLAR VOLUME W.R.T. PRESSURE
C ======================================================================
      IF(DVOLDP)THEN
         L = IDVFDP
         CALL EOS_DVDP(DVFDP,P,TEMPR,ZF,AP,BP,NP,NDVFDP,IFLD(L))
      ENDIF
C ======================================================================
C STEP 3: CALCULATE DERIVATIVES OF MOLAR VOLUME W.R.T. N(I)
C ======================================================================
      IF(DVOLDN)THEN
         L = IDVFDN
         CALL EOS_DVDN(DVFDN,P,TEMPR,ZF,AP,BP,AD,IEOSTL,NHC,NDIM,NDVFDN,
     &                 IFLD(L),NP)
      ENDIF
C ======================================================================
C STEP 4: CALCULATE DERIVATIVES OF LOG(PHI) W.R.T. PRESSURE
C ======================================================================
      IF(DFUGACITYDP)THEN
         L = IDPHIDP
         CALL EOS_DFDP(DPHIDP,P,ZF,AP,BP,AD,IEOSTL,SUBPHI,NHC,NDIM,
     &                 NDPHIDP,IFLD(L),NP)
      ENDIF
C ======================================================================
C STEP 5: CALCULATE DERIVATIVES OF LOG(PHI) W.R.T. N(I)
C ======================================================================
      IF(DFUGACITYDN)THEN
         L = IDPHIDN
         CALL EOS_DFDN(DPHIDN,P,ZF,AP,BP,AD,PRLOG,IEOSTL,SYM_PACK,NHC,
     &                 NDIM,NDPHIDN,IFLD(L),NP)
      ENDIF
C ======================================================================
C STEP 6: PERFORM VOLUME SHIFT
C ======================================================================
      DO KK = 1,N
         IP = IFLD(KK)
         ZF(IP) = ZF(IP) - CP(IP)*P(IP)
      END DO 
      END 
 
C***********************************************************************
      SUBROUTINE EOS_RESIDUE(RES,NORM,SBINV,SCR,NDIM,NP,NHC,N,IFLD)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,NP,N,IFLD(N)
      REAL*8 SCR(NP),NORM(NP),SBINV(NDIM),RES(NDIM,NHC)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER I,IP,KK
      REAL*8 TEMP
C-----------------------------------------------------------------------
C  THIS ROUTINE UPDATES RESIDUES OF FUGACITY EQUATIONS
C-----------------------------------------------------------------------
      DO KK = 1,N
         IP = IFLD(KK)
         SBINV(IP) = ONE/SBINV(IP)
         TEMP = RES(IP,1) 
         NORM(IP) = TEMP*TEMP
      END DO 
      DO I = 2, NHC
         DO KK = 1,N
            IP = IFLD(KK)
            TEMP = RES(IP,I) 
            NORM(IP) = NORM(IP) + TEMP*TEMP
         END DO 
      END DO 
      DO KK = 1,N
         IP = IFLD(KK)
         NORM(IP) = NORM(IP)/SCR(IP)
      END DO 
      END

C***********************************************************************
      SUBROUTINE EOS_RMAB(NR,NA,NB,R,A,B,NROW,NCOL,N,IFLD)
C***********************************************************************
      IMPLICIT NONE
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NR,NA,NB,NROW,NCOL,N,IFLD(N)
      REAL*8 B(NB,NCOL),A(NA,NROW,NCOL),R(NR,NROW)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER ISTART,I,J1,J2,J3,J4,IP,JCHECK,KK
C-----------------------------------------------------------------------
C  THIS ROUTINE REDUCES A VECTOR, R, BY A*B, WHERE A IS A MATRIX AND B
C  IS ANOTHER VECTOR.
C
C  IT TAKES AS INPUT:
C     R    : THE VECTOR TO BE REDUCED BY A*B.
C     A    : A MATRIX.
C     B    : A VECTOR.
C     NR   : THE LEADING DIMENSION OF R OR B.
C     NA   : THE LEADING DIMENSION OF A.
C     NROW : THE NUMBER OF ROWS IN A.
C     NCOL : THE NUMBER OF COLUMNS IN A.
C     N    : THE NUMBER OF POINTS.
C
C  IT RETURNS AS OUTPUT:
C     R    : THE ORIGINAL R MINUS A*B.
C-----------------------------------------------------------------------
      ISTART = MOD(NCOL,4) + 1
      DO I = 1, NROW
         IF(ISTART == 2)THEN
            DO KK = 1,N
               IP = IFLD(KK)
               R(IP,I) = R(IP,I) - A(KK,I,1)*B(IP,1)
            END DO 
         ELSEIF(ISTART == 3)THEN
            DO KK = 1,N
               IP = IFLD(KK)
               R(IP,I) = R(IP,I) - A(KK,I,1)*B(IP,1) - A(KK,I,2)*B(IP,2)
            END DO 
         ELSEIF(ISTART == 4)THEN
            DO KK = 1,N
               IP = IFLD(KK)
               R(IP,I) = R(IP,I) - A(KK,I,1)*B(IP,1) - A(KK,I,2)*B(IP,2)
     &                 - A(KK,I,3)*B(IP,3)
            END DO 
         ENDIF
         JCHECK = NCOL - ISTART
         IF (JCHECK>=0)   THEN
            DO J1 = ISTART,NCOL,4
               J2 = J1 + 1
               J3 = J2 + 1
               J4 = J3 + 1
               DO KK = 1,N
                  IP = IFLD(KK)
                  R(IP,I) = R(IP,I) - A(KK,I,J1)*B(IP,J1) 
     &                    - A(KK,I,J2)*B(IP,J2)- A(KK,I,J3)*B(IP,J3)
     &                    - A(KK,I,J4)*B(IP,J4)
               END DO 
            END DO
         ENDIF 
      END DO  
      END 

C***********************************************************************
      SUBROUTINE EOS_RMBA1(NR,NB,NA,R,B,A,NROW,N,IFLD)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NA,NB,NR,NROW,N,IFLD(N)
      REAL*8 B(NB,NROW),A(NA,NROW),R(NR)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER I1,I2,I3,I4,ISTART,IP,JCHECK,KK
C-----------------------------------------------------------------------
C  THIS ROUTINE REDUCES A TRANSPOSED VECTOR, R, BY B*A, WHERE B IS
C  ALSO A TRANSPOSED VECTOR AND A IS A MATRIX.
C
C  IT TAKES AS INPUT:
C     R    : THE TRANSPOSED VECTOR TO BE REDUCED BY B*A.
C     B    : A TRANSPOSED VECTOR.
C     A    : A MATRIX.
C     NROW : THE NUMBER OF ROWS IN A.
C     NCOL : THE NUMBER OF COLUMNS IN A.
C     N    : THE NUMBER OF POINTS.
C
C  IT RETURNS AS OUTPUT:
C     R    : THE ORIGINAL R MINUS B*A.
C-----------------------------------------------------------------------
      ISTART = MOD(NROW,4) + 1
      IF(ISTART==2)THEN
         DO KK = 1, N
            IP = IFLD(KK)
            R(IP) = - B(IP,1)*A(IP,1)
         END DO  
      ELSEIF(ISTART==3)THEN
         DO KK = 1, N
            IP = IFLD(KK)
            R(IP) = - B(IP,1)*A(IP,1) - B(IP,2)*A(IP,2)
         END DO  
      ELSEIF(ISTART==4)THEN
         DO KK = 1, N
            IP = IFLD(KK)
            R(IP) = - B(IP,1)*A(IP,1) - B(IP,2)*A(IP,2)
     &              - B(IP,3)*A(IP,3)
            END DO 
      ELSE
         DO KK = 1, N
            IP = IFLD(KK)
            R(IP) = ZERO
         END DO 
      ENDIF
      JCHECK = NROW - ISTART
      IF (JCHECK>=0)   THEN
         DO I1 = ISTART, NROW, 4
            I2 = I1 + 1
            I3 = I2 + 1
            I4 = I3 + 1
            DO KK = 1, N
               IP = IFLD(KK)
               R(IP) = R(IP) - B(IP,I1)*A(IP,I1) 
     &                       - B(IP,I2)*A(IP,I2)- B(IP,I3)*A(IP,I3)
     &                       - B(IP,I4)*A(IP,I4)
            END DO  
         END DO 
      ENDIF 
      END 
 
C***********************************************************************
      SUBROUTINE EOS_RR(ZCOMP,EK_IN,V,XDZ,SBINV,TOLRR,NDIM,NP,NHC,N,
     &                  IFLD)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,NP,N,IFLD(N)
      REAL*8 TOLRR,ZCOMP(NDIM,NHC),EK_IN(NDIM,NHC),XDZ(NDIM,NHC),
     &       V(NDIM),SBINV(NDIM)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER IC,L,ITER,ITMAX,KK,IERR
      PARAMETER (ITMAX = 100)
      REAL*8 VMAX,VMIN,KMIN,KMAX,RR,V_VAL,WN,WRP,
     &       VMID,WMIN,WMAX,W,SBINV_VAL
!      REAL*8 A(NHC),B(NHC),EK(NHC),Z(NHC),XDZ_VAL(NHC)

! bag8
      REAL*8, ALLOCATABLE :: A(:),B(:),EK(:),Z(:),XDZ_VAL(:)
! bag8

C-----------------------------------------------------------------------
C  THIS ROUTINE IS A RACHFORD-RICE EQUATION SOLVER.
C  IT TAKES AS INPUT:
C     V(L)     : AN INITIAL GUESS FOR THE EQUILIBRIUM VAPOR FRACTION
C     EK(L,I)     : K_VALUE  OF COMPONENT I OF CELL L
C     Z(L,I)     : OVERALL MOLE FRACTION  OF COMPONENT I OF CELL L
C     TOLRR    : TOLERANCE FOR SOLVING RR EQUATION
C     ND       : LEADING DIMENSION OF FLUID ARRAYS 
C     NHC       : THE NUMBER OF COMPONENTS.
C     NP       : THE NUMBER OF CELLS.
C  IT RETURNS AS OUTPUT:
C     V(L)     : THE EQUILIBRIUM VAPOR FRACTION.
C     XDZ(L,I) : THE RATIO OF THE MOLE FRACTION OF COMPONENT I IN THE
C                EQUILIBRIUM LIQUID PHASE AT POINT L TO THE OVERALL
C                MOLE FRACTION OF COMPONENT I AT POINT L.
C     SBINV(L)    : THE DERIVATIVE OF RR(L) WITH RESPECT TO V(L).
C-----------------------------------------------------------------------

! bag8
      ALLOCATE(A(NHC),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate A'
      ALLOCATE(B(NHC),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate B'
      ALLOCATE(EK(NHC),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate EK'
      ALLOCATE(Z(NHC),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate Z'
      ALLOCATE(XDZ_VAL(NHC),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate XDZ_VAL'
! bag8

      DO KK = 1,N
         L = IFLD(KK)

C----------bound solution between VMIN and VMAX
C          setup Aic where RR = SUM(Zic/(V-Aic))
         VMIN = -BIG
         VMAX = BIG
         KMAX = ONE
         KMIN = ONE
         DO IC = 1, NHC
            Z(IC) = ZCOMP(L,IC)
            EK(IC) = EK_IN(L,IC)
            A(IC) = ONE - EK(IC)
            IF(A(IC) /= ZERO)THEN
              A(IC) = ONE/A(IC)
            ELSE
              A(IC) = -BIG
            ENDIF
            IF(EK(IC) < KMIN)THEN
              KMIN = EK(IC)
              VMAX = A(IC)
            ELSEIF(EK(IC) > KMAX)THEN
              KMAX = EK(IC)
              VMIN = A(IC)
            ENDIF
         END DO 
         IF(KMIN == ONE) THEN
            V(L) = BIG
            CYCLE
         ELSEIF(KMAX == ONE) THEN
            V(L) = -BIG
            CYCLE
         ENDIF

C----------evaluate residual at VMID to see where solution is contained
C          R is monotonically decreasing
         VMID = HALF*(VMAX + VMIN)
         RR = Z(1)/(VMID - A(1))
         DO IC = 2, NHC
            RR = RR + Z(IC)/(VMID - A(IC))
         END DO
        
C-----------------------------------------------------------------------
C          Solution in range VMIN < V < VMID
C          Asymptote at VMIN (positive infinity at W = 0)
C          Set W so WMIN = 0 < W < VMID-VMIN = WMAX
C-----------------------------------------------------------------------
         IF (RR < ZERO)   THEN
            WMIN = ZERO
            WMAX = VMID-VMIN
            IF(V(L) > VMIN .AND. V(L) < VMID) THEN
               V_VAL = V(L)
            ELSE 
               V_VAL = HALF*(VMID+VMIN)
            ENDIF
            W = MAX(TOLRR, V_VAL-VMIN )

C           New iterate W = V - VMIN
C           RR = SUM( Zic/(W-B(ic)) )
C           B(IC) is exactly zero for for EK(IC) = KMAX 
            DO IC = 1,NHC
               B(IC) = VMIN * (EK(IC)-KMAX) * A(IC)
            END DO 

C           Begin iterations (0 < W < WMAX)
C           Iterate on 1/W because of asymptote at W = 0 
            DO ITER = 1,ITMAX
               XDZ_VAL(1) = ONE/(W-B(1))
               RR = Z(1)*XDZ_VAL(1)
               SBINV_VAL = -RR*XDZ_VAL(1)
               DO IC = 2,NHC
                  XDZ_VAL(IC) = ONE/(W-B(IC))
                  RR = RR + Z(IC)*XDZ_VAL(IC)
                  SBINV_VAL = SBINV_VAL - Z(IC)*XDZ_VAL(IC)*XDZ_VAL(IC)
               END DO
               IF(RR > TOLRR) THEN
                  WMIN = W
                  WRP = W*SBINV_VAL
                  WN = WRP+RR
                  IF(WN < ZERO) THEN
                     WN = W*WRP / WN
                     IF(WN >= WMAX) THEN
                        W = HALF*(WMIN+WMAX)
                     ELSE
                        W = WN
                     ENDIF
                  ELSE
                     W = HALF*(WMIN+WMAX)
                  ENDIF
               ELSEIF(RR < -TOLRR) THEN
                  WMAX = W
                  WRP = W*SBINV_VAL
                  WN = WRP+RR
                  IF(WN < ZERO) THEN
                     W = W*WRP / WN
                  ELSE
                     W = HALF*(WMIN+WMAX)
                  ENDIF
               ELSE
                  EXIT
               ENDIF
            END DO 
            V(L) = VMIN + W

C-----------------------------------------------------------------------
C          Solution in range VMID < V < VMAX
C          Asymptote at VMAX (negative infinity at W = 0)
C          Set W so WMIN = VMID-VMAX < W < 0 = WMAX
C-----------------------------------------------------------------------
         ELSEIF (RR > ZERO) THEN 
            WMIN = VMID-VMAX
            WMAX = ZERO
            IF(V(L) > VMID .AND. V(L) < VMAX) THEN
               V_VAL = V(L)
            ELSE
               V_VAL = HALF*(VMID+VMAX)
            ENDIF
            W = MIN( -TOLRR, V_VAL-VMAX )

C           New iterate W = V - VMAX
C           RR = SUM( Zic/(W-B(ic)) )
C           B(IC) is exactly zero for for EK(IC) = KMIN 
            DO IC = 1,NHC
               B(IC) = VMAX * (EK(IC)-KMIN) * A(IC)
            END DO 

C           Begin iterations (WMIN < W < 0)
C           Iterate on 1/W because of asymptote at W = 0
            DO ITER = 1,ITMAX
               XDZ_VAL(1) = ONE/(W-B(1))
               RR = Z(1)*XDZ_VAL(1)
               SBINV_VAL = -RR*XDZ_VAL(1)
               DO IC = 2,NHC
                  XDZ_VAL(IC) = ONE/(W-B(IC))
                  RR = RR + Z(IC)*XDZ_VAL(IC)
                  SBINV_VAL = SBINV_VAL - Z(IC)*XDZ_VAL(IC)*XDZ_VAL(IC)
               END DO
               IF(RR > TOLRR) THEN
                  WMIN = W
                  WRP = W*SBINV_VAL
                  WN = WRP+RR
                  IF(WN > ZERO) THEN
                     W = W*WRP / WN
                  ELSE
                     W = HALF*(WMIN+WMAX)
                  ENDIF
               ELSEIF(RR < -TOLRR) THEN
                  WMAX = W
                  WRP = W*SBINV_VAL
                  WN = WRP+RR
                  IF(WN > ZERO) THEN
                     WN = W*WRP / WN
                     IF(WN <= WMIN) THEN
                        W = HALF*(WMIN+WMAX)
                     ELSE
                        W = WN
                     ENDIF
                  ELSE
                     W = HALF*(WMIN+WMAX)
                  ENDIF
               ELSE
                  EXIT
               ENDIF
            END DO 
            V(L) = VMAX + W

         ELSE
            V(L) = VMID
            SBINV_VAL = ZERO
            DO IC = 1,NHC
               XDZ_VAL(IC) = ONE/(VMID-A(IC))
               SBINV_VAL = SBINV_VAL - Z(IC)*XDZ_VAL(IC)**2
            END DO
         ENDIF
      
         SBINV(L) = SBINV_VAL
         DO IC = 1,NHC
            XDZ(L,IC) = -XDZ_VAL(IC)*A(IC)
         END DO
            
      END DO

! bag8
      DEALLOCATE(A)
      DEALLOCATE(B)
      DEALLOCATE(EK)
      DEALLOCATE(Z)
      DEALLOCATE(XDZ_VAL)
! bag8

      END 
 
C***********************************************************************
      SUBROUTINE EOS_STAB(Z,P,ZF,EK,V,DLNK,PRLOG,Y,NMDLNK,A,W,PHIY,
     &                    EKS,RESULT,NMLNK,FLTYPE,TEMPR,AP,BP,CP,
     &                    AD,ZMY,INV_SUMY,IEOSTL,NHC,NDIM,NTEST, 
     &                    TOL_FLASH,TOL_ZFAC,TOL_TRIV,IFLD,NP)
C***********************************************************************
      USE xgendat
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,NP,FLTYPE(MXFLTYPE),NTEST,IFLD(NP),
     &        IEOSTL(NDIM)
      REAL*8 AP(NP),BP(NP),CP(NP),P(NDIM),Z(NDIM,NHC),AD(NP,NHC),
     &       ZF(NDIM,3),EK(NDIM,NHC),V(NDIM),DLNK(NDIM,NHC),
     &       PRLOG(NP),NMDLNK(NP),W(NDIM,NHC),Y(NDIM,NHC),
     &       PHIY(NDIM,NHC),EKS(NP,NHC),A(NDIM,NHC*(NHC+1)/2),
     &       RESULT(NP),NMLNK(NP),INV_SUMY(NDIM),ZMY(NDIM),TEMPR(NDIM)
      REAL*8 TOL_FLASH,TOL_ZFAC,TOL_TRIV
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER I,J,PASS,IP,CONVERGED,NTOP,NBOT,NONSTABLE,NBUB,NDEW,
     &        NSPLIT,N1PH,N2PH,L,NMOV,L0,L1,IT,L2,ITER,ITMAX,IC,KK
      LOGICAL SUBPHI,FUG_CALC,SYM_PACK
      REAL*8 CHGMN,CHGMX,DUM,ADM
C     NOTE: EXP(6.9) IS CLOSE TO 1000.
      DATA CHGMN,CHGMX/-6.9D0,6.9D0/
      DATA ITMAX/50/
C-----------------------------------------------------------------------
C  THIS ROUTINE PERFORMS A PHASE STABILITY TEST 
C      K(I) AND 1/K(I) ARE USED AS INITIAL ESTIMATES FOR THE K-VALUES.
C     ZF(*,3) -  COMPRESSIBILITY FACTOR (USED ONLY IF 2-PHASE
C                IS FOUND ON THE FIRST PASS, I.E. NOT CHANGED FOR CELLS
C                WHICH ARE FOUND TO BE SINGLE-PHASE)
C     ZMY: SUM(Z(I)-Y(I))
C     NMLNK: NORM ON LOG(K(I)), USED TO TEST FOR TRIVIAL CONDITION
C     PHIY- LOG OF FUGACITY COEFFICIENT EVALUATED AT Z(I) AND P
C     W   - LOG(K(I))
C     A  - JACOBIAN
C     DLNK  - RESIDUES/CHANGE IN LOG(K(I))
C     Y   - K(I)*Z(I), ALSO NORMALIZES VALUES
C     NMDLNK: NORM ON CHANGE IN LOG(K(I))
C-----------------------------------------------------------------------
      L0 = FLTYPE(1) + FLTYPE(2) + FLTYPE(3) + 1
      FUG_CALC = .TRUE.
      SYM_PACK = .TRUE.
C-----------------------------------------------------------------------
C STEP 1: CALCULATE ZF AND LOG(PHI(Z)) FOR OVERALL Z 
C-----------------------------------------------------------------------
      SUBPHI = .FALSE.
      L1 = L0
      CALL EOS_PROP(P,Z,ZF,PHIY,AD,AP,BP,CP,PRLOG,
     &              IEOSTL,FUG_CALC,SUBPHI,TOL_ZFAC,
     &              NHC,NDIM,NP,NTEST,IFLD(L1))
C-----------------------------------------------------------------------
C STEP 2: ASSIGN K-VALUES TO ALL CELLS OF TYPE 4 
C-----------------------------------------------------------------------
      DO PASS = 1,2
         L1 = L0
         NTEST = FLTYPE(4)
         IF (PASS == 1)   THEN
            DO I = 1,NHC
               DO KK = L1,L1+NTEST-1
                  IP = IFLD(KK)
                  IT = IEOSTL(IP)
                  EK(IP,I) = P(IP)/GUESSK(I,IT)
               END DO 
            END DO 
         ELSEIF (PASS==2)   THEN
            DO I = 1,NHC
               DO KK = L1,L1+NTEST-1
                  IP = IFLD(KK)
                  IT = IEOSTL(IP)
                  EK(IP,I) = GUESSK(I,IT)/P(IP)
               END DO 
            END DO 
         ENDIF
         DO KK = L1,L1+NTEST-1
            IP = IFLD(KK)
            ZMY(IP) = ZERO
            NMLNK(IP) = ZERO
         END DO 
         DO I = 1,NHC
            DO KK = L1,L1+NTEST-1
               IP = IFLD(KK)
               DUM = LOG(EK(IP,I))
               W(IP,I) = DUM
               NMLNK(IP)  =NMLNK(IP) + DUM*DUM
               ZMY(IP) = ZMY(IP)+(ONE-EK(IP,I))*Z(IP,I)
            END DO 
         END DO

C***********************************************************************
C        BEGIN ITERATIONS
         ITER = 0
1000     CONTINUE
         ITER = ITER + 1
C***********************************************************************

C-----------------------------------------------------------------------
C STEP 3: CALCULATE FUGACITY RESIDUAL 
C-----------------------------------------------------------------------
         DO KK = L1,L1+NTEST-1
            IP = IFLD(KK)
            INV_SUMY(IP) = ONE/(ONE-ZMY(IP))
            NMDLNK(IP) = ZERO
         END DO 
C        HERE DLNK IS LOG(PHIZ/K)
         DO I = 1,NHC
            DO KK = L1,L1+NTEST-1
               IP = IFLD(KK)
               Y(IP,I) = EK(IP,I)*Z(IP,I)*INV_SUMY(IP)
               DLNK(IP,I) = PHIY(IP,I)-W(IP,I)
            END DO 
         END DO 
         SUBPHI = .TRUE.
         CALL EOS_PROP(P,Y,ZF(1,2),DLNK,AD,AP,BP,CP,PRLOG,IEOSTL,
     &             FUG_CALC,SUBPHI,TOL_ZFAC,NHC,NDIM,NP,NTEST,IFLD(L1))
         DO I = 1,NHC
            DO KK = L1,L1+NTEST-1
               IP = IFLD(KK)
               DUM = DLNK(IP,I)
               NMDLNK(IP)=NMDLNK(IP)+DUM*DUM
           END DO 
         END DO 
         DO KK = L1,L1+NTEST-1
            IP = IFLD(KK)
            NMDLNK(IP) = NMDLNK(IP)/MAX(NMLNK(IP),SMALL)
         END DO 
C-----------------------------------------------------------------------
C STEP 4: SORT NTEST CELLS INTO NTOP CONVERGED AND NBOT NON_CONVERGED 
C-----------------------------------------------------------------------
         IF (ITER < ITMAX)   THEN
            L = L1
            CALL EOS_MOVE(NMDLNK,TOL_FLASH,1,NTOP,NMOV,IFLD(L),NP,NTEST)
         ELSE 
            NTOP = NTEST
         ENDIF 
         NBOT = NTEST - NTOP
         NTEST = NBOT
         L1 = L1 + NTOP

C***********************************************************************
         IF (NTEST == 0)   GO TO 2000
C***********************************************************************

C-----------------------------------------------------------------------
C STEP 5: UPDATE  K-VALUES
C-----------------------------------------------------------------------
         SUBPHI = .FALSE.
         CALL EOS_PROP_DR(P,ZF(1,2),ADM,ADM,ADM,A,AD,AP,BP,CP,PRLOG,
     &                    IEOSTL,TEMPR,1,NTEST,1,0,1,0,1,0,SUBPHI,
     &                    SYM_PACK,NHC,NDIM,NP,NTEST,IFLD(L1))
C        HERE Y(*,I) IS MOLE FRACTION OF THE TRIAL PHASE AND A IS DPHIYDZ
         J = 0
         DO I = 1,NHC
            J = J + I 
            DO KK = L1,L1+NTEST-1
               IP = IFLD(KK)
               Y(IP,I) = ONE/MAX(Y(IP,I),SMALL)
               A(IP,J) = A(IP,J)+Y(IP,I)
            END DO 
         END DO 
C       A IS THE MATRIX AND 1/Y IS MOLES OF THE TRIAL PHASE
C  ..   SOLVE LINEAR EQUATION FOR CHANGE IN LOG(K(I))/Y(I)
         CALL EOS_FORM(A,NDIM,NHC,NTEST,IFLD(L1))
         J = 0
         DO I = 1,NHC
            J = J + I 
            DO KK = L1,L1+NTEST-1
               IP = IFLD(KK)
               A(IP,J) = ABS(A(IP,J))
            END DO 
         END DO 
         CALL EOS_SOLV(A,DLNK,NDIM,NHC,1,NTEST,IFLD(L1)) 
         DO KK = L1,L1+NTEST-1 
            IP = IFLD(KK)
            ZMY(IP)=ZERO
            NMLNK(IP)=ZERO
         END DO 
         DO I = 1,NHC
            DO KK = L1,L1+NTEST-1
               IP = IFLD(KK)
               DLNK(IP,I) = MAX(CHGMN,MIN(CHGMX,Y(IP,I)*DLNK(IP,I)))
               W(IP,I) = W(IP,I)+DLNK(IP,I)
               EK(IP,I) = EXP(W(IP,I))
               DUM = W(IP,I)
               NMLNK(IP) = NMLNK(IP)+DUM*DUM
               ZMY(IP) = ZMY(IP)+(ONE-EK(IP,I))*Z(IP,I)
            END DO 
         END DO 
C-----------------------------------------------------------------------
C STEP 6: SORT NTEST CELLS INTO NTOP NONTRIVIAL AND NBOT TRIVIAL 
C-----------------------------------------------------------------------
         L = L1
         CALL EOS_MOVE(NMLNK,TOL_TRIV,3,NTOP,NMOV,IFLD(L),NP,NTEST)
         NBOT = NTEST - NTOP
         NTEST = NTOP

C***********************************************************************
         IF (NTEST > 0)   GO TO 1000
C***********************************************************************

2000     CONTINUE
         CONVERGED = L1 - L0
         L1 = L0
C-----------------------------------------------------------------------
C STEP 7: SORT CONVERGED CELLS INTO NTOP UNSTABLE AND NBOT STABLE CELLS 
C-----------------------------------------------------------------------
         L = L1
         CALL EOS_MOVE(ZMY,ZERO,1,NTOP,NMOV,IFLD(L),NDIM,CONVERGED)
         NONSTABLE = NTOP
C-----------------------------------------------------------------------
C STEP 8: COPY K-VALUES FOR NONSTABLE CELLS INTO K_SAVE (PASS=1)
C-----------------------------------------------------------------------
         IF (PASS == 1)   THEN
            DO KK = L1+NONSTABLE,FLTYPE(1)+FLTYPE(2)+FLTYPE(3)+FLTYPE(4)
               IP = IFLD(KK)
               RESULT(IP) = ZERO
            END DO 
            DO KK = L1,L1+NONSTABLE-1
               IP = IFLD(KK)
               ZF(IP,3) = ZF(IP,2)
               RESULT(IP) = ONE
            END DO 
            DO I = 1,NHC
               DO KK = L1,L1+NONSTABLE-1
                  IP = IFLD(KK)
                  EKS(IP,I) = EK(IP,I)
               END DO 
            END DO 
         ENDIF 
      END DO 
C-----------------------------------------------------------------------
C STEP 9: SORT NONSTABLE CELLS INTO NTOP WITH RESULT=1 AND NBOT WITH RESULT=0
C-----------------------------------------------------------------------
      L = L1
      CALL EOS_MOVE(RESULT,ZERO,3,NTOP,NMOV,IFLD(L),NP,NONSTABLE)
      NSPLIT = NTOP
      NBUB = NONSTABLE - NTOP
      NTEST = FLTYPE(4) - NONSTABLE
      L1 = L0 + NONSTABLE
C-----------------------------------------------------------------------
C STEP 10: SORT NTEST CELLS INTO NTOP WITH RESULT=1 AND NBOT WITH RESULT=0
C-----------------------------------------------------------------------
      L = L1
      IF (NTEST > 0)   THEN
         CALL EOS_MOVE(RESULT,ZERO,3,NTOP,NMOV,IFLD(L),NP,NTEST)
      ELSE 
         NTOP = 0
      ENDIF  
      NDEW = NTOP
      NBOT = NTEST - NTOP
      N1PH = NBOT 
      L1 = L0
C-----------------------------------------------------------------------
C STEP 11: FOR NSPLIT CELLS, COMBINE THE K-VALUES FROM BOTH PASSES
C-----------------------------------------------------------------------
      IF (NSPLIT > 0)   THEN
         L2 = L1 + NSPLIT - 1
         DO KK = L1,L2
            IP = IFLD(KK)
            NMLNK(IP) = ZERO
         END DO
         DO I = 1,NHC
            DO KK = L1,L2
               IP = IFLD(KK)
               EK(IP,I) = EK(IP,I)/EKS(IP,I)
               DUM = EK(IP,I) - ONE
               NMLNK(IP) = NMLNK(IP) + DUM*DUM
            END DO 
         END DO 
C-----------------------------------------------------------------------
C STEP 12: SORT NSPLIT CELLS INTO NTOP NONTRIVIAL AND NBOT TRIVIAL
C-----------------------------------------------------------------------
         L = L1
         CALL EOS_MOVE(NMLNK,TOL_TRIV,3,NTOP,NMOV,IFLD(L),NP,NSPLIT)
      ELSE 
         NTOP = 0
      ENDIF
      NBOT = NSPLIT - NTOP
C-----------------------------------------------------------------------
C STEP 13: FOR THE NTOP NONTRIVIAL CELLS, COMPLETE THE SOLUTION
C-----------------------------------------------------------------------
      IF (NTOP > 0)   THEN
         DO KK = L1,L1+NTOP-1
            IP = IFLD(KK)
            ZF(IP,1) = ZF(IP,3)
            V(IP) = HALF
         END DO 
         L1 = L1 + NTOP
      ENDIF 
C-----------------------------------------------------------------------
C STEP 14: FOR THE NBOT TRIVIAL CELLS, RESTORE K-VALUES FROM PASS 1 
C-----------------------------------------------------------------------
      IF (NBOT > 0)   THEN
         L2 = L1 + NBOT - 1
         DO IC = 1,NHC
            DO KK = L1,L2
               IP = IFLD(KK)
               EK(IP,IC) = EKS(IP,IC)
            END DO
         END DO
         NBUB = NBUB +NBOT
      ENDIF 
C-----------------------------------------------------------------------
C STEP 15: FOR THE NBUB CELLS, COMPLETE THE SOLUTION BY SETTING V
C-----------------------------------------------------------------------
      IF (NBUB > 0)   THEN
         DO KK = L1,L1+NBUB-1
            IP = IFLD(KK)
            V(IP) = TENTH
         END DO
         L1 = L1 + NBUB 
      ENDIF 
C-----------------------------------------------------------------------
C STEP 16: FOR THE NDEW CELLS, INVERT THE SOLUTION FROM PASS 1 
C-----------------------------------------------------------------------
      IF (NDEW > 0)   THEN
         L2 = L1+NDEW-1
         DO KK = L1,L2
            IP = IFLD(KK)
            ZF(IP,2) = ZF(IP,1)
            ZF(IP,1) = ZF(IP,3)
            V(IP) = ONE-TENTH
         END DO 
         DO IC = 1,NHC
            DO KK = L1,L2
               IP = IFLD(KK)
               EK(IP,IC) = ONE/EKS(IP,IC)
            END DO
         END DO
      ENDIF 
      N2PH = NTOP + NBUB + NDEW
C-----------------------------------------------------------------------
C STEP 17: TRANSFER N2PH CELLS FROM TYPE 4 INTO TYPE 3
C-----------------------------------------------------------------------
      FLTYPE(3) = FLTYPE(3) + N2PH
      FLTYPE(4) = FLTYPE(4) - N2PH
C-----------------------------------------------------------------------
C STEP 18: RECLASSIFY REMAINING TYPE 4 CELLS AS TYPE 8
C-----------------------------------------------------------------------
      FLTYPE(8) = FLTYPE(8) + FLTYPE(4)
      FLTYPE(4) = 0
      END 
 
C***********************************************************************
      SUBROUTINE EOS_2PH_UP(P,ZF,VOIL,VGAS,V,HCTOTL,VHC,ERRSAT,
     &                      COEFW,RES,TEMPR,NDIM,NP,NHC,N,
     &                      IFLD)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,NP,N,IFLD(N)
      REAL*8  P(NDIM),V(NDIM),TEMPR(NDIM),HCTOTL(NP),
     &        ZF(NDIM,3),COEFW(NP,NHC),RES(NDIM,NHC),VHC(NP),VOIL(NDIM),
     &        VGAS(NDIM),ERRSAT(NP)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER IP,KK,IERR
      REAL*8 RTP
!      REAL*8 RHS(NP)

! bag8
      REAL*8, ALLOCATABLE :: RHS(:)
! bag8

C ----------------------------------------------------------------------
C  THIS ROUTINE CALCULATES THE MOLAR VOLUMES AND OVERALL MOLAR VOLUME OF
C  TWO-PHASE CELLS. IT ALSO CORRECTS THE SATURATION ERROR USING THE
C  RESIDUALS OF THE FUGACITY EQUATIONS.
C ----------------------------------------------------------------------

! bag8
      ALLOCATE(RHS(NP),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate RHS'
! bag8

      CALL EOS_RMBA1(NP,NP,NDIM,RHS,COEFW,RES,NHC,N,IFLD)
      DO KK = 1,N
         IP = IFLD(KK)
         ERRSAT(IP) = ERRSAT(IP) + HCTOTL(IP)*RHS(IP)
      END DO 
      DO KK = 1,N
         IP = IFLD(KK)
         RTP = GASCON*TEMPR(IP)/P(IP)
         VOIL(IP) = RTP*ZF(IP,1)
         VGAS(IP) = RTP*ZF(IP,2)
         VHC(IP) = (ONE-V(IP))*VOIL(IP) + V(IP)*VGAS(IP)
      END DO 

! bag8
      DEALLOCATE(RHS)
! bag8

      END 
 
C***********************************************************************
      SUBROUTINE EOS_V1PH(Z,P,ZF,HCTOTL,WTOTL,ERRSAT,
     &                    AD,AP,BP,CP,IEOSTL,TEMPR,NHC,NDIM,
     &                    NP,N1PH,NAQF,TOL_ZFAC,IFLD)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
      INCLUDE 'xresprop.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,NP,N1PH,NAQF,IEOSTL(NDIM),IFLD(NP)
      REAL*8 TOL_ZFAC
      REAL*8 P(NDIM),TEMPR(NDIM),HCTOTL(NP),WTOTL(NP),
     &       Z(NDIM,NHC),AD(NP,NHC),ZF(NDIM),ERRSAT(NDIM),
     &       AP(NP),BP(NP),CP(NP)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER L,M,KK,IERR
      REAL*8 DUM,ADM,DWB_FVF
!      REAL*8 PRLOG(NP)

! bag8
      REAL*8, ALLOCATABLE :: PRLOG(:)
! bag8

C-----------------------------------------------------------------------
C  THIS ROUTINE CALCULATES ONE-PHASE FLUID VOLUME AND SATURATION ERROR
C     HCTOTL(L)  = MOLAR CONCENTRATION OF HYDROCARBON 
C     WTOTL(L)  = MOLAR CONCENTRATION OF WATER 
C     ERRSAT(L) = SATURATION ERROR
C-----------------------------------------------------------------------

! bag8
      ALLOCATE(PRLOG(NP),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate PRLOG'
! bag8

      DWB_FVF = WATDEN/WATFVF
      IF(N1PH > 0)THEN
         CALL EOS_PROP(P,Z,ZF,ADM,AD,AP,BP,CP,PRLOG,IEOSTL,
     &                 .FALSE.,.FALSE.,TOL_ZFAC,NHC,NDIM,NP,N1PH,IFLD)
         DO KK = 1, N1PH
            L = IFLD(KK)
            DUM = DWB_FVF*(ONE+WATCOMP*(P(L)-WAT_REFP))
            ERRSAT(L) = ONE - HCTOTL(L)*GASCON*TEMPR(L)*ZF(L)/P(L)
     &                - WTOTL(L)/DUM
            END DO 
      ENDIF
      IF(NAQF > 0)THEN
         DO KK = N1PH+1,N1PH+NAQF
            L = IFLD(KK)
            DUM = DWB_FVF*(ONE+WATCOMP*(P(L)-WAT_REFP))
            ERRSAT(L) = ONE - WTOTL(L)/DUM
         END DO 
      ENDIF

! bag8
      DEALLOCATE(PRLOG)
! bag8

      END 
 
C***********************************************************************
      SUBROUTINE EOS_V2PH(P,ZF,V,HCTOTL,TEMPR,ERRSAT,
     &                    WTOTL,NDIM,NP,IEOSTL,N,IFLD) 
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
      INCLUDE 'xresprop.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NDIM,NP,N,IEOSTL(NDIM),IFLD(NP)
      REAL*8 P(NDIM),V(NDIM),TEMPR(NDIM),HCTOTL(NP),
     &       ZF(NDIM,3),WTOTL(NP),ERRSAT(NP),DWB_FVF
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER L,M,KK
      REAL*8 DUM
C-----------------------------------------------------------------------
C  THIS ROUTINE CALCULATES TWO-PHASE SATURATION ERROR
C     HCTOTL(L)  = TOTAL MOLES OF HYDROCARBON 
C     WTOTL(L)  = TOTAL MOLES OF WATER 
C     ERRSAT(L) = SATURATION ERROR AT POINT L
C-----------------------------------------------------------------------
      DWB_FVF = WATDEN/WATFVF 
      DO KK = 1, N
         L = IFLD(KK)
         DUM = DWB_FVF*(ONE+WATCOMP*(P(L)-WAT_REFP))
         ERRSAT(L) = ONE - GASCON*TEMPR(L)*HCTOTL(L)
     &             * ( (ONE-V(L))*ZF(L,1) + V(L)*ZF(L,2) ) / P(L)
     &             - WTOTL(L)/DUM
      END DO 
      END 
 
C***********************************************************************
      SUBROUTINE EOS_VISCH(Z,DN,VISC,XVISC,IEOSTL,NDIM,NP,NHC,N,IFLD)
C***********************************************************************
      USE xgendat
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     THIS ROUTINE CACULATES VISCOSITY FOR A NONAQUEOUS PHASE
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER  NP,NHC,NDIM,IEOSTL(NDIM),N,IFLD(NP)
      REAL*8 DN(NP),Z(NDIM,NHC),VISC(NDIM),XVISC(NDIM)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      REAL*8 A0,A1,A2,A3,A4,CONVRT,P18,B
      PARAMETER (A0 = .1023D0)
      PARAMETER (A1 = 0.023364D0)
      PARAMETER (A2 = 0.058533D0)
      PARAMETER (A3 = -0.040758D0)
      PARAMETER (A4 = 0.0093324D0)
      PARAMETER (B = 2.05D-4)
      PARAMETER (P18 = .18D0)
      PARAMETER (CONVRT = 5.44D0)
C
      INTEGER IP,IC,L,KK
      REAL*8 RDEN,TCMW,PCMW,XJ,XJ2,AVGWMOL,AVGTCRIT,AVGPCRIT,AVGSQRTW,
     &       AVGVISC,VISCM,ETA,AVGVCRIT
C
      DO KK = 1,N
         IP = IFLD(KK)
         L = IEOSTL(IP)
         XJ = Z(IP,1)
C
C        WMOL is molecular volume for component
         AVGWMOL = XJ*WMOL(1)
C
C        TCRIT is critical temperature for component
         AVGTCRIT = XJ*TCRIT(1)
C
C        PCRIT is critical pressure for component
         AVGPCRIT = XJ*PCRIT(1)
C
C        EOS_V is critical volume for component
         AVGVCRIT = XJ*EOS_V(1)
C
C        EOS_SQRTW is square root of molecular weight for component
         AVGSQRTW = XJ*EOS_SQRTMW(1)
C
C        EOS_VISC is low pressure viscosity for  pure component x EOS_SQRTW
         AVGVISC = XJ*EOS_VISC(1,L)
         DO IC = 2,NHC
            XJ = Z(IP,IC)
            AVGWMOL = AVGWMOL + XJ*WMOL(IC)
            AVGTCRIT = AVGTCRIT+ XJ*TCRIT(IC)
            AVGPCRIT = AVGPCRIT + XJ*PCRIT(IC)
            AVGVCRIT = AVGVCRIT + XJ*EOS_V(IC)
            AVGSQRTW = AVGSQRTW + XJ*EOS_SQRTMW(IC)
            AVGVISC = AVGVISC + XJ*EOS_VISC(IC,L)
         END DO
C
C        Find low pressure mixture viscosity
         VISCM = AVGVISC/AVGSQRTW
C
C        Find reduced molar density
         RDEN = AVGVCRIT*DN(IP)
C
C        Find ETA parameter
C        5.44*AVGTCRIT**.1667/(SQRT(AVGWMOL)*AVGPCRIT**.6667)
         PCMW = AVGWMOL*AVGPCRIT
         PCMW = PCMW*PCMW*PCMW
         ETA = CONVRT*( AVGTCRIT/(AVGPCRIT*PCMW) )**SIXTH
C
C        Apply the JOSSI-STIEL-THODOS correlation
C        Use Thele modification at low densities
C        Note: Setting 1/viscosity here
         IF(RDEN > P18) THEN
            XJ = A0+RDEN*(A1+RDEN*(A2+RDEN*(A3+RDEN*A4)))
            XJ2 = XJ*XJ
            VISC(IP) = ETA / (ETA*VISCM + (XJ2*XJ2-TEN_M4) )
         ELSE
            VISC(IP) = ETA / (ETA*VISCM + B*RDEN)
         ENDIF
         IF(VISC(IP) >= TEN_M15) THEN
            XVISC(IP) = ONE/VISC(IP)
         ELSE
            XVISC(IP) = TEN_P15
         ENDIF
      END DO
      END
 
C***********************************************************************
      SUBROUTINE EOS_RESTART(TEMPR,P,IFLD,NORM,ZF,Z,V,
     &                     XDZ,SBINV,DFUGDN,DFUGDP,EJAC,DIAG,HJAC,RES,
     &                     ADOIL,APOIL,BPOIL,CPOIL,PRLOGO,ADGAS,
     &                     APGAS,BPGAS,CPGAS,PRLOGG,EK,
     &                     IEOSTL,X,Y,
     &                     NHC,NFLASH,NDIM,NP)
C***********************************************************************
      IMPLICIT NONE
ctemporary
      include 'control.h'
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,NP,IEOSTL(NDIM),NFLASH
      INTEGER IFLD(NP)
      REAL*8 TEMPR(NDIM),P(NDIM),X(NDIM,NHC),
     &       Y(NDIM,NHC),Z(NDIM,NHC),EK(NDIM,NHC),XDZ(NDIM,NHC),
     &       ADGAS(NP,NHC),ADOIL(NP,NHC),
     &       DFUGDP(NDIM,NHC),RES(NDIM,NHC),EJAC(NDIM,NHC*(NHC+1)/2),
     &       HJAC(NDIM,NHC,2),DFUGDN(NDIM,NHC,NHC),DIAG(NDIM,NHC)
      REAL*8 ZF(NDIM,3),NORM(NP),V(NDIM),APOIL(NP),BPOIL(NP),
     &       CPOIL(NP),APGAS(NP),BPGAS(NP),CPGAS(NP),PRLOGO(NP),
     &       PRLOGG(NP),SBINV(NP)
                                                       
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER I,IP,KK,IERR
      LOGICAL FUG_CALC,SUBPHI
!      REAL*8  SCR(NP)

! bag8
      REAL*8, ALLOCATABLE :: SCR(:)
! bag8

C ----------------------------------------------------------------------
C  THIS ROUTINE GENERATES FUGACITIES AND DERIVATIVE FOR RESTARTS 
C     IFLD  - GRID POINT INDEX
C     NORM  - RESIDUAL NORM
C     Z     - OVERALL HYDROCARBON MOLE FRACTIONS
C     P     - PRESSURE
C     ZF    - COMPRESSIBILITY FACTOR FOR LIQUID & GAS
C     EK    - EQUILIBRIUM K-VALUES
C     XDZ   - X(I)/Z(I) 
C     V     - MOLE FRACTION OF VAPOR PHASE
C     EJAC   - SYMMETRIC PART OF JACOBIAN CORRESPONDING TO DERIVATIVES
C             OF FUGACITIES W.R.T. LOG(K(I)).
C     DFUGDN   - DERIVATIVES OF FUGACITIES W.R.T. N(I) 
C     DFUGDP   - DERIVATIVES OF FUGACITIES W.R.T. P
C     RES    - RESIDUES OF FUGACITY EQUATIONS
C     X     - MOLE FRACTIONS FOR LIQUID
C     Y     - MOLE FRACITONS FOR GAS
C     NFLASH - NUMBER OF POINTS TO FLASH
C ----------------------------------------------------------------------
      IF (NFLASH == 0) RETURN

! bag8
      ALLOCATE(SCR(NP),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate SCR'
! bag8

C     CALCULATE FUGACITIES AT THE SAME TIME Z IS CALCULATED
      FUG_CALC = .TRUE.

C ======================================================================
C     CALCULATE COEFFICIENTS FROM RR EQUATION
C ======================================================================
      CALL EOS_RESTART_RR(Z,EK,V,XDZ,SBINV,NDIM,NP,NHC,NFLASH,IFLD)

C ======================================================================
C     CALCULATE NEW RESIDUALS AND NORM
C ======================================================================
      DO I = 1,NHC
         DO KK = 1,NFLASH
            IP = IFLD(KK)
            X(IP,I) = Z(IP,I)*XDZ(IP,I)
         END DO 
      END DO 
      SUBPHI=.FALSE.
      CALL EOS_PROP(P,X,ZF,RES,ADOIL,APOIL,BPOIL,CPOIL,PRLOGO,
     &              IEOSTL,FUG_CALC,SUBPHI,ZERO,NHC,
     &              NDIM,NP,NFLASH,IFLD)

      DO I = 1,NHC
         DO KK = 1,NFLASH
            IP = IFLD(KK)
            RES(IP,I) = RES(IP,I)-LOG(EK(IP,I))
            Y(IP,I) = EK(IP,I)*X(IP,I)
         END DO 
      END DO 
      SUBPHI=.TRUE.
      CALL EOS_PROP(P,Y,ZF(1,2),RES,ADGAS,APGAS,BPGAS,CPGAS,
     &              PRLOGG,IEOSTL,FUG_CALC,SUBPHI,
     &              ZERO,NHC,NDIM,NP,NFLASH,IFLD)
C
C     MIMIC EOS RESIDUAL CALCULATION
      DO KK = 1,NFLASH
         IP = IFLD(KK)
         SBINV(IP) = ONE/SBINV(IP)
         NORM(IP) = ZERO
      END DO 

! bag8
      DEALLOCATE(SCR)
! bag8

      END 

C***********************************************************************
      SUBROUTINE EOS_RESTART_RR(ZCOMP,EK,V,XDZ,SBINV,
     &                          NDIM,NP,NHC,N,IFLD)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NHC,NDIM,NP,N,IFLD(N)
      REAL*8 ZCOMP(NDIM,NHC),EK(NDIM,NHC),XDZ(NDIM,NHC),
     &       V(NDIM),SBINV(NDIM)
C-----------------------------------------------------------------------
C     Local Arguments
C-----------------------------------------------------------------------
      INTEGER IC,L,KK
      REAL*8 XK
C-----------------------------------------------------------------------
C  THIS ROUTINE SETS UP RACHFORD-RICE EQUATION COEFFICIENTS FOR RESTARTS.
C  IT TAKES AS INPUT:
C     V(L)     : EQUILIBRIUM VAPOR FRACTION
C     EK(L,I)  : K_VALUE  OF COMPONENT I OF CELL L
C     Z(L,I)   : OVERALL MOLE FRACTION  OF COMPONENT I OF CELL L
C     ND       : LEADING DIMENSION OF FLUID ARRAYS 
C     NHC      : THE NUMBER OF COMPONENTS.
C     NP       : THE NUMBER OF CELLS.
C  IT RETURNS AS OUTPUT:
C     XDZ(L,I) : THE RATIO OF THE MOLE FRACTION OF COMPONENT I IN THE
C                EQUILIBRIUM LIQUID PHASE AT POINT L TO THE OVERALL
C                MOLE FRACTION OF COMPONENT I AT POINT L.
C     SBINV(L)    : THE DERIVATIVE OF RR(L) WITH RESPECT TO V(L).
C-----------------------------------------------------------------------
C
      DO KK = 1,N
         L = IFLD(KK)
         SBINV(L) = ZERO
      END DO
      DO IC = 1,NHC
         DO KK = 1,N
            L = IFLD(KK)
            XK = EK(L,IC)-ONE
            XDZ(L,IC) = ONE / (ONE + XK * V(L) )
            SBINV(L) = SBINV(L) - ZCOMP(L,IC) * (XK*XDZ(L,IC))**2
         END DO
      END DO
      END 
