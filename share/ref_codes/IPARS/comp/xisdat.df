C  XISDAT.F - INPUT COMPOSITIONAL MODEL SCALAR DATA

C  ROUTINES IN THIS MODULE:

C  SUBROUTINE XISDAT  (NERR)

C  CODE HISTORY:        
C      THE IPARS TEAM          04/02/1997   FRAMEWORK
C      RICK DEAN               03/02/2001   INITIAL VERSION
C      SUNIL G. THOMAS         09/01/2007   THERMAL, DIFF-DISP AND CO2 
C                            - 09/31/2009   APPS, MODS RELATED TO 2-PH
C                                           HYSTERESIS, EVMFEM, ETC.
C      XIANHUI KONG            06/11/2014   PETROPHYSICAL MODELS CO2 
C      GUPRREET SINGH          09/15/2015   AQUEOUS PHASE TRACER
C*********************************************************************
      SUBROUTINE XISDAT (NERR)
C*********************************************************************

C  Inputs initial scalar data for the compositional model.  Grid-element
C  arrays CAN NOT be referenced in this routine.

C  Read critical properties for each component

C  NERR = Error number stepped by 1 on error (input & output, INTEGER*4)
C  NOTE: Much of the thermochemical data has been borrowed from the NIST 
C  Chemistry WebBook, based on NIST Standard Reference Database No. 69, 
C  June 2005, Eds. P.J. Linstrom and W.G. Mallard, National Institute of 
C  Standards and Technology, Gaithersburg MD, 20899 
C  Website: http://webbook.nist.gov/chemistry/

C*********************************************************************
      USE xgendat
      IMPLICIT NONE
C=====IPARS framework include files
      INCLUDE 'control.h'
      INCLUDE 'unitsex.h'
      INCLUDE 'xcompwel.h'
      INCLUDE 'blkary.h'
C=====EOS model include files
      INCLUDE 'xthermal.h'
      INCLUDE 'xresprop.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xiter.h'
      INCLUDE 'xbaldat.h'
      CHARACTER*3 TMP
      CHARACTER*10 OUTMOLF
      REAL*8 DUM
      CHARACTER*20 XUNITS
      INTEGER NDUM1,NERR,NDUM,I,J,K,L,IPH,IC,K1,K2,MERR
      REAL*8 TOTALTIME,TFLUID,TFLASH

c bag8 - allocate variables for flash calculation
      CALL XGENDAT_ALLOC()

      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)'PROC',MYPRC,
     &                         ' ENTERING SUBROUTINE XISDAT'
      IF(LEVELC) THEN
         TITU='COMPOSITIONAL SCALAR DATA'
         WRITE(NFOUT,*)
         CALL PRTTIT(TITU)
         WRITE(NFOUT,*)
      ENDIF
      OUTMOLF='OUT_ MOLF '

C-------setup miscellaneous parameters
      IFLPV0 = 7
      IFLINIT = 6
      DSMAX_TARG = FIVE*TEN_M2
      ICFLCHK = 1
      CFL = (TEN+EIGHT)/TEN

C-------read properties of surface conditions
      TSURF = STDTEMP
      PSURF = STDPRES
      CALL DEFAULT(EXTTEMP)
      CALL GETVAL('TSURF[F] ',TSURF,'R8',0,0,0,0,NDUM1,NERR)
      CALL DEFAULT(EXTPRES)
      CALL GETVAL('PSURF[psi] ',PSURF,'R8',0,0,0,0,NDUM1,NERR)

C-------adjust constants to match other programs
C     For Acres: LBMOLMCF = .3795
C                GASCON = 10.7315  
C     Note: GASCON is R, the universal gas constant, in cu-ft-psi/lbM-R,
C           RCPCV is R, the universal gas constant, in Btu/lbM-R, 
      GASCON = 10.731460D0
      CALL GETVAL('GASCON ',GASCON,'R8',0,0,0,0,NDUM1,NERR)
      LBMOLE_TO_MCF = TEN_M3*GASCON*(TSURF+TRF)/PSURF
      CALL GETVAL('LBMOLMCF ',LBMOLE_TO_MCF,'R8',0,0,0,0,NDUM1,NERR)

C-------input water density, compressibility, FVF, viscosity, isobaric
C       and isochoric specific heat capacities
      WAT_REFP=PSURF
      CALL DEFAULT(EXTPRES)
      CALL GETVAL('WATERP[psi] ',WAT_REFP,'R8',0,0,0,0,NDUM,NERR)
      WATFVF=ONE
      CALL GETVAL('WATFVF ',WATFVF,'R8',0,0,0,0,NDUM,NERR)
      WATCOMP=THREE*TEN_M6
      CALL DEFAULT(EXTCOMP)
      CALL GETVAL('WATCMP[/psi] ',WATCOMP,'R8',0,0,0,0,NDUM,NERR)
      WATVISC=ONE
      CALL DEFAULT(EXTVISC)
      CALL GETVAL('WATVIS[cp] ',WATVISC,'R8',0,0,0,0,NDUM,NERR)
      WAT_REFT=TSURF
      CALL DEFAULT(EXTTEMP)
      CALL GETVAL('WATREFT[F] ',WAT_REFT,'R8',0,0,0,0,NDUM,NERR)
      WVISCMP=WRVISCMP
      CALL GETVAL('WVISCMP ',WVISCMP,'R8',0,0,0,0,NDUM,NERR)
      WATDEN=STDENW/WATMOLW
      WATCP=STDWCP*WATMOLW
      CALL GETVAL('WATCP ',WATCP,'R8',0,0,0,0,NDUM,NERR)
      WATCV=WATCP-RCPCV
      CALL GETVAL('WATCV ',WATCV,'R8',0,0,0,0,NDUM,NERR)

      IF (LEVELC)THEN
         WRITE (NFOUT,100) WATFVF,'[ResVol/SurfVol]    ',
     &                     WATCOMP*CVMCOMP,EXTCOMP,
     &                     WAT_REFP*CVMPRES,EXTPRES,
     &                     WAT_REFT*CVMTEMP,EXTTEMP,
     &                     WATVISC*CVMVISC,EXTVISC,
     &                     WVISCMP,'[K]                 ',
     &                     WATCP,'[Btu/lbM-F]         ',
     &                     WATCV,'[Btu/lbM-F]         '
      ENDIF
  100 FORMAT(' WATER FVF AT RESV. TEMPERATURE (WATFVF)', 
     &         T50,F10.4,1X,A20,/,   
     &       ' WATER COMPRESSIBILITY (WATCMP)',T50,G11.3,1X,A20,/,
     &       ' WATER REFERENCE PRESSURE (WATERP)',T50,F10.2,1X,A20,/,
     &       ' WATER REFERENCE TEMP. (WATREFT)',T50,F10.2,1X,A20,/,
     &       ' WATER VISCOSITY (WATVIS)',T50,F10.4,1X,A20,/,
     &       ' WATER VISCOSITY ARRHENIUS (WVISCMP)',T50,F10.4,1X,A20,/,
     &       ' WATER ISOBARIC SP. HEAT (WATCP)',T50,F10.4,1X,A20,/,
     &       ' WATER ISOCHORIC SP. HEAT (WATCV)',T50,F10.4,1X,A20)

C-------convert WAT_REFT to K for use in viscosity correlation
      WAT_REFT=(WAT_REFT+TRF)/DEGK2F

C-------get number of phases and phase names
      NPH=3
      CALL GETVAL('NPHASE ',NPH,'I4',0,0,0,0,NDUM,NERR)
      PHNAM(1)='WATER'
      IF(NPH > 1) PHNAM(2)='OIL'
      IF(NPH > 2) PHNAM(3)='GAS'
      CALL GETVALS('PHASE ',PHNAM,'CS',-NPH,0,0,16,NDUM,NERR)
      DO I=1,NPH
         K=0
         DO J=1,$MXCNAM
            IF(PHNAM(I)(J:J)==' ') EXIT
            K=K+1
         END DO
         NPHNAM(I)=MAX(1,K)
      END DO

C-------get rock isochoric specific heat
      ROCKCV=STDRCKCV
      CALL GETVAL('ROCKCV ',ROCKCV,'R8',0,0,0,0,NDUM,NERR)

C-------get phase thermal conductivities
      DO J=1,3
         PHTCOND(1,J)=44.0D0
         PHTCOND(2,J)=8.1871D0
         PHTCOND(3,J)=1.7667D0
         PHTCOND(4,J)=1.8027D0
      END DO
      CALL GETVAL('PHTCOND ',PHTCOND,'R8',($MXPHASE+1),3,0,0,NDUM,NERR)

C-------get number of nonaqueous components
      NHC=-1
      CALL GETVAL('NHCOMP ',NHC,'I4',0,0,0,0,NDUM,NERR)
      IF(NHC == -1) THEN
         IF(NPH > 1) THEN
            NERR=NERR+1
            NHC=$MXCOMP
            IF(LEVELC) THEN
               WRITE(NFOUT,'(/,A)') 
     &                   'ERROR 3004; KEYWORD NHCOMP REQUIRED'
            ENDIF
         ELSE
            NHC=0
         ENDIF
      ENDIF

C-------get number of aqueous components
        NAQ= 0
        CALL GETVAL('NAQCOMP ',NAQ,'I4',0,0,0,0,NDUM,NERR)
        IF(NAQ<0) THEN
          NERR = NERR + 1
          IF(LEVELC) THEN
             WRITE(NFOUT,'(/,A)')
     &                   'ERROR - No. of aqueous components'
          ENDIF
        ENDIF

C-------check consistency between NHC and MXCOMP
      IF(NHC > $MXCOMP) THEN
         NERR = NERR + 1
         IF(LEVELC) THEN
            WRITE(NFOUT,*) ' MXCOMP must be set to ',NHC,
     &                     ' in comp.siz file'
         ENDIF
      ENDIF

C-------set total number of components
      NC=NHC+1
      IF(NC > $MXNUMEQ) THEN
         NERR = NERR + 1
         IF(LEVELC) THEN
            WRITE(NFOUT,*) ' Error - MXNUMEQ must be set to ',NC,
     &                     ' in *.siz file'
         ENDIF
         NC = $MXNUMEQ
      ENDIF
      NHC = MIN(NHC,$MXCOMP)
 
C-------get hydrocarbon component names
      DO J=1,$MXCOMP
         CMPNAM(J)=' '
      END DO
      IF(NHC > 0) THEN
         CALL GETVALS('COMP ',CMPNAM,'CS',-NHC,0,0,16,NDUM,NERR)
      ENDIF
      DO J=1,NHC
         IF(CMPNAM(J)==' ') THEN
            NERR=NERR+1
            IF(LEVELC) THEN
               WRITE(NFOUT,'(/,2A,I5)') 'ERROR: ',
     &                     'BAD COMPONENT NAME FOR HC COMPONENT ',J
            ENDIF
         ENDIF
      END DO

C-------get aqueous component names
      DO J=1,$MXCOMP
         CMPAQNAM(J)=' '
      END DO
      IF (NAQ>0) THEN
         CALL GETVALS('COMPAQ ',CMPAQNAM,'CS',-NAQ,0,0,16,NDUM,NERR)
      ENDIF
      DO J = 1,NAQ
         IF(CMPAQNAM(J)==' ') THEN
            NERR=NERR+1
            IF(LEVELC) THEN
               WRITE(NFOUT,'(/,2A,I5)') 'ERROR: ',
     &                     'BAD COMPONENT NAME FOR AQ COMPONENT ',J
            ENDIF
         ENDIF
      END DO

C-------shift names for water component
      DO J=NHC,1,-1
         CMPNAM(J+1)=CMPNAM(J)
      END DO
      CMPNAM(1)='WATER'

C-------get name length for each component
      DO I=1,NC
         K=0
         DO J=1,$MXCNAM
            IF(CMPNAM(I)(J:J)==' ') EXIT
            K=K+1
         END DO
         NCMPNAM(I)=MAX(1,K)
      END DO

      DO I=1,NAQ
         K=0
         DO J=1,$MXCNAM
            IF(CMPAQNAM(I)(J:J)==' ') EXIT
            K=K+1
         END DO
         NCMPAQNAM(I)=MAX(1,K)
      END DO

C-------get number of rock types
      NXROCKS = 1
      CALL GETVAL('NXROCKS ',NXROCKS,'I4',0,0,0,0,NDUM,NERR)
      IF (LEVELC) WRITE (NFOUT,
     &     "(' NXROCKTYPE ',T54, I3 )" )
     &      NXROCKS

      XNO_DD=.FALSE.
      CALL GETVAL('XNO_DIFFDISP ',XNO_DD,'FG',0,0,0,0,NDUM,NERR)
      IF (LEVELC) THEN
         IF (XNO_DD) THEN
            WRITE (NFOUT,*) "DISPERSION MODE IN XMODEL IS OFF "
         ELSE
            WRITE (NFOUT,*) "DISPERSION MODE IN XMODEL IS ON "
         ENDIF
      ENDIF

C ------get molecular diffusion
      XNO_MD=.TRUE. 
      DO L=1,$MXXRCK
         DO J=1,$MXCOMP+1
            DO IPH=1,$MXPHASE
              XMDIFF(L,J,IPH)=ZERO
            ENDDO
         ENDDO
      ENDDO
      CALL GETVAL('XMOL_DIFF ',XMDIFF,'R8',$MXXRCK,$MXCOMP+1,$MXPHASE,
     &            0,NDUM,NERR)
      IF(LEVELC) THEN
         DO L=1,NXROCKS
            DO J=1,NC
               DO IPH=1,NPH
                  WRITE (NFOUT,
     &            "(' MOL. EFF. DIFFUSIVITY (ROCK',I2,',CMPNT.',I2,
     &            ',PHASE',I2,')',T49,E10.2,1X,A20)" )
     &            L,J,IPH,XMDIFF(L,J,IPH), "[FT^2/DAY]         "
               ENDDO
            ENDDO
         ENDDO
      ENDIF
C -------set no-diffusion flag appropriately
      DO L=1,$MXXRCK
         DO J=1,$MXCOMP+1
            DO IPH=1,$MXPHASE
              IF(XMDIFF(L,J,IPH).GT.ZERO) THEN
                 XNO_MD=.FALSE.
                 EXIT
              ENDIF
            ENDDO
         ENDDO
      ENDDO

C -------get longitudinal dispersivity
      XNO_LD=.TRUE. 
      DO L=1,$MXXRCK
         DO IPH=1,NPH
            XLDISP(L,IPH)=ZERO
         ENDDO
      ENDDO
      CALL GETVAL('XLONG_DISP ',XLDISP,'R8',$MXXRCK,$MXPHASE,0,
     &            0,NDUM,NERR)
      IF (LEVELC) THEN
         DO L=1,NXROCKS
            DO IPH=1,NPH
               WRITE (NFOUT,
     &         "(' XMODEL LONGITUDINAL DISP. (ROCK',I2,',PHASE',I2,')',
     &         T49,E10.2,1X,A20)" )
     &         L, IPH, XLDISP(L,IPH), "[ft]                "
            ENDDO
         ENDDO
      ENDIF

C -------get transverse dispersivity
      XNO_TD=.TRUE. 
      DO L=1,$MXXRCK
         DO IPH=1,NPH
            XTDISP(L,IPH)=ZERO
         ENDDO
      ENDDO
      CALL GETVAL('XTRANS_DISP ',XTDISP,'R8',$MXXRCK,$MXPHASE,0,
     &            0,NDUM,NERR)
      IF (LEVELC) THEN
         DO L=1,NXROCKS
            DO IPH=1,NPH
               WRITE (NFOUT,
     &         "(' XMODEL TRANSVERSE DISP. (ROCK',I2,',PHASE',I2,')',
     &         T49,E10.2,1X,A20)" )
     &         L, IPH, XTDISP(L,IPH), "[ft]                "
            ENDDO
         ENDDO
      ENDIF

C -------set no-dispersivity flag appropriately
      DO L=1,$MXXRCK
         DO IPH=1,NPH
            IF(XLDISP(L,IPH).GT.ZERO) THEN
               XNO_LD=.FALSE.
               EXIT
            ELSEIF(XTDISP(L,IPH).GT.ZERO) THEN
               XNO_TD=.FALSE.
               EXIT
            ENDIF
         ENDDO
      ENDDO
      IF(XNO_MD.AND.XNO_LD.AND.XNO_TD) XNO_DD=.TRUE.

C-------get critical properties for pvt tables
      K = 0
      DO I=1,NHC
         TCRIT(I)=TEN_P10
         PCRIT(I)=TEN_P10
         ZCRIT(I)=TEN_P10
         ACENTF(I)=TEN_P10
         WMOL(I)=TEN_P10
         PCHOR(I)=TEN_P10
         VSHIFT(I)=TEN_P10
         DO J=1,NHC
            K=K+1
            BINACT(K)=ZERO
         END DO
         HCCP(I)=ZERO
         HCCV(I)=ZERO
      END DO
      IF( EXTTEMP(2:2)=='C' .OR. EXTTEMP(2:2)=='K') THEN
         CALL DEFAULT('[K]')
      ELSE
         CALL DEFAULT('[R]')
      ENDIF
      CALL GETVAL('TCRIT[R] ',TCRIT,'R8',NHC,0,0,0,NDUM,NERR)
      CALL DEFAULT(EXTPRES)
      CALL GETVAL('PCRIT[psi] ',PCRIT,'R8',NHC,0,0,0,NDUM,NERR)
      CALL GETVAL('ZCRIT ',ZCRIT,'R8',NHC,0,0,0,NDUM,NERR)
      CALL GETVAL('ACENT ',ACENTF,'R8',NHC,0,0,0,NDUM,NERR)
      CALL GETVAL('MOLWT ',WMOL,'R8',NHC,0,0,0,NDUM,NERR)
      CALL GETVAL('PARACHOR ',PCHOR,'R8',NHC,0,0,0,NDUM,NERR)
      CALL GETVAL('VSHIFT ',VSHIFT,'R8',NHC,0,0,0,NDUM,NERR)
      CALL GETVAL('HCCP ',HCCP,'R8',NHC,0,0,0,NDUM,NERR)
      IF(NDUM > 0 .AND. NERR == 0) THEN
         DO I=1,NHC
            IF(HCCP(I) /= ZERO) HCCV(I)=HCCP(I)-RCPCV
         END DO
      ELSEIF(NERR > 0) THEN
         STOP 'IN XISDAT: ERROR READING HCCP!!'
      ENDIF
      CALL GETVAL('BINACT ',BINACT,'R8',NHC,NHC,0,0,NDUM,NERR)
C-------set default values for known components
      CALL SET_EOS_DEFAULT(NHC,NC,TCRIT,PCRIT,ZCRIT,ACENTF,WMOL,
     &                     VSHIFT,PCHOR,HCCP,HCCV,CMPNAM)
      
C-------check symmetry for BINACT values
      CALL BIN_CHECK(BINACT,NHC,NERR,NFOUT,LEVELC)

      IF (LEVELC) THEN
         WRITE(NFOUT,205) (I,PHNAM(I),I=1,NPH)
  205    FORMAT(' PHASES:',I5,2X,A$MXCNAM,/,
     &          $MXPHASE('        ',I5,2X,A$MXCNAM,/))
         WRITE(NFOUT,206) (I,CMPNAM(I),I=1,NC)
  206    FORMAT(' COMPONENTS:',I5,2X,A$MXCNAM,/,
     &          $MXCOMP('            ',I5,2X,A$MXCNAM,/))
         IF (NAQ>0) THEN
             WRITE(NFOUT,207) (I,CMPAQNAM(I),I=1,NAQ)
  207        FORMAT(' AQ. COMPONENTS:',I5,2X,A$MXCNAM,/,
     &          $MXCOMP('                ',I5,2X,A$MXCNAM,/))
         ENDIF
         TMP='[R]'
         IF( EXTTEMP(2:2)=='C' .OR. EXTTEMP(2:2)=='K') TMP='[K]'
         IF(NHC > 0) THEN
            WRITE(NFOUT,215)
            WRITE(NFOUT,220)
            WRITE(NFOUT,230) TMP,EXTPRES(1:5),EXTCONC
         ENDIF
         DO I = 1,NHC
            WRITE (NFOUT,250) CMPNAM(I+1),TCRIT(I)*CVMTEMP,
     &                        PCRIT(I)*CVMPRES,ZCRIT(I),
     &                        ACENTF(I),WMOL(I),PCHOR(I),
     &                        VSHIFT(I),HCCP(I),HCCV(I)
         END DO

C ---------call subroutine to write BINACT as 2-d array
         IF(NHC > 0) THEN
            WRITE(NFOUT,240)
            CALL WRITE_2DR8(BINACT,NHC,NHC,NFOUT,4,0)
         ENDIF

 215     FORMAT(25X,' ========================',/,
     &          25X,' | Component Properties |',/,
     &          25X,' ========================',/)
 220     FORMAT(/,1X,' NAME',7X,'TC',7X,'PC',9X,'ZC',
     &           10X,'AC',6X,'MW',4X,'Parachor',2X,'Vshift',
     &            7X,'CP',7X,'CV')
 230     FORMAT(12X,A3,5X,A5,15X,A20)
 240     FORMAT(/,30X,' Binary Interaction Parameters',/)
 250     FORMAT(1X,A6,1X,2(2X,F7.2),4X,F7.4,4X,F7.4,2(2X,F7.2),2X,F7.4,
     &          1X,2(2X,F7.2))
      ENDIF

C-------modify parachor for units multiplier
      DO IC = 1,NHC
         PCHOR(IC) = PCHOR_MULT*PCHOR(IC)
      END DO

C-------zero out the initial CPU time for the cumulative calculations
      TOTALTIME = ZERO
      TFLUID = ZERO
      TFLASH = ZERO

C-------replace the default output options
      OUT_PRES = .TRUE.
      IF(NPH > 1) THEN
         OUT_SAT = .TRUE.
      ELSE
         OUT_SAT = .FALSE.
      ENDIF
      OUT_MOLE = .FALSE.
      OUT_ZFAC = .FALSE.
      OUT_VAPF = .FALSE.
      OUT_KVAL = .FALSE.
      OUT_TMOLF = .FALSE.
      OUT_MOLD = .FALSE.
      OUT_MASSD = .FALSE.
      OUT_MASSDW = .FALSE.
      OUT_VISC = .FALSE.
      OUT_VISCW = .FALSE.
      OUT_CONC = .FALSE.
      OUT_COMPR = .FALSE.
      OUT_REFP = .FALSE.
      OUT_PC = .FALSE.
      OUT_MOB = .FALSE.
      OUT_MOLDW = .FALSE.
      OUT_PV = .FALSE.
      OUT_RELP = .FALSE.
      OUT_TENS = .FALSE.
      OUT_TEMPR = .FALSE.
      OUT_1DTEMPR = .FALSE.
      OUT_1DXCP = .FALSE.
      OUT_1DMDEN = .FALSE.
      OUT_1DSAT = .FALSE.
      OUT_1DVEL = .FALSE.
      OUT_CO2LEAK = .FALSE.
      OUT_CO2MOL = .FALSE.
      OUT_CO2DIST = .FALSE.
      MAXERRSAT = .TRUE.
      HYSTERESIS = .FALSE.
      AQPHSWTCH = .FALSE.
      XDARCYFLUX = .FALSE.
      XTHERMAL = .FALSE.
      XTHSOLVE = .FALSE.
      XNOTHCOND = .FALSE.
      XNOFLXLMTR = .FALSE.
      XTPROPVAR = .FALSE.
      XTHCFLCHK = .TRUE.
      XHEATLOSS = .FALSE.
      IFTSATRES = .FALSE.
      IFTRLPRM = .FALSE.
      IFTPCWET = .FALSE.
      LJFUNPC = .FALSE.
      NOPCKPHI = .FALSE.
      XJLFUNPC = .FALSE.
      XTSEOSBIN = .FALSE.
      XFRACROCK = .FALSE.
      DO I = 2,NPH
         OUTMOLF(5:5) = PHNAM(I)
         OUT_MOLF(I) = .FALSE.
         CALL GETVAL(OUTMOLF,OUT_MOLF(I),'L4',0,0,0,0,NDUM,NERR)
      END DO
      CALL GETVAL('OUT_PRES ',OUT_PRES,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_SAT ',OUT_SAT,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_MOLE ',OUT_MOLE,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_ZFAC ',OUT_ZFAC,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_VAPF ',OUT_VAPF,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_KVAL ',OUT_KVAL,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_TMOLF ',OUT_TMOLF,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_MOLD ',OUT_MOLD,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_MASSD ',OUT_MASSD,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_VISC ',OUT_VISC,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_MASSDW ',OUT_MASSDW,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_VISCW ',OUT_VISCW,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_CONC ',OUT_CONC,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_COMPR ',OUT_COMPR,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_REFP ',OUT_REFP,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_PC ',OUT_PC,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_MOB ',OUT_MOB,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_MOLDW ',OUT_MOLDW,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_PV ',OUT_PV,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_RELP ',OUT_RELP,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_TENS ',OUT_TENS,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_1DTEMPR ',OUT_1DTEMPR,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_TEMPR ',OUT_TEMPR,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_1DCP ',OUT_1DXCP,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_1DMDEN ',OUT_1DMDEN,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_1DSAT ',OUT_1DSAT,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_1DVEL ',OUT_1DVEL,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_CO2LEAK ',OUT_CO2LEAK,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_CO2MOL ',OUT_CO2MOL,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('OUT_CO2DIST ',OUT_CO2DIST,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('MAXERRSAT ',MAXERRSAT,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('HYSTERESIS ',HYSTERESIS,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('AQPHSWTCH ',AQPHSWTCH,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('XDARCYFLUX ',XDARCYFLUX,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('XTHERMAL ',XTHERMAL,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('XTHERMSOLVE ',XTHSOLVE,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('XNOTHERMCOND ',XNOTHCOND,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('XNOFLXLMTR ',XNOFLXLMTR,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('XTHPROPVAR ',XTPROPVAR,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('XTHCFLCHECK ',XTHCFLCHK,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('XHEATLOSS ',XHEATLOSS,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('IFTSATRES ',IFTSATRES,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('IFTRLPRM ',IFTRLPRM,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('IFTPCWET ',IFTPCWET,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('LJFUNPC ',LJFUNPC,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('XJLFUNPC ',XJLFUNPC,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('NOPCKPHI ',NOPCKPHI,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('XTSEOSBIN ',XTSEOSBIN,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('XFRACROCK ',XFRACROCK,'L4',0,0,0,0,NDUM,NERR)

      IF(OUT_TENS) THEN
         IFTCALC = .TRUE.
      ELSE
         IFTCALC = .FALSE.
      ENDIF

      IF(OUT_CO2MOL) THEN
         CO2LMOL=ZERO
         CO2GMOL=ZERO
      ENDIF
      
      IF(OUT_CO2DIST) THEN
         CO2FRGMOL=ZERO
         CO2TRGMOL=ZERO
         CO2DSSMOL=ZERO
      ENDIF

      IF ((NPH <= 2).AND.(AQPHSWTCH).AND.LEVELC) THEN
         WRITE(NFOUT,*) 'WARNING: AQUEOUS SWITCH RECOMMENDED FOR NPH=3.'
      ENDIF

Cxianhui
C       USE LJFUNPC to replace old keyword XJLFUNPC for J-fun PC scaling
        IF(XJLFUNPC) LJFUNPC=.TRUE.
        WRITE(61,*)' HYSTESIS  ',HYSTERESIS
        WRITE(61,*)' AQSwitch  ',AQPHSWTCH
        WRITE(61,*)' IFTSATRES ',IFTSATRES
        WRITE(61,*)' IFTRLPRM  ',IFTRLPRM
        WRITE(61,*)' LJFUNPC   ',LJFUNPC
        WRITE(61,*)' NOPCKPHI  ',NOPCKPHI
        WRITE(61,*)' IFTPCWET  ',IFTPCWET
        WRITE(61,*)' XTSEOSBIN ',XTSEOSBIN
C-------get rock fluid curve parameters
      CALL XIROCKDAT(NERR)
      IF(NDUM.GT.0.AND.NERR.GT.0) THEN
         IF(LEVELC) WRITE(61,*) ' ERROR READING NEW ROCK FLAG! '
      ENDIF

Cxianhui
C-------get IFT model types
      IFTTYPE = 1
      CALL GETVAL('IFTTYPE ',IFTTYPE,'I4',0,0,0,0,NDUM,NERR)
      IF (LEVELC) WRITE (61,
     &     "('  IFTTYPE ',T24, I3 )" )
     &      IFTTYPE
C-------get HYST model types
      HYSTYPE = 3
      CALL GETVAL('HYSTYPE ',HYSTYPE,'I4',0,0,0,0,NDUM,NERR)
      IF (LEVELC) WRITE (61,
     &     "('  HYSTYPE ',T24, I3 )" )
     &      HYSTYPE

C-------read salinity for modification of BIC for CO2/BRINE
      IFT0= 30.0
      CALL GETVAL('IFT0 ',IFT0,'R8',0,0,0,0,NDUM,NERR)
         WRITE(61,*) ' IFT0 = ',IFT0
      CALL GETVAL('SALIN ',SALIN,'R8',0,0,0,0,NDUM,NERR)
         WRITE(61,*) ' SALIN = ',SALIN
      IF(NDUM.GT.0.AND.NERR.GT.0) THEN
         IF(LEVELC) WRITE(61,*) ' ERROR READING SALIN IFT0! '
      ENDIF

C-------replace the default tolerances
      TOL_FLASH = TEN_M8
      TOL_TRIV = TEN_M4
      TOL_RR = TEN_M10
      TOL_ZFAC = TEN_M10
      TOL_SAT = TEN_M3
      TOL_PW = TEN_M2
      TOL_RATE = TEN_M6
      OVERLMT = TEN_M8
      CALL GETVAL('TOL_FLASH ',TOL_FLASH,'R8',0,0,0,0,NDUM1,NERR)
      CALL GETVAL('TOL_RR ',TOL_RR,'R8',0,0,0,0,NDUM1,NERR)
      CALL GETVAL('TOL_TRIV ',TOL_TRIV,'R8',0,0,0,0,NDUM1,NERR)
      CALL GETVAL('TOL_ZFAC ',TOL_ZFAC,'R8',0,0,0,0,NDUM1,NERR)
      CALL GETVAL('TOL_SAT ',TOL_SAT,'R8',0,0,0,0,NDUM1,NERR)
      CALL DEFAULT(EXTPRES)
      CALL GETVAL('TOL_PW[psi] ',TOL_PW,'R8',0,0,0,0,NDUM1,NERR)
      CALL GETVAL('TOL_RATE ',TOL_RATE,'R8',0,0,0,0,NDUM1,NERR)
      CALL GETVAL('OVERSHOOT ',OVERLMT,'R8',0,0,0,0,NDUM1,NERR)
      IF (LEVELC .AND. NHC > 0)  THEN
         WRITE (NFOUT,300) TOL_FLASH,TOL_RR,TOL_TRIV,
     &                     TOL_ZFAC,TOL_SAT,TOL_PW,TOL_RATE,OVERLMT
  300    FORMAT(/,' CONVERGENCE TOLERANCE FOR FUGACITIES',T50,G11.3,/,
     &       ' CONVERGENCE TOLERANCE FOR RACHFORD-RICE',T50,G11.3,/,
     &       ' CONVERGENCE TOLERANCE FOR TRIVIAL SOLUTION',T50,G11.3,/,
     &       ' CONVERGENCE TOLERANCE FOR CUBIC EQUATION',T50,G11.3,/,
     &       ' CONVERGENCE TOLERANCE FOR SATURATIONS',T50,G11.3,/,
     &       ' CONVERGENCE TOLERANCE FOR WELL PRESSURES',T50,G11.3,/,
     &       ' CONVERGENCE TOLERANCE FOR WELL RATES',T50,G11.3,/,
     &       ' ALLOWABLE OVERSHOOT FOR FLUXES',T50,G11.3)
      ENDIF

C-------set temperature intervals for EOS tables
      DEL_TS = HALF
      DEL_TR = ONE
      CALL GETVAL('DEL_TS ',DEL_TS,'R8',0,0,0,0,NDUM1,NERR)
      CALL GETVAL('DEL_TR ',DEL_TR,'R8',0,0,0,0,NDUM1,NERR)

C-------set value for single phase identification
C       zero value turns option off
      MDENH = 30.0D0
      CALL DEFAULT(EXTCONC)
      CALL GETVAL('MDENH[lbM/cu-ft] ',MDENH,'R8',0,0,0,0,NDUM1,NERR)

C-------set number of thermal steps per flow step and solver type for 
C       conduction if applies (defaults to BCGS).
      NTHSTEP=1
      NFLXLMT=0
      FLXLMTR=0.75D0
      ITHLINSOL=2
      THSOLTHTA=ONE
      IF(XTHERMAL) THEN
         CALL GETVAL('N_THERM_STEPS ',NTHSTEP,'I4',0,0,0,0,NDUM,NERR)
         IF(XTHSOLVE) THEN
            CALL GETVAL('XTHLINSOL ',ITHLINSOL,'I4',0,0,0,0,NDUM,NERR)
            CALL GETVAL('XTHSOLTHETA ',THSOLTHTA,'R8',0,0,0,0,NDUM,NERR)
         ENDIF
         CALL GETVAL('XFLXLMTRTYPE ',NFLXLMT,'I4',0,0,0,0,NDUM,NERR)
         CALL GETVAL('XFLXLMTR ',FLXLMTR,'R8',0,0,0,0,NDUM,NERR)
      ENDIF

C--------set over- and under-burden to default temperature of domain (100F)
      TMPOB=TSURF
      TMPUB=224.6D0
      XRFOB=ZERO
      XRFUB=TEN_P4
      DPTHTGRD=0.01646D0
      DBDINFTY=TEN
      RHOOB=165.434D0
      RHOUB=165.434D0
      LMDOB(1)=44.0D0
      LMDOB(2)=8.1871D0
      LMDOB(3)=1.7667D0
      LMDOB(4)=1.8027D0
      LMDUB(1)=44.0D0
      LMDUB(2)=8.1871D0
      LMDUB(3)=1.7667D0
      LMDUB(4)=1.8027D0
      CVOB=ROCKCV
      CVUB=ROCKCV
C--------Read heatloss related parameters (assume default units now)
      IF(XHEATLOSS) THEN
         CALL GETVAL('TEMPOB ',TMPOB,'R8',0,0,0,0,NDUM,NERR)
         CALL GETVAL('TEMPUB ',TMPUB,'R8',0,0,0,0,NDUM,NERR)
         CALL GETVAL('LAMBDAOB ',LMDOB,'R8',$MXPHASE+1,0,0,0,NDUM,NERR)
         CALL GETVAL('LAMBDAUB ',LMDUB,'R8',$MXPHASE+1,0,0,0,NDUM,NERR)
         CALL GETVAL('RHOOB ',RHOOB,'R8',0,0,0,0,NDUM,NERR)
         CALL GETVAL('RHOUB ',RHOUB,'R8',0,0,0,0,NDUM,NERR)
         CALL GETVAL('CVOB ',CVUB,'R8',0,0,0,0,NDUM,NERR)
         CALL GETVAL('CVUB ',CVUB,'R8',0,0,0,0,NDUM,NERR)
         CALL GETVAL('XRFOB ',XRFOB,'R8',0,0,0,0,NDUM,NERR)
         CALL GETVAL('XRFUB ',XRFUB,'R8',0,0,0,0,NDUM,NERR)
         CALL GETVAL('DEPTHTGRAD ',DPTHTGRD,'R8',0,0,0,0,NDUM,NERR)
         CALL GETVAL('DBDINFTY ',DBDINFTY,'R8',0,0,0,0,NDUM,NERR)
         IF(THSOLTHTA /= ONE) THEN
            IF(LEVELC) WRITE(NFOUT,'(/,A,/)') 
     &         'IN XISDAT: CHANGED THSOLTHTA TO 1.0 FOR HEATLOSS OPTION'
            THSOLTHTA=1.0D0
         ENDIF
         IF(.NOT.XTHSOLVE) THEN
            IF(LEVELC) WRITE(NFOUT,'(/,A,/)') 
     &         'ERROR IN XISDAT: XTHSOLVE NEEDED WITH XHEATLOSS OPTION'
            STOP 13
         ENDIF
      ENDIF

C--------set element index at which CO2 leak rate may be desired.
      ICO2 = 99999
      JCO2 = 99999
      KCO2 = 99999
      NCO2 = 99999
      IF(OUT_CO2LEAK) THEN
         CALL GETVAL('ICO2OUT ',ICO2,'I4',0,0,0,0,NDUM,NERR)
         CALL GETVAL('JCO2OUT ',JCO2,'I4',0,0,0,0,NDUM,NERR)
         CALL GETVAL('KCO2OUT ',KCO2,'I4',0,0,0,0,NDUM,NERR)
         CALL GETVAL('NCO2OUT ',NCO2,'I4',0,0,0,0,NDUM,NERR)
      ENDIF

C-------replace the default iteration limits and solution techniques
      MAXFLITS = 30
      CALL GETVAL('MAXFLITS ',MAXFLITS,'I4',0,0,0,0,NDUM1,NERR)

      PARTIALJAC =.TRUE.
      CALL GETVAL('PARTIALJAC ',PARTIALJAC,'L4',0,0,0,0,NDUM1,NERR)

      BORROW_K=.TRUE.
      CALL GETVAL('KVALFIND ',BORROW_K,'L4',0,0,0,0,NDUM1,NERR)

      TESTALL=.FALSE.
      CALL GETVAL('TESTALL ',TESTALL,'L4',0,0,0,0,NDUM1,NERR)

      NEG_FLASH=.TRUE.
      CALL GETVAL('NEGFLASH ',NEG_FLASH,'L4',0,0,0,0,NDUM1,NERR)

      IF(NEG_FLASH) BORROW_K=.TRUE.

      IF (LEVELC .AND. NHC > 0)  THEN
         WRITE (NFOUT,400) MAXFLITS 
  400    FORMAT(' MAXIMUM NUMBER OF FLASH ITERATIONS',T50,I11)
         IF(.NOT.PARTIALJAC) THEN
            WRITE (NFOUT,411)  
  411       FORMAT(' DO FULL JACOBIAN UPDATES FOR FLASH')
         ELSE
            WRITE (NFOUT,412)  
  412       FORMAT(' DO PARTIAL JACOBIAN UPDATES FOR FLASH')
         ENDIF
         IF(.NOT.BORROW_K) THEN
            WRITE (NFOUT,410)  
  410       FORMAT(' DO NOT BORROW K-VALUES FROM NEIGHBORING CELLS')
         ELSE
            WRITE (NFOUT,415)  
  415       FORMAT(' BORROW K-VALUES FROM NEIGHBORING CELLS')
         ENDIF
         IF(TESTALL) THEN
            WRITE (NFOUT,430)  
  430       FORMAT(' TEST ALL SINGLE PHASE CELLS FOR STABILITY')
         ELSE
            WRITE (NFOUT,435)  
  435       FORMAT(' TEST SELECTED SINGLE PHASE CELLS FOR STABILITY')
         ENDIF
         IF(.NOT.NEG_FLASH) THEN
            WRITE (NFOUT,440)  
  440       FORMAT(' USE STABILITY TEST FOR PHASE SPLIT')
         ELSE
            WRITE (NFOUT,445)  
  445       FORMAT(' USE NEGATIVE FLASH FOR PHASE SPLIT')
         ENDIF
         IF(MDENH >= ZERO) THEN
            WRITE (NFOUT,450) MDENH*CVMCONC,EXTCONC 
  450       FORMAT(' MASS DENSITY FOR 1-PH IDENTIFICATION',T50,F10.2,
     &             1X,A20)
         ENDIF
      ENDIF

      LRESTART=.FALSE.
      CALL GETVAL('LONGREST ',LRESTART,'L4',0,0,0,0,NDUM1,NERR)
      IF(.NOT.PARTIALJAC) LRESTART=.FALSE.

C-------read phase number for reference pressure
      IREFPRES = 2
      IF(NPH == 1) IREFPRES = 1
      CALL GETVAL('REFPRES ',IREFPRES,'I4',0,0,0,0,NDUM,NERR)

      IF (LEVELC)  THEN
         WRITE (NFOUT,500) TSURF*CVMTEMP+CVATEMP,EXTTEMP,
     &                   PSURF*CVMPRES,EXTPRES
  500    FORMAT(' SURFACE TEMPERATURE (TSURF)',T50,F10.2,1X,A20,/,
     &          ' SURFACE PRESSURE (PSURF)',T50,F10.2,1X,A20)
      ENDIF

C-------set stopping time in XSTEP1 for interactive debugging
      STOPTIME = TEN_P10
      CALL GETVAL('STOPTIME ',STOPTIME,'R8',0,0,0,0,NDUM1,NERR)

C-------set print time for dumping data
      DUMPTIME1 = ZERO
      CALL GETVAL('DUMPSTART ',DUMPTIME1,'R8',0,0,0,0,NDUM1,NERR)

C-------set print time to end dumping data
      DUMPTIME2 = TEN_P10
      CALL GETVAL('DUMPEND ',DUMPTIME2,'R8',0,0,0,0,NDUM1,NERR)

C-------set cell for printing in flash
      IDUMP = 0
      CALL GETVAL('DUMPCELL ',IDUMP,'I4',0,0,0,0,NDUM1,NERR)

C-------set number of material balance components
      NCPRT = 5
      CALL GETVAL('NCPRT ',NCPRT,'I4',0,0,0,0,NDUM1,NERR)
      NCPRT = MIN(NC,NCPRT)

C-------set component in phase indicator
      DO I=1,NC
         ICINPH(I,1)=0
         DO J=2,NPH
            ICINPH(I,J)=1
         END DO
      END DO
      ICINPH(1,1)=1
      DO J=2,NPH
         ICINPH(1,J)=0
      END DO
      DO J = 1,NPH
         IFIP(J) = ZERO
      END DO

C-------alter component assignment for phases
      CALL GETVAL('ICINPH ',ICINPH,'I4',-($MXCOMP+1),$MXPHASE,0,0,
     &            NDUM,NERR)
   
C-------number component positions in phases
      NCINPH=0
      DO I=1,NPH
         DO J=1,NC
            IF(ICINPH(J,I) > 0) THEN
               NCINPH=NCINPH+1
               ICINPH(J,I)=NCINPH
            ENDIF
         END DO
      END DO
      
C-------set up pointer to lightest component
      DUM = TEN_P15
      DO IC = 1,NHC
         IF(WMOL(IC) < DUM) THEN
            LTCOMP = IC
            DUM = WMOL(IC)
         ENDIF
      END DO
  
C-------read-in pointer to lightest component
      CALL GETVAL('LTCOMP ',LTCOMP,'I4',0,0,0,0,NDUM,NERR)
 
C-------set up storage for work vector in flash routines
      IF(NPH == 1) THEN
         DO I=1,NWRK
            IWRK(I) = 0
         END DO
      ELSEIF(NPH == 2) THEN
         DO I=1,NWRK
            IWRK(I) = 0
         END DO
         IWRK(3) = NHC
         IWRK(4) = 1
         IWRK(5) = 1
         IWRK(6) = 1
      ELSE
         DO I=1,NWRK
            IWRK(I) = 1
         END DO
         IWRK(2) = NHC + 1
         IWRK(3) = NHC
         IWRK(8) = NHC
      ENDIF

      K= IWRK(1)
      IWRK(1) = 1
      DO I=2,NWRK
         L = IWRK(I)
         IWRK(I) = IWRK(I-1) + K
         K = L
      END DO
      NWRKSZE = MAX(1,IWRK(NWRK) + K - 1)
   
C-------set up conversion factors for fluid phases in place
      EXTPLL=' '
      EXTPLG=' '
      K1 = 0
      MERR = 0
      DO I=1,20
         IF(EXTWELL(I:I) == '[') THEN
            K1 = I
            EXIT
         ENDIF
      END DO
      IF(K1 == 0) MERR = 1
      L = 0
      DO I=K1+1,20
         IF(EXTWELL(I:I) /= ' ') THEN
            L = I
            EXIT
         ENDIF
      END DO
      IF(L == 0) MERR = 1
      K1 = L
      L = 0
      DO I=K1+1,20
         IF(EXTWELL(I:I) == ' ' .OR. EXTWELL(I:I) == '/') THEN
            L = I
            EXIT
         ENDIF
      END DO
      K2 = L-1
      IF(L == 0) MERR = 1
      IF(MERR == 1) THEN
         NERR=NERR+1
         IF(LEVELC) THEN
            WRITE(NFOUT,'(/,2A)') 'ERROR 3004; ',
     &                     'BAD CONVERSION FOR EXTWELL IN XISDAT'
         ENDIF
      ELSE
         L = 1
         EXTPLL(1:1)='['
         DO I=K1,K2
            L=L+1
            EXTPLL(L:L)=EXTWELL(I:I)
         END DO
         L=L+1
         EXTPLL(L:L)=']'
      ENDIF
      K1 = 0
      DO I=1,20
         IF(EXTWELG(I:I) == '[') THEN
            K1 = I
            EXIT
         ENDIF
      END DO
      IF(K1 == 0) MERR = 1
      L = 0
      DO I=K1+1,20
         IF(EXTWELG(I:I) /= ' ') THEN
            L = I
            EXIT
         ENDIF
      END DO
      IF(L == 0) MERR = 1
      K1 = L
      L = 0
      DO I=K1+1,20
         IF(EXTWELG(I:I) == ' ' .OR. EXTWELG(I:I) == '/') THEN
            L = I
            EXIT
         ENDIF
      END DO
      K2 = L-1
      IF(L == 0) MERR = 1
      IF(MERR == 1) THEN
         NERR=NERR+1
         IF(LEVELC) THEN
            WRITE(NFOUT,'(/,2A)') 'ERROR 3004; ',
     &                     'BAD CONVERSION FOR EXTWELL IN XISDAT'
         ENDIF
      ELSE
         L = 1
         EXTPLG(1:1)='['
         DO I=K1,K2
            L=L+1
            EXTPLG(L:L)=EXTWELG(I:I)
         END DO
         L=L+1
         EXTPLG(L:L)=']'
      ENDIF
      IF(MYPRC == 0) THEN
         WRITE (NFOUT,*)
         WRITE (NFOUT,*) 'EXTERNAL UNITS:'
      ENDIF
      IF(EXTPLL(1:4) == '[stb') THEN
         CVMPLL = ONE
      ELSE
         XUNITS='[bbl]'
         CALL EXTUIN('EXTPLCL ',EXTPLL,XUNITS,CVMPLL,DUM,NERR,
     &               'LIQUID IN PLACE     ')
      ENDIF
      XUNITS='[mscf]'
      CALL EXTUIN('EXTPLCG ',EXTPLG,XUNITS,CVMPLG,DUM,NERR,
     &            'VAPOR IN PLACE      ')

      END

C*********************************************************************
      SUBROUTINE WRITE_2DR8(VAR,N1,N2,NFOUT,JFMT,IORDER)
C*********************************************************************
      IMPLICIT NONE
      INTEGER N1,N2,NFOUT,JFMT,IORDER
      REAL*8 VAR(N1,N2)
C-------local variables
      INTEGER I,J
C
C        PRINTS TWO-DIMENSIONAL REAL*8 ARRAY
C        JFMT = NUMBER OF DECIMAL  POINTS
C        IORDER  = 0, IF NDIM1 PRINTED DOWN PAGE
C                  1, IF NDIM1 PRINTED ACROSS PAGE
C
      IF(JFMT == 0) THEN
         IF(IORDER == 0) THEN
            DO I = 1,N1
               WRITE(NFOUT,'(5X,10F7.0)') (VAR(I,J),J=1,N2)
            END DO
         ELSE
            DO J = 1,N2
               WRITE(NFOUT,'(5X,10F7.0)') (VAR(I,J),I=1,N1)
            END DO
         ENDIF
      ELSEIF(JFMT == 1) THEN
         IF(IORDER == 0) THEN
            DO I = 1,N1
               WRITE(NFOUT,'(5X,10F7.1)') (VAR(I,J),J=1,N2)
            END DO
         ELSE
            DO J = 1,N2
               WRITE(NFOUT,'(5X,10F7.1)') (VAR(I,J),I=1,N1)
            END DO
         ENDIF
      ELSEIF(JFMT == 2) THEN
         IF(IORDER == 0) THEN
            DO I = 1,N1
               WRITE(NFOUT,'(5X,10F7.2)') (VAR(I,J),J=1,N2)
            END DO
         ELSE
            DO J = 1,N2
               WRITE(NFOUT,'(5X,10F7.2)') (VAR(I,J),I=1,N1)
            END DO
         ENDIF
      ELSEIF(JFMT == 3) THEN
         IF(IORDER == 0) THEN
            DO I = 1,N1
               WRITE(NFOUT,'(5X,10F7.3)') (VAR(I,J),J=1,N2)
            END DO
         ELSE
            DO J = 1,N2
               WRITE(NFOUT,'(5X,10F7.3)') (VAR(I,J),I=1,N1)
            END DO
         ENDIF
      ELSE
         IF(IORDER == 0) THEN
            DO I = 1,N1
               WRITE(NFOUT,'(5X,10F7.4)') (VAR(I,J),J=1,N2)
            END DO
         ELSE
            DO J = 1,N2
               WRITE(NFOUT,'(5X,10F7.4)') (VAR(I,J),I=1,N1)
            END DO
         ENDIF
      ENDIF
      RETURN
      END

C*********************************************************************
      SUBROUTINE SET_EOS_DEFAULT(NHC,NC,TCRIT,PCRIT,ZCRIT,ACENTF,WMOL,
     &                           VSHIFT,PCHOR,HCCP,HCCV,CMPNAM)
C*********************************************************************
C
C        SETS DEFAULT VALUES FOR COMPONENTS
C
C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
      INCLUDE 'xresprop.h'
      INTEGER  NHC, NC
      REAL*8 TCRIT(NHC), PCRIT(NHC), ZCRIT(NHC), PCHOR(NHC),
     &       ACENTF(NHC), VSHIFT(NHC), HCCP(NHC), HCCV(NHC), 
     &       WMOL(NHC)
      CHARACTER*$MXCNAM CMPNAM(NHC+1)
      INTEGER NDEF, I, IC, ISET, J, MATCH, IT
      PARAMETER (NDEF = 15)
      CHARACTER*8 CNAME1(NDEF), CNAME2(NDEF)
      INTEGER IMAP(NHC)
      REAL*8 DFT(NDEF), DFP(NDEF), DFZ(NDEF), DFA(NDEF),
     &       DFM(NDEF), DFVSHFT(NDEF), DPCHOR(NDEF), 
     &       DFHCCP(NDEF)
      DATA CNAME1/
     &'METHANE ','ETHANE  ','PROPANE ','I-BUTANE','BUTANE  ','I-PENTAN',
     &'PENTANE ','HEXANE  ','HEPTANE ','OCTANE  ','NONANE  ','DECANE  ',
     &'NITROGEN','CO2     ','H2S     ' /
      DATA CNAME2/
     &'C1      ','C2      ','C3      ','IC4     ','C4      ','IC5     ',
     &'C5      ','C6      ','C7      ','C8      ','C9      ','C10     ',
     &'N2      ','CO2     ','H2S     ' /
      DATA DFT /  
     &  343.04D0, 549.76D0, 665.68D0, 734.65D0, 765.32D0, 828.77D0,  
     &  845.37D0, 913.37D0, 972.47D0, 1023.9D0, 1070.4D0, 1111.8D0,  
     &  227.27D0, 547.57D0, 672.37D0 /
      DATA DFP /  
     &   667.8D0,  707.8D0,  616.3D0,  529.1D0,  550.7D0,  490.4D0,  
     &   488.6D0,  436.9D0,  396.8D0,  360.6D0,  332.0D0,  304.0D0,  
     &   493.0D0, 1070.6D0, 1306.0D0 /
      DATA DFZ /  
     &   .2884D0,  .2843D0,  .2804D0,  .2824D0,  .2736D0,  .2701D0,  
     &   .2623D0,  .2643D0,  .2633D0,  .2587D0,  .2536D0,  .2462D0,  
     &   .2916D0,  .2742D0,  .2831D0 /
      DATA DFA /  
     &   .0115D0,  .0908D0,  .1454D0,  .1756D0,  .1928D0,  .2273D0,  
     &   .2510D0,  .2957D0,  .3506D0,  .3978D0,  .4437D0,  .4902D0,  
     &   .0450D0,  .2310D0,  .1000D0 /
      DATA DFM /  
     &  16.043D0, 30.070D0, 44.097D0, 58.124D0, 58.124D0, 72.151D0,  
     &  72.151D0, 86.178D0,100.205D0,114.232D0,128.259D0,142.286D0,  
     &  28.013D0, 44.010D0, 34.076D0 /
      DATA DFVSHFT /  
     &  -.1595D0, -.1134D0, -.0863D0, -.0844D0, -.0675D0, -.0608D0,  
     &  -.0390D0, -.0080D0,  .0033D0,  .0314D0,  .0408D0,  .0655D0,  
     &  -.1927D0, -.0817D0, -.1288D0 /
      DATA DPCHOR /  
     &    71.0D0,  111.0D0,  151.0D0,  191.0D0,  191.0D0,  231.0D0,  
     &   231.0D0,  271.0D0,  311.0D0,  351.0D0,  391.0D0,  431.0D0,  
     &    35.0D0,   49.0D0,   80.0D0 /
      DATA DFHCCP /  
     & 8.4689D0, 12.3638D0, 17.1382D0, 22.4762D0, 22.9624D0, 27.6290D0, 
     & 27.9856D0, 33.2385D0, 38.5946D0, 43.7565D0, 49.0247D0, 54.3034D0,
     & 6.8843D0, 8.7646D0, 8.1463D0 /

C-------create a map of names
      ISET=NC-NHC
      DO IC=1,NHC
         IMAP(IC)=0
         DO I=1,NDEF
            MATCH=1
            DO J=1,8
               IF(CMPNAM(IC+ISET)(J:J) /= CNAME1(I)(J:J)) THEN
                  MATCH=0
                  EXIT
               ENDIF
            END DO
            IF(MATCH == 0) THEN
               MATCH=1
               DO J=1,8
                  IF(CMPNAM(IC+ISET)(J:J) /= CNAME2(I)(J:J)) THEN
                     MATCH=0
                     EXIT
                  ENDIF
               END DO
            ENDIF
            IF(MATCH == 1) THEN
               IMAP(IC)=I
               EXIT
            ENDIF
         END DO
      END DO

C-------set tcrit
      DO IC=1,NHC
         IF(TCRIT(IC) == TEN_P10 .AND. IMAP(IC) > 0) THEN
            TCRIT(IC)=DFT(IMAP(IC))
         ENDIF
      END DO
 
C-------set pcrit
      DO IC=1,NHC
         IF(PCRIT(IC) == TEN_P10 .AND. IMAP(IC) > 0) THEN
            PCRIT(IC)=DFP(IMAP(IC))
         ENDIF
      END DO

C-------set zcrit
      DO IC=1,NHC
         IF(ZCRIT(IC) == TEN_P10 .AND. IMAP(IC) > 0) THEN
            ZCRIT(IC)=DFZ(IMAP(IC))
         ENDIF
      END DO
 
C-------set acentf
      DO IC=1,NHC
         IF(ACENTF(IC) == TEN_P10 .AND. IMAP(IC) > 0) THEN
            ACENTF(IC)=DFA(IMAP(IC))
         ENDIF
      END DO
 
C-------set wmol
         DO IC=1,NHC
            IF(WMOL(IC) == TEN_P10 .AND. IMAP(IC) > 0) THEN
               WMOL(IC)=DFM(IMAP(IC))
            ENDIF
         END DO 
 
C-------set vshift
      DO IC=1,NHC
         IF(VSHIFT(IC) == TEN_P10) THEN 
            IF(IMAP(IC) > 0) THEN 
               VSHIFT(IC)=DFVSHFT(IMAP(IC))
            ELSE
               VSHIFT(IC)=ZERO
            ENDIF
         ENDIF
      END DO  
 
C-------set parachor
      DO IC=1,NHC
         IF(PCHOR(IC) == TEN_P10) THEN 
            IF(IMAP(IC) > 0) THEN 
               PCHOR(IC)=DPCHOR(IMAP(IC))
            ELSE
               PCHOR(IC)=ZERO
            ENDIF
         ENDIF
      END DO  
      
C-------set hccp
      DO IC=1,NHC
         IF(HCCP(IC) == ZERO .AND. IMAP(IC) > 0) THEN
            HCCP(IC)=DFHCCP(IMAP(IC))
            HCCV(IC)=HCCP(IC)-RCPCV
         ENDIF
      END DO
 
      END

C*********************************************************************
      SUBROUTINE SET_EOS_PARM(ITAB,TEMP,NFOUT,LEVELC,NERR,DEL_TEMP)
C*********************************************************************
C
C        SETS UP EOS PARAMATERS FOR A PARTICULAR TEMPERATURE
C        CREATES NEW TABLE IF NECESSARY  AND ASSIGNS TABLE NUMBER TO ITAB
C        INPUT: TEMP, NFOUT, LEVELC, DEL_TEMP
C        IPUT/OUTPUT: NERR
C        OUTPUT: ITAB
C
C*********************************************************************
      USE xgendat
      IMPLICIT NONE
      INCLUDE 'xmodel.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xthermal.h'
      INTEGER ITAB, NFOUT, NERR
      LOGICAL LEVELC
      REAL*8 TEMP, DEL_TEMP

      INTEGER  IC, I, JC, K
      REAL*8  TR, XM, X
      REAL*8  MW, TC, PC, AC
      INTEGER IONCE
      SAVE IONCE
      DATA IONCE/0/

C-------see if temperature already exists
      DO I=1,NTEMP
         IF( ABS(TEMP-TABTEMP(I)) <= DEL_TEMP) THEN
            ITAB = I
            RETURN
         ENDIF
      END DO
      
      IF(NTEMP == $MXTEMP) THEN
         NERR=NERR+1
         IF(LEVELC) THEN
            WRITE(NFOUT,'(/,2A,I5)') 'ERROR 3004; ',
     &                  'TOO MANY TEMPERATURES FOR PVT TABLES '
         ENDIF
         RETURN
      ENDIF

      NTEMP=NTEMP+1
      ITAB = NTEMP
      TABTEMP(NTEMP)=TEMP
 
      IF(IONCE == 0) THEN
         DO IC = 1,NHC 
C-------------critical volume. Used for viscosity.
            EOS_V(IC) = GASCON*ZCRIT(IC)*TCRIT(IC)/PCRIT(IC)
C-------------sqrt(molecular weight) Used for viscosity.
            EOS_SQRTMW(IC) = SQRT(WMOL(IC))
         END DO
         IONCE = 1
      ENDIF

      DO IC = 1,NHC 
         TC=TCRIT(IC)
         PC=PCRIT(IC)
         AC=ACENTF(IC)
         TR=(TEMP+TRF)/TC
      
C----------m parameter in EOS
         IF(AC <= .49D0)THEN
            XM = .37464D0 + 1.54226D0*AC - .26992D0*AC**2 
         ELSE
            XM = .379642D0 + 1.48503D0*AC - .164423D0*AC**2 
     &         + .016666D0*AC**3
         ENDIF
      
C----------A/p parameter in EOS where A is dimensionless
         EOS_AP(IC,ITAB) = PRA * (ONE + XM*(ONE-SQRT(TR)) )**2 
     &                  / (PC*TR**2)
      
C----------B/p parameter in EOS where B is dimensionless
         EOS_BP(IC,ITAB) = PRB / (TR*PC)
      
C----------C/p parameter in EOS where C is dimensionless
         EOS_CP(IC,ITAB)=EOS_BP(IC,ITAB)*VSHIFT(IC)
      
C----------use Wilson equation to guess K-values
C          k-value = guessk / p
C        GUESSK(IC,ITAB)=PC * EXP(5.373D0*(ONE+AC)*(ONE-ONE/TR))
         GUESSK(IC,ITAB)=PC * EXP(5.4D0*(ONE-ONE/TR))

C----------low pressure pure component viscosity from Stiele and Thodos
C          Modification to 1.778 coefficient for continuity at Tr=1.5
C          Includes extra square root of molecular weight 
         IF (TR <= THREEHALF) THEN
            X = 3.4D-4 * TR**.94D0
         ELSE
            X = 1.776D-4 * (4.58D0*TR - 1.67D0)**(FIVE/EIGHT)
         ENDIF
CGUS Lotfollahi suggested change: WMOL(IC) ----> EOS_SQRTMW(IC) below
         EOS_VISC(IC,ITAB) = X * WMOL(IC) * PC**TWOTHIRD
     &                     / (5.44D0*TC**SIXTH)
      END DO
       
c-------modify interaction coefficients 
      K=0
      DO JC = 1,NHC
         DO IC = 1,NHC
            K=K+1
            EOS_BIN(K,ITAB)=TWO * (ONE-BINACT(K)) 
     &                     * SQRT(EOS_AP(IC,ITAB)*EOS_AP(JC,ITAB))
         END DO
      END DO

      END 

C*********************************************************************
      SUBROUTINE DUMP_A(HEADER)
C*********************************************************************
      USE scrat1mod

      INCLUDE 'control.h'
!      INCLUDE 'scrat1.h'
      CHARACTER*50 HEADER
      IF(LEVELC) THEN
         WRITE(NFOUT,*)
         CALL PRTTIT(HEADER)
         J=0
         DO I=1,LAST
            NEND=MIN(100,LAST-J)
            WRITE(NFOUT,'(I5,2x,100A1)') I,(A(J+L),L=1,NEND)
            IF(J+NEND == LAST) EXIT
            J=J+100
         END DO
      ENDIF
      END

C*********************************************************************
      INTEGER FUNCTION TEMPR_SELECT(T)
C*********************************************************************
C
C        SELECTS RESERVOIR COMPOSITIONAL TABLE NEAREST TO T. 
C
C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
      INCLUDE 'xthermal.h'
      INCLUDE 'xmodel.h'
      REAL*8 T

      INTEGER K,I
      REAL*8 DIFF,U

      DIFF = ABS(T-TABTEMP(1))
      K = 1
      DO I = 2,NRESVTEMP
         U = ABS(T-TABTEMP(I))
         IF(U <= DIFF) THEN
            K = I
            DIFF = U
         ENDIF
      END DO
      TEMPR_SELECT = K
      END

C*********************************************************************
      SUBROUTINE BIN_CHECK(BINACT,NHC,NERR,NFOUT,LEVELC)
C*********************************************************************
C
C        CHECK SYMMETRY IN BINARY INTERACTION TABLE
C
C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
      INTEGER NHC, NFOUT, NERR
      LOGICAL LEVELC
      REAL*8 BINACT(NHC,NHC)

      INTEGER  IC, JC
      
      DO JC = 1,NHC
         IF(BINACT(JC,JC) /= ZERO) THEN
            NERR = NERR + 1
            IF(LEVELC) THEN
               WRITE(NFOUT,'(2A,I5)') 
     &                     'DIAGONAL SHOULD BE ZERO FOR BINARY ',
     &                     'INTERACTION COEFFICIENT ',JC
            ENDIF
         ENDIF
         DO IC = JC+1,NHC
            IF(BINACT(IC,JC) /= BINACT(JC,IC)) THEN
               NERR = NERR + 1
               IF(LEVELC) THEN
                  WRITE(NFOUT,'(2A)') 
     &                        'BINARY INTERACTION COEFFICIENTS MUST ',
     &                        'BE SYMMETRIC '
                  WRITE(NFOUT,'(A,2I5,F15.7)') '    IC,JC,VALUE ',
     &                                        IC,JC,BINACT(IC,JC)
                  WRITE(NFOUT,'(A,2I5,F15.7)') '    IC,JC,VALUE ',
     &                                        JC,IC,BINACT(JC,IC)
               ENDIF
            ENDIF
         END DO
      END DO
      END
      
C*********************************************************************
      SUBROUTINE XIROCKDAT (NERR)
C*********************************************************************

C  Inputs initial ROCK data for the compositional model.  Grid-element
C  arrays CAN NOT be referenced in this routine.

C=====IPARS framework include files
      INCLUDE 'control.h'
      INCLUDE 'unitsex.h'
      INCLUDE 'xcompwel.h'
      INCLUDE 'blkary.h'
C=====IFT HYST model include files
      INCLUDE 'rock.h'
      INCLUDE 'xmodel.h'

      WRITE(61,*) 'XIROCKDAT: '

C     READ IFT TRAPPING NUMBER RELATIVE PERMEABILITY INPUT
      SGLOW = .225
      SGHIGH = 0.1
      SWLOW=.379
      SWHIGH=0.15
      KGLOW=.298
      KGHIGH = 0.6
      KWLOW=0.405
      KWHIGH=1.0
      EGLOW = 1.9
      EGHIGH =1.0
      EWLOW = 3.8
      EWHIGH =1.5
      EPC = 2.2
      PCLOW = 1.0
      TGL=97000000
      TWL=4400000
      TAUG=1.05
      TAUW=1.05
      SALIN= 0.0
      IFTTHETA = 0.0

Cxianhui
      CALL GETVAL('SGLOW ',SGLOW,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('SGHIGH ',SGHIGH,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('KGLOW ',KGLOW,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('KGHIGH ',KGHIGH,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('EGLOW ',EGLOW,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('EGHIGH ',EGHIGH,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('TGL ',TGL,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('SWLOW ',SWLOW,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('SWHIGH ',SWHIGH,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('KWLOW ',KWLOW,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('KWHIGH ',KWHIGH,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('EWLOW ',EWLOW,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('EWHIGH ',EWHIGH,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('TWL ',TWL,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('TAUG ',TAUG,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('TAUW ',TAUW,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('SALIN ',SALIN,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('EPC ',EPC,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('PCLOW ',PCLOW,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('IFTTHETA ',IFTTHETA,'R8',0,0,0,0,NDUM,NERR)
C     CONVERT DEGREE ANGLE TO PI() 
      IFTTHETA = MAX(0.0,MIN(IFTTHETA,180.0))
      IFTTHETA = IFTTHETA / 180.0 * 3.1415926

      WRITE(61,*) '========= TRAPPING NUMBER IFTRLPRM = ',IFTRLPRM
      IF(IFTRLPRM .OR.1)THEN
      WRITE(61,*) ' SGLOW =   ',SGLOW
      WRITE(61,*) ' SGHIGH =  ',SGHIGH
      WRITE(61,*) ' KGLOW =   ',KGLOW
      WRITE(61,*) ' KGHIGH =  ',KGHIGH
      WRITE(61,*) ' EGLOW =   ',EGLOW
      WRITE(61,*) ' EGHIGH =  ',EGHIGH
      WRITE(61,*) ' SWLOW =   ',SWLOW
      WRITE(61,*) ' SWHIGH =  ',SWHIGH
      WRITE(61,*) ' KWLOW =   ',KWLOW
      WRITE(61,*) ' KWHIGH =  ',KWHIGH
      WRITE(61,*) ' EWLOW =   ',EWLOW
      WRITE(61,*) ' EWHIGH =  ',EWHIGH
      WRITE(61,*) ' TGL =     ',TGL
      WRITE(61,*) ' TWL =     ',TWL
      WRITE(61,*) ' TAUG =    ',TAUG
      WRITE(61,*) ' TAUW =    ',TAUW
      WRITE(61,*) ' EPC =     ',EPC
      WRITE(61,*) ' PCLOW =   ',PCLOW
      WRITE(61,*) ' SALIN =   ',SALIN
      WRITE(61,*) ' IFTTHETA = ',IFTTHETA 
      IF(NDUM.GT.0.AND.NERR.GT.0) THEN
         IF(LEVELC) WRITE(61,*) ' ERROR READING XIROCK! '
      ENDIF
      WRITE(61,*)'======= END OF TRAPPPING number model input === '
      ENDIF
CKong

CXianhui
C==========INPUT HYST INFOR Krw=KRW0*(SWNORM)^LAMBDAW
      WRITE(61,*)"==== HYSTERESIS ROCK KrPc # ", HYSTERESIS, NXROCKS
      CALL GETVAL('SWRES ',SWRES,'R8',NXROCKS,0,0,0,NDUM,NERR)
      IF(NDUM.GT.0.AND.NERR.GT.0) THEN
         IF(LEVELC) WRITE(61,*) ' READING SWRES! ',SWRES
      ENDIF
      CALL GETVAL('SORES ',SORES,'R8',NXROCKS,0,0,0,NDUM,NERR)
      IF(NDUM.GT.0.AND.NERR.GT.0) THEN
         IF(LEVELC) WRITE(61,*) ' READING SORES! ',SORES
      ENDIF
      CALL GETVAL('SGRES ',SGRES,'R8',NXROCKS,0,0,0,NDUM,NERR)
      IF(NDUM.GT.0.AND.NERR.GT.0) THEN
         IF(LEVELC) WRITE(61,*) ' READING SGRES! ',SGRES
      ENDIF
      CALL GETVAL('KRNW0 ',KRNW0,'R8',NXROCKS,0,0,0,NDUM,NERR)
      CALL GETVAL('KRW0 ',KRW0,'R8',NXROCKS,0,0,0,NDUM,NERR)
      IF(NDUM.GT.0.AND.NERR.GT.0) THEN
         IF(LEVELC) WRITE(61,*) ' READING KRNW0! ',KRNW0
      ENDIF
      CALL GETVAL('LAMBDA ',RPLMDA,'R8',NXROCKS,0,0,0,NDUM,NERR)
      CALL GETVAL('LAMBDAW ',RPLMDAW,'R8',NXROCKS,0,0,0,NDUM,NERR)
      CALL GETVAL('LAMBDANW ',RPLMDANW,'R8',NXROCKS,0,0,0,NDUM,NERR)
      CALL GETVAL('LAMBDAIM ',RPLMDAIM,'R8',NXROCKS,0,0,0,NDUM,NERR)
      IF(NDUM.GT.0.AND.NERR.GT.0) THEN
         IF(LEVELC) WRITE(61,*) ' READING LAMBDA! ',RPLMDA
      ENDIF
      CALL GETVAL('ENTRYPRES ',ENTRYP,'R8',NXROCKS,0,0,0,NDUM,NERR)
      CALL GETVAL('REFPERM ',REFPERM,'R8',NXROCKS,0,0,0,NDUM,NERR)
      CALL GETVAL('REFPORO ',REFPORO,'R8',NXROCKS,0,0,0,NDUM,NERR)
      IF(NDUM.GT.0.AND.NERR.GT.0) THEN
         IF(LEVELC) WRITE(61,*) ' READING ENTRYPRES! ',ENTRYP
         IF(LEVELC) WRITE(61,*) ' READING REFPERM! ',REFPERM
         IF(LEVELC) WRITE(61,*) ' READING REFPoro! ',REFPORO
      ENDIF

      IF((0.EQ.REFPERM(1).OR.REFPORO(1).EQ.0).AND.LJFUNPC)THEN
       WRITE(*,*)'WARNING REF K phi Zero',REFPERM(1),REFPORO(1),SGRES(1)
      ENDIF
      IF(NXROCKS.GE.ONE.AND.HYSTERESIS.OR.1)THEN
         WRITE(61,*) ' SWRES=    ',SWRES(1:NXROCKS)
         WRITE(61,*) ' SORES=    ',SORES(1:NXROCKS)
         WRITE(61,*) ' SGRES=    ',SGRES(1:NXROCKS)
         WRITE(61,*) ' KRW0=     ',KRW0(1:NXROCKS)
         WRITE(61,*) ' KRNW0=    ',KRNW0(1:NXROCKS)
         WRITE(61,*) ' LAMBDA=   ',RPLMDA(1:NXROCKS)
         WRITE(61,*) ' LAMBDAW=  ',RPLMDAW(1:NXROCKS)
         WRITE(61,*) ' LAMBDANW= ',RPLMDANW(1:NXROCKS)
         WRITE(61,*) ' LAMBDAIM= ',RPLMDAIM(1:NXROCKS)
         WRITE(61,*) ' ENTRYP=   ',ENTRYP(1:NXROCKS)
         WRITE(61,*) ' REFPERM=  ',REFPERM(1:NXROCKS)
         WRITE(61,*) ' REFPoro=  ',REFPORO(1:NXROCKS)
         WRITE(61,*)"==== END OF HYSTERESIS ROCK KrPc ========"
      ENDIF
CKong

CXianhui
C     COMPOSITIONAL FOAM INPUT
      OUT_TRACER=.FALSE.
      FOAMMOD =.FALSE.
CXIN-----------------START--------------------------
      FOAMTYPE = ONE
      CALL GETVAL('FOAMTYPE ',FOAMTYPE,'I4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('VELREF ',VELREF,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('EPSILON ',EPSILON,'R8',0,0,0,0,NDUM,NERR)
      XOILDEN=3.467D0
      CALL GETVAL('XOILDEN[lbM/cu-ft] ',XOILDEN,'R8',0,0,0,0,NDUM,NERR)
CXIN------------------END----------------------------
      CALL GETVAL('OUT_TRACER ',OUT_TRACER,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('FOAMMOD ',FOAMMOD,'L4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('CSTAR ',CSTAR,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('SWSTAR ',SWSTAR,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('SOSTAR ',SOSTAR,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('EPXLO ',EPXLO,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('RREF ',RREF,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('VELGR ',VELGR,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('SHRTN ',SHRTN,'R8',0,0,0,0,NDUM,NERR)
      IF (FOAMMOD.OR.1)THEN
        WRITE(61,*)'======= FOAMMOD input:  ',FOAMMOD
        WRITE(61,*)' FOAMMOD: ',FOAMMOD
        WRITE(61,*)' OUT_TRACER = ',OUT_TRACER
        WRITE(61,*)' CSTAR = ',CSTAR
        WRITE(61,*)' SWSTAR = ',SWSTAR
        WRITE(61,*)' SOSTAR = ',SOSTAR
        WRITE(61,*)' EPXLO = ',EPXLO 
        WRITE(61,*)' RREF = ',RREF
        WRITE(61,*)' VELGR = ',VELGR
        WRITE(61,*)' SHRTN = ',SHRTN
        WRITE(61,*)'======= END OF FOAMMOD input === '
      ENDIF

CKong

C========INPUT FRACT INFOR
CXianhui
      CALL GETVAL('FRACI0 ',FRACI0,'I4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('FRACI1 ',FRACI1,'I4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('FRACJ0 ',FRACJ0,'I4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('FRACJ1 ',FRACJ1,'I4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('FRACK0 ',FRACK0,'I4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('FRACK1 ',FRACK1,'I4',0,0,0,0,NDUM,NERR)
      CALL GETVAL('FRACPERM ',FRACPERM,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('FRACPORO ',FRACPORO,'R8',0,0,0,0,NDUM,NERR)
      CALL GETVAL('FRACP ',FRACP,'R8',0,0,0,0,NDUM,NERR)
Ckong
C      WRITE(*,*)'OUT XIROCKDAT: '

      END
