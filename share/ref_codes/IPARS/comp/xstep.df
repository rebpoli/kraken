C  XSTEP.F - MAKE ONE TIME STEP WITH THE COMPOSITIONAL MODEL
C  ROUTINES IN THIS MODULE:

C  SUBROUTINE XSTEP1   (NERR)
C  SUBROUTINE XSTEP2   (KONVG,NERR)
C  SUBROUTINE XSTEP3   (KONVG,NERR)

C  CODE HISTORY:

C  RICK DEAN        02/28/01    COPIED ISTEP FROM BLACKI AND MODIFIED
C  SUNIL G. THOMAS  08/22/07    ADD MODS TO OUTPUT WELL CUMULATIVE 
C                               QUANTITIES AND AUTOMATICALLY TURN OFF 
C                               WELLS BASED ON COMPONENT RATES
C  SUNIL G. THOMAS  09/01/07    THERMAL, DIFF-DISP AND CO2 APPS, MODS 
C                 - 09/09/09    FOR HYSTERESIS, HEATLOSS AND BUG-FIXES 
C                               FOR MULTIBLOCK (USING EV-MFEM)
C  XIANHUI KONG     06/11/14    PETROPHYSICAL MODELS FOR CO2 CCS, 
C                               HYSTERESIS,PC J-FUNCTION, WETTABILITY
C  GURPREET SINGH   09/15/2015  AQUEOUS COMPONENTS 
C*********************************************************************
      SUBROUTINE XSTEP1 (NERR)
C*********************************************************************

C  Compositional model executive routine to start a time step.
C  IMPEC technique
C  1.  Compute Jacobian and residual for Newtonian iteration.
C  2.  Start inter-block calculations.

C  NERR = ERROR KEY STEPPED BY ONE FOR EACH ERROR
C         (INPUT AND OUTPUT, INTEGER)

C  BUGKEY(6) - Max changes and scaling for iterations
C  BUGKEY(8) - Material balance errors
C  BUGKEY(9) - Well phase rates in XSTEP3
C  BUGKEY(10) - Residuals and mass and pressure change arrays
C  BUGKEY(11) - Saturation and concentration arrays
C  BUGKEY(13-15) - Information from well routines

C Following variables are used to eliminate redundant calls to subroutines
C
C NEWFLOW: (XSET_WPRES,CPYARYR8N,RELPERM,XPROP,UPDATE,WELVAL1)
C    Set to TRUE if ONCEONLY = TRUE at start of XSTEP1
C    Set to TRUE if KCONVG_SAT = TRUE after checking saturation error
C    and checking saturation changes for timestep
C    Always reset to FALSE in XSTEP3

C NEWRESID: (XINPLACE,XTRAN,XWELLCALC,XWELFLOW,XCOND)
C    Set to TRUE if ONCEONLY = TRUE at start of XSTEP1
C    Set to FALSE if KCONVG_SAT = TRUE after checking saturation error
C    and checking saturation changes for timestep or if NEWT > MAXITS
C    Always reset to TRUE in XSTEP3

C NEWFLASH: (EOS_WORK)
C    In XIVDAT, set to TRUE if restart run and FALSE if initial run
C    In XSTEP3, set to TRUE if iterations continue or timestep cut, and 
C               set to FALSE if iterations converged or exceeded MAXITS    

C NEWPV: (XPORE)
C    Set to TRUE if ONCEONLY = TRUE at start of XSTEP1
C    Set to TRUE if timestep scaled after checking saturation error
C    and checking saturation changes for timestep
C    Set to FALSE if KCONVG_SAT = TRUE after checking saturation error
C    and checking saturation changes for timestep or if NEWT > MAXITS
C    Always set to FALSE in XSTEP3 unless restart step

C*********************************************************************
      USE xgendat
      IMPLICIT NONE
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'blkary.h'
      INCLUDE 'layout.h'
      INCLUDE 'wells.h'
      INCLUDE 'xarydat.h'
      INCLUDE 'xbaldat.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xiter.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xwells.h'

      INTEGER JPROP(4),JDISP(6),JDIFF(11),JTRAN(10),JWVAL1(4),JIWEL(13),
     &        JPOR(6),JPLACE1(9),JREL(7),JSERR(2),JWPRES(5),JWFLOW(3),
     &        JCOND(10),JPLACE2(3),JCOPY(4),JPCALC(3),JSCAL(5),JSATM(5),
     &        JFLD(3),JFLDR(3),JPAVG(3),JWSTART(2),JMFR(3),JPHDEN(3),
     &        JVEL(10),IHYST(9)
     &        ,JHYST(14),JSATR(12),JIREL(15),JFRAC(6)
     &        ,NARG(7),JEOSBIN(3),JIFT(7),JLJPC(7),JRLFM(7)
C$YGMRES     &         ,JTRANYV(11)
      SAVE JPROP,JDISP,JDIFF,JTRAN,JWVAL1,JIWEL,JPOR,JPLACE1,JPLACE2,
     &     JREL,JSERR,JWPRES,JWFLOW,JCOND,JCOPY,JPCALC,JSCAL,JSATM,JFLD,
     &     JFLDR,JPAVG,JWSTART,JMFR,JPHDEN,JVEL,IHYST
     &     ,JHYST,JSATR,JIREL
     &     ,JFRAC,NARG,JEOSBIN,JIFT,JLJPC,JRLFM
C$YGMRES     &         ,JTRANYV

C     NITER CONTROLS TIMESTEP SCALINGS
C     NWITER CONTROLS NUMBER OF CALLS TO WELL ITERATIONS
C     IWFLAG IS INDICATOR FOR ENCOUNTERING BHP LIMIT DURING ITERATION
      INTEGER NITER,NWITER,IWFLAG,I,IPH,IC,L,NERR
      PARAMETER(NITER = 4, NWITER = 2)
      LOGICAL ONCEONLY,ONEPRINT,TEMP_PARTIAL,KUP
      DATA ONCEONLY /.TRUE./, ONEPRINT/.TRUE./
      REAL*8 CHANGE_BHP,DUM,SCAL,SCALTIM,SCAL1,SCAL2,TEMP(2)
      CHARACTER*8 CNAME
CXIN----------START---------- add external subroutine XRELFOAM1
      EXTERNAL XPROP,XPORE,XINPLACE1,XRELPERM1,XHYSRLPRM1,XMFRAC_ALL,
     &         XPHMDENS,XGETDISP,XDIFFX,XDIFFY,XDIFFZ,XVELCOMP,XTRANX,
     &         XTRANY,XTRANZ,XSAT_ERROR,XSAT_SUMERR,XWELVAL1,XSET_WPRES,
     &         XWELFLOW,XINPLACE2,CPYARYR8N,CPYARYR8,XSCALE,XSAT_STEP,
     &         XWSTART,XSCALEK,CPYARYI4,XPAVG
     &         ,XHYSRLPRM3,XIFTSATRES,
     &         XIFTRLPRM,FRACROCK,TRANC1,TASSIGN,XCALCXTENS,XLJFUNPC,
     &         XRELFOAM,XRELFOAM1
CXIN-----------END--------------------------------------------------
C$YGMRES     &         ,XSPRB3X,XSPRB3Y,XSPRB3Z

C  DEFINE WORK ROUTINE ARGUMENTS 

      IF (LEVELE .AND. BUGKEY(1)) WRITE (NFBUG,*)'PROC',MYPRC,
     &    ' ENTERING SUBROUTINE XSTEP1, OLD TAG =',MSGTAG($XMODEL+1)
      IF (ONCEONLY) THEN
         ONCEONLY=.FALSE.
         NEWRESID = .TRUE.
         NEWFLOW = .TRUE.
         NEWPV = .TRUE.
         OVERSHT = BIG

         JPROP(1)=3
         JPROP(2)=N_MOB
         JPROP(3)=N_PMD
         JPROP(4)=N_MOBPROD

         JREL(1)=6
         JREL(2)=N_ROCK
         JREL(3)=N_MOB
         JREL(4)=N_SAT
         JREL(5)=N_PC
         JREL(6)=N_DPC
         JREL(7)=N_DMOB

         IHYST(1)=8
         IHYST(2)=N_ROCK
         IHYST(3)=N_SAT
         IHYST(4)=N_SWMIN
         IHYST(5)=N_SGT
         IHYST(6)=N_MOB
         IHYST(7)=N_DMOB
         IHYST(8)=N_PC
         IHYST(9)=N_DPC

         JPOR(1)=5
         JPOR(2)=N_POR
         JPOR(3)=N_PV
         JPOR(4)=N_PRES
         JPOR(5)=N_CR
         JPOR(6)=N_REFPRES

         JPCALC(1)=2
         JPCALC(2)=N_PRES
         JPCALC(3)=N_PC

         JPLACE1(1)=7
         JPLACE1(2)=N_CONC
         JPLACE1(3)=N_PV
         JPLACE1(4)=N_CONCN
         JPLACE1(5)=N_PVN
         JPLACE1(6)=N_RESID
         JPLACE1(7)=N_CR
         JPLACE1(8)=N_DFLOW

         JSATM(1) = 4
         JSATM(2) = N_CONCN
         JSATM(3) = N_CONC
         JSATM(4) = N_DSTDN
         JSATM(5) = N_CFL

         JFLD(1) = 2
         JFLD(2) = N_FLDPNT
         JFLD(3) = N_FLDPNTN

         JFLDR(1) = 2
         JFLDR(2) = N_FLDPNTN
         JFLDR(3) = N_FLDPNT

         JPLACE2(1)=2
         JPLACE2(2)=N_CONC
         JPLACE2(3)=N_PV

         JMFR(1)=2
         JMFR(2)=N_PMD
         JMFR(3)=N_KSI

         JPHDEN(1)=2
         JPHDEN(2)=N_PMD
         JPHDEN(3)=N_PMDEN

         JVEL(1)=9
         JVEL(2)=N_TCOFX
         JVEL(3)=N_TCOFY
         JVEL(4)=N_TCOFZ
         JVEL(5)=N_DEPTH
         JVEL(6)=N_PRES
         JVEL(7)=N_PC
         JVEL(8)=N_MDENN
         JVEL(9)=N_MOB
         JVEL(10)=N_XVEL

         JDISP(1)=5
         JDISP(2)=N_PV
         JDISP(3)=N_ROCK
         JDISP(4)=N_SAT
         JDISP(5)=N_XVEL
         JDISP(6)=N_XDMAT

         JDIFF(1)=10
         JDIFF(3)=N_PV
         JDIFF(4)=N_CR
         JDIFF(5)=N_SAT
         JDIFF(6)=N_PMDEN
         JDIFF(7)=N_KSI 
         JDIFF(8)=N_XDMAT 
         JDIFF(9)=N_TFLOW
         JDIFF(10)=N_DFLOW 
         JDIFF(11)=N_RESID

         JTRAN(1)=9
         JTRAN(3)=N_DEPTH
         JTRAN(4)=N_PRES
         JTRAN(5)=N_MDENN
         JTRAN(6)=N_MOBPROD
         JTRAN(7)=N_TFLOW
         JTRAN(8)=N_DFLOW
         JTRAN(9)=N_RESID
         JTRAN(10)=N_PC

C$YGMRES         JTRANYV(1)=10
C$YGMRES         JTRANYV(3)=N_DEPTH
C$YGMRES         JTRANYV(4)=N_PRES
C$YGMRES         JTRANYV(5)=N_PC
C$YGMRES         JTRANYV(6)=N_MDENN
C$YGMRES         JTRANYV(7)=N_MOB
C$YGMRES         JTRANYV(8)=N_TFLOW
C$YGMRES         JTRANYV(9)=N_DFLOW
C$YGMRES         JTRANYV(10)=N_RESID
C$YGMRES         JTRANYV(11)=N_TLAMB

         JSERR(1)=1
         JSERR(2)=N_ERRSAT

         JWVAL1(1)=3
         JWVAL1(2)=N_TEMPR
         JWVAL1(3)=N_MOB
         JWVAL1(4)=N_PMD

         JWPRES(1)=4
         JWPRES(2)=N_PRES
         JWPRES(4)=N_DEPTH

         JWFLOW(1)=2
         JWFLOW(2)=N_DFLOW
         JWFLOW(3)=N_RESID

         JSCAL(1)=4
         JSCAL(4)=N_I4U
         JSCAL(5)=N_R8U

         JPAVG(1)=2
         JPAVG(2)=N_PRES
         JPAVG(3)=N_PV

         JWSTART(1)=1
         JWSTART(2)=N_PV

Cxianhui
         JIFT(1)=6
         JIFT(2)=N_PRES
         JIFT(3)=N_MDENN
         JIFT(4)=N_KSI
         JIFT(5)=N_TEMPR
         JIFT(6)=N_TENS
         JIFT(7)=N_XTENS

         JLJPC(1)=6
         JLJPC(2)=N_PC
         JLJPC(3)=N_DPC
         JLJPC(4)=N_PORO
         JLJPC(5)=N_YPERM
         JLJPC(6)=N_XTENS
         JLJPC(7)=N_ROCK

         JSATR(1)=11
         JSATR(2)=N_PRES
         JSATR(3)=N_DEPTH
         JSATR(4)=N_MDENN
         JSATR(5)=N_PC
         JSATR(6)=N_ROCK
         JSATR(7)=N_XPERM
         JSATR(8)=N_YPERM
         JSATR(9)=N_ZPERM
         JSATR(10)=N_SGR
         JSATR(11)=N_SWR
         JSATR(12)=N_XTENS

         JHYST(1)=13
         JHYST(2)=N_ROCK
         JHYST(3)=N_SAT
         JHYST(4)=N_SWMIN
         JHYST(5)=N_SGT
         JHYST(6)=N_MOB
         JHYST(7)=N_DMOB
         JHYST(8)=N_PC
         JHYST(9)=N_DPC
         JHYST(10)=N_YPERM
         JHYST(11)=N_PORO
         JHYST(12)=N_SGR
         JHYST(13)=N_SWR
         JHYST(14)=N_XVISC

         JIREL(1)=14
         JIREL(2)=N_PRES
         JIREL(3)=N_SAT
         JIREL(4)=N_ROCK
         JIREL(5)=N_YPERM
         JIREL(6)=N_PORO
         JIREL(7)=N_PC
         JIREL(8)=N_DPC
         JIREL(09)=N_MOB
         JIREL(10)=N_DMOB
         JIREL(11)=N_SGT
         JIREL(12)=N_SWMIN
         JIREL(13)=N_SGR
         JIREL(14)=N_SWR
         JIREL(15)=N_XTENS

         JRLFM(1)=6
         JRLFM(2)=N_ROCK
         JRLFM(3)=N_MOB
         JRLFM(4)=N_SAT
         JRLFM(5)=N_DMOB
CXIN---------------START-------------------------------
         JRLFM(6)=N_CONC
C         JRLFM(6)=N_TRACER
CXIN------------------END------------------------------
         JRLFM(7)=N_XVEL 
Ckong
      ENDIF

      NERRC=0

      IF((NHISUSE == 0).AND.(NSTEP < 1)) GO TO 9

C     SET TIM FOR STOPPING PROGRAM FOR INTERACTIVE DEBUGGING
      IF(TIM > STOPTIME .AND. NEWT == 1) THEN
         I = 0
      ENDIF
      IF(BUGKEY(6).AND.MYPRC.EQ.0) THEN
         WRITE(NFBUG,'(A,G15.6,A,I3)') ' TIME IN XSTEP1 = ',
     &                                   TIM,' NEWT =',NEWT
      ENDIF
C
C-------------------------------------------------------------------------
C  FLASH FLUIDS
C-------------------------------------------------------------------------
C
C  STORE MDEN VALUES IN TEMPORARY SPACE DELC
C  NOTE: DELC USED AS WORKSPACE IN PRINTOUT ROUTINES
C  UPDATE JACOBIANS FOR ALL CELLS IF RESTART WRITE SO RESTARTS WILL BE SAME
C  AS ORIGINAL RUNS
      IF (NEWFLASH) THEN
         KUP = .NOT.STEPCUT
         IF(TIM+DELTIM-ACTTIM(4) > -DTIMTOL .AND. .NOT.LRESTART) THEN
            PARTIALJAC = .FALSE.
         ENDIF
         CALL EOS_WORK(NCINPH,.FALSE.,NFBUG,NHC,NC,NPH,ICINPH,
     &                 N_TCOFX,N_TCOFY,N_TCOFZ,N_DELC,KUP,RESTART,
     &                 LRESTART,IFTCALC)
         IF(TIM+DELTIM-ACTTIM(4) > -DTIMTOL .AND. .NOT.LRESTART) THEN
            PARTIALJAC = .TRUE.
         ENDIF
         RESTART = .FALSE.
         IF (LEVELE .AND. BUGKEY(11) .AND.
     &       TIM >= DUMPTIME1 .AND. TIM <= DUMPTIME2) THEN
            DO IPH = 1,NPH
               CNAME=PHNAM(IPH)
               WRITE(TITU,'(3A)') 'SAT ',CNAME,' FOR FAULT BLOCK'
               CALL GEAOUT(N_SAT,IPH,1)
            END DO
         ENDIF
      ENDIF
C
C-------------------------------------------------------------------------
C  CHECK SATURATION ERROR AND WELL PRESSURE LIMITS
C-------------------------------------------------------------------------
C
      KCONVG_SAT = .FALSE.
      SCAL = ONE
      IF (NEWT /= 1) THEN

         CALL TIMON(6)
         SAT_ERRMAX = -ONE
         SAT_ERRAVG = -ONE
         IF(MAXERRSAT) THEN
            CALL CALLWORK(XSAT_ERROR,JSERR)
         ELSE
            CALL CALLWORK(XSAT_SUMERR,JSERR)
         ENDIF
         CALL TIMOFF(6)
$MANY         CALL TIMON(5)
$MANY         IF(MAXERRSAT) THEN
$MANY            CALL MAXIT(1,SAT_ERRMAX)
$MANY            CALL SPREAD8(1,SAT_ERRMAX)
$MANY         ELSE
$MANY            CALL SUMIT(1,SAT_ERRAVG)
$MANY            CALL SPREAD8(1,SAT_ERRAVG)
$MANY         ENDIF
$MANY         CALL TIMOFF(5)

         IF(.NOT.MAXERRSAT) SAT_ERRAVG = SAT_ERRAVG/NEMOD(MODACT)

         IF(ICFLCHK>0 .AND. ONLY_COMP .AND. NEWT <= NITER) THEN

            SCAL1 = ONE
            SCAL2 = ONE

            CALL TIMON(6)
            DSMAX = -ONE
            CALL CALLWORK(XSAT_STEP,JSATM)
            CALL TIMOFF(6)
$MANY            CALL TIMON(5)
$MANY            CALL MAXIT(1,DSMAX)
$MANY            CALL SPREAD8(1,DSMAX)
$MANY            CALL TIMOFF(5)

C           note: locations are not correct when run in parallel
            IF (BUGKEY(6).AND.MYPRC.EQ.0) THEN
               WRITE(NFBUG,'(A,G15.6,I3,G15.6,4I5)')
     &            ' SATURATION CHANGE, tim,newt,dsmax,i,j,k,nblk ',
     &             TIM,NEWT,DSMAX,ISMAX,JSMAX,KSMAX,NSMAX
               WRITE(*,'(A,G15.6,I3,G15.6,4I5)')
     &            ' SATURATION CHANGE, tim,newt,dsmax,i,j,k,nblk ',
     &             TIM,NEWT,DSMAX,ISMAX,JSMAX,KSMAX,NSMAX
            ENDIF

C            IF(DSMAX > THREEHALF*DSMAX_TARG) SCAL1 = DSMAX_TARG/DSMAX
            IF(DSMAX > FIVE*DSMAX_TARG) SCAL1 = DSMAX_TARG/DSMAX
            IF(MAXERRSAT) THEN
               IF(SAT_ERRMAX > TWO*TEN_M2)
     &            SCAL2 = TWO*TEN_M2/SAT_ERRMAX
            ELSE
               IF(SAT_ERRAVG > TWO*TEN_M2)
     &            SCAL2 = TWO*TEN_M2/SAT_ERRAVG
            ENDIF
            SCAL = MIN(SCAL1,SCAL2)
            IF (BUGKEY(6) .AND. SCAL < ONE.AND.MYPRC.EQ.0) THEN
               IF(SCAL == SCAL1) THEN
                  WRITE(NFBUG,'(A,G13.5,A,G13.5)')
     &                 ' TIMESTEP SCALED AT ',TIM,
     &                 ' DUE TO SATURATION CHANGE OF ',DSMAX
                  WRITE(*,'(A,G13.5,A,G13.5)')
     &                 ' TIMESTEP SCALED AT ',TIM,
     &                 ' DUE TO SATURATION CHANGE OF ',DSMAX
               ELSE
                  IF(MAXERRSAT) THEN
                     WRITE(NFBUG,'(A,G13.5,A,G13.5)')
     &                 ' TIMESTEP SCALED AT ',TIM,
     &                 ' DUE TO SATURATION ERROR OF ',SAT_ERRMAX
                     WRITE(*,'(A,G13.5,A,G13.5)')
     &                 ' TIMESTEP SCALED AT ',TIM,
     &                 ' DUE TO SATURATION ERROR OF ',SAT_ERRMAX
                  ELSE
                     WRITE(NFBUG,'(A,G13.5,A,G13.5)')
     &                 ' TIMESTEP SCALED AT ',TIM,
     &                 ' DUE TO SATURATION ERROR OF ',SAT_ERRAVG
                     WRITE(*,'(A,G13.5,A,G13.5)')
     &                 ' TIMESTEP SCALED AT ',TIM,
     &                 ' DUE TO SATURATION ERROR OF ',SAT_ERRAVG
                  ENDIF
               ENDIF
            ENDIF
         ENDIF

         IF(MAXERRSAT) THEN
            IF(SAT_ERRMAX < TOL_SAT) KCONVG_SAT = .TRUE.
         ELSE
            IF(SAT_ERRAVG < TOL_SAT) KCONVG_SAT = .TRUE.
         ENDIF
         IF (BUGKEY(6).AND.MYPRC.EQ.0) THEN
            WRITE(NFBUG,'(A,G15.6,I3,G15.6,4I5)')
     &      ' SATURATION ERROR,  tim,newt,value,i,j,k,nblk ',TIM,NEWT,
     &       SAT_ERRMAX,ISAT,JSAT,KSAT,NSAT
            WRITE(*,'(A,G15.6,I3,G15.6,4I5)')
     &      ' SATURATION ERROR,  tim,newt,value,i,j,k,nblk ',TIM,NEWT,
     &       SAT_ERRMAX,ISAT,JSAT,KSAT,NSAT
         ENDIF

      ENDIF

C
C-------------------------------------------------------------------------
C  GATHER RESERVOIR PRESSURES INTO WELL VECTOR
C-------------------------------------------------------------------------
C
C     NOTE: NEWFLOW WILL BE TRUE HERE ONLY IF FIRST STEP OF A RUN
C           OTHERWISE NEWFLOW IS ALWAYS FALSE AT THIS POINT
C           N_SATN NOT SET UNTIL LATER IN THIS ROUTINE
      CALL TIMON(10)
      IF(NEWFLOW) THEN
         JWPRES(3) = N_DELC
      ELSE
         JWPRES(3) = N_MDENN
      ENDIF
      IF(NEWT == 1) THEN
         JWPRES(5) = N_SAT
      ELSE
         JWPRES(5) = N_SATN
      ENDIF
      CALL CALLWORK(XSET_WPRES,JWPRES)
      CALL TIMOFF(10)

C     COLLECT WELL VECTOR WPRES FROM APPROPRIATE PROCESSORS
C     REQUIRED ONLY IF WELL SPANS SEVERAL PROCESSORS
$MANY      IF(WELLSPAN) THEN
$MANY         CALL TIMON(25)
$MANY         CALL XGET_WPRES
$MANY         CALL TIMOFF(25)
$MANY      ENDIF
C
C-------------------------------------------------------------------------
C  UPDATE BHP AND CHECK FOR PRESSURE LIMIT
C-------------------------------------------------------------------------
C
      CHANGE_BHP = ONE
      IF(NEWT /= 1 .AND. NEWT <= NITER) THEN
         CALL TIMON(10)
         CALL XBHP(CHANGE_BHP,IWFLAG)
         CALL TIMOFF(10)
$MANY         CALL TIMON(25)

         IF (CHANGE_BHP.GT.0) THEN
$MANY         DUM = ONE/CHANGE_BHP
$MANY         CALL MAXIT(1,DUM)
$MANY         CALL SPREAD8(1,DUM)
$MANY         CHANGE_BHP = ONE/DUM
         ENDIF

! bag8 - prevent division by zero
!$MANY         DUM = CHANGE_BHP
!$MANY         CALL MINIT(1,DUM)
!$MANY         CALL SPREAD8(1,DUM)
!$MANY         CHANGE_BHP = DUM

$MANY         CALL TIMOFF(25)
         IF (IWFLAG == 1) KCONVG_SAT = .FALSE.
         IF(CHANGE_BHP < ONE) THEN
            KCONVG_SAT = .FALSE.
            IF (NEWT == 2 .AND. BUGKEY(6).AND.MYPRC.EQ.0) THEN
                WRITE(NFBUG,'(2A)') ' VARIABLES SCALED',
     &                              ' DUE TO BHP CONTROL'
                WRITE(*,'(2A)') ' VARIABLES SCALED',
     &                          ' DUE TO BHP CONTROL'
            ENDIF
         ENDIF
      ENDIF
C
C-------------------------------------------------------------------------
C  SCALE VARIABLES AND TIMESTEP
C-------------------------------------------------------------------------
C
      IF(OVERSHT < ONE .AND. ONLY_COMP) THEN
         IF(OVERSHT >= HALF .OR. NEWT > 2) THEN
            SCAL = MIN(SCAL,(ONE-TEN_M2)*OVERSHT)
         ELSE
            KCONVG_SAT = .FALSE.
         ENDIF
      ENDIF

      IF(ICFLCHK>0 .AND. ONLY_COMP .AND. (SCAL /= ONE .OR.
     &  (NEWT == 2 .AND. CHANGE_BHP /= ONE)) ) THEN
         KCONVG_SAT = .FALSE.
         NEWPV = .TRUE.
         DUM = DELTIM
         DELTIM = SCAL*DELTIM
         DELTIM = MAX(TENTH*DUM,DELTIM,DTIMMIN)
         SCAL = DELTIM/DUM
         SCALTIM = SCAL
         IF(SCAL < THIRD) SCAL = ZERO
         IF(NEWT == 2) SCAL = MIN(SCAL,CHANGE_BHP)
         JSCAL(2) = N_CONC
         JSCAL(3) = N_CONCN
         I4UTIL = NC
         R8UTIL = SCAL
         CALL CALLWORK(XSCALE,JSCAL)
         JSCAL(2) = N_FLK
         JSCAL(3) = N_FLKN
         I4UTIL = NHC
         IF(NPH > 2) CALL CALLWORK(XSCALEK,JSCAL)
         JSCAL(2) = N_PRES
         JSCAL(3) = N_PRESN
         I4UTIL = 1
         CALL CALLWORK(XSCALE,JSCAL)
         IF(SCAL == ZERO) CALL CALLWORK(CPYARYI4,JFLDR)
         TEMP_PARTIAL = PARTIALJAC
         PARTIALJAC = .FALSE.
         CALL EOS_WORK(NCINPH,.FALSE.,NFBUG,NHC,NC,NPH,ICINPH,
     &                 N_TCOFX,N_TCOFY,N_TCOFZ,N_DELC,.FALSE.,
     &                 .FALSE.,.FALSE.,IFTCALC)
         PARTIALJAC = TEMP_PARTIAL
         IF (BUGKEY(6) .AND. SCALTIM < ONE.AND.MYPRC.EQ.0) THEN
            WRITE(NFBUG,'(A,G13.5,A,G13.5)')
     &                  ' TIMESTEP SCALED FROM',DUM,' TO ',DELTIM
            WRITE(*,'(A,G13.5,A,G13.5)')
     &                  ' TIMESTEP SCALED FROM',DUM,' TO ',DELTIM
         ENDIF

C        REGATHER RESERVOIR PRESSURES INTO WELL VECTOR DUE TO SCALING
         CALL TIMON(10)
         JWPRES(3) = N_MDENN
         JWPRES(5) = N_SATN
         CALL CALLWORK(XSET_WPRES,JWPRES)
         CALL TIMOFF(10)

C        RECOLLECT WELL VECTOR WPRES DUE TO SCALING
C        REQUIRED ONLY IF WELL SPANS SEVERAL PROCESSORS
$MANY         IF(WELLSPAN) THEN
$MANY            CALL TIMON(25)
$MANY            CALL XGET_WPRES
$MANY            CALL TIMOFF(25)
$MANY         ENDIF
      ENDIF
C
C-------------------------------------------------------------------------
C  SET FLAGS FOR UPDATES
C-------------------------------------------------------------------------
C
      IF (KCONVG_SAT) THEN
         NEWFLOW = .TRUE.
         NEWRESID = .FALSE.
         NEWPV = .FALSE.
      ELSEIF (NEWT > MAXITS) THEN
         NEWRESID = .FALSE.
         NEWPV = .FALSE.
      ENDIF

C  STORE VALUES FOR MDENN (DELC IN CALL TO EOS_WORK)
C  NOTE: DELC USED AS WORKSPACE IN PRINTOUT ROUTINES
      IF (NEWFLOW) THEN
         CALL TIMON(6)
         JCOPY(1) = 3
         JCOPY(2) = N_DELC
         JCOPY(3) = N_MDENN
         JCOPY(4) = N_I4U
         I4UTIL = NPH
         CALL CALLWORK(CPYARYR8N,JCOPY)
         CALL TIMOFF(6)
      ENDIF
C
C-------------------------------------------------------------------------
C  CALCULATE INTERFACIAL TENSION USING CORRELATIONS
C-------------------------------------------------------------------------
C
            IF(IFTSATRES) THEN
               CALL CALLWORK(XCALCXTENS,JIFT)
               CALL CALLWORK(XIFTSATRES,JSATR)
            ENDIF
C
C-------------------------------------------------------------------------
C  CALCULATE MOBILITIES AND PC
C-------------------------------------------------------------------------
C
      IF (NEWFLOW) THEN
         CALL TIMON(23)
         IF (HYSTERESIS.AND.(((NPH > 2).AND.AQPHSWTCH).OR.(NPH == 2)))
     &   THEN
            IF(HYSTYPE.EQ.3)THEN
               CALL CALLWORK(XHYSRLPRM3,JHYST)
            ELSEIF(HYSTYPE.EQ.1)THEN
               CALL CALLWORK(XHYSRLPRM1,IHYST)
            ELSE
               print *, ' ERROR INVALID HYST TYPE'
            ENDIF
         ELSEIF(IFTRLPRM.AND.(((NPH>2).AND.AQPHSWTCH).OR.(NPH==2)))THEN
            CALL CALLWORK(XIFTRLPRM,JIREL)
         ELSE
            CALL CALLWORK(XRELPERM1,JREL)
         ENDIF
         CALL TIMOFF(23)
         IF (LEVELE .AND. BUGKEY(11) .AND.
     &       TIM >= DUMPTIME1 .AND. TIM <= DUMPTIME2) THEN
            DO IPH = 1,NPH
               CNAME=PHNAM(IPH)
               WRITE(TITU,'(3A)') 'MOB ',CNAME,' FOR FAULT BLOCK'
               CALL GEAOUT(N_MOB,IPH,1)
            END DO
         ENDIF
Cxianhui
C        PC BASED ON J-FUNCTIONn
         IF(LJFUNPC)THEN
            CALL CALLWORK(XLJFUNPC,JLJPC)
         ENDIF
CKong
CXianhui
         IF(FOAMMOD)THEN
CXIN-------------------------START-------------------------------
            IF (FOAMTYPE .EQ. 1)THEN
               CALL CALLWORK(XVELCOMP,JVEL)
               CALL CALLWORK(XRELFOAM1,JRLFM)
C            ELSE
C            CALL CALLWORK(XRELFOAM,JRLFM)
            ENDIF
CXIN--------------------------END--------------------------------
         ENDIF
CKong
      ENDIF
C
C-------------------------------------------------------------------------
C  CALCULATE PV
C-------------------------------------------------------------------------
C
      CALL TIMON(24)
      IF (NEWPV) CALL CALLWORK(XPORE,JPOR)
C
C-------------------------------------------------------------------------
C  CALCULATE FLUIDS IN PLACE AND SET UP ACCUMULATION TERM FOR RESIDUAL
C-------------------------------------------------------------------------
C
      DO IC = 1,NC
         CURRENT(IC) = ZERO
      END DO
      IF (NEWRESID) THEN
         CALL CALLWORK(XINPLACE1,JPLACE1)
      ELSE
         CALL CALLWORK(XINPLACE2,JPLACE2)
      ENDIF
C
C-------------------------------------------------------------------------
C  CALCULATE MOBPROD FOR FLOW TERMS
C-------------------------------------------------------------------------
C
      IF (NEWFLOW) CALL CALLWORK(XPROP,JPROP)
      CALL TIMOFF(24)

C     DO FOLLOWING AT START OF SIMULATION ONLY
      IF (NEWT == 1 .AND. TIM == ZERO .AND. ONEPRINT) THEN

C        CALCULATE AVERAGE RESERVOIR PRESSURE AT START OF SIMULATION
C        AND CURRENT FLUIDS IN PLACE
         DO IC = 1,NC
            BALANCE(IC,MODACT,4) = CURRENT(IC)
         END DO
         JPAVG(1) = 2
         JPAVG(2) = N_PRES
         JPAVG(3) = N_PV
         PAVG = ZERO
         PVTOTL = ZERO
         CALL CALLWORK(XPAVG,JPAVG)
$MANY         TEMP(1) = PAVG
$MANY         TEMP(2) = PVTOTL
$MANY         CALL SUMIT(2,TEMP)
$MANY         PAVG = TEMP(1)
$MANY         PVTOTL = TEMP(2)
         IF(MYPRC == 0 .AND. PVTOTL > ZERO) PAVG = PAVG/PVTOTL
$MANY         CALL SPREAD8(1,PAVG)
         CALL XSTDOUTS
         IF (LEVELC) THEN
            DO L = 1,NPH
               IFIP(L) = FIP(L)
            END DO
         ENDIF
         CALL XSTDOUTA
         OUT_COMPR = .FALSE.
         OUT_REFP = .FALSE.
         OUT_PV = .FALSE.
         OUT_TEMPR = .FALSE.
         ONEPRINT = .FALSE.
      ENDIF

C  STORE VALUES FOR PRESSURE, CONCENTRATION, PV, K VALUES,
C  SATURATIONS, AND FLUID TYPES FOR RESTARTS
      IF(NEWT == 1) THEN
         CALL TIMON(6)
         JCOPY(1) = 3
         JCOPY(2) = N_PRES
         JCOPY(3) = N_PRESN
         I4UTIL = 1
         JCOPY(4) = N_I4U
         CALL CALLWORK(CPYARYR8N,JCOPY)

         JCOPY(2) = N_CONC
         JCOPY(3) = N_CONCN
         I4UTIL = NC
         CALL CALLWORK(CPYARYR8N,JCOPY)

         JCOPY(2) = N_CONCAQ
         JCOPY(3) = N_CONCAQN
         I4UTIL = NAQ
         CALL CALLWORK(CPYARYR8N,JCOPY)

         JCOPY(2) = N_FLK
         JCOPY(3) = N_FLKN
         I4UTIL = NHC
         IF(NPH > 2) CALL CALLWORK(CPYARYR8N,JCOPY)

         JCOPY(2) = N_SAT
         JCOPY(3) = N_SATN
         I4UTIL = NPH
         CALL CALLWORK(CPYARYR8N,JCOPY)

         CALL CALLWORK(CPYARYI4,JFLD)

         JCOPY(1) = 2
         JCOPY(2) = N_PV
         JCOPY(3) = N_PVN
         CALL CALLWORK(CPYARYR8,JCOPY)
         CALL TIMOFF(6)
      ENDIF
C
C-------------------------------------------------------------------------
C  GATHER RESERVOIR PROPERTIES INTO WELL VECTORS
C-------------------------------------------------------------------------
C
      IF(NEWFLOW) THEN
         CALL TIMON(10)
         CALL CALLWORK(XWELVAL1,JWVAL1)
         CALL TIMOFF(10)

C        COLLECT WELL VECTORS WMOB,WTEMPR,WPMD FROM APPROPRIATE PROCESSORS
C        REQUIRED ONLY IF WELL SPANS SEVERAL PROCESSORS
$MANY         IF(WELLSPAN) THEN
$MANY            CALL TIMON(25)
$MANY            CALL XGET_ELEVAL
$MANY            CALL TIMOFF(25)
$MANY         ENDIF
      ENDIF
C
C-------------------------------------------------------------------------
C  PERFORM WELL CALCULATIONS
C-------------------------------------------------------------------------
C
    9 CONTINUE

      IF (NEWRESID) THEN
         CALL TIMON(10)
         CALL XWELLCALC
         CALL TIMOFF(10)
         IF((NHISUSE == 0).AND.(NSTEP < 1)) RETURN
C
C        CHECK WELL CELLS FOR STABILITY LIMITS AT START OF NEW TIMESTEP
         IF(ICFLCHK > 0 .AND. NEWT == 1 .AND. ONLY_COMP) THEN
            DTVAL = BIG
            CALL TIMON(10)
            CALL CALLWORK(XWSTART,JWSTART)
            CALL TIMOFF(10)
$MANY            CALL TIMON(5)

            IF (DTVAL.GT.0.D0) THEN
$MANY            DUM = ONE/DTVAL
$MANY            CALL MAXIT(1,DUM)
$MANY            CALL SPREAD8(1,DUM)
$MANY            DTVAL = ONE/DUM
            ENDIF

! bag8 - prevent division by zero
!$MANY            DUM = DTVAL
!$MANY            CALL MINIT(1,DUM)
!$MANY            CALL SPREAD8(1,DUM)
!$MANY            DTVAL = DUM

$MANY            CALL TIMOFF(5)
            IF(DTVAL < THREE*DELTIM/FOUR) THEN
               IF (BUGKEY(6).AND.MYPRC.EQ.0) THEN
                  WRITE(NFBUG,'(A,G13.5,A,G13.5,A)')
     &                  ' TIMESTEP REDUCED FROM',DELTIM,' TO ',DTVAL,
     &                  ' DUE TO WELLS'
                  WRITE(*,'(A,G13.5,A,G13.5,A)')
     &                  ' TIMESTEP REDUCED FROM',DELTIM,' TO ',DTVAL,
     &                  ' DUE TO WELLS'
               ENDIF
               DELTIM = DTVAL
C
C              CALL XWELLCALC AGAIN BECAUSE OF TABLE LOOKUP FOR RATES
               CALL TIMON(10)
               CALL XWELLCALC
               CALL TIMOFF(10)
            ENDIF
         ENDIF
C
C        DISTRIBUTE WELL VECTORS QLAYER,WELL_COEF TO APPROPRIATE PROCESSORS
C        ALSO DISTRIBUTES WELL CONTROLS WSHUT AND BHP_CONTROL
C        REQUIRED ONLY IF WELL SPANS SEVERAL PROCESSORS
$MANY         IF(WELLSPAN) THEN
$MANY            CALL TIMON(25)
$MANY            CALL XPUT_WELVAL
$MANY            CALL XPUT_ELEVAL
$MANY            CALL TIMOFF(25)
$MANY         ENDIF
      ENDIF
C
C-------------------------------------------------------------------------
C  EXCHANGE PHYSICAL PARAMETERS WITH NEIGHBORING PROCESSORS
C-------------------------------------------------------------------------
C  
$MANY      CALL TIMON(3)
$MANY      CALL UPDATE(N_PRES,1)
$MANY      IF(NEWFLOW) THEN
$MANY         CALL UPDATE(N_MOBPROD,1)
$MANY         CALL UPDATE(N_PC,1)
$MANY         CALL UPDATE(N_MDENN,1)
$MANY         IF(.NOT.XNO_DD) THEN
$MANY            CALL UPDATE(N_PMD,1)
$MANY         ENDIF
$MANY         IF(NPH > 1 .AND. ICFLCHK > 0) THEN
$MANY            CALL UPDATE(N_DPC,1)
$MANY            CALL UPDATE(N_DMOB,1)
$MANY            CALL UPDATE(N_MOB,1)
$MANY         ENDIF
$MANY      ENDIF
$MANY      CALL TIMOFF(3)

C-------------------------------------------------------------------------
C  EVALUATE DIFFUSION TERMS AND RESIDUAL
C-------------------------------------------------------------------------
C First evaluate mole fractions, then update diff./disp. tensor, then
C evaluate contribution to stiffness matrix.

      IF(NEWRESID.AND.(.NOT.XNO_DD)) THEN
         CALL TIMON(6)
         CALL CALLWORK(XMFRAC_ALL,JMFR)
         CALL CALLWORK(XPHMDENS,JPHDEN)
         IF((.NOT.XNO_LD).OR.(.NOT.XNO_TD)) THEN
            CALL CALLWORK(XVELCOMP,JVEL)
            CALL CALLWORK(XGETDISP,JDISP)
         ENDIF
         CALL TIMOFF(6)
$MANY         CALL TIMON(3)
$MANY         CALL UPDATE(N_PV,1)
$MANY         CALL UPDATE(N_KSI,1)
$MANY         CALL UPDATE(N_SAT,1)
$MANY         CALL UPDATE(N_PMDEN,1)
$MANY         IF((.NOT.XNO_LD).OR.(.NOT.XNO_TD)) CALL UPDATE(N_XDMAT,1)
$MANY         CALL TIMOFF(3)
         CALL TIMON(8)
         JDIFF(2)=N_TCOFX
         CALL CALLWORK(XDIFFX,JDIFF)
         JDIFF(2)=N_TCOFY
         CALL CALLWORK(XDIFFY,JDIFF)
         JDIFF(2)=N_TCOFZ
         CALL CALLWORK(XDIFFZ,JDIFF)
         CALL TIMOFF(8)
      ENDIF

C
C-------------------------------------------------------------------------
C  EVALUATE TRANSPORT TERMS AND RESIDUAL
C-------------------------------------------------------------------------
C
      IF (NEWRESID) THEN
         CALL TIMON(8)
         JTRAN(2)=N_TCOFX
         CALL CALLWORK(XTRANX,JTRAN)
         JTRAN(2)=N_TCOFY
         CALL CALLWORK(XTRANY,JTRAN)
         JTRAN(2)=N_TCOFZ
         CALL CALLWORK(XTRANZ,JTRAN)
         CALL TIMOFF(8)
      ENDIF
C
C-------------------------------------------------------------------------
C  ADD WELLS TO FLOW COEFFICIENTS AND RESIDUALS
C-------------------------------------------------------------------------
C
      IF (NEWRESID) THEN
         CALL TIMON(10)
         CALL CALLWORK(XWELFLOW,JWFLOW)
         CALL TIMOFF(10)
      ENDIF

      IF (NERRC > 0) THEN
         NERR = NERR + 1
         RETURN
      ENDIF
C
C-------------------------------------------------------------------------
C  SEND BLOCK INTERFACE DATA
C-------------------------------------------------------------------------
C
$DUAL      CALL XDUALS(NERRC)
$DUAL      IF (NERRC > 0) THEN
$DUAL         NERR = NERR + 1
$DUAL         RETURN
$DUAL      ENDIF
   
C-------elements passed in interface buffer
$DUAL      IF(NEWT == 1) THEN
$DUAL         NBEMC($XMODEL) = 3+2*NPH+NCINPH
$DUAL      ELSE
$DUAL         NBEMC($XMODEL) = 2
$DUAL      ENDIF

      END
C*********************************************************************
      SUBROUTINE XSTEP2 (KONVG,NERR)
C*********************************************************************

C  Compositional model exective routine to continue a time step
C  1.  Complete inter-block calculations
C  2.  Check Newtonian convergence

C  NERR = ERROR KEY STEPPED BY ONE FOR EACH ERROR
C         (INPUT AND OUTPUT, INTEGER)

C  KONVG = CONVERGENCE FLAG (OUTPUT, INTEGER)
C        = 1 ==> CONVERGED
C        = 2 ==> CONTINUE ITERATION
C        = 3 ==> FAILED
C        = 4 ==> CUT TIME STEP (SET BY FRAMEWORK ONLY)
C*********************************************************************
      IMPLICIT NONE
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'blkary.h'
      INCLUDE 'layout.h'
      INCLUDE 'wells.h'
      INCLUDE 'xarydat.h'
      INCLUDE 'xbaldat.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xiter.h'
      INCLUDE 'xparam.h'

      INTEGER KONVG,NERR
      INTEGER IC
      INTEGER JCOND(11),JWCOND(2)
      SAVE JCOND,JWCOND

      LOGICAL ONCEONLY, ONEPRINT
      DATA ONCEONLY /.TRUE./

      EXTERNAL XCOND,XWELCOND,XMAXRESID

C  DEFINE WORK ROUTINE ARGUMENTS

      IF (ONCEONLY) THEN
         ONCEONLY=.FALSE.

         IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)'PROC',MYPRC,
     &    ' ENTERING SUBROUTINE XSTEP2, OLD TAG =',MSGTAG($XMODEL+1)

         JCOND(1)=10
         JCOND(2)=N_XCOF
         JCOND(3)=N_XRESID
         JCOND(4)=N_DFLOW
         JCOND(5)=N_TFLOW
         JCOND(6)=N_RESID
         JCOND(7)=N_ERRSAT
         JCOND(8)=N_DSTDP
         JCOND(9)=N_DSTDN
         JCOND(10)=N_PV
C        N_DELC used as workspace for IMPEC scaling factors
C        Also used in XDUALCOND
         JCOND(11)=N_DELC

         JWCOND(1)=1
         JWCOND(2)=N_DELC
      ENDIF

      IF((NHISUSE == 0).AND.(NSTEP < 1)) RETURN

C  RECEIVE BLOCK INTERFACE DATA AND COMPLETE RESIDUALS

      DO IC = 1,NC
         FLUXOM(IC) = ZERO
      END DO
$DUAL      IF(NEWRESID) THEN
$DUAL         CALL XDUALR()
$DUAL      ENDIF

C  FORM IMPEC EQUATIONS FROM FLOW EQUATIONS

      IF (NEWRESID) THEN
         CALL TIMON(8)
         CALL CALLWORK(XCOND,JCOND)
         CALL CALLWORK(XWELCOND,JWCOND)
         CALL TIMOFF(8)
$DUAL         CALL XDUALCOND()

C-------print residuals
C         CALL DUMPARRAY8 (N_TFLOW,'TFLOW(,,,1,2)',14)
C         CALL DUMPARRAY4 (N_XCOF,'XCOF(4)',4)
         IF (LEVELE .AND. BUGKEY(10) .AND.
     &       TIM >= DUMPTIME1 .AND. TIM <= DUMPTIME2) THEN
            DO IC = 1,NCPRT
               WRITE(TITU,'(A,I5)') 'RESIDUAL FOR COMPONENT ',IC
               CALL GEAOUT(N_RESID,IC,1)
            END DO
            WRITE(TITU,'(A)') 'XRESID '
            CALL GEAOUT(N_XRESID,1,1)
C            WRITE(TITU,'(A)') 'XCOF 1'
C            CALL GEAOUT(N_XCOF,1,1)
C            WRITE(TITU,'(A)') 'XCOF 3'
C            CALL GEAOUT(N_XCOF,3,1)
C            WRITE(TITU,'(A)') 'XCOF 4'
C            CALL GEAOUT(N_XCOF,4,1)
C            WRITE(TITU,'(A)') 'XCOF 5'
C            CALL GEAOUT(N_XCOF,5,1)
C            WRITE(TITU,'(A)') 'XCOF 6'
C            CALL GEAOUT(N_XCOF,6,1)
C            WRITE(TITU,'(A)') 'XCOF 7'
C            CALL GEAOUT(N_XCOF,7,1)
         ENDIF
      ENDIF

C bag8 - calculate 2-norm of XRESID for adaptivity
      IF (ADAPTIVITY) THEN
        RESIDT=0.D0
        RESIDM=0.D0
        RESID2=0.D0
        CALL CALLWORK(XMAXRESID,[1,N_XRESID])
$MANY         CALL MAXIT(1,RESIDM(1))
$MANY         CALL SPREAD8(1,RESIDM(1))
$MANY         CALL SUMIT(1,RESIDT(1))
$MANY         CALL SPREAD8(1,RESIDT(1))
$MANY         CALL SUMIT(1,RESID2(1))
$MANY         CALL SPREAD8(1,RESID2(1))
         RESID2(1)=SQRT(RESID2(1))
      ENDIF

C  SET CONVERGENCE FLAG
C  PROGRAM SETS KONVG = 4 BEFORE XSTEP3 WHEN KONVG = 3 UNLESS
C  PROGRAM IS GOING TO STOP
      KONVG = 2
      IF (NEWT > 1) THEN
         IF (KCONVG_SAT) THEN
            KONVG = 1
         ELSEIF(NEWT > MAXITS) THEN
            KONVG = 3
         ENDIF
      ENDIF
      END

C*********************************************************************
      SUBROUTINE XSTEP3 (KONVG,NERR)
C*********************************************************************

C  Compostional  model exective routine to complete a time step
C    1.  Update unknowns for next Newtonian iteration (KONVG = 2)
C    2.  Wrap up time step (KONVG = 1)
C    3.  Restart time step (KONVG = 4)
C    4.  Abort run  (KONVG = 3)

C  KONVG = CONVERGENCE FLAG (INPUT, INTEGER)
C        = 1 ==> CONVERGED
C        = 2 ==> CONTINUE ITERATION
C        = 3 ==> FAILED
C        = 4 ==> CUT TIME STEP

C  NERR = ERROR KEY STEPPED BY ONE FOR EACH ERROR
C         (INPUT AND OUTPUT, INTEGER)

C*********************************************************************
      IMPLICIT NONE
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'blkary.h'
      INCLUDE 'wells.h'
      INCLUDE 'unitsex.h'
      INCLUDE 'xarydat.h'
      INCLUDE 'xbaldat.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xiter.h'
      INCLUDE 'xthermal.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xwells.h'

      INTEGER KONVG,NERR
      INTEGER IC,N,K,IPH,I,IW
      INTEGER JPOR(6),JCOPY(4),JPRES(3),JFLOW(8),JCONC(5),JP(3),
     &        JPVOLD(3),JSATM(5),JFLD(3),JPAVG(3),JWFLOW(2),JWSTAB(3),
     &        JGSTAB(11),JSTABCHK(6),JCPY(4),JMFRW(3),JPHDENS(3),
     &        JRELP(5),JHYST(6),JVEL(10),JSPHT(7),JFLOWAQ(11)
      SAVE JPOR,JCOPY,JPRES,JFLOW,JCONC,JPVOLD,JSATM,JFLD,JPAVG,
     &     JWFLOW,JWSTAB,JGSTAB,JSTABCHK,JCPY,JMFRW,JPHDENS,JRELP,
     &     JHYST,JVEL,JSPHT,JFLOWAQ

      INTEGER KSEND,ITMP,IOLD,INEW
      PARAMETER(KSEND=$MXCOMP+$MXPHASE+3,IOLD=0,INEW=1)
      REAL*8 WCOMP($MXCOMP+1),X,WSUM(KSEND,$MXWELL),WELL_CSUM($MXWELL),
     &       WELL_MOLFR($MXCOMP+1,$MXWELL),TEMP(2),DUM

      LOGICAL ONCEONLY, WSHUTCHK
      DATA ONCEONLY /.TRUE./, WSHUTCHK /.FALSE./

      EXTERNAL CPYARYR8N,XPORE,XPRES,XCONC,XFLOW,CPYARYR8,
     &         XSAT_STEP,CPYARYI4,XPAVG,XWFLOW,XWSTAB,XSTABCHK,
     &         XGSTABX2,XGSTABY2,XGSTABZ2,XGSTABX3,XGSTABY3,XGSTABZ3,
     &         XMFRAC_ALL,XMASSFRAC_ALL,XPHDENS,XRELPERM2,XHYSRLPRM2,
     &         XVELCOMP,XSPHEAT,XFLOWAQ,XPHMDENS
      CHARACTER*8 CNAME

      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)'PROC',MYPRC,
     &  ' ENTERING SUBROUTINE XSTEP3, OLD TAG =',MSGTAG($XMODEL+1)

C  DEFINE WORK ROUTINE ARGUMENTS 

      IF (ONCEONLY) THEN
         ONCEONLY=.FALSE.

         JPOR(1)=5
         JPOR(2)=N_POR
         JPOR(3)=N_PV
         JPOR(4)=N_PRES
         JPOR(5)=N_CR
         JPOR(6)=N_REFPRES

         JFLOW(1)=7
         JFLOW(2)=N_CONC
         JFLOW(3)=N_DFLOW
         JFLOW(4)=N_TFLOW
         JFLOW(5)=N_RESID
         JFLOW(6)=N_XDUNK
         JFLOW(7)=N_CR
         JFLOW(8)=N_DELC

         JWFLOW(1)=1
         JWFLOW(2)=N_DELC

         JFLOWAQ(1)=10
         JFLOWAQ(2)=N_POR
         JFLOWAQ(3)=N_XVEL
         JFLOWAQ(4)=N_PV
         JFLOWAQ(5)=N_PVN
         JFLOWAQ(6)=N_PMDEN
         JFLOWAQ(7)=N_PMDENN
         JFLOWAQ(8)=N_SAT
         JFLOWAQ(9)=N_SATN
         JFLOWAQ(10)=N_CONCAQ
         JFLOWAQ(11)=N_CONCAQN

         JPRES(1)=2
         JPRES(2)=N_PRES
         JPRES(3)=N_XDUNK

         JCONC(1)=4
         JCONC(2)=N_CONC
         JCONC(3)=N_DELC
         JCONC(4)=N_PV
         JCONC(5)=N_XRESID

         JPVOLD(1) = 2
         JPVOLD(2) = N_PV
         JPVOLD(3) = N_XRESID

         JPAVG(1) = 2
         JPAVG(2) = N_PRES
         JPAVG(3) = N_PV

         JCOPY(1) = 3
         JCOPY(4) = N_I4U

         JSATM(1) = 4
         JSATM(2) = N_CONCN
         JSATM(3) = N_CONC
         JSATM(4) = N_DSTDN
         JSATM(5) = N_CFL

         JFLD(1) = 2

         JWSTAB(1)=2
         JWSTAB(2)=N_DMOB
         JWSTAB(3)=N_DCFL

         JGSTAB(1)=10
         JGSTAB(3)=N_DEPTH
         JGSTAB(4)=N_PRES
         JGSTAB(5)=N_MDENN
         JGSTAB(6)=N_MOB
         JGSTAB(7)=N_DCFL
         JGSTAB(8)=N_PC
         JGSTAB(9)=N_DMOB
         JGSTAB(10)=N_DPC
         JGSTAB(11)=N_CFL

         JSTABCHK(1)=5
         JSTABCHK(2)=N_PV
         JSTABCHK(3)=N_PMD
         JSTABCHK(4)=N_SAT
         JSTABCHK(5)=N_DCFL
         JSTABCHK(6)=N_CFL

         JCPY(1)=3
         JCPY(4)=N_I4U

         JMFRW(1)=2
         JMFRW(2)=N_PMD
         JMFRW(3)=N_KSI

         JPHDENS(1)=2
         JPHDENS(2)=N_PMD
         JPHDENS(3)=N_PMDEN

         JRELP(1)=4
         JRELP(2)=N_ROCK
         JRELP(3)=N_XVISC
         JRELP(4)=N_SAT
         JRELP(5)=N_MOB

         JHYST(1)=5
         JHYST(2)=N_ROCK
         JHYST(3)=N_XVISC
         JHYST(4)=N_SAT
         JHYST(5)=N_SGT
         JHYST(6)=N_MOB

         JVEL(1)=9
         JVEL(2)=N_TCOFX
         JVEL(3)=N_TCOFY
         JVEL(4)=N_TCOFZ
         JVEL(5)=N_DEPTH
         JVEL(6)=N_PRES
         JVEL(7)=N_PC
         JVEL(8)=N_PMDEN
         JVEL(9)=N_MOB
         JVEL(10)=N_XVEL

         JSPHT(1)=6
         JSPHT(2)=N_TEMPR
         JSPHT(3)=N_KSI
         JSPHT(4)=N_KSIN
         JSPHT(5)=N_XCPL
         JSPHT(6)=N_XCVL
         JSPHT(7)=N_XCVS

      ENDIF

C  BRANCH ON CONVERGENCE STATE

      IF((NHISUSE.EQ.0).AND.(NSTEP < 1)) GO TO 5

      STEPCUT = .FALSE.
      NEWRESID = .TRUE.
      NEWFLOW = .FALSE.
      OVERSHT = BIG

      GO TO (1,2,1,4),KONVG
C-----------------------------------------
C  CONTINUE NEWTONIAN ITERATION
C  UPDATE SOLUTION AND RETURN
C-----------------------------------------
    2 CONTINUE
      NEWPV = .FALSE.
      NEWFLASH = .TRUE.
      IF(LEVELE .AND. (BUGKEY(10) .OR. BUGKEY(11)) .AND.
     &   TIM >= DUMPTIME1 .AND. TIM <= DUMPTIME2) THEN
         WRITE(NFBUG,'(A,G15.5)')'DUMP VARIABLES AT TIME = ',TIM+DELTIM
      ENDIF
      IF (LEVELE .AND. BUGKEY(10) .AND.
     &    TIM >= DUMPTIME1 .AND. TIM <= DUMPTIME2) THEN
         TITU='CHANGE IN PRESSURE FOR FAULT BLOCK'
         CALL GEAOUT(N_XDUNK,1,1)
      ENDIF

C  EXCHANGE PRESSURE INCREMENTS WITH NEIGHBORING PROCESSORS

$MANY      CALL TIMON(3)
$MANY      CALL UPDATE(N_XDUNK,1)
$MANY      CALL TIMOFF(3)

C  UPDATE PHASE PRESSURES
      CALL TIMON(26)
      CALL CALLWORK(XPRES,JPRES)

C  STORE OLD PV IN XRESID VECTOR
      CALL CALLWORK(CPYARYR8,JPVOLD)

C  UPDATE PORE VOLUMES
      CALL CALLWORK(XPORE,JPOR)

C  BACKSOLVE FOR MASS CHANGES
      CALL CALLWORK(XFLOW,JFLOW)
      CALL CALLWORK(XWFLOW,JWFLOW)
      CALL TIMOFF(26)
$DUAL      CALL XDUALFLOW()
      IF (LEVELE .AND. BUGKEY(10) .AND.
     &    TIM >= DUMPTIME1 .AND. TIM <= DUMPTIME2) THEN
         DO IC = 1,NCPRT
            CNAME=CMPNAM(IC)
            WRITE(TITU,'(3A)') 'CHANGE IN ',CNAME,' FOR FAULT BLOCK'
            CALL GEAOUT(N_DELC,IC,1)
         END DO
      ENDIF

C  UPDATE CONCENTRATIONS
      CALL TIMON(26)
      CALL CALLWORK(XCONC,JCONC)
      CALL TIMOFF(26)
$MANY         CALL TIMON(5)

      IF (OVERSHT.GT.0.D0) THEN
$MANY         DUM = ONE/OVERSHT
$MANY         CALL MAXIT(1,DUM)
$MANY         CALL SPREAD8(1,DUM)
$MANY         OVERSHT = ONE/DUM
      ENDIF

! bag8 - prevent division by zero
!$MANY         DUM = OVERSHT
!$MANY         CALL MINIT(1,DUM)
!$MANY         CALL SPREAD8(1,DUM)
!$MANY         OVERSHT = DUM

$MANY         CALL TIMOFF(5)

      IF (LEVELE .AND. BUGKEY(11) .AND.
     &    TIM >= DUMPTIME1 .AND. TIM <= DUMPTIME2) THEN
         TITU='PRESSURE FOR FAULT BLOCK'
         CALL GEAOUT(N_PRES,1,1)
         DO IC = 1,NCPRT
            CNAME=CMPNAM(IC)
            WRITE(TITU,'(3A)') 'CONCENTRATION ',CNAME,' FOR FAULT BLOCK'
            CALL GEAOUT(N_CONC,IC,1)
         END DO
      ENDIF

      RETURN
C-----------------------------------------
C  NEWTONIAN ITERATION CONVERGED OR FAILED
C  UPDATE WELL DATA AND BALANCES AT END OF TIME STEP
C  NOTE: XWELFLOW GATHERED CELL PRESSURES IN XSTEP1
C  UPDATE TEMPERATURE IN RESERVOIR AFTER FLOW CONVERGES
C  PROGRAM HALTS AFTER XSTEP3 IF KONVG = 3
C-----------------------------------------
    1 CONTINUE
      NEWPV = .FALSE.
      NEWFLASH = .FALSE.
C-----------------------------------------
C   AQUEOUS PHASE TRACER TRANSPORT
      IF (NAQ>0.AND.KONVG==1) THEN
CGUS---- USAGE OF N_PMDEN ARRAY CONFLICTS IN XPHDENS & XPHMDENS
C        FOR THERMAL
         CALL CALLWORK(XPHDENS,JPHDENS)
         CALL CALLWORK(XVELCOMP,JVEL)
         CALL CALLWORK(XPHMDENS,JPHDENS)
         CALL CALLWORK(XFLOWAQ,JFLOWAQ)
         I4UTIL=NPH
         JCPY(2)=N_PMDEN
         JCPY(3)=N_PMDENN
         CALL CALLWORK(CPYARYR8N,JCPY)
      ENDIF

    5 CONTINUE
C     UPDATE WELL RATES
C     NOTE THAT WPRES AND WELBHP HAVE BEEN UPDATED IN XSTEP1
C     BEFORE COMING TO THIS POINT
      CALL TIMON(10)
      CALL XRATE
      CALL TIMOFF(10)

C     GATHER WELL RESULTS FROM PROCESSORS (WELL_COMP,WELL_PH,WELBHP,WELDEN)
C     WELDEN AND WELBHP REQUIRED FOR RESTARTS
$MANY      CALL TIMON(25)
$MANY      DO N = 1,NUMWEL
$MANY         IF(NWELPRC(N) == 0 .OR. MODWEL(N) /= MODACT) CYCLE
$MANY         IF(NWELPRC(N) == MYPRC) THEN
$MANY            K = 0
$MANY            DO IC = 1,NC
$MANY               K = K + 1
$MANY               WSUM(K,N) = WELL_COMP(IC,N)
$MANY            END DO
$MANY            DO IPH = 1,NPH
$MANY               K = K + 1
$MANY               WSUM(K,N) = WELL_PH(IPH,N)
$MANY            END DO
$MANY            K = K + 1
$MANY            WSUM(K,N) = WELBHP(N)
$MANY            K = K + 1
$MANY            WSUM(K,N) = WELDEN(N)
$MANY         ENDIF
$MANY      END DO              
$MANY      CALL WELGET(KSEND,WSUM)
$MANY      IF(MYPRC == 0) THEN
$MANY         DO N = 1,NUMWEL
$MANY            IF(NWELPRC(N) == 0 .OR. MODWEL(N) /= MODACT) CYCLE
$MANY            K = 0
$MANY            DO IC = 1,NC
$MANY               K = K + 1
$MANY               WELL_COMP(IC,N) = WSUM(K,N)
$MANY            END DO
$MANY            DO IPH = 1,NPH
$MANY               K = K + 1
$MANY               WELL_PH(IPH,N) = WSUM(K,N)
$MANY            END DO
$MANY            K = K + 1
$MANY            WELBHP(N) = WSUM(K,N)
$MANY            K = K + 1
$MANY            WELDEN(N) = WSUM(K,N)
$MANY         END DO  
$MANY      ENDIF
$MANY      CALL TIMOFF(25)

      IF (MYPRC == 0) THEN

         DO IC = 1,NC
            WCOMP(IC) = ZERO
         END DO

         DO  N = 1,NUMWEL
            IF (MODWEL(N) /= MODACT .OR. IWTYPE(N) == 0) CYCLE
            WSHUTCHK = .TRUE.
            WELL_CSUM(N) = ZERO
            IF(IWTYPE(N) == -1) THEN
               CALL WELLOUT(N,1,WELL_PH(1,N)*CVMWELL)
               WTOT_PH(NPH+1,N) = WTOT_PH(NPH+1,N)
     &                          + WELL_PH(1,N)*DELTIM
               WTOT_COMP(NC+1,N) = WTOT_COMP(NC+1,N)
     &                           + WELL_COMP(1,N)*DELTIM
            ELSEIF(IWTYPE(N) > 0) THEN
               CALL WELLOUT(N,3,-WELL_PH(1,N)*CVMWELL)
               IF(NPH > 2) THEN
                  CALL WELLOUT(N,2,-WELL_PH(2,N)*CVMWELL)
                  IF(WELL_PH(2,N) < ZERO) THEN
                     X = WELL_PH(1,N)/WELL_PH(2,N)
                     CALL WELLOUT(N,5,X)
                  ENDIF
                  CALL WELLOUT(N,4,-WELL_PH(3,N)*CVMWELG)
                  IF(WELL_PH(2,N) < ZERO) THEN
                     X = WELL_PH(3,N)*CVMWELG/(WELL_PH(2,N)*CVMWELL)
                     CALL WELLOUT(N,6,X)
                  ENDIF
                  DO IC=1,NHC
                     IF(WELXOUT(IC,N))
     &               CALL WELLOUT(N,9+2*IC,-WELL_COMP(IC+1,N))
                  END DO
               ELSEIF(NPH == 2) THEN
                  IF(PHNAM(2) == 'OIL') THEN
                     CALL WELLOUT(N,2,-WELL_PH(2,N)*CVMWELL)
                     IF(WELL_PH(2,N) < ZERO) THEN
                        X = WELL_PH(1,N)/WELL_PH(2,N)
                        CALL WELLOUT(N,5,X)
                     ENDIF
                  ELSE
                     CALL WELLOUT(N,4,-WELL_PH(2,N)*CVMWELG)
                     DO IC=1,NHC
                        IF(WELXOUT(IC,N))
     &                  CALL WELLOUT(N,9+2*IC,-WELL_COMP(IC+1,N))
                     END DO
                  ENDIF
               ENDIF
               DO IPH = 1,NPH
                  WTOT_PH(IPH,N) = WTOT_PH(IPH,N)
     &                           - WELL_PH(IPH,N)*DELTIM
               END DO
               DO IC = 1,NC
                  WTOT_COMP(IC,N) = WTOT_COMP(IC,N)
     &                            - WELL_COMP(IC,N)*DELTIM
               END DO
            ELSEIF(IWTYPE(N) == -2) THEN
               CALL WELLOUT(N,8,WELL_PH(3,N)*CVMWELG)
               DO IC=1,NHC
                  IF(WELXOUT(IC,N))
     &            CALL WELLOUT(N,9+2*IC-1,WELL_COMP(IC+1,N))
               END DO
               DO IPH = 1,NPH
                  WTOT_PH(NPH+IPH,N) = WTOT_PH(NPH+IPH,N)
     &                               + WELL_PH(IPH,N)*DELTIM
               END DO
               DO IC = 1,NC
                  WTOT_COMP(NC+IC,N) = WTOT_COMP(NC+IC,N)
     &                               + WELL_COMP(IC,N)*DELTIM
               END DO
            ENDIF
            CALL WELLOUT(N,7,WELBHP(N)*CVMPRES)

            DO IC = 1,NC
               WCOMP(IC) = WCOMP(IC) + WELL_COMP(IC,N)
               WELL_MOLFR(IC,N) = ZERO
               WELL_CSUM(N) = WELL_CSUM(N) + WELL_COMP(IC,N)
            END DO
            DO IC = 1,NC
               IF(WELL_CSUM(N) < ZERO)
     &            WELL_MOLFR(IC,N) = WELL_COMP(IC,N)/WELL_CSUM(N)
               WSHUTCHK = WSHUTCHK .AND. (WELL_MCUT(IC,N) >= ZERO)
     &                  .AND. (WELL_MOLFR(IC,N) >= WELL_MCUT(IC,N))
               IF(.NOT.WSHUTCHK) EXIT
            END DO
            IF(WSHUTCHK) THEN
               IWTYPE(N) = 0
               WRITE(0,*) "SHUTTING-IN WELL ",N," AT TIME ",TIM
               IF(LEVELC) WRITE(NFOUT,7) 'SHUTTING-IN WELL ',N,
     &                                   ' AT TIME ',TIM
    7          FORMAT(A17,1X,I4,A9,2X,F15.4)
            ENDIF
         END DO

         IF((NHISUSE == 0).AND.(NSTEP < 1)) RETURN

         DO IC = 1,NC
            BALANCE(IC,MODACT,2) = DELTIM*WCOMP(IC)
            WTOTL(IC) = WTOTL(IC) + BALANCE(IC,MODACT,2)
         END DO

         IF (BUGKEY(9) .AND. TIM >= DUMPTIME1 .AND.
     &       TIM <= DUMPTIME2) THEN
            DO IW = 1,NUMWEL
               IF (MODWEL(IW) == MODACT) THEN
                  WRITE (NFBUG,'(A,I4,3X,10G12.5)')
     &                ' XSTEP3 WELL PHASES ',IW,(WELL_PH(I,IW),I=1,NPH)
               ENDIF
            END DO
         ENDIF
      ENDIF

      IF((NHISUSE == 0).AND.(NSTEP < 1)) RETURN
$MANY      CALL SPREAD(NUMWEL,IWTYPE)

      DO IC = 1,NC
         BALANCE(IC,MODACT,1) = CURRENT(IC)
         BALANCE(IC,MODACT,3) = FLUXOM(IC)
      END DO

      IF (LEVELD .AND. BUGKEY(8)) THEN
         DO IC = 1,NCPRT
            X = CURRENT(IC) + BALANCE(IC,MODACT,4)
            IF(X > ZERO) THEN
               X = ONE + TWO*( (CURRENT(IC)-BALANCE(IC,MODACT,4)
     &              -WTOTL(IC)) / X )
            ELSE
               X = ONE
            ENDIF
            WRITE(NFBUG,'(A,G15.6,I5,F20.12)')
     &         ' MATERIAL BALANCE, tim,ic,value ',
     &          TIM,IC,X
         END DO
      ENDIF

C-------update temperature of reservoir
      IF(XTHERMAL .AND. (KONVG == 1)) THEN
         CALL TIMON(6)
         THDTIM=DELTIM/NTHSTEP
         CALL CALLWORK(XPHDENS,JPHDENS)
         CALL CALLWORK(XMASSFRAC_ALL,JMFRW)
         IF (HYSTERESIS.AND.(((NPH > 2).AND.AQPHSWTCH).OR.(NPH == 2)))
     &   THEN
            CALL CALLWORK(XHYSRLPRM2,JHYST)
         ELSE
            CALL CALLWORK(XRELPERM2,JRELP)
         ENDIF
$MANY         CALL TIMON(3)
$MANY         CALL UPDATE(N_PRES,1)
$MANY         CALL UPDATE(N_PC,1)
$MANY         CALL UPDATE(N_PMD,1)
$MANY         CALL UPDATE(N_PMDEN,1)
$MANY         CALL UPDATE(N_PMDENN,1)
$MANY         CALL UPDATE(N_MOB,1)
$MANY         CALL TIMOFF(3)
         CALL CALLWORK(XVELCOMP,JVEL)
         THTFAC=ZERO
         CALL CALLWORK(XSPHEAT,JSPHT)
         CALL XTHCAPACITY(IOLD)
         THTFAC=ONE
         CALL CALLWORK(XSPHEAT,JSPHT)
         CALL XTHCAPACITY(INEW)
         DO ITHSTEP=1,NTHSTEP
            THTIM=TIM+(ITHSTEP-1)*THDTIM
            THTIM_NEW=THTIM+THDTIM
            THTIM_HALF=THTIM+HALF*THDTIM
            CALL XTHSTEP(NERR)
         END DO
         I4UTIL=NPH*3
         JCPY(2)=N_XVEL
         JCPY(3)=N_XVELN
         CALL CALLWORK(CPYARYR8N,JCPY)
         I4UTIL=NCINPH
         JCPY(2)=N_KSI
         JCPY(3)=N_KSIN
         CALL CALLWORK(CPYARYR8N,JCPY)
         I4UTIL=NPH
         JCPY(2)=N_PMDEN
         JCPY(3)=N_PMDENN
         CALL CALLWORK(CPYARYR8N,JCPY)
         CALL TIMOFF(6)
      ENDIF

C-------calculate average reservoir pressure
      CALL TIMON(6)
      PAVG = ZERO
      PVTOTL = ZERO
      CALL CALLWORK(XPAVG,JPAVG)
      CALL TIMOFF(6)
$MANY      CALL TIMON(5)
$MANY      TEMP(1) = PAVG
$MANY      TEMP(2) = PVTOTL
$MANY      CALL SUMIT(2,TEMP)
$MANY      PAVG = TEMP(1)
$MANY      PVTOTL = TEMP(2)
      IF(MYPRC == 0 .AND. PVTOTL > ZERO) PAVG = PAVG/PVTOTL
$MANY      CALL SPREAD8(1,PAVG)
$MANY      CALL TIMOFF(5)

C-------set factor for STEPMULT for next timestep
      IF( ( NEWT > 4 .OR. .NOT.ONLY_COMP ) .AND. KONVG == 1 ) THEN

C        saturation change for timestep (aqueous and nonaqueous only)
         CALL TIMON(6)
         DSMAX = -ONE
         CALL CALLWORK(XSAT_STEP,JSATM)
         CALL TIMOFF(6)

$MANY         CALL TIMON(5)
$MANY         CALL MAXIT(1,DSMAX)
$MANY         CALL SPREAD8(1,DSMAX)
$MANY         CALL TIMOFF(5)

C        note: locations are not correct when run in parallel
         IF (BUGKEY(6).AND.MYPRC.EQ.0) THEN
            WRITE(NFBUG,'(A,G15.6,I3,G15.6,4I5)')
     &         ' SATURATION CHANGE, tim,newt,value,i,j,k,nblk ',
     &          TIM,NEWT,DSMAX,ISMAX,JSMAX,KSMAX,NSMAX
            WRITE(*,'(A,G15.6,I3,G15.6,4I5)')
     &         ' SATURATION CHANGE, tim,newt,value,i,j,k,nblk ',
     &          TIM,NEWT,DSMAX,ISMAX,JSMAX,KSMAX,NSMAX
         ENDIF
      ENDIF

      IF(DSMAX > ZERO) THEN
         STEPMULT = DSMAX_TARG/DSMAX
         IF (BUGKEY(6).AND.MYPRC.EQ.0) THEN
           WRITE(*,*)'STEPMULT,DSMAX_TARG,DSMAX=',
     &       STEPMULT,DSMAX_TARG,DSMAX
         ENDIF
      ELSE
         STEPMULT = BIG
      ENDIF
C
C     check stability limits (currently ignores faults)
      DTSTAB = BIG
      IF(ICFLCHK > 0) THEN
C        set initial values to zero and calculate well contribution
         CALL TIMON(6)
         CALL CALLWORK(XWSTAB,JWSTAB)
         IF(NPH == 3) THEN
            JGSTAB(2) = N_TCOFX
            CALL CALLWORK(XGSTABX3,JGSTAB)
            JGSTAB(2) = N_TCOFY
            CALL CALLWORK(XGSTABY3,JGSTAB)
            JGSTAB(2) = N_TCOFZ
            CALL CALLWORK(XGSTABZ3,JGSTAB)
         ELSEIF(NPH == 2) THEN
            JGSTAB(2) = N_TCOFX
            CALL CALLWORK(XGSTABX2,JGSTAB)
            JGSTAB(2) = N_TCOFY
            CALL CALLWORK(XGSTABY2,JGSTAB)
            JGSTAB(2) = N_TCOFZ
            CALL CALLWORK(XGSTABZ2,JGSTAB)
         ENDIF
         CALL CALLWORK(XSTABCHK,JSTABCHK)

         CALL TIMOFF(6)
$MANY         CALL TIMON(5)

         IF (DTSTAB.GT.0.D0) THEN
$MANY         DUM = ONE/DTSTAB
$MANY         CALL MAXIT(1,DUM)
$MANY         CALL SPREAD8(1,DUM)
$MANY         DTSTAB = ONE/DUM
         ENDIF

! bag8 - prevent division by zero
!$MANY         DUM = DTSTAB
!$MANY         CALL MINIT(1,DUM)
!$MANY         CALL SPREAD8(1,DUM)
!$MANY         DTSTAB = DUM

$MANY         CALL TIMOFF(5)

C        note: locations are not correct when run in parallel
         IF (BUGKEY(6).AND.MYPRC.EQ.0) THEN
            WRITE(NFBUG,'(A,G15.6,I3,G15.6,4I5)')
     &         ' STABLE TIMESTEP, tim,newt,value,i,j,k,nblk ',
     &          TIM,NEWT,DTSTAB,ICFLMAX,JCFLMAX,KCFLMAX,NCFLMAX
            WRITE(*,'(A,G15.6,I3,G15.6,4I5)')
     &         ' STABLE TIMESTEP, tim,newt,value,i,j,k,nblk ',
     &          TIM,NEWT,DTSTAB,ICFLMAX,JCFLMAX,KCFLMAX,NCFLMAX
         ENDIF
      ENDIF

      RETURN
C-----------------------------------------
C  TIME STEP CUT
C-----------------------------------------
    4 CONTINUE
      STEPCUT = .TRUE.
      NEWPV = .TRUE.
      NEWFLASH = .TRUE.

C     RESET REFERENCE PRESSURE
      CALL TIMON(6)
      JFLD(2) = N_PRESN
      JFLD(3) = N_PRES
      CALL CALLWORK(CPYARYR8,JFLD)

C     RESET CONCENTRATIONS
      I4UTIL = NC
      JCOPY(2) = N_CONCN
      JCOPY(3) = N_CONC
      CALL CALLWORK(CPYARYR8N,JCOPY)

C     RESET AQUEOUS CONCENTRATIONS
      I4UTIL = NAQ
      JCOPY(2) = N_CONCAQN
      JCOPY(3) = N_CONCAQ
      CALL CALLWORK(CPYARYR8N,JCOPY)

C     RESET PHASE SATURATIONS
      I4UTIL = NPH
      JCOPY(2) = N_SATN
      JCOPY(3) = N_SAT
      CALL CALLWORK(CPYARYR8N,JCOPY)

C     RESET FLUID POINTERS
      JFLD(2) = N_FLDPNTN
      JFLD(3) = N_FLDPNT
      CALL CALLWORK(CPYARYI4,JFLD)

C     RESET K-VALUES
      I4UTIL = NHC
      JCOPY(2) = N_FLKN
      JCOPY(3) = N_FLK
      IF(NPH > 2) CALL CALLWORK(CPYARYR8N,JCOPY)
      CALL TIMOFF(6)

      END

c----------------------------------------------------------------------
      SUBROUTINE XMAXRESID(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &  KL1,KL2,KEYOUT,NBLK,XRESID)
c----------------------------------------------------------------------
      IMPLICIT NONE
      INCLUDE 'layout.h'
      INCLUDE 'xbaldat.h'
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V(KDIM),JL2V(KDIM),
     &        KL1,KL2,KEYOUT(IDIM,JDIM,KDIM),NBLK
      REAL*8 XRESID(IDIM,JDIM,KDIM)
      INTEGER I,J,K,IOFF,JOFF,KOFF,MERR
      REAL*8 DX,DY,DZ,H,R

      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,MERR)
      DO 1 K=KL1,KL2
      DZ=DZREC(K+KOFF,NBLK)
      DO 1 J=JL1V(K),JL2V(K)
      DY=DYREC(J+JOFF,NBLK)
      DO 1 I=IL1,IL2
      DX=DXREC(I+IOFF,NBLK)
      IF (KEYOUT(I,J,K).EQ.1) THEN
         R=XRESID(I,J,K)
         RESIDT(1)=RESIDT(1)+R
         H = SQRT(DX**2+DY**2+DZ**2)
         RESID2(1)=RESID2(1)+H**2*R**2
         IF (ABS(R).GT.RESIDM(1)) THEN
            RESIDM(1)=ABS(R)
         ENDIF
      ENDIF
    1 CONTINUE

      END

