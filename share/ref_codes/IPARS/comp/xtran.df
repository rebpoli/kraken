C  XTRAN.F - TRANSPORT EVALUATION FOR DIAGONAL TENSOR PERMEABILITY
C  COMPOSITIONAL IMPEC MODEL

C  ROUTINES IN THIS MODULE:

C  SUBROUTINE XCOND(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                   KEYOUT,NBLK,XCOF,XRESID,DFLOW,TFLOW,RESID, 
C                   ERRSAT,DSTDP,DSTDN,PV,SCAL)

C  SUBROUTINE XTRANX (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                     KEYOUT,NBLK,TCOF,DEPTH,PRES,MDEN,MOBPROD,TFLOW,
C                     DFLOW,RESID)

C  SUBROUTINE XTRANY (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                     KEYOUT,NBLK,TCOF,DEPTH,PRES,MDEN,MOBPROD,TFLOW,
C                     DFLOW,RESID)

C  SUBROUTINE XTRANZ (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                     KEYOUT,NBLK,TCOF,DEPTH,PRES,MDEN,MOBPROD,TFLOW,
C                     DFLOW,RESID)

C  SUBROUTINE XFLOW(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                   KEYOUT,NBLK,CONC,DFLOW,TFLOW,RESID,DELP,CR,DELC)

C  SUBROUTINE XCONC (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
C                    KL1,KL2,KEYOUT,NBLK,CONC,DELC,PV,PVOLD)

C  SUBROUTINE XSAT_STEP(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
C                       KL1,KL2,KEYOUT,NBLK,CONCN,CONC,DSTDN,ICFL)

C  SUBROUTINE XSCALE (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
C                     KL1,KL2,KEYOUT,NBLK,VNEW,VOLD,NUM,SCAL)

C  SUBROUTINE XSCALEK (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
C                      KL1,KL2,KEYOUT,NBLK,VNEW,VOLD,NUM,SCAL)

C  SUBROUTINE XPAVG (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
C                    KL1,KL2,KEYOUT,NBLK,PRES,PV)

C  SUBROUTINE XGSTABX3(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                      KEYOUT,NBLK,TCOF,DEPTH,PRES,MDEN,MOB,DCFL, 
C                      PC,DMOB,DPC,ICFL)

C  SUBROUTINE XGSTABY3(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                      KEYOUT,NBLK,TCOF,DEPTH,PRES,MDEN,MOB,DCFL, 
C                      PC,DMOB,DPC,ICFL)

C  SUBROUTINE XGSTABZ3(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                      KEYOUT,NBLK,TCOF,DEPTH,PRES,MDEN,MOB,DCFL, 
C                      PC,DMOB,DPC,ICFL)

C  SUBROUTINE XGSTABX2(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                      KEYOUT,NBLK,TCOF,DEPTH,PRES,MDEN,MOB,DCFL, 
C                      PC,DMOB,DPC,ICFL)

C  SUBROUTINE XGSTABY2(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                      KEYOUT,NBLK,TCOF,DEPTH,PRES,MDEN,MOB,DCFL, 
C                      PC,DMOB,DPC,ICFL)

C  SUBROUTINE XGSTABZ2(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                      KEYOUT,NBLK,TCOF,DEPTH,PRES,MDEN,MOB,DCFL, 
C                      PC,DMOB,DPC,ICFL)

C  SUBROUTINE XSTABCHK(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                      KEYOUT,NBLK,PV,PMD,SAT,DCFL,ICFL)

C  SUBROUTINE XFLOWAQ(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                      KEYOUT,NBLK,POR,VEL,PV,PVN,PMDEN,PMDENN,SAT,
C                      SATN,CONC,CONCN)
C  CODE HISTORY:

C  RICK DEAN        06/28/01   INITIAL VERSION
C  RICK DEAN        12/31/02   ADDED OVERSHOOT AND STABILITY LOGIC
C  SUNIL G. THOMAS  09/01/07   BUG FIX IN XSTABCHK
C  GURPREET SINGH   09/15/15   AQUEOUS COMPONENTS
C*********************************************************************
      SUBROUTINE XCOND(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                 KEYOUT,NBLK,XCOF,XRESID,DFLOW,TFLOW,RESID, 
     &                 ERRSAT,DSTDP,DSTDN,PV,SCAL)
C*********************************************************************

C Produces IMPEC equations from mass conservation equations

C  INPUT:
C     TFLOW(I,J,K,IC,IDIR) = OFF-DIAGONAL FLOW COEFFICIENT FOR P(I-1,J,K) 
C                            IN (I,J,K,IC) MASS CONSERVATION EQUATION (REAL*8)
C     RESID(I,J,K,IC) = RESIDUAL FOR RIGHT HAND SIDE (REAL*8)
C     DFLOW(I,J,K,IC) = DIAGONAL FLOW COEFFICIENT FOR P(I,J,K) 
C                       IN (I,J,K,IC) MASS CONSERVATION EQUATION (REAL*8)

C  OUTPUT:
C     XCOF(I,J,K,L) = IMPEC FLOW COEFFICENTS (REAL*4)
C     XRESID(I,J,K) = IMPEC RESIDUAL FOR RIGHT HAND SIDE (REAL*8)
C     SCAL(I,J,K,IC) = SCALING FACTOR FOR IMPEC (REAL*8)

C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xmodel.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER KL1,KL2,IL1,IL2,IDIM,JDIM,KDIM,NBLK,LDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*4 XCOF(IDIM,JDIM,KDIM,$NUMCOF)
      REAL*8 XRESID(IDIM,JDIM,KDIM),ERRSAT(IDIM,JDIM,KDIM),
     &       DSTDN(IDIM,JDIM,KDIM,NC),RESID(IDIM,JDIM,KDIM,NC),
     &       TFLOW(IDIM,JDIM,KDIM,NC,3),DFLOW(IDIM,JDIM,KDIM,NC),
     &       DSTDP(IDIM,JDIM,KDIM),PV(IDIM,JDIM,KDIM),
     &       SCAL(IDIM,JDIM,KDIM,NC)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER I,J,K,L,IC,IM1,JM1,KM1,JL1(KDIM),JL2(KDIM),KL2P,IL2P

      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)'PROC',MYPRC,
     &  ' ENTERING SUBROUTINE XCOND, OLD TAG =',MSGTAG($IMODEL+1)
      IL2P=IL2+1
      KL2P=KL2+1

C-------set up JL1 and JL2 vectors
      JL1(KL1)=JL1V(KL1)
      JL2(KL1)=JL2V(KL1)
      DO K = KL1+1,KL2
         JL1(K)=MIN(JL1V(K-1),JL1V(K))
         JL2(K)=MAX(JL2V(K-1),JL2V(K))
      END DO
      JL1(KL2P)=JL1V(KL2)
      JL2(KL2P)=JL2V(KL2)

C-------scale dstdn by pv, use xresid for storage
      DO K = KL1,KL2
      DO J = JL1V(K),JL2V(K)
      DO I = IL1,IL2
         IF(KEYOUT(I,J,K) > 0) THEN
            XRESID(I,J,K) = ONE / PV(I,J,K)
            SCAL(I,J,K,1) = DSTDN(I,J,K,1) * XRESID(I,J,K)
         ENDIF
      END DO
      END DO
      END DO
      DO IC = 2,NC
         DO K = KL1,KL2
         DO J = JL1V(K),JL2V(K)
         DO I = IL1,IL2
            IF(KEYOUT(I,J,K) > 0) THEN
               SCAL(I,J,K,IC) = DSTDN(I,J,K,IC) * XRESID(I,J,K)
            ENDIF
         END DO
         END DO
         END DO
      END DO

C-------initialize XRESID and XCOF
C       Note: JL2V(KL2+1) is not defined
      DO K = KL1,KL2
      DO J = JL1V(K),JL2V(K)+1
      DO I = IL1,IL2+1
         IF(KEYOUT(I,J,K) > 0) THEN
            XRESID(I,J,K)= ERRSAT(I,J,K) 
            XCOF(I,J,K,1)= DSTDP(I,J,K) 
         ELSE
            XRESID(I,J,K) = ZERO
            XCOF(I,J,K,1) = SZERO
         ENDIF
         XCOF(I,J,K,2) = SZERO
         XCOF(I,J,K,3) = SZERO
         XCOF(I,J,K,4) = SZERO
         XCOF(I,J,K,5) = SZERO
         XCOF(I,J,K,6) = SZERO
         XCOF(I,J,K,7) = SZERO
      END DO
      END DO
      END DO
      DO J = JL1V(KL2),JL2V(KL2)+1
      DO I = IL1,IL2+1
         XCOF(I,J,KL2P,1)= SZERO
         XCOF(I,J,KL2P,2) = SZERO
         XCOF(I,J,KL2P,3) = SZERO
         XCOF(I,J,KL2P,4) = SZERO
         XCOF(I,J,KL2P,5) = SZERO
         XCOF(I,J,KL2P,6) = SZERO
         XCOF(I,J,KL2P,7) = SZERO
      END DO
      END DO

C-------process components
      DO IC = 1,NC

C        direction 1
         DO K = KL1,KL2
         DO J = JL1V(K),JL2V(K)
         DO I = IL1,IL2P
            IF(KEYOUT(I,J,K) > 0) THEN
               XRESID(I,J,K) = XRESID(I,J,K) 
     &                       + SCAL(I,J,K,IC)*RESID(I,J,K,IC)
               XCOF(I,J,K,1) = XCOF(I,J,K,1) 
     &                       - SCAL(I,J,K,IC)*DFLOW(I,J,K,IC)
            ENDIF
            IF(TFLOW(I,J,K,IC,1) == ZERO) CYCLE
            IF(KEYOUT(I,J,K) > 0) XCOF(I,J,K,2) = XCOF(I,J,K,2)
     &                            + SCAL(I,J,K,IC)*TFLOW(I,J,K,IC,1)
            IF(KEYOUT(I-1,J,K) > 0) XCOF(I-1,J,K,3) = XCOF(I-1,J,K,3)
     &                              + SCAL(I-1,J,K,IC)*TFLOW(I,J,K,IC,1)
         END DO
         END DO
         END DO

C        direction 2
         DO K = KL1,KL2
         DO J = JL1V(K),JL2V(K)+1
         JM1 = J-1
         DO I = IL1,IL2
            IF(TFLOW(I,J,K,IC,2) == ZERO) CYCLE
            IF(KEYOUT(I,J,K) > 0) XCOF(I,J,K,4) = XCOF(I,J,K,4)
     &                            + SCAL(I,J,K,IC)*TFLOW(I,J,K,IC,2)
            IF(KEYOUT(I,JM1,K) > 0) XCOF(I,JM1,K,5) = XCOF(I,JM1,K,5)
     &                              + SCAL(I,JM1,K,IC)*TFLOW(I,J,K,IC,2)
         END DO
         END DO
         END DO

C        direction 3
         DO K = KL1,KL2P
         KM1 = K-1
         DO J = JL1(K),JL2(K)
         DO I = IL1,IL2
            IF(TFLOW(I,J,K,IC,3) == ZERO) CYCLE
            IF(KEYOUT(I,J,K) > 0) XCOF(I,J,K,6) = XCOF(I,J,K,6)
     &                          + SCAL(I,J,K,IC)*TFLOW(I,J,K,IC,3)
            IF(KEYOUT(I,J,KM1) > 0) XCOF(I,J,KM1,7) = XCOF(I,J,KM1,7)
     &                              + SCAL(I,J,KM1,IC)*TFLOW(I,J,K,IC,3)
         END DO
         END DO
         END DO
      END DO

      END

C*********************************************************************
      SUBROUTINE XTRANX(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                  KEYOUT,NBLK,TCOF,DEPTH,PRES,MDEN,MOBPROD,TFLOW, 
     &                  DFLOW,RESID,PC)
C*********************************************************************

C  INPUT:
C     TCOF(I,J,K) = TRANSMISSIBILITY BETWEEN CELL I AND I-1 (REAL*8)
C     DEPTH(I,J,K) = CELL DEPTH (REAL*8)
C     PRES(I,J,K) = PRESSURE (REAL*8)
C     MOBPROD(I,J,K,L) = MOBILITY X MOLE FRACTION X MOLAR DENSITY (REAL*8)
C                        VALUE OF L DETERMINED BY ICINPH(IC,IPH)
C     MDEN(I,J,K,IPH) = MASS DENSITY FOR PHASE IPH (REAL*8)
C     PC(I,J,K,IPH) = CAPILLARY PRESSURE FOR PHASE IPH (REAL*8)

C  INPUT/OUTPUT:
C     RESID(I,J,K,IC) = RESIDUAL FOR RIGHT HAND SIDE (REAL*8)
C     DFLOW(I,J,K,IC) = DIAGONAL FLOW COEFFICIENT FOR P(I,J,K) 
C                       IN (I,J,K,IC) MASS CONSERVATION EQUATION (REAL*8)

C  OUTPUT:
C     TFLOW(I,J,K,IC,IDIR) = OFF-DIAGONAL FLOW COEFFICIENT FOR P(I-1,J,K) 
C                            IN (I,J,K,IC) MASS CONSERVATION EQUATION (REAL*8)

C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xmodel.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER KL1,KL2,IL1,IL2,IDIM,JDIM,KDIM,NBLK,LDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 TCOF(IDIM,JDIM,KDIM),DEPTH(IDIM,JDIM,KDIM),
     &       PRES(IDIM,JDIM,KDIM),RESID(IDIM,JDIM,KDIM,NC),
     &       TFLOW(IDIM,JDIM,KDIM,NC,1),DFLOW(IDIM,JDIM,KDIM,NC),
     &       MDEN(IDIM,JDIM,KDIM,NPH),MOBPROD(IDIM,JDIM,KDIM,NCINPH),
     &       PC(IDIM,JDIM,KDIM,NPH)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER I,J,K,IL2P,LC,IC,IPH,IMIN,IERR
      REAL*8 DEN,G,TC,COEF,FLUX
!      REAL*8 DELH(IDIM,JDIM,KDIM),DELP(IDIM,JDIM,KDIM)

! bag8
      REAL*8, ALLOCATABLE :: DELH(:,:,:),DELP(:,:,:)
! bag8

      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)'PROC',MYPRC,
     &  ' ENTERING SUBROUTINE XTRANX, OLD TAG =',MSGTAG($IMODEL+1)

! bag8
      ALLOCATE(DELH(IDIM,JDIM,KDIM),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate DELH'
      ALLOCATE(DELP(IDIM,JDIM,KDIM),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate DELP'
! bag8

C  SET GRAVITY CONSTANT TO .5 g  
      G = HALF*GRAV
      IL2P = IL2+1
      IMIN = MAX(IL1,2)

C-------set difference in depth times half gravity
      DO K = KL1,KL2
      DO J = JL1V(K),JL2V(K)
      DO I = IMIN,IL2P
         DELH(I,J,K) = G *(DEPTH(I,J,K)-DEPTH(I-1,J,K))
      END DO
      END DO
      END DO

C-------zero initial coefficients
      IF(XNO_DD) THEN
         DO IC = 1,NC
         DO K = KL1,KL2
         DO J = JL1V(K),JL2V(K)
         DO I = IL1,IL2P
            TFLOW(I,J,K,IC,1) = ZERO
         END DO
         END DO
         END DO
         END DO
      ENDIF
         
      DO IPH = 1,NPH     

C----------setup up potential for phase IPH 
         DO K = KL1,KL2
         DO J = JL1V(K),JL2V(K)
         DO I = IMIN,IL2P
            DEN =  MDEN(I,J,K,IPH) + MDEN(I-1,J,K,IPH) 
            IF(MDEN(I,J,K,IPH) == ZERO .OR.
     &         MDEN(I-1,J,K,IPH) == ZERO) DEN = TWO*DEN
            DELP(I,J,K) = (PRES(I,J,K)-PRES(I-1,J,K))
     &                  + (PC(I,J,K,IPH)-PC(I-1,J,K,IPH)) 
     &                  - DEN*DELH(I,J,K)
         END DO
         END DO
         END DO

C----------add contribution for each component in phase IPH
         DO IC = 1,NC
            LC = ICINPH(IC,IPH)
            IF (LC == 0) CYCLE
            DO K = KL1,KL2
            DO J = JL1V(K),JL2V(K)
            DO I = IL1,IL2P
               TC = TCOF(I,J,K)*DELTIM
               IF(TC == ZERO) CYCLE
               IF(DELP(I,J,K) > ZERO ) THEN
                  COEF = TC*MOBPROD(I,J,K,LC)
               ELSEIF(DELP(I,J,K) < ZERO ) THEN
                  COEF = TC*MOBPROD(I-1,J,K,LC)
               ELSE
                  COEF = TC*HALF*(MOBPROD(I-1,J,K,LC)
     &                 +          MOBPROD(I,J,K,LC))
               ENDIF
               FLUX = COEF*DELP(I,J,K)
               IF(KEYOUT(I,J,K) /= 0) THEN
                  TFLOW(I,J,K,IC,1) = TFLOW(I,J,K,IC,1) + COEF  
                  IF(KEYOUT(I,J,K) > 0) THEN
                     DFLOW(I,J,K,IC) = DFLOW(I,J,K,IC) + COEF
                     RESID(I,J,K,IC) = RESID(I,J,K,IC) + FLUX
                  ENDIF
               ENDIF
               IF(KEYOUT(I-1,J,K) > 0) THEN
                  DFLOW(I-1,J,K,IC) = DFLOW(I-1,J,K,IC) + COEF
                  RESID(I-1,J,K,IC) = RESID(I-1,J,K,IC) - FLUX
               ENDIF
            END DO
            END DO
            END DO 
         END DO
      END DO 

! bag8
      DEALLOCATE(DELH)
      DEALLOCATE(DELP)
! bag8

      END

C*********************************************************************
      SUBROUTINE XTRANY(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                  KEYOUT,NBLK,TCOF,DEPTH,PRES,MDEN,MOBPROD,TFLOW, 
     &                  DFLOW,RESID,PC)
C*********************************************************************

C  INPUT:
C     TCOF(I,J,K) = TRANSMISSIBILITY BETWEEN CELL J AND J-1 (REAL*8)
C     DEPTH(I,J,K) = CELL DEPTH (REAL*8)
C     PRES(I,J,K) = PRESSURE (REAL*8)
C     MOBPROD(I,J,K,L) = MOBILITY X MOLE FRACTION X MOLAR DENSITY (REAL*8)
C                        VALUE OF L DETERMINED BY ICINPH(IC,IPH)
C     MDEN(I,J,K,IPH) = MASS DENSITY FOR PHASE IPH (REAL*8)
C     PC(I,J,K,IPH) = CAPILLARY PRESSURE FOR PHASE IPH (REAL*8)

C  INPUT/OUTPUT:
C     RESID(I,J,K,IC) = RESIDUAL FOR RIGHT HAND SIDE (REAL*8)
C     DFLOW(I,J,K,IC) = DIAGONAL FLOW COEFFICIENT FOR P(I,J,K) 
C                       IN (I,J,K,IC) MASS CONSERVATION EQUATION (REAL*8)

C  OUTPUT:
C     TFLOW(I,J,K,IC,IDIR) = OFF-DIAGONAL FLOW COEFFICIENT FOR P(I,J-1,K) 
C                            IN (I,J,K,IC) MASS CONSERVATION EQUATION (REAL*8)

C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xmodel.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER KL1,KL2,IL1,IL2,IDIM,JDIM,KDIM,NBLK,LDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 TCOF(IDIM,JDIM,KDIM),DEPTH(IDIM,JDIM,KDIM),
     &       PRES(IDIM,JDIM,KDIM),RESID(IDIM,JDIM,KDIM,NC),
     &       TFLOW(IDIM,JDIM,KDIM,NC,2),DFLOW(IDIM,JDIM,KDIM,NC),
     &       MDEN(IDIM,JDIM,KDIM,NPH),MOBPROD(IDIM,JDIM,KDIM,NCINPH),
     &       PC(IDIM,JDIM,KDIM,NPH)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER I,J,K,LC,IC,IPH,JM1,IERR
      REAL*8 DEN,G,TC,COEF,FLUX
!      REAL*8 DELH(IDIM,JDIM,KDIM),DELP(IDIM,JDIM,KDIM)

! bag8
      REAL*8, ALLOCATABLE :: DELH(:,:,:),DELP(:,:,:)
! bag8

      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)'PROC',MYPRC,
     &  ' ENTERING SUBROUTINE XTRANY, OLD TAG =',MSGTAG($IMODEL+1)

! bag8
      ALLOCATE(DELH(IDIM,JDIM,KDIM),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate DELH'
      ALLOCATE(DELP(IDIM,JDIM,KDIM),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate DELP'
! bag8

C  SET GRAVITY CONSTANT TO .5 g  
      G = HALF*GRAV

C-------set difference in depth times half gravity
      DO K = KL1,KL2
         DO J = JL1V(K),JL2V(K)+1
            JM1 = J-1
            IF(JM1 <= 0) CYCLE
            DO I = IL1,IL2
               DELH(I,J,K) = G *(DEPTH(I,J,K)-DEPTH(I,JM1,K))
            END DO
         END DO
      END DO

C-------zero initial coefficients
      IF(XNO_DD) THEN
         DO IC = 1,NC
         DO K = KL1,KL2
         DO J = JL1V(K),JL2V(K)+1
         DO I = IL1,IL2
            TFLOW(I,J,K,IC,2) = ZERO
         END DO
         END DO
         END DO
         END DO
      ENDIF
         
      DO IPH = 1,NPH     

C----------setup up potential for phase IPH 
         DO K = KL1,KL2
         DO J = JL1V(K),JL2V(K)+1
            JM1 = J-1
            IF(JM1 <= 0) CYCLE
            DO I = IL1,IL2
               DEN =  MDEN(I,J,K,IPH) + MDEN(I,JM1,K,IPH) 
               IF(MDEN(I,J,K,IPH) == ZERO .OR.
     &            MDEN(I,JM1,K,IPH) == ZERO) DEN = TWO*DEN
               DELP(I,J,K) = (PRES(I,J,K)-PRES(I,JM1,K))
     &                     + (PC(I,J,K,IPH)-PC(I,JM1,K,IPH)) 
     &                     - DEN*DELH(I,J,K)
            END DO
         END DO
         END DO

C----------add contribution for each component in phase IPH
         DO IC = 1,NC
            LC = ICINPH(IC,IPH)
            IF (LC == 0) CYCLE
            DO K = KL1,KL2
            DO J = JL1V(K),JL2V(K)+1
               JM1 = J-1
               IF(JM1 <= 0) CYCLE
               DO I = IL1,IL2
                  TC = TCOF(I,J,K)*DELTIM
                  IF(TC == ZERO) CYCLE
                  IF(DELP(I,J,K) > ZERO) THEN
                     COEF = TC*MOBPROD(I,J,K,LC)
                  ELSEIF(DELP(I,J,K) < ZERO) THEN
                     COEF = TC*MOBPROD(I,JM1,K,LC)
                  ELSE
                     COEF = TC*HALF*(MOBPROD(I,JM1,K,LC)
     &                    +          MOBPROD(I,J,K,LC))
                  ENDIF
                  FLUX = COEF*DELP(I,J,K)
                  IF(KEYOUT(I,J,K) /= 0) THEN
                     TFLOW(I,J,K,IC,2) = TFLOW(I,J,K,IC,2) + COEF  
                     IF(KEYOUT(I,J,K) > 0) THEN
                        DFLOW(I,J,K,IC) = DFLOW(I,J,K,IC) + COEF
                        RESID(I,J,K,IC) = RESID(I,J,K,IC) + FLUX
                     ENDIF
                  ENDIF
                  IF(KEYOUT(I,JM1,K) > 0) THEN
                     DFLOW(I,JM1,K,IC) = DFLOW(I,JM1,K,IC) + COEF
                     RESID(I,JM1,K,IC) = RESID(I,JM1,K,IC) - FLUX
                  ENDIF
               END DO
            END DO
            END DO 
         END DO
      END DO 

! bag8
      DEALLOCATE(DELH)
      DEALLOCATE(DELP)
! bag8

      END

C*********************************************************************
      SUBROUTINE XTRANZ(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                  KEYOUT,NBLK,TCOF,DEPTH,PRES,MDEN,MOBPROD,TFLOW, 
     &                  DFLOW,RESID,PC)
C*********************************************************************

C  INPUT:
C     TCOF(I,J,K) = TRANSMISSIBILITY BETWEEN CELL K AND K-1 (REAL*8)
C     DEPTH(I,J,K) = CELL DEPTH (REAL*8)
C     PRES(I,J,K) = PRESSURE (REAL*8)
C     MOBPROD(I,J,K,L) = MOBILITY X MOLE FRACTION X MOLAR DENSITY (REAL*8)
C                        VALUE OF L DETERMINED BY ICINPH(IC,IPH)
C     MDEN(I,J,K,IPH) = MASS DENSITY FOR PHASE IPH (REAL*8)
C     PC(I,J,K,IPH) = CAPILLARY PRESSURE FOR PHASE IPH (REAL*8)

C  INPUT/OUTPUT:
C     RESID(I,J,K,IC) = RESIDUAL FOR RIGHT HAND SIDE (REAL*8)
C     DFLOW(I,J,K,IC) = DIAGONAL FLOW COEFFICIENT FOR P(I,J,K) 
C                       IN (I,J,K,IC) MASS CONSERVATION EQUATION (REAL*8)

C  OUTPUT:
C     TFLOW(I,J,K,IC,IDIR) = OFF-DIAGONAL FLOW COEFFICIENT FOR P(I,J,K-1) 
C                            IN (I,J,K,IC) MASS CONSERVATION EQUATION (REAL*8)

C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xmodel.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER KL1,KL2,IL1,IL2,IDIM,JDIM,KDIM,NBLK,LDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 TCOF(IDIM,JDIM,KDIM),DEPTH(IDIM,JDIM,KDIM),
     &       PRES(IDIM,JDIM,KDIM),RESID(IDIM,JDIM,KDIM,NC),
     &       TFLOW(IDIM,JDIM,KDIM,NC,3),DFLOW(IDIM,JDIM,KDIM,NC),
     &       MDEN(IDIM,JDIM,KDIM,NPH),MOBPROD(IDIM,JDIM,KDIM,NCINPH),
     &       PC(IDIM,JDIM,KDIM,NPH)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER I,J,K,LC,IC,IPH,KM1,KL2P,JL1(KDIM),JL2(KDIM),KL1S,IERR
      REAL*8 DEN,G,TC,COEF,FLUX
!      REAL*8 DELH(IDIM,JDIM,KDIM),DELP(IDIM,JDIM,KDIM)

! bag8
      REAL*8, ALLOCATABLE :: DELH(:,:,:),DELP(:,:,:)
! bag8

      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)'PROC',MYPRC,
     &  ' ENTERING SUBROUTINE XTRANZ, OLD TAG =',MSGTAG($IMODEL+1)

! bag8
      ALLOCATE(DELH(IDIM,JDIM,KDIM),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate DELH'
      ALLOCATE(DELP(IDIM,JDIM,KDIM),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate DELP'
! bag8

C-------set gravity constant to .5 g  
      G = HALF*GRAV
      KL2P = KL2+1
      KL1S = MAX(2,KL1)

C-------set up JL1 and JL2 vectors
      JL1(KL1)=JL1V(KL1)
      JL2(KL1)=JL2V(KL1)
      DO K = KL1+1,KL2
         JL1(K)=MIN(JL1V(K-1),JL1V(K))
         JL2(K)=MAX(JL2V(K-1),JL2V(K))
      END DO
      JL1(KL2P)=JL1V(KL2)
      JL2(KL2P)=JL2V(KL2)

C-------set difference in depth times half gravity
      DO K = KL1S,KL2P
         KM1 = K-1
         DO J = JL1(K),JL2(K)
         DO I = IL1,IL2
            DELH(I,J,K) = G *(DEPTH(I,J,K)-DEPTH(I,J,KM1))
         END DO
         END DO
      END DO

C-------zero initial coefficients
      IF(XNO_DD) THEN
         DO IC = 1,NC
         DO K = KL1,KL2P
         DO J = JL1(K),JL2(K)
         DO I = IL1,IL2
            TFLOW(I,J,K,IC,3) = ZERO
         END DO
         END DO
         END DO
         END DO
      ENDIF
         
      DO IPH = 1,NPH     

C----------setup up potential for phase IPH 
         DO K = KL1S,KL2P
            KM1 = K-1
            DO J = JL1(K),JL2(K)
            DO I = IL1,IL2
               DEN =  MDEN(I,J,K,IPH) + MDEN(I,J,KM1,IPH) 
               IF(MDEN(I,J,K,IPH) == ZERO .OR.
     &            MDEN(I,J,KM1,IPH) == ZERO) DEN = TWO*DEN
               DELP(I,J,K) = (PRES(I,J,K)-PRES(I,J,KM1))
     &                     + (PC(I,J,K,IPH)-PC(I,J,KM1,IPH)) 
     &                     - DEN*DELH(I,J,K)
            END DO
            END DO
         END DO

C----------add contribution for each component in phase IPH
         DO IC = 1,NC
            LC = ICINPH(IC,IPH)
            IF (LC == 0) CYCLE
            DO K = KL1S,KL2P
               KM1 = K-1
               DO J = JL1(K),JL2(K)
               DO I = IL1,IL2
                  TC = TCOF(I,J,K)*DELTIM
                  IF(TC == ZERO) CYCLE
                  IF(DELP(I,J,K) > ZERO ) THEN
                     COEF = TC*MOBPROD(I,J,K,LC)
                  ELSEIF(DELP(I,J,K) < ZERO ) THEN
                     COEF = TC*MOBPROD(I,J,KM1,LC)
                  ELSE
                     COEF = TC*HALF*(MOBPROD(I,J,KM1,LC)
     &                    +          MOBPROD(I,J,K,LC))
                  ENDIF
                  FLUX = COEF*DELP(I,J,K)
                  IF(KEYOUT(I,J,K) /= 0) THEN
                     TFLOW(I,J,K,IC,3) = TFLOW(I,J,K,IC,3) + COEF  
                     IF(KEYOUT(I,J,K) > 0) THEN
                        DFLOW(I,J,K,IC) = DFLOW(I,J,K,IC) + COEF
                        RESID(I,J,K,IC) = RESID(I,J,K,IC) + FLUX
                     ENDIF
                  ENDIF
                  IF(KEYOUT(I,J,KM1) > 0) THEN
                     DFLOW(I,J,KM1,IC) = DFLOW(I,J,KM1,IC) + COEF
                     RESID(I,J,KM1,IC) = RESID(I,J,KM1,IC) - FLUX
                  ENDIF
               END DO
            END DO
            END DO 
         END DO
      END DO 

! bag8
      DEALLOCATE(DELH)
      DEALLOCATE(DELP)
! bag8

      END


C*********************************************************************
      SUBROUTINE XFLOW(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                 KEYOUT,NBLK,CONC,DFLOW,TFLOW,RESID,DELP,CR, 
     &                 DELC)
C*********************************************************************

C Calculates mass flux correction for cells from pressure changes

C  INPUT:
C     TFLOW(I,J,K,IC,IDIR) = OFF-DIAGONAL FLOW COEFFICIENT FOR P(I-1,J,K) 
C                            IN (I,J,K,IC) MASS CONSERVATION EQUATION (REAL*8)
C     RESID(I,J,K,IC) = RESIDUAL FOR RIGHT HAND SIDE (REAL*8)
C     DFLOW(I,J,K,IC) = DIAGONAL FLOW COEFFICIENT FOR P(I,J,K) 
C                       IN (I,J,K,IC) MASS CONSERVATION EQUATION (REAL*8)
C     CR(I,J,K) = COMPRESSIBLITIY X PV0 (REAL*4)
C     CONC(I,J,K,IC) = CONCENTRATION (REAL*8)
C     DELP(I,J,K) = PRESSURE CHANGE (REAL*8)
C     PV(I,J,K) = PORE VOLUME (REAL*8)

C  OUTPUT:
C     DELC(I,J,K,L) = CHANGE IN MASS (REAL*8)

C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xmodel.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER KL1,KL2,IL1,IL2,IDIM,JDIM,KDIM,NBLK,LDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*4 CR(IDIM,JDIM,KDIM)
      REAL*8 DELC(IDIM,JDIM,KDIM,NC),CONC(IDIM,JDIM,KDIM,NC),
     &       DELP(IDIM,JDIM,KDIM),RESID(IDIM,JDIM,KDIM,NC),
     &       TFLOW(IDIM,JDIM,KDIM,NC,3),DFLOW(IDIM,JDIM,KDIM,NC)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER I,J,K,IC,IM1,JM1,KM1,KL2P,JL1(KDIM),JL2(KDIM),KL1S,IL2P
      REAL*8 X
      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)'PROC',MYPRC,
     &  ' ENTERING SUBROUTINE XFLOW, OLD TAG =',MSGTAG($IMODEL+1)
      IL2P=IL2+1
      KL2P = KL2+1
      KL1S = MAX(2,KL1)

C-------set up JL1 and JL2 vectors
      JL1(KL1)=JL1V(KL1)
      JL2(KL1)=JL2V(KL1)
      DO K = KL1+1,KL2
         JL1(K)=MIN(JL1V(K-1),JL1V(K))
         JL2(K)=MAX(JL2V(K-1),JL2V(K))
      END DO
      JL1(KL2P)=JL1V(KL2)
      JL2(KL2P)=JL2V(KL2)

      DO IC = 1,NC

C        direction-1
         DO K = KL1,KL2
         DO J = JL1V(K),JL2V(K)
         DO I = IL1,IL2P
            IF(KEYOUT(I,J,K) > 0) THEN
               DELC(I,J,K,IC) = -RESID(I,J,K,IC) - (DFLOW(I,J,K,IC)  
     &                        - CR(I,J,K)*CONC(I,J,K,IC))*DELP(I,J,K)
            ENDIF
            X = TFLOW(I,J,K,IC,1)
            IF(X == ZERO) CYCLE
            IM1 = I-1
            IF(KEYOUT(I,J,K) > 0) DELC(I,J,K,IC) = DELC(I,J,K,IC)
     &                                           + X*DELP(IM1,J,K)
            IF(KEYOUT(IM1,J,K) > 0) DELC(IM1,J,K,IC) = DELC(IM1,J,K,IC)
     &                                               + X*DELP(I,J,K)
         END DO
         END DO
         END DO

C        direction-2
         DO K = KL1,KL2
         DO J = JL1V(K),JL2V(K)+1
         JM1 = J-1
         IF(JM1 <= 0) CYCLE
         DO I = IL1,IL2
            X = TFLOW(I,J,K,IC,2)
            IF(X == ZERO) CYCLE
            IF(KEYOUT(I,J,K) > 0) DELC(I,J,K,IC) = DELC(I,J,K,IC) 
     &                                           + X*DELP(I,JM1,K)
            IF(KEYOUT(I,JM1,K) > 0) DELC(I,JM1,K,IC) = DELC(I,JM1,K,IC) 
     &                                               + X*DELP(I,J,K)
         END DO
         END DO
         END DO

C        direction-3
         DO K = KL1S,KL2P
         KM1 = K-1
         DO J = JL1(K),JL2(K)
         DO I = IL1,IL2
            X = TFLOW(I,J,K,IC,3)
            IF(X == ZERO) CYCLE
            IF(KEYOUT(I,J,K) > 0) DELC(I,J,K,IC) = DELC(I,J,K,IC) 
     &                                           + X*DELP(I,J,KM1)
            IF(KEYOUT(I,J,KM1) > 0) DELC(I,J,KM1,IC) = DELC(I,J,KM1,IC)
     &                                               + X*DELP(I,J,K)
         END DO
         END DO
         END DO
      END DO
      END

C*********************************************************************
      SUBROUTINE XCONC (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &                  KL1,KL2,KEYOUT,NBLK,CONC,DELC,PV,PVOLD)
C*********************************************************************
 
C  Updates concentrations for cells.
C  Checks for overshoot on concentrations.
C  THIS IS A WORK ROUTINE.

C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'xmodel.h'
      INCLUDE 'control.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xbaldat.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 CONC(IDIM,JDIM,KDIM,NC),DELC(IDIM,JDIM,KDIM,NC),
     &       PVOLD(IDIM,JDIM,KDIM),PV(IDIM,JDIM,KDIM)

      INTEGER I,J,K,IC
      REAL*8 X,Y,SCAL 

      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)'PROC',MYPRC,
     &  ' ENTERING SUBROUTINE XCONC, OLD TAG =',MSGTAG($XMODEL+1)

      SCAL = BIG
      DO IC = 1,NC
      DO K = KL1,KL2
      DO J = JL1V(K),JL2V(K)
      DO I = IL1,IL2
         IF(KEYOUT(I,J,K) > 0) THEN
            X = CONC(I,J,K,IC)
            IF (PV(I,J,K) > ZERO) THEN
              Y = (DELC(I,J,K,IC)+X*PVOLD(I,J,K))/PV(I,J,K)
            ELSE
              Y = 0.D0
            ENDIF
            IF(Y < -OVERLMT) THEN
               IF(LEVELE .AND. BUGKEY(6)) THEN
                  WRITE(NFBUG,'(A,F10.3,A,I3)') ' TIME =',TIM,
     &               ' OVERSHOOT FOR FLOW FOR COMPONENT ',IC
                  WRITE(NFBUG,'(A,3I5,2A,E15.6,A,E15.6)') 
     &               '     CELL=(',I,J,K,')',
     &               '  CONC =',CONC(I,J,K,IC),
     &               '  NEW VALUE =',Y
               ENDIF
               SCAL = MIN(SCAL, X/(X-Y))
               CONC(I,J,K,IC) = TENTH*CONC(I,J,K,IC)
            ELSE
               CONC(I,J,K,IC) = Y
            ENDIF
            DELC(I,J,K,IC) = CONC(I,J,K,IC) - X
         ENDIF
      END DO
      END DO
      END DO
      END DO
      OVERSHT = MIN(OVERSHT,SCAL)

      END

C*********************************************************************
      SUBROUTINE XSAT_STEP(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &                     KL1,KL2,KEYOUT,NBLK,CONCN,CONC,DSTDN,ICFL)
C*********************************************************************
 
C  Determines maximum effective saturation change for timestep.
C  Sets stability check indicator for max change in each fault block
C  THIS IS A WORK ROUTINE.

C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'xmodel.h'
      INCLUDE 'control.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xbaldat.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      INTEGER ICFL(IDIM,JDIM,KDIM)
      REAL*8 CONC(IDIM,JDIM,KDIM,NC),CONCN(IDIM,JDIM,KDIM,NC),
     &       DSTDN(IDIM,JDIM,KDIM,NC)

      INTEGER I,J,K,IC,IMAX,JMAX,KMAX
      REAL*8 SY,X

      SY = -ONE
      DO IC = 1,NC
      DO K = KL1,KL2
      DO J = JL1V(K),JL2V(K)
      DO I = IL1,IL2
         IF(KEYOUT(I,J,K) == 1) THEN
            X = ABS( DSTDN(I,J,K,IC) * 
     &          (CONC(I,J,K,IC) - CONCN(I,J,K,IC)) )
            IF(X > SY) THEN
               SY = X
               IMAX = I
               JMAX = J
               KMAX = K
            ENDIF
         ENDIF
      END DO
      END DO
      END DO
      END DO

      IF (SY > DSMAX) THEN
         DSMAX = SY
         ISMAX = IMAX
         JSMAX = JMAX
         KSMAX = KMAX
         NSMAX = NBLK
      ENDIF
      IF(SY > ZERO) ICFL(IMAX,JMAX,KMAX) = 1

      END

C*********************************************************************
      SUBROUTINE XSCALE (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &                   KL1,KL2,KEYOUT,NBLK,VNEW,VOLD,NUM,SCAL)
C*********************************************************************
 
C  Scales input value for timestep for cells.
C  THIS IS A WORK ROUTINE.

C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK,NUM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 VNEW(IDIM,JDIM,KDIM,NUM),VOLD(IDIM,JDIM,KDIM,NUM),SCAL

      INTEGER I,J,K,M
      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)'PROC',MYPRC,
     &  ' ENTERING SUBROUTINE XSCALE, OLD TAG =',MSGTAG($IMODEL+1)

      DO M = 1,NUM
      DO K = KL1,KL2
      DO J = JL1V(K),JL2V(K)
      DO I = IL1,IL2
         IF(KEYOUT(I,J,K) > 0) THEN
            VNEW(I,J,K,M) = SCAL*(VNEW(I,J,K,M)-VOLD(I,J,K,M))  
     &                    + VOLD(I,J,K,M)
         ENDIF
      END DO
      END DO
      END DO
      END DO

      END

C*********************************************************************
      SUBROUTINE XSCALEK (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &                    KL1,KL2,KEYOUT,NBLK,VNEW,VOLD,NUM,SCAL)
C*********************************************************************
 
C  Scales input value for timestep for cells.
C  THIS IS A WORK ROUTINE.

C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'xparam.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK,NUM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 VNEW(IDIM,JDIM,KDIM,NUM),VOLD(IDIM,JDIM,KDIM,NUM),SCAL

      INTEGER I,J,K,M
      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)'PROC',MYPRC,
     &  ' ENTERING SUBROUTINE XSCALE, OLD TAG =',MSGTAG($IMODEL+1)

      IF(SCAL == ZERO) THEN
         DO M = 1,NUM
         DO K = KL1,KL2
         DO J = JL1V(K),JL2V(K)
         DO I = IL1,IL2
            IF(KEYOUT(I,J,K) > 0) THEN
               VNEW(I,J,K,M) = VOLD(I,J,K,M)
            ENDIF
         END DO
         END DO
         END DO
         END DO
      ELSE
         DO M = 1,NUM
         DO K = KL1,KL2
         DO J = JL1V(K),JL2V(K)
         DO I = IL1,IL2
            IF(KEYOUT(I,J,K) > 0) THEN
               VNEW(I,J,K,M) = (VNEW(I,J,K,M)/VOLD(I,J,K,M))**SCAL  
     &                       * VOLD(I,J,K,M)
            ENDIF
         END DO
         END DO
         END DO
         END DO
      ENDIF

      END

C*********************************************************************
      SUBROUTINE XPAVG (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &                  KL1,KL2,KEYOUT,NBLK,PRES,PV)
C*********************************************************************
 
C  Calculates total pore volume and pore volume x pressure.
C  THIS IS A WORK ROUTINE.

C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xbaldat.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 PRES(IDIM,JDIM,KDIM),PV(IDIM,JDIM,KDIM)

      INTEGER I,J,K
      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)'PROC',MYPRC,
     &  ' ENTERING SUBROUTINE XPAVG, OLD TAG =',MSGTAG($IMODEL+1)

      DO K = KL1,KL2
      DO J = JL1V(K),JL2V(K)
      DO I = IL1,IL2
         IF(KEYOUT(I,J,K) > 0) THEN
            PVTOTL = PVTOTL + PV(I,J,K)
            PAVG = PAVG + PV(I,J,K)*PRES(I,J,K)
         ENDIF
      END DO
      END DO
      END DO

      END

C*********************************************************************
      SUBROUTINE XGSTABX3(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                    KEYOUT,NBLK,TCOF,DEPTH,PRES,MDEN,MOB,DCFL, 
     &                    PC,DMOB,DPC,ICFL)
C*********************************************************************
 
C  Calculates stability limit contribution in x-direction for grid blocks
C  Assumes NPH = 3
C  THIS IS A WORK ROUTINE.

C  INPUT:
C     TCOF(I,J,K) = TRANSMISSIBILITY BETWEEN CELL I AND I-1 (REAL*8)
C     DEPTH(I,J,K) = CELL DEPTH (REAL*8)
C     PRES(I,J,K) = PRESSURE (REAL*8)
C     MOB(I,J,K,IPH) = MOBILITY FOR PHASE IPH (REAL*8)
C     MDEN(I,J,K,IPH) = MASS DENSITY FOR PHASE IPH (REAL*8)
C     PC(I,J,K,IPH) = CAPILLARY PRESSURE FOR PHASE IPH (REAL*8)
C     DPC(I,J,K,*) = DERIVATIVE OF CAPILLARY PRESSURE (REAL*4)
C     DMOB(I,J,K,*) = DERIVATIVE OF MOBILITY (REAL*4)
C                     DOES NOT INCLUDE DERIVATIVE OF VISCOSITY
C     ICFL(I,J,K) = STABILITY CHECK INDICATOR (INTEGER)

C  INPUT/OUTPUT:
C     DCFL(I,J,K,*) = STABILITY LIMIT ARRAY (REAL*4)

C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xmodel.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER KL1,KL2,IL1,IL2,IDIM,JDIM,KDIM,NBLK,LDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM),
     &        ICFL(IDIM,JDIM,KDIM)
      REAL*8 TCOF(IDIM,JDIM,KDIM),DEPTH(IDIM,JDIM,KDIM),
     &       PRES(IDIM,JDIM,KDIM),MOB(IDIM,JDIM,KDIM,NPH),
     &       MDEN(IDIM,JDIM,KDIM,NPH),PC(IDIM,JDIM,KDIM,NPH)
      REAL*4 DCFL(IDIM,JDIM,KDIM,6),DMOB(IDIM,JDIM,KDIM,4),
     &       DPC(IDIM,JDIM,KDIM,2)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER I,J,K,IL2P,LC,IC,IPH,L,IM1,IUP(NPH)
      REAL*8 DEN,G,TC,DELH,DELP(NPH),FMOB(NPH),X,P1,P2,TMOB,DPW,DPO,
     &       DPG,KRWP,KRGP,KROWP,KROGP,WOMOB,OGMOB,PCWP,PCGP

      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)'PROC',MYPRC,
     &  ' ENTERING SUBROUTINE XGSTABX3, OLD TAG =',MSGTAG($IMODEL+1)

C  SET GRAVITY CONSTANT TO .5 g  
      G = HALF*GRAV
      IL2P = IL2+1
         
      DO K = KL1,KL2
      DO J = JL1V(K),JL2V(K)
      DO I = IL1,IL2P
         IM1 = I-1
C        skip this interface if neither cell is checked for stability
         IF(ICFL(I,J,K) == 0 .AND. ICFL(IM1,J,K) == 0) CYCLE
         TC = TCOF(I,J,K)
         IF(TC == ZERO) CYCLE

C----------setup up potential for phase IPH 
         P2 = PRES(I,J,K)
         P1 = PRES(IM1,J,K)
         DELH = G *(DEPTH(I,J,K)-DEPTH(IM1,J,K))
         TMOB = ZERO
         X = ZERO
         DO IPH = 1,NPH    
            DEN =  MDEN(I,J,K,IPH) + MDEN(IM1,J,K,IPH) 
            IF(MDEN(I,J,K,IPH) == ZERO .OR.
     &         MDEN(IM1,J,K,IPH) == ZERO) DEN = TWO*DEN
            DELP(IPH) = (P2-P1)+(PC(I,J,K,IPH)-PC(IM1,J,K,IPH)) 
     &                  - DEN*DELH
            IF(DELP(IPH) < ZERO) THEN
               IUP(IPH) = IM1
            ELSE
               IUP(IPH) = I
            ENDIF
            FMOB(IPH) = MOB(IUP(IPH),J,K,IPH)
            TMOB = TMOB + FMOB(IPH)
            X = X + FMOB(IPH)*DELP(IPH)
         END DO
         IF(TMOB <= ZERO) CYCLE
         IF(X >= ZERO) THEN
            L = I
         ELSE
            L = IM1
         ENDIF
         X = TC/TMOB

         DPW = ABS(DELP(1))
         DPO = ABS(DELP(2))
         DPG = ABS(DELP(3))
         PCWP = DPC(I,J,K,1)+DPC(IM1,J,K,1)
         PCGP = DPC(I,J,K,2)+DPC(IM1,J,K,2)
         KRWP = DMOB(IUP(1),J,K,1)*DPW
         KROWP = DMOB(IUP(2),J,K,2)*DPO
         KROGP = DMOB(IUP(2),J,K,3)*DPO
         KRGP = DMOB(IUP(3),J,K,4)*DPG
         WOMOB = FMOB(1) + FMOB(2)
         OGMOB = FMOB(2) + FMOB(3)

         DCFL(L,J,K,1) = DCFL(L,J,K,1) 
     &                 + X*(OGMOB*KRWP-FMOB(1)*KROWP-FMOB(1)*OGMOB*PCWP)
         DCFL(L,J,K,2) = DCFL(L,J,K,2) 
     &                 - X*FMOB(1)*(KROGP+KRGP+FMOB(3)*PCGP)
         DCFL(L,J,K,3) = DCFL(L,J,K,3) 
     &                 - X*FMOB(3)*(KRWP+KROWP-FMOB(1)*PCWP)
         DCFL(L,J,K,4) = DCFL(L,J,K,4) 
     &                 + X*(WOMOB*KRGP-FMOB(3)*KROGP+FMOB(3)*WOMOB*PCGP)
 
         DCFL(IUP(2),J,K,5) = DCFL(IUP(2),J,K,5) + TC*FMOB(2)*DPO
         DCFL(IUP(3),J,K,6) = DCFL(IUP(3),J,K,6) + TC*FMOB(3)*DPG
      END DO 
      END DO
      END DO
      END

C*********************************************************************
      SUBROUTINE XGSTABY3(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                    KEYOUT,NBLK,TCOF,DEPTH,PRES,MDEN,MOB,DCFL, 
     &                    PC,DMOB,DPC,ICFL)
C*********************************************************************
 
C  Calculates stability limit contribution in y-direction for grid blocks
C  Assumes NPH = 3
C  THIS IS A WORK ROUTINE.

C  INPUT:
C     TCOF(I,J,K) = TRANSMISSIBILITY BETWEEN CELL I AND I-1 (REAL*8)
C     DEPTH(I,J,K) = CELL DEPTH (REAL*8)
C     PRES(I,J,K) = PRESSURE (REAL*8)
C     MOB(I,J,K,IPH) = MOBILITY FOR PHASE IPH (REAL*8)
C     MDEN(I,J,K,IPH) = MASS DENSITY FOR PHASE IPH (REAL*8)
C     PC(I,J,K,IPH) = CAPILLARY PRESSURE FOR PHASE IPH (REAL*8)
C     DPC(I,J,K,*) = DERIVATIVE OF CAPILLARY PRESSURE (REAL*4)
C     DMOB(I,J,K,*) = DERIVATIVE OF MOBILITY (REAL*4)
C                     DOES NOT INCLUDE DERIVATIVE OF VISCOSITY
C     ICFL(I,J,K) = STABILITY CHECK INDICATOR (INTEGER)

C  INPUT/OUTPUT:
C     DCFL(I,J,K,*) = STABILITY LIMIT ARRAY (REAL*4)

C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xmodel.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER KL1,KL2,IL1,IL2,IDIM,JDIM,KDIM,NBLK,LDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM),
     &        ICFL(IDIM,JDIM,KDIM)
      REAL*8 TCOF(IDIM,JDIM,KDIM),DEPTH(IDIM,JDIM,KDIM),
     &       PRES(IDIM,JDIM,KDIM),MOB(IDIM,JDIM,KDIM,NPH),
     &       MDEN(IDIM,JDIM,KDIM,NPH),PC(IDIM,JDIM,KDIM,NPH)
      REAL*4 DCFL(IDIM,JDIM,KDIM,6),DMOB(IDIM,JDIM,KDIM,4),
     &       DPC(IDIM,JDIM,KDIM,2)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER I,J,K,IL2P,LC,IC,IPH,L,JM1,IUP(NPH)
      REAL*8 DEN,G,TC,DELH,DELP(NPH),FMOB(NPH),X,P1,P2,TMOB,DPW,DPO,
     &       DPG,KRWP,KRGP,KROWP,KROGP,WOMOB,OGMOB,PCWP,PCGP

      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)'PROC',MYPRC,
     &  ' ENTERING SUBROUTINE XGSTABY3, OLD TAG =',MSGTAG($IMODEL+1)

C  SET GRAVITY CONSTANT TO .5 g  
      G = HALF*GRAV
      IL2P = IL2+1
         
      DO K = KL1,KL2
      DO J = JL1V(K),JL2V(K)
      JM1 = J-1
      DO I = IL1,IL2P
C        skip this interface if neither cell is checked for stability
         IF(ICFL(I,J,K) == 0 .AND. ICFL(I,JM1,K) == 0) CYCLE
         TC = TCOF(I,J,K)
         IF(TC == ZERO) CYCLE

C----------setup up potential for phase IPH 
         P2 = PRES(I,J,K)
         P1 = PRES(I,JM1,K)
         DELH = G *(DEPTH(I,J,K)-DEPTH(I,JM1,K))
         TMOB = ZERO
         X = ZERO
         DO IPH = 1,NPH    
            DEN =  MDEN(I,J,K,IPH) + MDEN(I,JM1,K,IPH) 
            IF(MDEN(I,J,K,IPH) == ZERO .OR.
     &         MDEN(I,JM1,K,IPH) == ZERO) DEN = TWO*DEN
            DELP(IPH) = (P2-P1)+(PC(I,J,K,IPH)-PC(I,JM1,K,IPH)) 
     &                  - DEN*DELH
            IF(DELP(IPH) < ZERO) THEN
               IUP(IPH) = JM1
            ELSE
               IUP(IPH) = J
            ENDIF
            FMOB(IPH) = MOB(I,IUP(IPH),K,IPH)
            TMOB = TMOB + FMOB(IPH)
            X = X + FMOB(IPH)*DELP(IPH)
         END DO
         IF(TMOB <= ZERO) CYCLE
         IF(X >= ZERO) THEN
            L = J
         ELSE
            L = JM1
         ENDIF
         X = TC/TMOB

         DPW = ABS(DELP(1))
         DPO = ABS(DELP(2))
         DPG = ABS(DELP(3))
         PCWP = DPC(I,J,K,1)+DPC(I,JM1,K,1)
         PCGP = DPC(I,J,K,2)+DPC(I,JM1,K,2)
         KRWP = DMOB(I,IUP(1),K,1)*DPW
         KROWP = DMOB(I,IUP(2),K,2)*DPO
         KROGP = DMOB(I,IUP(2),K,3)*DPO
         KRGP = DMOB(I,IUP(3),K,4)*DPG
         WOMOB = FMOB(1) + FMOB(2)
         OGMOB = FMOB(2) + FMOB(3)

         DCFL(I,L,K,1) = DCFL(I,L,K,1) 
     &                 + X*(OGMOB*KRWP-FMOB(1)*KROWP-FMOB(1)*OGMOB*PCWP)
         DCFL(I,L,K,2) = DCFL(I,L,K,2) 
     &                 - X*FMOB(1)*(KROGP+KRGP+FMOB(3)*PCGP)
         DCFL(I,L,K,3) = DCFL(I,L,K,3) 
     &                 - X*FMOB(3)*(KRWP+KROWP-FMOB(1)*PCWP)
         DCFL(I,L,K,4) = DCFL(I,L,K,4) 
     &                 + X*(WOMOB*KRGP-FMOB(3)*KROGP+FMOB(3)*WOMOB*PCGP)
 
         DCFL(I,IUP(2),K,5) = DCFL(I,IUP(2),K,5) + TC*FMOB(2)*DPO
         DCFL(I,IUP(3),K,6) = DCFL(I,IUP(3),K,6) + TC*FMOB(3)*DPG
      END DO 
      END DO
      END DO
      END

C*********************************************************************
      SUBROUTINE XGSTABZ3(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                    KEYOUT,NBLK,TCOF,DEPTH,PRES,MDEN,MOB,DCFL, 
     &                    PC,DMOB,DPC,ICFL)
C*********************************************************************
 
C  Calculates stability limit contribution in z-direction for grid blocks
C  Assumes NPH = 3
C  THIS IS A WORK ROUTINE.

C  INPUT:
C     TCOF(I,J,K) = TRANSMISSIBILITY BETWEEN CELL I AND I-1 (REAL*8)
C     DEPTH(I,J,K) = CELL DEPTH (REAL*8)
C     PRES(I,J,K) = PRESSURE (REAL*8)
C     MOB(I,J,K,IPH) = MOBILITY FOR PHASE IPH (REAL*8)
C     MDEN(I,J,K,IPH) = MASS DENSITY FOR PHASE IPH (REAL*8)
C     PC(I,J,K,IPH) = CAPILLARY PRESSURE FOR PHASE IPH (REAL*8)
C     DPC(I,J,K,*) = DERIVATIVE OF CAPILLARY PRESSURE (REAL*4)
C     DMOB(I,J,K,*) = DERIVATIVE OF MOBILITY (REAL*4)
C                     DOES NOT INCLUDE DERIVATIVE OF VISCOSITY
C     ICFL(I,J,K) = STABILITY CHECK INDICATOR (INTEGER)

C  INPUT/OUTPUT:
C     DCFL(I,J,K,*) = STABILITY LIMIT ARRAY (REAL*4)

C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xmodel.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER KL1,KL2,IL1,IL2,IDIM,JDIM,KDIM,NBLK,LDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM),
     &        ICFL(IDIM,JDIM,KDIM)
      REAL*8 TCOF(IDIM,JDIM,KDIM),DEPTH(IDIM,JDIM,KDIM),
     &       PRES(IDIM,JDIM,KDIM),MOB(IDIM,JDIM,KDIM,NPH),
     &       MDEN(IDIM,JDIM,KDIM,NPH),PC(IDIM,JDIM,KDIM,NPH)
      REAL*4 DCFL(IDIM,JDIM,KDIM,6),DMOB(IDIM,JDIM,KDIM,4),
     &       DPC(IDIM,JDIM,KDIM,2)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER I,J,K,IL2P,LC,IC,IPH,L,KM1,IUP(NPH)
      REAL*8 DEN,G,TC,DELH,DELP(NPH),FMOB(NPH),X,P1,P2,TMOB,DPW,DPO,
     &       DPG,KRWP,KRGP,KROWP,KROGP,WOMOB,OGMOB,PCWP,PCGP

      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)'PROC',MYPRC,
     &  ' ENTERING SUBROUTINE XGSTABZ3, OLD TAG =',MSGTAG($IMODEL+1)

C  SET GRAVITY CONSTANT TO .5 g  
      G = HALF*GRAV
      IL2P = IL2+1
         
      DO K = KL1,KL2
      KM1 = K-1
      DO J = JL1V(K),JL2V(K)
      DO I = IL1,IL2P
C        skip this interface if neither cell is checked for stability
         IF(ICFL(I,J,K) == 0 .AND. ICFL(I,J,KM1) == 0) CYCLE
         TC = TCOF(I,J,K)
         IF(TC == ZERO) CYCLE

C----------setup up potential for phase IPH 
         P2 = PRES(I,J,K)
         P1 = PRES(I,J,KM1)
         DELH = G *(DEPTH(I,J,K)-DEPTH(I,J,KM1))
         TMOB = ZERO
         X = ZERO
         DO IPH = 1,NPH    
            DEN =  MDEN(I,J,K,IPH) + MDEN(I,J,KM1,IPH) 
            IF(MDEN(I,J,K,IPH) == ZERO .OR.
     &         MDEN(I,J,KM1,IPH) == ZERO) DEN = TWO*DEN
            DELP(IPH) = (P2-P1)+(PC(I,J,K,IPH)-PC(I,J,KM1,IPH)) 
     &                  - DEN*DELH
            IF(DELP(IPH) < ZERO) THEN
               IUP(IPH) = KM1
            ELSE
               IUP(IPH) = K
            ENDIF
            FMOB(IPH) = MOB(I,J,IUP(IPH),IPH)
            TMOB = TMOB + FMOB(IPH)
            X = X + FMOB(IPH)*DELP(IPH)
         END DO
         IF(TMOB <= ZERO) CYCLE
         IF(X >= ZERO) THEN
            L = K
         ELSE
            L = KM1
         ENDIF
         X = TC/TMOB

         DPW = ABS(DELP(1))
         DPO = ABS(DELP(2))
         DPG = ABS(DELP(3))
         PCWP = DPC(I,J,K,1)+DPC(I,J,KM1,1)
         PCGP = DPC(I,J,K,2)+DPC(I,J,KM1,2)
         KRWP = DMOB(I,J,IUP(1),1)*DPW
         KROWP = DMOB(I,J,IUP(2),2)*DPO
         KROGP = DMOB(I,J,IUP(2),3)*DPO
         KRGP = DMOB(I,J,IUP(3),4)*DPG
         WOMOB = FMOB(1) + FMOB(2)
         OGMOB = FMOB(2) + FMOB(3)

         DCFL(I,J,L,1) = DCFL(I,J,L,1) 
     &                 + X*(OGMOB*KRWP-FMOB(1)*KROWP-FMOB(1)*OGMOB*PCWP)
         DCFL(I,J,L,2) = DCFL(I,J,L,2) 
     &                 - X*FMOB(1)*(KROGP+KRGP+FMOB(3)*PCGP)
         DCFL(I,J,L,3) = DCFL(I,J,L,3) 
     &                 - X*FMOB(3)*(KRWP+KROWP-FMOB(1)*PCWP)
         DCFL(I,J,L,4) = DCFL(I,J,L,4) 
     &                 + X*(WOMOB*KRGP-FMOB(3)*KROGP+FMOB(3)*WOMOB*PCGP)
 
         DCFL(I,J,IUP(2),5) = DCFL(I,J,IUP(2),5) + TC*FMOB(2)*DPO
         DCFL(I,J,IUP(3),6) = DCFL(I,J,IUP(3),6) + TC*FMOB(3)*DPG
      END DO 
      END DO
      END DO
      END

C*********************************************************************
      SUBROUTINE XGSTABX2(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                    KEYOUT,NBLK,TCOF,DEPTH,PRES,MDEN,MOB,DCFL, 
     &                    PC,DMOB,DPC,ICFL)
C*********************************************************************
 
C  Calculates stability limit contribution in x-direction for grid blocks
C  Assumes NPH = 2
C  THIS IS A WORK ROUTINE.

C  INPUT:
C     TCOF(I,J,K) = TRANSMISSIBILITY BETWEEN CELL I AND I-1 (REAL*8)
C     DEPTH(I,J,K) = CELL DEPTH (REAL*8)
C     PRES(I,J,K) = PRESSURE (REAL*8)
C     MOB(I,J,K,IPH) = MOBILITY FOR PHASE IPH (REAL*8)
C     MDEN(I,J,K,IPH) = MASS DENSITY FOR PHASE IPH (REAL*8)
C     PC(I,J,K,IPH) = CAPILLARY PRESSURE FOR PHASE IPH (REAL*8)
C     DPC(I,J,K) = DERIVATIVE OF CAPILLARY PRESSURE (REAL*4)
C     DMOB(I,J,K,*) = DERIVATIVE OF MOBILITY (REAL*4)
C                     DOES NOT INCLUDE DERIVATIVE OF VISCOSITY
C     ICFL(I,J,K) = STABILITY CHECK INDICATOR (INTEGER)

C  INPUT/OUTPUT:
C     DCFL(I,J,K) = STABILITY LIMIT ARRAY (REAL*4)

C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xmodel.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER KL1,KL2,IL1,IL2,IDIM,JDIM,KDIM,NBLK,LDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM),
     &        ICFL(IDIM,JDIM,KDIM)
      REAL*8 TCOF(IDIM,JDIM,KDIM),DEPTH(IDIM,JDIM,KDIM),
     &       PRES(IDIM,JDIM,KDIM),MOB(IDIM,JDIM,KDIM,NPH),
     &       MDEN(IDIM,JDIM,KDIM,NPH),PC(IDIM,JDIM,KDIM,NPH)
      REAL*4 DCFL(IDIM,JDIM,KDIM),DMOB(IDIM,JDIM,KDIM,2),
     &       DPC(IDIM,JDIM,KDIM)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER I,J,K,IL2P,LC,IC,IPH,L,IM1,IUP(NPH)
      REAL*8 DEN,G,TC,DELH,DELP(NPH),FMOB(NPH),X,P1,P2,TMOB,DPW,DPO,
     &       KRWP,KROWP,PCWP

      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)'PROC',MYPRC,
     &  ' ENTERING SUBROUTINE XGSTABX2, OLD TAG =',MSGTAG($IMODEL+1)

C  SET GRAVITY CONSTANT TO .5 g  
      G = HALF*GRAV
      IL2P = IL2+1
         
      DO K = KL1,KL2
      DO J = JL1V(K),JL2V(K)
      DO I = IL1,IL2P
         IM1 = I-1
C        skip this interface if neither cell is checked for stability
         IF(ICFL(I,J,K) == 0 .AND. ICFL(IM1,J,K) == 0) CYCLE
         TC = TCOF(I,J,K)
         IF(TC == ZERO) CYCLE

C----------setup up potential for phase IPH 
         P2 = PRES(I,J,K)
         P1 = PRES(IM1,J,K)
         DELH = G *(DEPTH(I,J,K)-DEPTH(IM1,J,K))
         TMOB = ZERO
         X = ZERO
         DO IPH = 1,NPH    
            DEN =  MDEN(I,J,K,IPH) + MDEN(IM1,J,K,IPH) 
            IF(MDEN(I,J,K,IPH) == ZERO .OR.
     &         MDEN(IM1,J,K,IPH) == ZERO) DEN = TWO*DEN
            DELP(IPH) = (P2-P1)+(PC(I,J,K,IPH)-PC(IM1,J,K,IPH)) 
     &                  - DEN*DELH
            IF(DELP(IPH) < ZERO) THEN
               IUP(IPH) = IM1
            ELSE
               IUP(IPH) = I
            ENDIF
            FMOB(IPH) = MOB(IUP(IPH),J,K,IPH)
            TMOB = TMOB + FMOB(IPH)
            X = X + FMOB(IPH)*DELP(IPH)
         END DO
         IF(TMOB <= ZERO) CYCLE
         IF(X >= ZERO) THEN
            L = I
         ELSE
            L = IM1
         ENDIF
         X = TC/TMOB

         DPW = ABS(DELP(1))
         DPO = ABS(DELP(2))
         PCWP = DPC(I,J,K)+DPC(IM1,J,K)
         KRWP = DMOB(IUP(1),J,K,1)*DPW
         KROWP = DMOB(IUP(2),J,K,2)*DPO

         DCFL(L,J,K) = DCFL(L,J,K) + X*(FMOB(2)*KRWP
     &               - FMOB(1)*KROWP-FMOB(1)*FMOB(2)*PCWP)
      END DO 
      END DO
      END DO
      END

C*********************************************************************
      SUBROUTINE XGSTABY2(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                    KEYOUT,NBLK,TCOF,DEPTH,PRES,MDEN,MOB,DCFL, 
     &                    PC,DMOB,DPC,ICFL)
C*********************************************************************
 
C  Calculates stability limit contribution in y-direction for grid blocks
C  Assumes NPH = 2
C  THIS IS A WORK ROUTINE.

C  INPUT:
C     TCOF(I,J,K) = TRANSMISSIBILITY BETWEEN CELL I AND I-1 (REAL*8)
C     DEPTH(I,J,K) = CELL DEPTH (REAL*8)
C     PRES(I,J,K) = PRESSURE (REAL*8)
C     MOB(I,J,K,IPH) = MOBILITY FOR PHASE IPH (REAL*8)
C     MDEN(I,J,K,IPH) = MASS DENSITY FOR PHASE IPH (REAL*8)
C     PC(I,J,K,IPH) = CAPILLARY PRESSURE FOR PHASE IPH (REAL*8)
C     DPC(I,J,K) = DERIVATIVE OF CAPILLARY PRESSURE (REAL*4)
C     DMOB(I,J,K,*) = DERIVATIVE OF MOBILITY (REAL*4)
C                     DOES NOT INCLUDE DERIVATIVE OF VISCOSITY
C     ICFL(I,J,K) = STABILITY CHECK INDICATOR (INTEGER)

C  INPUT/OUTPUT:
C     DCFL(I,J,K) = STABILITY LIMIT ARRAY (REAL*4)

C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xmodel.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER KL1,KL2,IL1,IL2,IDIM,JDIM,KDIM,NBLK,LDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM),
     &        ICFL(IDIM,JDIM,KDIM)
      REAL*8 TCOF(IDIM,JDIM,KDIM),DEPTH(IDIM,JDIM,KDIM),
     &       PRES(IDIM,JDIM,KDIM),MOB(IDIM,JDIM,KDIM,NPH),
     &       MDEN(IDIM,JDIM,KDIM,NPH),PC(IDIM,JDIM,KDIM,NPH)
      REAL*4 DCFL(IDIM,JDIM,KDIM),DMOB(IDIM,JDIM,KDIM,2),
     &       DPC(IDIM,JDIM,KDIM)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER I,J,K,IL2P,LC,IC,IPH,L,JM1,IUP(NPH)
      REAL*8 DEN,G,TC,DELH,DELP(NPH),FMOB(NPH),X,P1,P2,TMOB,DPW,DPO,
     &       KRWP,KROWP,PCWP

      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)'PROC',MYPRC,
     &  ' ENTERING SUBROUTINE XGSTABY2, OLD TAG =',MSGTAG($IMODEL+1)

C  SET GRAVITY CONSTANT TO .5 g  
      G = HALF*GRAV
      IL2P = IL2+1
         
      DO K = KL1,KL2
      DO J = JL1V(K),JL2V(K)
      JM1 = J-1
      DO I = IL1,IL2P
C        skip this interface if neither cell is checked for stability
         IF(ICFL(I,J,K) == 0 .AND. ICFL(I,JM1,K) == 0) CYCLE
         TC = TCOF(I,J,K)
         IF(TC == ZERO) CYCLE

C----------setup up potential for phase IPH 
         P2 = PRES(I,J,K)
         P1 = PRES(I,JM1,K)
         DELH = G *(DEPTH(I,J,K)-DEPTH(I,JM1,K))
         TMOB = ZERO
         X = ZERO
         DO IPH = 1,NPH    
            DEN =  MDEN(I,J,K,IPH) + MDEN(I,JM1,K,IPH) 
            IF(MDEN(I,J,K,IPH) == ZERO .OR.
     &         MDEN(I,JM1,K,IPH) == ZERO) DEN = TWO*DEN
            DELP(IPH) = (P2-P1)+(PC(I,J,K,IPH)-PC(I,JM1,K,IPH)) 
     &                  - DEN*DELH
            IF(DELP(IPH) < ZERO) THEN
               IUP(IPH) = JM1
            ELSE
               IUP(IPH) = J
            ENDIF
            FMOB(IPH) = MOB(I,IUP(IPH),K,IPH)
            TMOB = TMOB + FMOB(IPH)
            X = X + FMOB(IPH)*DELP(IPH)
         END DO
         IF(TMOB <= ZERO) CYCLE
         IF(X >= ZERO) THEN
            L = J
         ELSE
            L = JM1
         ENDIF
         X = TC/TMOB

         DPW = ABS(DELP(1))
         DPO = ABS(DELP(2))
         PCWP = DPC(I,J,K)+DPC(I,JM1,K)
         KRWP = DMOB(I,IUP(1),K,1)*DPW
         KROWP = DMOB(I,IUP(2),K,2)*DPO

         DCFL(I,L,K) = DCFL(I,L,K) + X*(FMOB(2)*KRWP
     &               - FMOB(1)*KROWP-FMOB(1)*FMOB(2)*PCWP)
      END DO 
      END DO
      END DO
      END

C*********************************************************************
      SUBROUTINE XGSTABZ2(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                    KEYOUT,NBLK,TCOF,DEPTH,PRES,MDEN,MOB,DCFL, 
     &                    PC,DMOB,DPC,ICFL)
C*********************************************************************
 
C  Calculates stability limit contribution in z-direction for grid blocks
C  Assumes NPH = 2
C  THIS IS A WORK ROUTINE.

C  INPUT:
C     TCOF(I,J,K) = TRANSMISSIBILITY BETWEEN CELL I AND I-1 (REAL*8)
C     DEPTH(I,J,K) = CELL DEPTH (REAL*8)
C     PRES(I,J,K) = PRESSURE (REAL*8)
C     MOB(I,J,K,IPH) = MOBILITY FOR PHASE IPH (REAL*8)
C     MDEN(I,J,K,IPH) = MASS DENSITY FOR PHASE IPH (REAL*8)
C     PC(I,J,K,IPH) = CAPILLARY PRESSURE FOR PHASE IPH (REAL*8)
C     DPC(I,J,K) = DERIVATIVE OF CAPILLARY PRESSURE (REAL*4)
C     DMOB(I,J,K,*) = DERIVATIVE OF MOBILITY (REAL*4)
C                     DOES NOT INCLUDE DERIVATIVE OF VISCOSITY
C     ICFL(I,J,K) = STABILITY CHECK INDICATOR (INTEGER)

C  INPUT/OUTPUT:
C     DCFL(I,J,K) = STABILITY LIMIT ARRAY (REAL*4)

C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xmodel.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER KL1,KL2,IL1,IL2,IDIM,JDIM,KDIM,NBLK,LDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM),
     &        ICFL(IDIM,JDIM,KDIM)
      REAL*8 TCOF(IDIM,JDIM,KDIM),DEPTH(IDIM,JDIM,KDIM),
     &       PRES(IDIM,JDIM,KDIM),MOB(IDIM,JDIM,KDIM,NPH),
     &       MDEN(IDIM,JDIM,KDIM,NPH),PC(IDIM,JDIM,KDIM,NPH)
      REAL*4 DCFL(IDIM,JDIM,KDIM),DMOB(IDIM,JDIM,KDIM,2),
     &       DPC(IDIM,JDIM,KDIM)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER I,J,K,IL2P,LC,IC,IPH,L,KM1,IUP(NPH)
      REAL*8 DEN,G,TC,DELH,DELP(NPH),FMOB(NPH),X,P1,P2,TMOB,DPW,DPO,
     &       KRWP,KROWP,PCWP

      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)'PROC',MYPRC,
     &  ' ENTERING SUBROUTINE XGSTABZ2, OLD TAG =',MSGTAG($IMODEL+1)

C  SET GRAVITY CONSTANT TO .5 g  
      G = HALF*GRAV
      IL2P = IL2+1
         
      DO K = KL1,KL2
      KM1 = K-1
      DO J = JL1V(K),JL2V(K)
      DO I = IL1,IL2P
C        skip this interface if neither cell is checked for stability
         IF(ICFL(I,J,K) == 0 .AND. ICFL(I,J,KM1) == 0) CYCLE
         TC = TCOF(I,J,K)
         IF(TC == ZERO) CYCLE

C----------setup up potential for phase IPH 
         P2 = PRES(I,J,K)
         P1 = PRES(I,J,KM1)
         DELH = G *(DEPTH(I,J,K)-DEPTH(I,J,KM1))
         TMOB = ZERO
         X = ZERO
         DO IPH = 1,NPH    
            DEN =  MDEN(I,J,K,IPH) + MDEN(I,J,KM1,IPH) 
            IF(MDEN(I,J,K,IPH) == ZERO .OR.
     &         MDEN(I,J,KM1,IPH) == ZERO) DEN = TWO*DEN
            DELP(IPH) = (P2-P1)+(PC(I,J,K,IPH)-PC(I,J,KM1,IPH)) 
     &                  - DEN*DELH
            IF(DELP(IPH) < ZERO) THEN
               IUP(IPH) = KM1
            ELSE
               IUP(IPH) = K
            ENDIF
            FMOB(IPH) = MOB(I,J,IUP(IPH),IPH)
            TMOB = TMOB + FMOB(IPH)
            X = X + FMOB(IPH)*DELP(IPH)
         END DO
         IF(TMOB <= ZERO) CYCLE
         IF(X >= ZERO) THEN
            L = K
         ELSE
            L = KM1
         ENDIF
         X = TC/TMOB

         DPW = ABS(DELP(1))
         DPO = ABS(DELP(2))
         PCWP = DPC(I,J,K)+DPC(I,J,KM1)
         KRWP = DMOB(I,J,IUP(1),1)*DPW
         KROWP = DMOB(I,J,IUP(2),2)*DPO

         DCFL(I,J,L) = DCFL(I,J,L) + X*(FMOB(2)*KRWP
     &               - FMOB(1)*KROWP-FMOB(1)*FMOB(2)*PCWP)
      END DO 
      END DO
      END DO
      END

C*********************************************************************
      SUBROUTINE XSTABCHK(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                    KEYOUT,NBLK,PV,PMD,SAT,DCFL,ICFL)
C*********************************************************************
 
C  Computes time step size for stability limit
C  THIS IS A WORK ROUTINE.

C  INPUT:
C     PV(I,J,K) = PORE VOLUME (REAL*8)
C     PMD(I,J,K,L) = MASS FRACTION X MOLAR DENSITY (REAL*8)
C     SAT(I,J,K,IPH) = FLUID SATURATION (REAL*8)
C     ICFL(I,J,K) = STABILITY CHECK INDICATOR (INTEGER)
C     DCFL(I,J,K) = STABILITY LIMIT ARRAY (REAL*4)

C  INPUT/OUTPUT:
C     DTSTAB = TIME STEP SIZE DUE TO STABILITY LIMIT

C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xbaldat.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER KL1,KL2,IL1,IL2,IDIM,JDIM,KDIM,NBLK,LDIM,LCO,LCG
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM),
     &        ICFL(IDIM,JDIM,KDIM)
      REAL*8 PV(IDIM,JDIM,KDIM),PMD(IDIM,JDIM,KDIM,NCINPH),
     &       SAT(IDIM,JDIM,KDIM,NPH)
      REAL*4 DCFL(IDIM,JDIM,KDIM,6)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER I,J,K,IC,IG,IMAX,JMAX,KMAX
      REAL*8 DMIN,EPS,FI,QO,QG,SO,SG,Y,X

      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)'PROC',MYPRC,
     &  ' ENTERING SUBROUTINE XSTABCHK, OLD TAG =',MSGTAG($IMODEL+1)

      DMIN = BIG
      EPS = TEN_M10

      IF(NPH == 3) THEN
         DO K = KL1,KL2
         DO J = JL1V(K),JL2V(K)
         DO I = IL1,IL2
C           skip this cell if not flagged for stability check
            IF(ICFL(I,J,K) == 0) CYCLE
   
             FI = DCFL(I,J,K,1) + ABS(DCFL(I,J,K,2))
             FI = MAX( FI, DCFL(I,J,K,4) + ABS(DCFL(I,J,K,3)) )
             QO = DCFL(I,J,K,5)
             QG = DCFL(I,J,K,6)
             SO = SAT(I,J,K,2)
             SG = SAT(I,J,K,3)
             DO IC = 2,NC
                LCO = ICINPH(IC,2)
                LCG = ICINPH(IC,3)
                IF(LCO <= 0 .OR. LCG <= 0) CYCLE
                Y = SO*PMD(I,J,K,LCO) + SG*PMD(I,J,K,LCG)
                IF(Y > EPS) THEN
                   X = (QO*PMD(I,J,K,LCO) + QG*PMD(I,J,K,LCG))/Y
                   FI = MAX(FI,X)
                ENDIF
             END DO
             X = FI/PV(I,J,K)
             IF(X > ZERO) THEN
                X = CFL/X
                IF(X < DMIN) THEN
                   DMIN = X
                   IMAX = I
                   JMAX = J
                   KMAX = K
                ENDIF
             ENDIF
         END DO 
         END DO 
         END DO
      ELSEIF(NPH == 2) THEN
         DO K = KL1,KL2
         DO J = JL1V(K),JL2V(K)
         DO I = IL1,IL2
C           skip this cell if not flagged for stability check
            IF(ICFL(I,J,K) == 0) CYCLE
            FI = DCFL(I,J,K,1)
            SO = SAT(I,J,K,2)
            IF(SO > EPS) FI = MAX(FI,DCFL(I,J,K,2)/SO)
            X = FI/PV(I,J,K)
            IF(X > ZERO) THEN
               X = CFL/X
               IF(X < DMIN) THEN
                  DMIN = X
                  IMAX = I
                  JMAX = J
                  KMAX = K
               ENDIF
            ENDIF
         END DO 
         END DO 
         END DO
      ENDIF

      IF (DMIN < DTSTAB) THEN
         DTSTAB = DMIN
         ICFLMAX = IMAX
         JCFLMAX = JMAX
         KCFLMAX = KMAX
         NCFLMAX = NBLK
      ENDIF
      END

C*********************************************************************
      SUBROUTINE XFLOWAQ(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                 KEYOUT,NBLK,POR,VEL,PV,PVN,PMDEN,PMDENN,SAT,
     &                 SATN,CONC,CONCN)
C*********************************************************************

C Aqueous phase component transport

C  INPUT:
C     VEL(I,J,K,NPH,3) = VOLUMETRIC PHASE VELOCITIES (REAL*8)
C     POR(I,J,K) = PORE VOLUME AT TIME T = 0 (REAL*4)
C     PV(I,J,K) = PORE VOLUME (REAL*8)
C     PVN(I,J,K) = OLD TIMESTEP PORE VOLUME (REAL*8)
C     PMDEN(I,J,K,NPH) = PORE VOLUME (REAL*8)
C     PMDENN(I,J,K,NPH) = OLD TIMESTEP PORE VOLUME (REAL*8)
C     SAT(I,J,K,NPH) = PHASE SATURATION (REAL*8)
C     SATN(I,J,K,NPH) = OLD TIMESTEP PHASE SATURATION (REAL*8)
C     CONCN(I,J,K,IC) = OLD TIMESTEP CONCENTRATION (REAL*8)

C  OUTPUT:
C     CONC(I,J,K,IC) = CONCENTRATION (REAL*8)

C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xwells.h'
      INCLUDE 'wells.h'
      INCLUDE 'xcompwel.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER KL1,KL2,IL1,IL2,IDIM,JDIM,KDIM,NBLK,LDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 VEL(IDIM,JDIM,KDIM,NPH,3),PV(IDIM,JDIM,KDIM),
     &       PVN(IDIM,JDIM,KDIM),PMDEN(IDIM,JDIM,KDIM,NPH),
     &       PMDENN(IDIM,JDIM,KDIM,NPH),SAT(IDIM,JDIM,KDIM,NPH),
     &       SATN(IDIM,JDIM,KDIM,NPH),CONC(IDIM,JDIM,KDIM,NAQ),
     &       CONCN(IDIM,JDIM,KDIM,NAQ)
      REAL*4 POR(IDIM,JDIM,KDIM)
C
C---- LOCAL VARIABLES
C
      INTEGER AQNEWT,MAXNEWT,IC,IM1,JM1,KM1,KL2P,JL1(KDIM),JL2(KDIM),
     &        KL1S,IL2P,I,J,K,IERR
      REAL*8 FLUX,AVGPMDEN,RM,RESID_M,CONCAQ
      REAL*8, ALLOCATABLE :: RESID(:,:,:,:)
 
      INTEGER IW,IOFF,JOFF,KOFF,MERR,NE,L,JS
  
      ALLOCATE(RESID(IDIM,JDIM,KDIM,NAQ),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate AQ. RESID'

C
C---- CHECK IF PHASE VELOCITIES ARE VOLUMETRIC
C
      IF (.NOT.XDARCYFLUX) THEN
         WRITE(*,*)'XDARCYFLUX FALSE: AQ. COMPONENT TRANSPORT SKIPPED!'
         RETURN
      ENDIF

C     GET LOCAL TO GLOBAL INDEX OFFSETS
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,MERR)
      
      IL2P=IL2+1
      KL2P = KL2+1
      KL1S = MAX(2,KL1)

C-------set up JL1 and JL2 vectors
      JL1(KL1)=JL1V(KL1)
      JL2(KL1)=JL2V(KL1)
      DO K = KL1+1,KL2
         JL1(K)=MIN(JL1V(K-1),JL1V(K))
         JL2(K)=MAX(JL2V(K-1),JL2V(K))
      END DO
      JL1(KL2P)=JL1V(KL2)
      JL2(KL2P)=JL2V(KL2)

C---- Inexact Newton for component transport

      MAXNEWT = 20
      RESID_M = 1.D0
      AQNEWT = 0

      DO WHILE (RESID_M>1.D-8)
      
      RESID = 0.D0
      RESID_M = 0.D0

      DO IC = 1,NAQ
C        direction-1
         DO K = KL1,KL2
         DO J = JL1V(K),JL2V(K)
         DO I = IL1,IL2P
            IM1 = I-1
            IF(KEYOUT(I,J,K) > 0) THEN
               RESID(I,J,K,IC) = RESID(I,J,K,IC)+(PV(I,J,K)
     &              *PMDEN(I,J,K,1)*SAT(I,J,K,1)*CONC(I,J,K,IC)
     &              -PVN(I,J,K)*PMDENN(I,J,K,1)*SATN(I,J,K,1)
     &              *CONCN(I,J,K,IC))
            ENDIF
            IF(KEYOUT(IM1,J,K)/=0) THEN
              IF (VEL(I,J,K,1,1)>0.D0) THEN
                 CONCAQ = CONC(IM1,J,K,IC)
              ELSE
                 CONCAQ = CONC(I,J,K,IC)
              ENDIF
              AVGPMDEN = 0.5D0*(PMDEN(I,J,K,1)+PMDEN(IM1,J,K,1))
              FLUX = AVGPMDEN*CONCAQ*VEL(I,J,K,1,1)*DELTIM
              RESID(I,J,K,IC) = RESID(I,J,K,IC) - FLUX
              RESID(IM1,J,K,IC) = RESID(IM1,J,K,IC) + FLUX
            ENDIF
         END DO
         END DO
         END DO

C        direction-2
         DO K = KL1,KL2
         DO J = JL1V(K),JL2V(K)+1
         JM1 = J-1
         IF(JM1 <= 0) CYCLE
         DO I = IL1,IL2
            IF(KEYOUT(I,JM1,K)/=0) THEN
              IF (VEL(I,J,K,1,2)>0.D0) THEN
                 CONCAQ = CONC(I,JM1,K,IC)
              ELSE
                 CONCAQ = CONC(I,J,K,IC)
              ENDIF
              AVGPMDEN = 0.5D0*(PMDEN(I,J,K,1)+PMDEN(I,JM1,K,1))
              FLUX = AVGPMDEN*CONCAQ*VEL(I,J,K,1,2)*DELTIM
              RESID(I,J,K,IC) = RESID(I,J,K,IC) - FLUX
              RESID(I,JM1,K,IC) = RESID(I,JM1,K,IC) + FLUX
            ENDIF
         END DO
         END DO
         END DO

C        direction-3
         DO K = KL1S,KL2P
         KM1 = K-1
         DO J = JL1(K),JL2(K)
         DO I = IL1,IL2
            IF(KEYOUT(I,J,KM1)/=0) THEN
              IF (VEL(I,J,K,1,3)>0.D0) THEN
                 CONCAQ = CONC(I,J,KM1,IC)
              ELSE
                 CONCAQ = CONC(I,J,K,IC)
              ENDIF
              AVGPMDEN = 0.5D0*(PMDEN(I,J,K,1)+PMDEN(I,J,KM1,1))
              FLUX = AVGPMDEN*CONCAQ*VEL(I,J,K,1,3)*DELTIM
              RESID(I,J,K,IC) = RESID(I,J,K,IC) - FLUX
              RESID(I,J,KM1,IC) = RESID(I,J,KM1,IC) + FLUX
            ENDIF
         END DO
         END DO
         END DO

C---- WELL CONTRIBUTION
         DO IW = 1,NUMWEL
            IF(MODWEL(IW) /= MODACT) CYCLE
            NE = NUMELE(IW)
            JS = INJCOMP(IW)
            DO  L = 1,NE
               IF (LOCWEL(6,L,IW)==MYPRC .AND.
     &             LOCWEL(1,L,IW)==NBLK) THEN
                  I = LOCWEL(3,L,IW)-IOFF
                  J = LOCWEL(4,L,IW)-JOFF
                  K = LOCWEL(5,L,IW)-KOFF
                  IF(KEYOUT(I,J,K) /= 1) CYCLE

C--------------INJECTION WELL
                  IF (KWELL(IW)<30) THEN
                     RESID(I,J,K,IC) = RESID(I,J,K,IC)-COMPAQINJ(IC,JS)
     &                                 *QLAYER(1,L,IW)*DELTIM
C--------------PRODUCTION WELL
                  ELSE
                     RESID(I,J,K,IC) = RESID(I,J,K,IC)-CONC(I,J,K,IC)
     &                                 *QLAYER(1,L,IW)*DELTIM
                  ENDIF
               ENDIF
            END DO   
         END DO

C---- RESIDUAL CALCULATION & CONC. UPDATE
         DO K=KL1,KL2
         DO J=JL1V(K),JL2V(K)
         DO I=IL1,IL2
            IF(KEYOUT(I,J,K)>0) THEN
               RM = ABS(RESID(I,J,K,IC)/POR(I,J,K))
               IF (RM>RESID_M) RESID_M = RM
               CONC(I,J,K,IC)=-RESID(I,J,K,IC)/(PMDEN(I,J,K,1)
     &                        *SAT(I,J,K,1)*PV(I,J,K))+CONC(I,J,K,IC)
            ENDIF
         ENDDO
         ENDDO
         ENDDO
      END DO
     
      AQNEWT = AQNEWT + 1
CGUS Parallel run needs to be fixed
C$MANY            CALL UPDATE(N_CONC,1)
      ENDDO
 
      IF (AQNEWT>MAXNEWT) THEN
         WRITE(*,*)'WARNING: MAX. NEWTON EXCEEDED BY = ',AQNEWT-MAXNEWT
      ENDIF

      DEALLOCATE(RESID)

      RETURN
      END
