C  HSTEP.F - MAKE ONE TIME STEP WITH THE HYDROLOGY MODEL

C  ROUTINES IN THIS MODULE:

C  SUBROUTINE HSTEP1   (NERR)
C  SUBROUTINE HSTEP2   (KONVG,NERR)
C  SUBROUTINE HSTEP3   (KONVG,NERR)
C  SUBROUTINE HUPPRES   (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                       KEYOUT,NBLK,POIL,DUNK)
C  SUBROUTINE HPROP    (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                       KEYOUT,NBLK,POR,POIL,PWAT,COIL,DUNK,COILN,
C                       CWATN,RELPRM,DPCSW,COF,RESID,KROCK,POILN)
C  SUBROUTINE HBUGOUT  (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                       KEYOUT,NBLK,POR,POIL,PWAT,COIL,DUNK,COILN,
C                       CWATN,RELPRM,DPCSW,COF,RESID,KROCK,TCOFX,TCOFY,
C                       TCOFZ)
C  SUBROUTINE HMAXRESID (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                       KEYOUT,NBLK,RESID)

C  CODE HISTORY:

C  JOHN WHEELER     4/29/97    SKELETON ROUTINE
C  JOHN WHEELER     5/ 1/97    PORT HPROP ROUTINE FROM PIERS
C  JOHN WHEELER     5/24/97    ADD HBUGOUT AND HMAXRESID ROUTINES
C  JOHN WHEELER     9/15/97    COMPLETE BALANCES
C  JOHN WHEELER     6/10/99    SPLIT STEP ROUTINE FOR MULTIMODEL
C  GURPREET SINGH   10/16      TWO PHASE IMPLICIT BRICKS (APPROX)
C                              A NUMBER OF REDUNDANT OPERATIONS FROM
C                              FULLY IMPLICIT HYDROI ARE MAINTAINED
C                              FOR EXTENSION TO FULLY IMPLICIT TWO
C                              PHASE BRICKS
C    TAMEEM ALMANI   07/27/2016 INCLUDE NECESSARY CHANGES FOR
C                               COUPLING WITH MECHANICS
C    
C*********************************************************************
      SUBROUTINE HSTEP1 (NERR)
C*********************************************************************

C  Hydrology model exective routine to start a time step.
C  1.  Compute Jacobian and residual for Newtonian iteration.
C  2.  Start inter-block calculations.

C  NERR = ERROR KEY STEPPED BY ONE FOR EACH ERROR
C         (INPUT AND OUTPUT, INTEGER )

C*********************************************************************
      IMPLICIT NONE
$POWER      INCLUDE 'msjunk.h'

      INCLUDE 'control.h'
      INCLUDE 'blkary.h'
      INCLUDE 'wells.h'

      INCLUDE 'harydat.h'
      INCLUDE 'hbaldat.h'

      INTEGER IPROP(16),ITRAN(12),IWSUM(6),IHWEL(10),IVEL(11)
      DATA IPROP/16*0/,ITRAN/12*0/,IWSUM/6*0/,IHWEL/10*0/,
     &     IVEL/11*0/

      INTEGER N,IV,NERR

      EXTERNAL HPROP,HTRAN,HWELSUM,HWELL,HVELCOMP

C  DEFINE WORK ROUTINE ARGUMENTS 

      IF (HONCE(1)) THEN
         HONCE(1)=.FALSE.

         IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)'PROC',MYPRC,
     &    ' ENTERING SUBROUTINE HSTEP1, OLD TAG =',MSGTAG($HMODEL+1)

         IPROP(1)=15
         IPROP(2)=N_PV
         IPROP(3)=N_POIL
         IPROP(4)=N_PWAT
         IPROP(5)=N_COIL
         IPROP(6)=N_DDENS
         IPROP(7)=N_COILN
         IPROP(8)=N_CWATN
         IPROP(9)=N_RELPRM
         IPROP(10)=N_DPCSW
         IPROP(11)=N_COF
         IPROP(12)=N_RESID
         IPROP(13)=N_ROCK
         IPROP(14)=N_POILN
         IPROP(15)=N_PVN
         IPROP(16)=N_CR

         ITRAN(1)=11
         ITRAN(2)=N_POIL
         ITRAN(3)=N_PWAT
         ITRAN(4)=N_DDENS
         ITRAN(5)=N_RELPRM
         ITRAN(6)=N_DPCSW
         ITRAN(7)=N_COF
         ITRAN(8)=N_RESID
         ITRAN(9)=N_DEPTH
         ITRAN(10)=N_TCOFX
         ITRAN(11)=N_TCOFY
         ITRAN(12)=N_TCOFZ

         IWSUM(1)=5
         IWSUM(2)=N_DEPTH
         IWSUM(3)=N_POIL
         IWSUM(4)=N_PWAT
         IWSUM(5)=N_DDENS
         IWSUM(6)=N_RELPRM

         IHWEL(1)=9
         IHWEL(2)=N_DEPTH
         IHWEL(3)=N_POIL
         IHWEL(4)=N_PWAT
         IHWEL(5)=N_DDENS
         IHWEL(6)=N_RELPRM
         IHWEL(7)=N_DPCSW
         IHWEL(8)=N_COIL
         IHWEL(9)=N_COF
         IHWEL(10)=N_RESID

         IVEL(1)=10
         IVEL(2)=N_TCOFX
         IVEL(3)=N_TCOFY
         IVEL(4)=N_TCOFZ
         IVEL(5)=N_DEPTH
         IVEL(6)=N_POIL
         IVEL(7)=N_PWAT
         IVEL(8)=N_DDENS
         IVEL(9)=N_RELPRM      
         IVEL(10)=N_ROCK      
         IVEL(11)=N_HVEL

      ENDIF

C  START NEWTONIAN ITERATION LOOP
C  EVALUATE PHYSICAL PARAMETERS AND ACCUMULATION TERMS

      CURRENT(1)=0.D0
      CURRENT(2)=0.D0
      CALL TIMON(20)
      CALL CALLWORK(HPROP,IPROP)
      CALL TIMOFF(20)

C  EVALUATE PROPERTIES ON DIRICHLET BOUNDARIES

      CALL TIMON(18)
      CALL HBDPROP()
      CALL TIMOFF(18)

      IF((NHISUSE == 0).AND.(NSTEP < 1)) GO TO 9

      IF (NEWT.EQ.1.AND.TIM.EQ.0.D0) THEN
         BALANCE(1,MODACT,4)=CURRENT(1)
         BALANCE(2,MODACT,4)=CURRENT(2)
      ENDIF

C  EXCHANGE PHYSICAL PARAMETERS WITH NEIGHBORING PROCESSORS

$MANY      CALL TIMON(22)

$MANY      CALL UPDATE(N_POIL,1)
$MANY      CALL UPDATE(N_PWAT,1)
$MANY      CALL UPDATE(N_DDENS,1)
$MANY      CALL UPDATE(N_RELPRM,1)
$MANY      CALL UPDATE(N_DPCSW,1)

$MANY      CALL TIMOFF(22)

      CALL CALLWORK(HVELCOMP, IVEL)


C  EVALUATE TRANSPORT IN COEFFICIENTS AND RESIDUALS

      CALL TIMON(21)
      CALL CALLWORK(HTRAN,ITRAN)
      CALL TIMOFF(21)

C  EVALUATE TRANSPORT ACROSS DIRICHLET BOUNDARIES

      CALL TIMON(18)
      CALL HBDTRAN ()
      CALL TIMOFF(18)

C  EVALUATE WELL CONDITIONS

    9 CONTINUE

      CALL TIMON(10)

      DO 1 N=1,NUMWEL
      DO 3 IV=1,5
    3 WELIPC(IV,N)=0.D0
      DO 1 IV=1,12
    1 WELVEC(IV,N)=0.D0

      CALL CALLWORK(HWELSUM,IWSUM)

$MANY      CALL TIMON(23)
$MANY      DO 2 N=1,NUMWEL
$MANY      IF (MODWEL(N).EQ.MODACT)
$MANY     &   CALL WELSUM(N,12,WELVEC(1,N))
$MANY    2 CONTINUE                
$MANY      CALL TIMOFF(23)

      CALL CALLWORK(HWELL,IHWEL)

      CALL TIMOFF(10)

      IF((NHISUSE == 0).AND.(NSTEP < 1)) RETURN

C  SEND BLOCK INTERFACE DATA

$DUAL      CALL HDUALS()

      END
C*********************************************************************
      SUBROUTINE HSTEP2 (KONVG,NERR)
C*********************************************************************

C  Hydrology model exective routine to continue a time step
C  1.  Complete inter-block calculations
C  2.  Check Newtonian convergence

C  NERR = ERROR KEY STEPPED BY ONE FOR EACH ERROR
C         (INPUT AND OUTPUT, INTEGER)

C  KONVG = CONVERGENCE FLAG (OUTPUT, INTEGER)
C        = 1 ==> CONVERGED
C        = 2 ==> CONTINUE ITERATION
C        = 3 ==> FAILED
C        = 4 ==> CUT TIME STEP (SET BY FRAMEWORK ONLY)

C*********************************************************************
      IMPLICIT NONE
$POWER      INCLUDE 'msjunk.h'

      INCLUDE 'control.h'
      INCLUDE 'blkary.h'
      INCLUDE 'wells.h'
      INCLUDE 'layout.h'

      INCLUDE 'harydat.h'
      INCLUDE 'hbaldat.h'

      INTEGER IBUGO(16),IMRSD(2),ICOND(9)
      DATA NUMBUG6/0/,IBUGO/16*0/,IMRSD/2*0/,
     &     ICOND/9*0/

      INTEGER IW,I,NERR,NUMBUG6,KONVG
      
      EXTERNAL HBUGOUT,HMAXRESID,HCOND

      IF((NHISUSE == 0).AND.(NSTEP < 1)) RETURN

C  DEFINE WORK ROUTINE ARGUMENTS 

      IF (HONCE(2)) THEN
         HONCE(2)=.FALSE.

         IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)'PROC',MYPRC,
     &    ' ENTERING SUBROUTINE HSTEP2, OLD TAG =',MSGTAG($HMODEL+1)

         IBUGO(1)=15
         IBUGO(2)=N_POR
         IBUGO(3)=N_POIL
         IBUGO(4)=N_PWAT
         IBUGO(5)=N_COIL
         IBUGO(6)=N_DDENS
         IBUGO(7)=N_COILN
         IBUGO(8)=N_CWATN
         IBUGO(9)=N_RELPRM
         IBUGO(10)=N_DPCSW
         IBUGO(11)=N_COF
         IBUGO(12)=N_RESID
         IBUGO(13)=N_ROCK
         IBUGO(14)=N_TCOFX
         IBUGO(15)=N_TCOFY
         IBUGO(16)=N_TCOFZ

         ICOND(1)= 8
         ICOND(2) =N_PV
         ICOND(3) =N_DDENS
         ICOND(4) =N_COIL
         ICOND(5) =N_CWAT
         ICOND(6) =N_COF
         ICOND(7) =N_RESID
         ICOND(8) =N_HCOF
         ICOND(9) =N_HRESID

         IMRSD(1)=1
         IMRSD(2)=N_HRESID
         
      ENDIF

C  RECEIVE BLOCK INTERFACE DATA AND COMPLETE RESIDUALS

      FLUXOM(1)=0.D0
      FLUXOM(2)=0.D0
$DUAL      CALL HDUALR()

C ELIMINATE SATURATION UNKNOWNS FROM PHASE CONSERVATION EQUATIONS

      CALL TIMON(21)
      CALL CALLWORK(HCOND,ICOND)
      CALL TIMOFF(21)

C  DEBUG OUTPUT

      IF (BUGKEY(6).AND.(NEWT.LT.3).AND.(NUMBUG6.LT.7)) THEN
         CALL CALLWORK(HBUGOUT,IBUGO)
         NUMBUG6=NUMBUG6+1
         IF (LEVELC) THEN
            DO 6 IW=1,NUMWEL
            IF (MODWEL(IW).EQ.MODACT
$TRCHEM     &     .OR. MODACT.EQ.FLOWMODEL
     &         )
     &         WRITE (NFBUG,7) IW,(WELIPC(I,IW),I=1,5)
    6       CONTINUE
         ENDIF
    7    FORMAT(' WELL',I3,' QOI',G11.4,' QOP',G11.4,' QWI',G11.4,
     &    ' QWP',G11.4,' BHP',F8.2)
      ENDIF
 
C  CHECK NEWTONIAN CONVERGENCE

      RESIDM=0.D0
      RESIDT=0.D0
      KONVG=2
      IF (NEWT.EQ.1) THEN
CGUS ---- 2PHASE INEXACT NEWTON DIFFERS FROM EXACT NEWTON
C         CVTOL2=.5D0*(BALANCE(1,MODACT,4)+BALANCE(2,MODACT,4))*CVTOL
C         CVTOL1=5.D0*CVTOL2/NEMOD($HMODEL)
         CVTOL1 = CVTOL
         CVTOL2 = CVTOL
      ELSE
         CALL CALLWORK(HMAXRESID,IMRSD)

$MANY         CALL MAXIT(3,RESIDM)
$MANY         CALL SPREAD8(3,RESIDM)
$MANY         CALL SUMIT(1,RESIDT)
$MANY         CALL SPREAD8(1,RESIDT)

         IF (NEWT.LE.MAXITS) THEN
            IF (RESIDM.LT.CVTOL1.AND.
     &          ABS(RESIDT).LT.CVTOL2.AND.FLAG/=1) KONVG=1
         ELSE
            IF (RESIDM.LT.5.D0*CVTOL1.AND.
     &       ABS(RESIDT).LT.5.D0*CVTOL2.AND.
     &       FLAG/=1) THEN
               KONVG = 1
            ELSEIF(FLAG==1) THEN
               WRITE(0,*)'NEWTON FAILED: NEGATIVE CONCENTRATIONS'
               KONVG = 3
            ELSE
               KONVG = 3
            ENDIF
         ENDIF
      ENDIF

C  TRACE AND SCREEN OUTPUT

      IF (BUGKEY(7)) THEN
         WRITE (NFBUG,14) NEWT-1,MODACT,MYPRC,RESIDM,RESIDT
         WRITE (*,14) NEWT-1,MODACT,MYPRC,RESIDM,RESIDT
   14    FORMAT(' NEWT',I3,' MOD',I3,' PROC',I3,' Rm',G10.3,
     &          ' Rt', G10.3)
      ENDIF    

      END
C*********************************************************************
      SUBROUTINE HSTEP3 (KONVG,NERR)
C*********************************************************************
 
C  Hydrology model exective routine to complete a time step
C    1.  Update unknowns for next Newtonian iteration (KONVG = 2)
C    2.  Wrap up time step (KONVG = 1)
C    3.  Restart time step (KONVG = 4)
C    4.  Abort time step  (KONVG = 3)

C  KONVG = CONVERGENCE FLAG (INPUT, INTEGER)
C        = 1 ==> CONVERGED
C        = 2 ==> CONTINUE ITERATION
C        = 3 ==> FAILED
C        = 4 ==> CUT TIME STEP

C  NERR = ERROR KEY STEPPED BY ONE FOR EACH ERROR
C         (INPUT AND OUTPUT, INTEGER )

C*********************************************************************
      IMPLICIT NONE
$POWER      INCLUDE 'msjunk.h'

      INCLUDE 'control.h'
      INCLUDE 'blkary.h'
      INCLUDE 'wells.h'
      INCLUDE 'unitsex.h'

      INCLUDE 'harydat.h'
      INCLUDE 'hbaldat.h'

      INTEGER IUP(3),ICOPY(3),IFLOW(9),ICONC(6),ISCAL(4)
      REAL*8 DUB,WELISO,WELISW,CVMWW,CVMWO
      DATA IUP/3*0/,ICOPY/3*0/,IFLOW/9*0/,ICONC/6*0/,ISCAL/4*0/

      EXTERNAL HUPPRES,CPYARYR8,HFLOW,HUPCONC,HSCAL

      INTEGER KONVG,IW,N,NERR

ctm
$POROE      INTEGER PEKONVG
ctm

      IF((NHISUSE == 0).AND.(NSTEP < 1)) GO TO 1

C  DEFINE WORK ROUTINE ARGUMENTS 

      IF (HONCE(3)) THEN
         HONCE(3)=.FALSE.

         IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)'PROC',MYPRC,
     &    ' ENTERING SUBROUTINE HSTEP3, OLD TAG =',MSGTAG($HMODEL+1)

         IUP(1)=2
         IUP(2)=N_POIL
         IUP(3)=N_HDUNK

         IFLOW(1) = 8
         IFLOW(2) = N_COF
         IFLOW(3) = N_RESID
         IFLOW(4) = N_HDUNK
         IFLOW(5) = N_COIL
         IFLOW(6) = N_CWAT
         IFLOW(7) = N_PV
         IFLOW(8) = N_CR
         IFLOW(9) = N_DELC

         ICONC(1) = 5
         ICONC(2) = N_COIL
         ICONC(3) = N_CWAT
         ICONC(4) = N_DELC
         ICONC(5) = N_PV
         ICONC(6) = N_PVN

      ENDIF

C  BRANCH ON CONVERGENCE STATE

      GO TO (1,2,1,4),KONVG

C  CONTINUE NEWTONIAN ITERATION

    2 IF (BUGKEY(6).AND.NEWT.LT.3) THEN
         TITU='CHANGE IN OIL PRESSURE FOR FAULT BLOCK'
         CALL GEAOUT(N_DUNK,1,1)
         TITU='CHANGE IN OIL CONCENTRATION FOR FAULT BLOCK'
         CALL GEAOUT(N_DUNK,2,1)
      ENDIF

C  UPDATE GRID SOLUTION

      CALL CALLWORK(HUPPRES,IUP)
      
C  BACKSOLVE FOR CHANGE IN SATURATION

      CALL CALLWORK(HFLOW,IFLOW)
      
C  UPDATE OIL CONCENTRATION
      CALL CALLWORK(HUPCONC,ICONC)


C  UPDATE BOTTOM HOLE PRESSURE FOR RATE CONTROLED WELLS

      DO 30 IW=1,NUMWEL
      IF (MODWEL(IW).EQ.MODACT) THEN
         WELBHP(IW)=WELBHP(IW)+DWELBHP(IW)
         WELDEN(IW)=WELDEN(IW)+DWELDEN(IW)
      ENDIF
   30 CONTINUE

      RETURN

C  NEWTONIAN ITERATION CONVERGED OR FAILED
C  UPDATE WELL DATA AND BALANCES AT END OF TIME STEP

    1 CONTINUE

C  CHECK SATURATION ERROR

C      IF (KONVG==1) THEN
C         I4UTIL = 0 
C         ISCAL(1) = 3
C         ISCAL(2) = N_COIL
C         ISCAL(3) = N_CWAT
C         ISCAL(4) = N_I4U
C         CALL CALLWORK(HSCAL,ISCAL)
C         FLAG = I4UTIL
CGUS - HARDCODING FLAG = 0 TO UNDO HSCAL
         FLAG = 0
C      ENDIF

$MANY      CALL TIMON(23)
$MANY      DO 11 N=1,NUMWEL
$MANY      IF (MODWEL(N).EQ.MODACT)
$MANY     &   CALL WELSUM(N,4,WELIPC(1,N))
$MANY   11 CONTINUE
$MANY      CALL WELGET(5,WELIPC)
$MANY      CALL TIMOFF(23)

      IF (MYPRC.EQ.0) THEN

         WELISW=0.D0
         WELISO=0.D0
         CVMWW=CVMWELL/DELTIM
         CVMWO=CVMWELL/DELTIM
         IF (STBEXT) CVMWO=CVMWO*STDENW/STDENO
         DO 9 N=1,NUMWEL
         IF (MODWEL(N).EQ.MODACT) THEN
            WELOI(N)=WELOI(N)+WELIPC(1,N)
            WELOP(N)=WELOP(N)+WELIPC(2,N)
            WELWI(N)=WELWI(N)+WELIPC(3,N)
            WELWP(N)=WELWP(N)+WELIPC(4,N)
            IF (KWELL(N).LT.31) THEN
               GOTO (20,21,22),KWELL(N)+1
            ELSE
               GOTO (23,24,24,20,24),KWELL(N)-30
            ENDIF

   21       CALL WELLOUT (N,1,WELIPC(3,N)*CVMWW)
            GO TO 20

   22       CALL WELLOUT (N,1,WELIPC(3,N)*CVMWW)
            CALL WELLOUT (N,7,WELIPC(5,N)*CVMPRES)
            GO TO 20

   23       CALL WELLOUT (N,2,WELIPC(2,N)*CVMWO)
            CALL WELLOUT (N,3,WELIPC(4,N)*CVMWW)
            DUB=1000.D0
            IF (WELIPC(2,N).NE.0.D0)
     &         DUB=WELIPC(4,N)*CVMWW/(WELIPC(2,N)*CVMWO)
            CALL WELLOUT (N,5,DUB)
            GO TO 20

   24       CALL WELLOUT (N,2,WELIPC(2,N)*CVMWO)
            CALL WELLOUT (N,3,WELIPC(4,N)*CVMWW)
            DUB=1000.D0
            IF (WELIPC(2,N).NE.0.D0)
     &         DUB=WELIPC(4,N)*CVMWW/(WELIPC(2,N)*CVMWO)
            CALL WELLOUT (N,5,DUB)
            CALL WELLOUT (N,7,WELIPC(5,N)*CVMPRES)
            GO TO 20

   20       WELISO=WELISO+WELIPC(1,N)-WELIPC(2,N)
            WELISW=WELISW+WELIPC(3,N)-WELIPC(4,N)
         ENDIF
    9    CONTINUE

         IF((NHISUSE == 0).AND.(NSTEP < 1)) RETURN

         BALANCE(1,MODACT,2)=WELISO
         BALANCE(2,MODACT,2)=WELISW

         IF (BUGKEY(7)) THEN
            DO 14 IW=1,NUMWEL
            IF (MODWEL(IW).EQ.MODACT)
     &         WRITE (NFOUT,15) IW,WELOI(IW),
     &         WELOP(IW),WELWI(IW),WELWP(IW)
   14       CONTINUE
   15       FORMAT(' WELL',I4,' QOI=',G12.5,' QOP=',G12.5,' QWI=',
     &         G12.5,' QWP=',G12.5)
         ENDIF
      ENDIF
      IF((NHISUSE == 0).AND.(NSTEP < 1)) RETURN

      CALL TIMON(18)
      CALL HBDBAL ()
      CALL TIMOFF(18)

      BALANCE(1,MODACT,1)=CURRENT(1)
      BALANCE(2,MODACT,1)=CURRENT(2)
      BALANCE(1,MODACT,3)=FLUXOM(1)
      BALANCE(2,MODACT,3)=FLUXOM(2)
      BALANCE(1,MODACT,7)=OILITNP
      BALANCE(2,MODACT,7)=WATITNP

C  OUTPUT DIRICHLET BOUNDARY DATA

      CALL BND_OUT()

ctm MECHANICS

$POROE      PEKONVG = 0
$POROE      IF (KONVG.EQ.1) THEN
$POROE         IF(MODELON($PEMODEL)) THEN
$POROE           CALL EITER(PEKONVG,NERR)
$POROE           IF(PEKONVG.NE.1) KONVG = 2
$POROE           ENDIF
C RESETTING NEWTON FOR MECHANICS
$POROEC           NEWT = 0
$POROE           NEWT = 1
$POROE      ENDIF

ctm MECHANICS

      RETURN

C  TIME STEP CUT

    4 ICOPY(1)=2
      ICOPY(2)=N_POILN
      ICOPY(3)=N_POIL
      CALL CALLWORK(CPYARYR8,ICOPY)
      ICOPY(2)=N_COILN
      ICOPY(3)=N_COIL
      CALL CALLWORK(CPYARYR8,ICOPY)
      ICOPY(2)=N_PVN
      ICOPY(3)=N_PV
      CALL CALLWORK(CPYARYR8,ICOPY)

$POROE       CALL ECUTTIME(NERR)

ctm
      RETURN
ctm

      END
C*********************************************************************
      SUBROUTINE HUPPRES (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                 KEYOUT,NBLK,POIL,DUNK)
C*********************************************************************
 
C  ROUTINE UPDATES SOLUTION.  THIS IS A WORK ROUTINE.

C  POIL(I,J,K) = OIL PRESSURE, PSI (INPUT AND OUTPUT, REAL*8)

C  DUNK(I,J,K,1) = CHANGE IN OIL PRESSURE, PSI (INPUT, REAL*8)
C***********************************************************************
      IMPLICIT NONE

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V(KDIM),JL2V(KDIM),
     &        KL1,KL2,KEYOUT(IDIM,JDIM,KDIM),NBLK
      REAL*8 POIL(IDIM,JDIM,KDIM),DUNK(IDIM,JDIM,KDIM)

      INTEGER I,J,K,JL1,JL2

cgp dbg
      INCLUDE 'control.h'
      LOGICAL DBG
      DATA DBG /.FALSE./

      IF (DBG) THEN
         WRITE(0,*)
         WRITE(0,'(A,I2,A,I2,A)')'------------- NSTEP ',NSTEP,' NEWT',
     &                      NEWT,': HUPPRES -------------'
c         PAUSE
      ENDIF
cgp dbg

      DO K=KL1,KL2
      JL1=JL1V(K)
      JL2=JL2V(K)
      DO J=JL1,JL2
      DO I=IL1,IL2
      IF (KEYOUT(I,J,K).EQ.1) THEN
cgp dbg 
         IF (DBG) THEN
            WRITE(0,'(A,3I3,3(3X,A,E23.15))')'I,J,K',I,J,K,
     &              'POIL',POIL(I,J,K),'DUNK',DUNK(I,J,K),
     &              'POIL+',POIL(I,J,K)+DUNK(I,J,K)
         ENDIF
cgp dbg 
         POIL(I,J,K)=POIL(I,J,K)+DUNK(I,J,K)
      ENDIF
      ENDDO
      ENDDO
      ENDDO
      
      RETURN
      END
C*********************************************************************
      SUBROUTINE HPROP (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                 KEYOUT,NBLK,PV,POIL,PWAT,COIL,DENS,COILN,
     &                 CWATN,RELPRM,DPCSW,COF,RESID,KROCK,POILN,PVN,CR)
C*********************************************************************
 
C  ROUTINE EVALUATES CURRENT PHYSICAL CONDITIONS AND ACCUMILATION
C  TERMS IN COEFFICIENTS AND RESIDUALS.  THIS IS A WORK ROUTINE.

C  PV(I,J,K)  = PORE VOLUME (INPUT, REAL*8)

C  PVN(I,J,K)  = PORE VOLUME AT OLD TIMESTEP (OUTPUT, REAL*8)

C  POIL(I,J,K) = OIL PRESSURE, PSI (INPUT, REAL*8)

C  PWAT(I,J,K) = WATER PRESSURE, PSI (OUTPUT, REAL*8)

C  COIL(I,J,K) = OIL CONCENTRATION, LB/CU-FT (INPUT, REAL*8)

C  DENS(I,J,K,1) = OIL DENSITY, LB/CU-FT (OUTPUT, REAL*8)
C  DENS(I,J,K,2) = WATER DENSITY, LB/CU-FT (OUTPUT, REAL*8)

C  COILN(I,J,K) = OIL CONCENTRATION AT BEGINNING OF TIME STEP , LB/CU-FT
C                 (OUTPUT, REAL*8)

C  CWATN(I,J,K) = WATER CONCENTRATION AT BEGINNING OF TIME STEP , LB/CU-FT
C                 (OUTPUT, REAL*8)

C  RELPRM(I,J,K) = RELATIVE PERMEABILITY DATA (OUTPUT, REAL*8)

C  DPCSW(I,J,K) = DERIVATIVE OF Pc WRT Sw, PSI (OUTPUT, REAL*8)

C  COF(I,J,K,N,L)  = JACOBIAN COEFFICIENTS (OUTPUT, REAL*4)

C  RESID(I,J,K,L)= RESIDUALS (OUTPUT, REAL*8)

C  KROCK(I,J,K)= ROCK TYPE (INPUT, INTEGER )

C  POILN(I,J,K) = OIL PRESSURE AT BEGINNING OF STEP, PSI (OUTPUT, REAL*8)

C  CR(I,J,K) = ROCK COMPRESSIBILITY, 1/PSI (INPUT, REAL*8)

C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'rock.h'
      INCLUDE 'hfluids.h'
      INCLUDE 'hbaldat.h'

      INTEGER IDIM,JDIM,KDIM,IL1,IL2,JL1V(KDIM),JL2V(KDIM),
     &        KL1,KL2,KEYOUT(IDIM,JDIM,KDIM),NBLK,LDIM,
     &        KROCK(IDIM,JDIM,KDIM)
      REAL*8 PV(IDIM,JDIM,KDIM),
     &       POIL(IDIM,JDIM,KDIM),        DPCSW(IDIM,JDIM,KDIM),
     &       PWAT(IDIM,JDIM,KDIM),        COIL(IDIM,JDIM,KDIM),
     &       DENS(IDIM,JDIM,KDIM,2),      RESID(IDIM,JDIM,KDIM,2),
     &       COILN(IDIM,JDIM,KDIM),       CWATN(IDIM,JDIM,KDIM),
     &       RELPRM(IDIM,JDIM,KDIM,4),    POILN(IDIM,JDIM,KDIM),
     &       PVN(IDIM,JDIM,KDIM), CR(IDIM,JDIM,KDIM)
    
      REAL*4 COF(IDIM,JDIM,KDIM,$NUMCOF,2)

      REAL*8 DOP,DWP,SW,SO,PC,OIL,WAT
      INTEGER I,J,K,JL1,JL2,L

      COF = 0.D0

      DO 1 K=KL1,KL2
      JL1=JL1V(K)
      JL2=JL2V(K)
      DO 1 J=JL1,JL2
      DO 1 I=IL1,IL2
      IF (KEYOUT(I,J,K).NE.1) GO TO 1
    
C********* EVALUATE DENSITIES, SATURATION, AND PRESSURES
      
      DOP=OILCMP*POIL(I,J,K)
      DOP=((((((1.38888889D-3*DOP+8.333333333D-3)*DOP+4.1666666667D-2)
     & *DOP+.166666666667D0)*DOP+.5D0)*DOP+1.D0)*DOP+1.D0)*OILDEN
      DENS(I,J,K,1)=DOP
      SO=COIL(I,J,K)/DOP
      SW=1.D0-SO
      L=KROCK(I,J,K)
      CALL LOOKUP(NPCOW(L),SW,PC,DPCSW(I,J,K))
      PWAT(I,J,K)=POIL(I,J,K)-PC
      DWP=WATCMP*PWAT(I,J,K)
      DWP=((((((1.38888889D-3*DWP+8.333333333D-3)*DWP+4.1666666667D-2)
     & *DWP+.166666666667D0)*DWP+.5D0)*DWP+1.D0)*DWP+1.D0)*WATDEN
      DENS(I,J,K,2)=DWP
    
C********* EVALUATE RELATIVE PERMEABILITIES
    
      CALL LOOKUP(NKOSW(L),SW,RELPRM(I,J,K,1),RELPRM(I,J,K,2))
      CALL LOOKUP(NKWSW(L),SW,RELPRM(I,J,K,3),RELPRM(I,J,K,4))
    
C********* INITIALIZE ACCUMULATION TERMS
    
      COF(I,J,K,1,1)=(PV(I,J,K)*OILCMP+CR(I,J,K))*DOP*SO
      COF(I,J,K,1,2)=(PV(I,J,K)*WATCMP+CR(I,J,K))*DWP*SW

      OIL=COIL(I,J,K)*PV(I,J,K)
      WAT=DWP*SW*PV(I,J,K)

      IF (NEWT==1.OR.NSTEP<1) THEN
         CWATN(I,J,K)=DWP*SW
         COILN(I,J,K)=COIL(I,J,K)
         POILN(I,J,K)=POIL(I,J,K)
         PVN(I,J,K) = PV(I,J,K)
         RESID(I,J,K,1)=0.D0
         RESID(I,J,K,2)=0.D0
      ELSE
         RESID(I,J,K,1)=-COILN(I,J,K)*PVN(I,J,K)+OIL
         RESID(I,J,K,2)=-CWATN(I,J,K)*PVN(I,J,K)+WAT
      ENDIF         

      CURRENT(1)=CURRENT(1)+OIL
      CURRENT(2)=CURRENT(2)+WAT
    1 CONTINUE

      END
C*********************************************************************
      SUBROUTINE HBUGOUT (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
     &                 KL2,KEYOUT,NBLK,POR,POIL,PWAT,COIL,DUNK,COILN,
     &                 CWATN,RELPRM,DPCSW,COF,RESID,KROCK,TCOFX,TCOFY,
     &                 TCOFZ)
C*********************************************************************
 
C  ROUTINE OUTPUT DEBUG DATA.  THIS IS A WORK ROUTINE.

C  POR(I,J,K)  = PORE VOLUME (INPUT, REAL*4)

C  POIL(I,J,K) = OIL PRESSURE, PSI (INPUT, REAL*8)

C  PWAT(I,J,K) = WATER PRESSURE, PSI (INPUT, REAL*8)

C  COIL(I,J,K) = OIL CONCENTRATION, LB/CU-FT (INPUT, REAL*8)

C  DUNK(I,J,K,1) = OIL DENSITY, LB/CU-FT (INPUT, REAL*8)
C  DUNK(I,J,K,2) = WATER DENSITY, LB/CU-FT (INPUT, REAL*8)

C  COILN(I,J,K) = OIL CONCENTRATION AT BEGINNING OF TIME STEP , LB/CU-FT
C                 (INPUT, REAL*8)

C  CWATN(I,J,K) = WATER CONCENTRATION AT BEGINNING OF TIME STEP , LB/CU-FT
C                 (INPUT, REAL*8)

C  RELPRM(I,J,K) = RELATIVE PERMEABILITY DATA (INPUT, REAL*8)

C  DPCSW(I,J,K) = DERIVATIVE OF Pc WRT Sw, PSI (INPUT, REAL*8)

C  COF(I,J,K,N,L,M)  = JACOBIAN COEFFICIENTS (INPUT, REAL*4)

C  RESID(I,J,K)= RESIDUALS (INPUT, REAL*8)

C  KROCK(I,J,K)= ROCK TYPE (INPUT, INTEGER )

C  TCOFX(I,J,K) = TRANSMISSABILITY CONSTANT (INPUT, REAL*8)
C  TCOFY(I,J,K)
C  TCOFZ(I,J,K)

C  NOTE: FOR PROCESSORS OTHER THAN 0, THIS ROUTINE MAY WRITE TO FORT.2

C***********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'

      INCLUDE 'hbaldat.h'

      INTEGER  JL1V(KDIM),JL2V(KDIM),    KEYOUT(IDIM,JDIM,KDIM),
     &         KROCK(IDIM,JDIM,KDIM)
      REAL*4 COF(IDIM,JDIM,KDIM,$NUMCOF,2,2),
     &       POR(IDIM,JDIM,KDIM)
      REAL*8 POIL(IDIM,JDIM,KDIM),        DPCSW(IDIM,JDIM,KDIM),
     &       PWAT(IDIM,JDIM,KDIM),        COIL(IDIM,JDIM,KDIM),
     &       DUNK(IDIM,JDIM,KDIM,2),      RESID(IDIM,JDIM,KDIM,2),
     &       COILN(IDIM,JDIM,KDIM),       CWATN(IDIM,JDIM,KDIM),
     &       TCOFX(IDIM,JDIM,KDIM),       TCOFY(IDIM,JDIM,KDIM),
     &       TCOFZ(IDIM,JDIM,KDIM),       RELPRM(IDIM,JDIM,KDIM,4)

      CALL OPENBUG()
      IF (.NOT.BUGOPEN) RETURN

      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,MERR)

      WRITE (NFBUG,1) TIM,DELTIM,NEWT
    1 FORMAT(/' DEBUG OUTPUT AT TIME =',F10.4,', DELTIM =',F10.5,
     &  ' NEWT =',I3)
      IF (LEVELC) WRITE (NFBUG,31) CURRENT
   31 FORMAT(' TOTAL OIL =',G16.8,', TOTAL WATER =',G16.8)

      WRITE(NFBUG,16) MYPRC,IL1,IL2,JL1V(KL2),JL2V(KL2),KL1,KL2,IOFF,
     & JOFF,KOFF
   16 FORMAT(' PROC',I4,', IL1',I4,', IL2',I4,', JL1(KL2)',I4,
     & ', JL2(KL2)',I4,', KL1',I4,', KL2',I4/' IOFF',I4,', JOFF',I4,
     & ', KOFF',I4)

      DO 10 LL=1,3

      IF (ITRACE(LL).LT.1) THEN
         IO=(IL1+IL2)/2
         IF (LL.EQ.1) THEN
            KO=KL1
            JO=JL1V(KO)
         ELSE
            IF (LL.EQ.2) THEN
               KO=(KL1+KL2)/2
               IF (NUMPRC.EQ.1) THEN
                  JO=(JL1V(KO)+JL2V(KO))/2
               ELSE
                  JO=JL2V(KO)
               ENDIF
            ELSE
               KO=KL2
               JO=JL2V(KO)
            ENDIF
         ENDIF
      ELSE
         IO=ITRACE(LL)-IOFF
         JO=JTRACE(LL)-JOFF
         KO=KTRACE(LL)-KOFF
      ENDIF

      IF (IO.LT.1.OR.IO.GT.IDIM) GO TO 10
      IF (KO.LT.1.OR.KO.GT.KDIM) GO TO 10
      IF (JO.LT.1.OR.JO.GT.JDIM) GO TO 10

      WRITE (NFBUG,11) IO+IOFF,JO+JOFF,KO+KOFF,NBLK
   11 FORMAT(/' I LOCATION=',I5,', J LOCATION =',I5,', K LOCATION =',
     &  I5,' BLOCK =',I3)

      WRITE (NFBUG,18) KEYOUT(IO,JO,KO)
   18 FORMAT (' KEYOUT(I,J,K)',T22,I12)
      IF (IO.GT.1) WRITE (NFBUG,19) KEYOUT(IO-1,JO,KO)
   19 FORMAT (' KEYOUT(I-1,J,K)',T22,I12)
      IF (IO.LT.IDIM) WRITE (NFBUG,20) KEYOUT(IO+1,JO,KO)
   20 FORMAT (' KEYOUT(I+1,J,K)',T22,I12)
      IF (JO.GT.1) WRITE (NFBUG,21) KEYOUT(IO,JO-1,KO)
   21 FORMAT (' KEYOUT(I,J-1,K)',T22,I12)
      IF (JO.LT.JDIM) WRITE (NFBUG,22) KEYOUT(IO,JO+1,KO)
   22 FORMAT (' KEYOUT(I,J+1,K)',T22,I12)
      IF (KO.GT.1) WRITE (NFBUG,23) KEYOUT(IO,JO,KO-1)
   23 FORMAT (' KEYOUT(I,J,K-1)',T22,I12)
      IF (KO.LT.KDIM) WRITE (NFBUG,24) KEYOUT(IO,JO,KO+1)
   24 FORMAT (' KEYOUT(I,J,K+1)',T22,I12)

      IF (IO.LT.IL1.OR.IO.GT.IL2) GO TO 10
      IF (KO.LT.KL1.OR.KO.GT.KL2) GO TO 10
      IF (JO.LT.JL1V(KO).OR.JO.GT.JL2V(KO)) GO TO 10
      IF (KEYOUT(IO,JO,KO).NE.1) GO TO 10
 
      DO 2 L=1,7
      WRITE (NFBUG,3) L,COF(IO,JO,KO,L,1,1),COF(IO,JO,KO,L,1,2)
    3 FORMAT (' COF(I,J,K,',I2,',,)',T22,2G16.7)
    2 WRITE (NFBUG,4) COF(IO,JO,KO,L,2,1),COF(IO,JO,KO,L,2,2)
    4 FORMAT (T22,2G16.7)

      WRITE (NFBUG,5) RESID(IO,JO,KO,1),RESID(IO,JO,KO,2)
    5 FORMAT (' RESID(I,J,K)',T22,G17.9/T22,G17.9)

      WRITE (NFBUG,12) TCOFX(IO,JO,KO),TCOFX(IO+1,JO,KO)
   12 FORMAT (' TCOFX(I,J,K)',T22,G17.9,', TCOFX(I+1,J,K)',G17.9)

      WRITE (NFBUG,8) TCOFY(IO,JO,KO),TCOFY(IO,JO+1,KO)
    8 FORMAT (' TCOFY(I,J,K)',T22,G17.9,', TCOFY(I,J+1,K)',G17.9)

      WRITE (NFBUG,9) TCOFZ(IO,JO,KO),TCOFZ(IO,JO,KO+1)
    9 FORMAT (' TCOFZ(I,J,K)',T22,G17.9,', TCOFZ(I,J,K+1)',G17.9)

      WRITE (NFBUG,14) POIL(IO,JO,KO),PWAT(IO,JO,KO)
   14 FORMAT (' POIL(I,J,K)',T22,G17.9,', PWAT(I,J,K)   ',G17.9)

   10 CONTINUE

      END
C*********************************************************************
      SUBROUTINE HMAXRESID (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
     &                 KL2,KEYOUT,NBLK,RESID)
C*********************************************************************
 
C  ROUTINE PICKS OUT LOCAL MAXIMUM RESIDUALS AND TOTALS RESIDUALS.
C  THIS IS A WORK ROUTINE.

C  RESID(I,J,K,N)= RESIDUALS (INPUT, REAL*8)

C  NOTE:  RESULTS ARE PUT IN COMMON /HBALDAT/
C***********************************************************************
      IMPLICIT NONE
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'layout.h'

      INCLUDE 'hbaldat.h'


      INTEGER  IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V(KDIM),JL2V(KDIM),
     &         KL1,KL2,KEYOUT(IDIM,JDIM,KDIM),NBLK
      REAL*8 RESID(IDIM,JDIM,KDIM)

      INTEGER IRM,JRM,KRM,NBRM,IOFF,JOFF,KOFF,I,J,K,MERR,JL1,JL2
      REAL*8  RMA,RT,RM

      RT=RESIDT
      RM=RESIDM

      DO 1 K=KL1,KL2
      JL1=JL1V(K)
      JL2=JL2V(K)
      DO 1 J=JL1,JL2
      DO 1 I=IL1,IL2
      IF (KEYOUT(I,J,K).EQ.1) THEN
         RT=RT+RESID(I,J,K)
         IF (ABS(RESID(I,J,K)).GT.RM) THEN
            IRM=I
            JRM=J
            KRM=K
            NBRM=NBLK
            RMA=RESID(I,J,K)
            RM=ABS(RMA)
         ENDIF
      ENDIF
    1 CONTINUE
      RESIDT=RT
      RESIDM=RM

      IF (BUGOPEN.AND.BUGKEY(7).AND.NBLK.EQ.NUMBLK) THEN
         CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,MERR)
         WRITE(NFBUG,12) RMA,IRM+IOFF,JRM+JOFF,KRM+KOFF,NBRM
   12    FORMAT(' MAX RESID =',G13.6,T34,' AT I,J,K =',3I4,', BLK',
     &   I4)
      ENDIF
 
      END
