C  LAYOUT.H - MEMORY MANAGEMENT AND PARALLEL DATA

      REAL*8 GRAV,GMAG,DOWN,XREC,YREC,ZREC,CONV_FACTOR
      INTEGER PRCMAP,NUMBLK,ILAY,JLAY,KLAY,MAXREF,NUMTMP,NUMMODEL,
     & MSGS,NEMOD,MSGTRG,MSGSRC,LSTIND,MSGSNDF,MSGSNDL,MSGRCVF,
     & MSGRCVL,MSGIND,NYMAP,KNDGRD,METHOD,EV_PRCBLK,NETOTR0,NETOTR,
     & N0MAP
      REAL*4 DXREC,DYREC,DZREC,XYZ111
      LOGICAL MYBLK,MODPROC,MFMFE_BRICKS,PLOT_MYPRC,DEALII,
     &  DATASPACES,MPI_EXTERNAL,COMMI_DONE

      COMMON /LAYOUT/ GRAV,GMAG($MXBLKS),DOWN(3,$MXBLKS),
     & XREC($MXRECXP,$MXBLKS),
     & YREC($MXRECYP,$MXBLKS), ZREC($MXRECZP,$MXBLKS),CONV_FACTOR,
     & PRCMAP($MXCOLS), NUMBLK,ILAY,JLAY,KLAY,MAXREF,NUMTMP,NUMMODEL,
     & MSGS($MXTMP,$MXBLKS),MODPROC($MXMOD,$MXPROC),NEMOD($MXMOD),
     & MSGTRG($MXMPP,$MXTMP,$MXBLKS),
     & MSGSRC($MXMPP,$MXTMP,$MXBLKS),LSTIND,MSGSNDF($MXMPP,$MXTMP,$MXBLKS),
     & MSGSNDL($MXMPP,$MXTMP,$MXBLKS),MSGRCVF($MXMPP,$MXTMP,$MXBLKS),
     & MSGRCVL($MXMPP,$MXTMP,$MXBLKS),MSGIND(2,$MXMGI),N0MAP($MXBLKS),
     & NYMAP($MXBLKS),KNDGRD,METHOD,EV_PRCBLK,NETOTR0,NETOTR($MXMOD),
     & MYBLK($MXBLKS),
     & DXREC($MXRECX,$MXBLKS),DYREC($MXRECY,$MXBLKS),
     & DZREC($MXRECZ,$MXBLKS),XYZ111(3,$MXBLKS),
     & MFMFE_BRICKS,PLOT_MYPRC,DEALII,
     & DATASPACES,MPI_EXTERNAL,COMMI_DONE

CBW EXTENTION TO NODAL BASED COMMUNICATION
      INTEGER PRCMAPN, N0MAPN
      COMMON /LAYOUTN/ PRCMAPN(2*$MXCOLS), N0MAPN($MXBLKS)
CBW

c bag8 - local flux
      INTEGER EVFEM_HEX
      COMMON /EVFEM_COM/EVFEM_HEX

c bag8 - adapt evfem
      INTEGER ADAPT_MODE,N_MARK,XAPRIORI,NEADAPT,ADAPT_INDICATOR
      LOGICAL ADAPTIVITY,ADAPT_START_FINE,ADAPT_REFINE_MOVE1,
     &  ADAPT_RESET,ADAPT_MARK_LEVEL
      COMMON /ADAPT_COM/ADAPT_MODE,N_MARK,XAPRIORI,NEADAPT,
     &  ADAPT_INDICATOR,ADAPTIVITY,ADAPT_START_FINE,
     &  ADAPT_REFINE_MOVE1,ADAPT_RESET,ADAPT_MARK_LEVEL

C*********************************************************************

C  NUMBLK = NUMBER OF GRID BLOCKS

C  ILAY,JLAY,KLAY = NUMBER OF COMMUNICATION LAYERS IN 3 DIRECTIONS

C  METHOD = METHOD OF DIVIDING GRID ELEMENTS AMONG PROCESSORS
C         = 1 ==> SQUARE ASSIGNMENT
C         = 2 ==> STRIP ASSIGNMENT

C  EV_PRCBLK = OPTION TO INHERIT PROCESSOR ASSIGNMENT FROM FAULT BLOCKS
C           (DEFAULT = 0, OFF)

C  MAXREF = MAXIMUM GRID-REFINEMENT LEVELS

C  NUMTMP = NUMBER OF MESSAGE TEMPLATES IN USE

C  CONV_FACTOR = CONVERSION FACTOR FOR TRANSMISSIBILITY
C      = 6.3282864E-3 for field units (default) [(cu-ft cp) / (psi day)]
C      = 1.0 for dimensionless or SI units

C  GRAV    = GRAVITY MAGNITUDE (PSI SQ-FT/ LB)

C  DOWN(i,n) = GRAVITY UNIT VECTOR FOR FAULT BLOCK n

C  XREC(i,n),YREC(j,n),ZREC(k,n) = GRID ELEMENT LOCATIONS FOR FAULT
C  BLOCK n (ORTHOGONAL GRID OPTION) (FT)

C  MSGS(n,k) = NUMBER OF SEND MESSAGES FOR TEMPLATE n AND FAULT BLOCK k
C              (Assume equal number of receive messages.)
C     n = 1 ==> adjacent elements only (7 point template)
C       = 2 ==> cube (27 point template) (also cornerless cube)
C       = 3 ==> higher order (33 point template) (requires 2 comm layers)
C       = 4 ==> finite element (27 point template)(requires 2 comm layers)

C  MSGTRG(m,n,k) = TARGET PROCESSOR OF SEND MESSAGE m FOR TEMPLATE n AND
C                  FAULT BLOCK k

C  MSGSRC(m,n,k) = SOURCE PROCESSOR OF RECEIVE MESSAGE m FOR TEMPLATE n
C                  AND FAULT BLOCK k

C  LSTIND = LAST INDEX IN MSGIND USED

C  MSGSNDF(m,n,k) = 1ST INDEX IN MSGIND OF SEND MESSAGE m FOR TEMPLATE n
C                   AND FAULT BLOCK k

C  MSGSNDL(m,n,k) = LAST INDEX IN MSGIND OF SEND MESSAGE m FOR
C                   TEMPLATE n AND FAULT BLOCK k

C  MSGRCVF(m,n,k) = 1ST INDEX IN MSGIND OF RECEIVE MESSAGE m FOR
C                   TEMPLATE n AND FAULT BLOCK k

C  MSGRCVL(m,n,k) = LAST INDEX IN MSGIND OF RECEIVE MESSAGE m FOR
C                   TEMPLATE n AND FAULT BLOCK k

C  MSGIND(L,I) = GRID INDEXES FOR MESSAGE ENTRY I
C  L = 1,2 ==> J,K GLOBAL INDEXES OF MESSAGE DATA

C  N0MAP(N) = BASE LOCATION FOR BLOCK N IN PRCMAP

C  NYMAP(N) = NUMBER OF ELEMENTS IN THE Y DIRECTION FOR BLOCK N IN
C  PRCMAP

C  KNDGRD = GRID OPTION KEY
C         = 1 ==> ORTHOGONAL GRID OPTION
C         = 2 ==> CORNER POINT OPTION

C  NEMOD(m) = TOTAL GRID ELEMENTS FOR MODEL m

C  NETOTR0 = TOTAL NUMBER OF GRID ELEMENTS IN ALL RESTART RECORDS FOR
C            A FRAMEWORK ARRAY

C  NETOTR(m) = TOTAL NUMBER OF GRID ELEMENTS IN ALL RESTART RECORDS FOR
C              A MODEL m ARRAY

C  DXREC(i,n), DYREC(j,n), DZREC(k,n) = GRID INTERVAL LENGTHS FOR FAULT
C  BLOCK n (ORTHOGONAL GRID OPTION) (FT)

C  XYZ111(i,n) = X, Y, AND Z VALUES OF OUTSIDE CORNER OF GRID BLOCK 1,1,1
C  OF FAULT BLOCK n (ORTHOGONAL GRID OPTION) (FT)

C  PRCMAP(M) = PROCESSOR ASSIGNMENTS FOR EACH GRID COLUMN IN EACH
C  BLOCK OF GRID ELEMENTS.  PRCMAP INDEXES ARE GLOBAL, NOT LOCAL.
C  M = M1 + (K-1) * JDIM + J - 1
C    = N0MAP(N) + K * NYMAP(N) + J WHERE
C  N = GRID-BLOCK NUMBER
C  J = Y INDEX IN THE BLOCK
C  K = Z INDEX IN THE BLOCK
C  PRCMAP() = -2 ==> Grid column not in the system

C  MYBLK(n) = TRUE IF THE ACTIVE PROCESSOR HAS ELEMENTS IN FAULT BLOCK n
C             OTHERWISE FALSE

C  MODPROC(m,j) = TRUE IF MODEL m IS RUNNING ON PROCESSOR (j-1)

C  NUMMODEL = NUMBER OF ACTIVE PHYSICAL MODELS

C bag8
C  EVFEM_HEX = FLAG FOR USING ENHANCED VELOCITY WITH MPFA MODELS
C    0 = Off
C    1 = TPFA boundary on reference grid
C    2 = TPFA boundary on physical grid
C    3 = MPFA boundary with Dirichlet BC
C    4 = MPFA boundary manually from a file
C    5 = MPFA boundary treating as internal boundary, matching case
C    6 = MPFA boundary treating as internal boundary, nonmatching case

C  MFMFE_BRICKS = FLAG TO FILL {XC,YC,ZC} 3D ARRAYS USING BRICK
C                 GEOMETRY IN {XREC,YREC,ZREC} 1D ARRAYS

