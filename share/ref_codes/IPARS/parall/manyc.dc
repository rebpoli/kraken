/*----------------------------------------------------------------------

Author:   H. Carter Edwards

Purpose:  IPARS grid element array ghost regions communications

History:  December 1997 - Initial development
          MPeszynska, 6/23/98 : put a kludge for keyout update
	         requested by JWheeler, see below at / * mpesz 
          MPeszynska, 10/98: 
                 put extensions for Multi Model, see // mpesz below
--

Global Variables:  NONE

Global Subprograms:
	COMMITMP  [FORTRAN compatible interface]
	UPDATEC   [FORTRAN compatible interface]

--

Description:

  An IPARS grid element array may be partitioned among two or more
processors.  If a single block of a grid element array is
partitioned then regions of overlapping "ghost-cells" are defined
on the interface between partitions of the block.  These regions
are periodically updated and must be communicated to restore
consistency between processors.  The routines in this file perform
these 'update' communications.

Multi Model extension:

  In the original IPARS framework / communications code it was assumed
that there was one physcial model executed and that all grid arrays
were allocated and all ghost cells updated for all the fault
blocks. The Multi Model extension to the frameowrk gives up this
assumption and allows grid arrays for a given model to be allocated
either only in some fault blocks or in all. The new memory management
is linked below with the extended commitmp() routine and slightly
modified updatec() routine. In the first one the original data
structures creating lists of ghost cells were replaced by arrays of
lists indexed by the physical models. In the latter, UPDATE calls
verify now for which physcial model the given array has been allocated
and use appropriate list of ghost cells to pack/send and receive/unpack data.

----------------------------------------------------------------------*/

/**
#define DEBUGGING
**/
/**
#define MM_DEBUG
**/

/* ------------------------------------------------------------------ */
/* 'update' communication routines */

#include <stdio.h>
#include <stdlib.h>
#include "cfsimple.h"

/*---------------------------------------------- */
/* extra definitions of functions from memman3.c */

#define nget_nactivemodels _F_NAME_(NGET_NACTIVEMODELS,nget_nactivemodels)
#define isactive          _F_NAME_(ISACTIVE,isactive)
#define get_blkmodel      _F_NAME_(GET_BLKMODEL,get_blkmodel)
#define get_arymodel      _F_NAME_(GET_ARYMODEL,get_arymodel)
#define get_CurrentModel  _F_NAME_(GET_CURRENTMODEL,get_currentmodel)


#ifdef DEBUGGING
static FILE * fpdbg = NULL ;
#endif

// ======================
// mpesz debug
FILE * fmmodel = NULL;

void fuzzyline()
{
  if (fmmodel != NULL)
    fprintf(fmmodel,
	    "\n----------------------------------------------------------\n");
}

/* ------------------------------------------------------------------ */

#define IPARS_TYPE_REAL_4	1
#define IPARS_TYPE_REAL_8	2
#define IPARS_TYPE_INTEGER_2	3
#define IPARS_TYPE_INTEGER_4	4
#define IPARS_TYPE_LOGICAL_2	5
#define IPARS_TYPE_LOGICAL_4  	6

/* ------------------------------------------------------------------ */
/* MPI via the FORTRAN interface */

#define _mpi_irecv    _F_NAME_(MPI_IRECV,mpi_irecv)
#define _mpi_isend    _F_NAME_(MPI_ISEND,mpi_isend)
#define _mpi_waitany  _F_NAME_(MPI_WAITANY,mpi_waitany)

_F_EXTERN_(void) _mpi_irecv();
_F_EXTERN_(void) _mpi_isend();
_F_EXTERN_(void) _mpi_waitany();

/* ------------------------------------------------------------------ */
/* Other IPARS routines */

#define _blkdim     _F_NAME_(BLKDIM,blkdim)
#define _nblkary    _F_NAME_(NBLKARY,nblkary)
#define _blklocal   _F_NAME_(BLKLOCAL,blklocal)
#define _aryptr     _F_NAME_(ARYPTR,aryptr)

_F_EXTERN_(void) _blkdim();
_F_EXTERN_(void) _nblkary();
_F_EXTERN_(void) _blklocal();
_F_EXTERN_(void) _aryptr();

/* ------------------------------------------------------------------ */
/* Routines defined here */

#define _commitmp   _F_NAME_(COMMITMP,commitmp)
#define _updatec    _F_NAME_(UPDATEC,updatec)

_F_EXTERN_(void) _commitmp();
_F_EXTERN_(void) _updatec();

/* -------------------------------------------------------------------*/
/* Routine local to this file */

static void test_updatec();
static void keyout_intcpy();
static void test_memcpy();
/* ------------------------------------------------------------------ */

struct msgcell {
  int off ;       /* Offset into the send block */
  int len ;       /* Length of column cell */
};

struct msgblk {
  int blk ;       /* Which block */
  int stride ;    /* Stride of the block (idim * jdim * kdim) */
  int recvncell ; /* Number of column cells to send */
  int sendncell ; /* Number of column cells to recv */
};

struct msgone {
  int              nblk ;     /* Number of blocks of message */
  struct msgblk  * blk ;      /* Block partitioning of cells */
  struct msgcell * sendcell ; /* Column cells to send */
  struct msgcell * recvcell ; /* Column cells to recv */
  int              destsrc ;  /* Exchange processor */
  int              sendnum ;  /* Sum( sendcell[i].len ) */
  int              recvnum ;  /* Sum( recvcell[i].len ) */
  int              recvlen ;  /* sizeof(recvbuf[recvlen]) */
  char           * recvbuf ;  /* receive buffer */
};

struct msgall {
  int             num ;     /* Number of exchanges */
  struct msgone * msg ;     /* Individual messages */
  int           * mpi_req ; /* MPI requests */
  int           * mpi_stat ;/* MPI status */
  int             sendnum ; /* maximum( msg[i].sendnum )  */
  int             sendlen ; /* sizeof( sendbuf[sendlen] ) */
  char          * sendbuf ; /* shared send buffer */
};

#define MAX_TEMPLATE 3

// ======================
// mpesz setup for MultiModel: maximum number of 
// communication lists is $MXMOD +1 so that the array of communication
// lists could be indexed from 0.. MXMOD

#define MAXMODEL $MXMOD + 1

// ======================
// mpesz for MultiModel: the number of active physcial models:
// set below in commitmp(): must be at least 1, at most MXMOD = $MXMOD
// 
int NactiveModel = 0;


// =====================
// mpesz for Multi Model : replace the original communication list <message>
// by an array of communication lists <mm_message>
// the array elements are aliased later to names used originally by HCE
//
static struct msgall mm_message [ MAXMODEL ] [ MAX_TEMPLATE];

/* ------------------------------------------------------------------ */

void _commitmp(
  _F_INTEGER * mpi_comm , /* IN: MPI communicator */
  _F_INTEGER * mpi_nproc, /* IN: MPI communicator's size */
  _F_INTEGER * mpi_rank , /* IN: MPI rank of this processor */
  _F_INTEGER * mpi_nstat, /* IN: MPI status size */
  _F_INTEGER * vn0map ,   /* IN: Processor map, part 1 */
  _F_INTEGER * vnymap ,   /* IN: Processor map, part 2 */
  _F_INTEGER * vprcmap ,  /* IN: Processor map, part 3 */
  _F_INTEGER * ktmp ,     /* IN: Template identifier */
  _F_INTEGER (*Neighbor)[2] , /* IN: Horizontal neighbor offsets */
  _F_INTEGER * NumNeighbor , /* IN: Number of horizontal neighbor offsets */
  _F_INTEGER * ierr )     /* OUT: Error code */
{
  const char myname[] = "COMMITMP" ;

  const int nproc        = *mpi_nproc ;
  const int p_me         = *mpi_rank ;
  const int num_neighbor = *NumNeighbor ;
  const int id_template  = *ktmp - 1 ;

  _F_INTEGER numblk , numary ;

  int mm_nummessage  [MAXMODEL];
  int mm_numblocks   [MAXMODEL];
  int mm_numsendcell [MAXMODEL];
  int mm_numrecvcell [MAXMODEL];

  int nb , nx , ny , nz ;
  int i , j , k , ioff , joff , koff ;
  int ilocdim , jlocdim , klocdim ;
  int neigh , ip , ib , im ;

  // =====================
  // mpesz for Multi Model : these flags are used to decide how
  // many communication lists are made

  const int nact = nget_nactivemodels();
  int imod;

  // =====================
  // mpesz for MultiModel: the actual number of communication lists 
  // to be initialized is nmodels 
  // nmodels is equal to 1 if there is only one physical model being
  // run in all faultblocks
  int nmodels      = 0;

  typedef int int4 [4] ;
  typedef int int2 [2] ;

  // =====================
  // mpesz setup for Multi Model : replaced send by mm_send [MAXMODEL]
  // send, recv, and block later

  int4 * mm_send [MAXMODEL] ;
  int2 * mm_recv [MAXMODEL] ;
  int  * mm_block [MAXMODEL] ;

  char * mm_ptr [MAXMODEL] ;
  struct msgone * mm_msglist [MAXMODEL];

  // =====================
  // mpesz setup for Multi Model : alias the auxiliary buffer arrays 
  // above to the names used by HCE in original routines

#define send mm_send[imod]
#define recv mm_recv[imod]
#define block mm_block[imod]
#define ptr mm_ptr[imod]
#define msglist mm_msglist[imod]

#define nummessage  mm_nummessage  [imod]
#define numblocks   mm_numblocks   [imod]
#define numsendcell mm_numsendcell [imod]
#define numrecvcell  mm_numrecvcell [imod]

  // ======================

  unsigned sizeall , stride ;

#ifdef DEBUGGING
  if ( fpdbg == NULL ) {
    char buf[128] ;
    sprintf(buf,"DBG%d.%d",nproc,p_me);
    fpdbg = fopen(buf,"w");
  }

  fprintf(fpdbg,"%s BEGIN\n",myname);
  fprintf(fpdbg,"nproc = %d, p_me = %d, num_neighbor = %d, id_template = %d\n",
    nproc, p_me, num_neighbor, id_template );
  for ( neigh = 0 ; neigh < num_neighbor ; ++neigh )
    fprintf(fpdbg,"neigh[%d] = ( %d , %d )\n",
      neigh,Neighbor[neigh][0], Neighbor[neigh][1]);
  fflush(fpdbg);
#endif
  

  // =====================
  // mpesz setup for Multi Model: decide how many communication lists to make
  //
  nmodels = (nact == 1 ? 1 : MAXMODEL );
  NactiveModel = nact;

  { 
    char buf[128] ;
    sprintf(buf,"MMODEL.%d",p_me);
    fmmodel = fopen(buf,"w");
    fprintf(fmmodel,
	    "\nPROCESSOR %d file %s for nactive_models=%d\n",
	    p_me, buf, NactiveModel
	    );
  }

  /*------------------------------------------------------------------*/
  /* Count: Number of messages, number of blocks, & number of cells */

  _nblkary( &numblk , &numary );
  
  // =====================
  // mpesz for Multi Model : loop over all the active models
  // if only one model active, then only use 0'th elements of the array

  for (imod = 0 ; imod < nmodels ; imod++) {
    if (isactive (&imod) ) {
      fuzzyline();
      fprintf(fmmodel, "\n Model %d is active, CREATING LISTS.\n",imod);
    } else {
      // fprintf(fmmodel, "\n Model %d is not active, ... skipping\n",imod);
      continue;
    }

  send  = (int4 *) malloc( sizeof(int) * nproc * 7 );
  recv  = (int2 *) ( send + nproc );
  block = (int  *) ( recv + nproc );

  memset( send , 0 , sizeof(int) * nproc * 4 );
  memset( recv , 0 , sizeof(int) * nproc * 2 );
  memset( block, 0 , sizeof(int) * nproc );

  for ( nb = 1 ; nb <= numblk ; ++nb ) {

    /* Mapping for the block */

    const int n0  = vn0map[nb - 1];
    const int nym = vnymap[nb - 1];
    int kbeg , kend , jbeg , jend ;

    // =====================
    // mpesz for MultiModel 
    // if the model is ALL=0 or if the model is equal to the blockmodel then
    // loop over the block elements, otherwise, skip that block
    const int blkmod = get_blkmodel(nb-1);

    if ( (imod != 0) && (imod != blkmod )  ){
      //fprintf(fmmodel,
      //"\n Skipping block %d with mod=%d for model %d\n",
      //nb,blkmod,imod);
      continue;
    } else {
      fprintf(fmmodel,
	      "\n\nContinuing for block %d with mod=%d for model %d\n",
	      nb,blkmod,imod);
    }

    _blkdim( &nb, &nx, &ny, &nz, ierr );
    if ( *ierr ) {
      fprintf(stderr,"%s: BLKDIM error #%d \n",myname,*ierr);
      exit(-1);
    }

    _blklocal( &nb, &ilocdim, &jlocdim, &klocdim, &ioff, &joff, &koff, ierr );
    if ( *ierr ) {
      fprintf(stderr,"%s: BLKLOCAL error #%d \n",myname,*ierr);
      exit(-1);
    }

    /* Loop over local interior columns and ghost columns */

    kbeg = 1 + koff ; if ( kbeg < 1 ) kbeg = 1 ;
    kend = klocdim + koff ; if ( nz < kend ) kend = nz ;

    jbeg = 1 + joff ; if ( jbeg < 1 ) jbeg = 1 ;
    jend = jlocdim + joff ; if ( ny < jend ) jend = ny ;

    for ( k = kbeg ; k <= kend ; ++k ) {
      for ( j = jbeg ; j <= jend ; ++j ) {

        /* Processor which owns the current column */

        const int p_this = vprcmap[ n0 + nym * k + j - 1 ];

        if ( p_this < 0 || nproc < p_this ) {
          ; /* A "keyed out" or error valued column, skip it */
        }
        else if ( p_this != p_me ) { /* Check for receive */

          /* Loop over neighborting columns */

          for ( neigh = 0 ; neigh < num_neighbor ; ++neigh ) {

            const int jneigh = j + Neighbor[neigh][0] ;
            const int kneigh = k + Neighbor[neigh][1] ;

            if ( 0 < jneigh && jneigh <= ny &&
                 0 < kneigh && kneigh <= nz ) {

              /* Processor of the neighboring cell */

              const int p_neigh = vprcmap[ n0 + nym * kneigh + jneigh - 1 ];

              /* I need this column */

              if ( p_neigh == p_me ) {
                recv[p_this][0]++ ;

		// mpesz debug
		fprintf(fmmodel, "\n recv for p_niegh=%d number %d",
			p_this,recv[p_this][0]);

		break ;
              }
            }
          }
        }
        else { /* Check for one or more sends */

          /* Loop over neighborting columns */

          for ( neigh = 0 ; neigh < num_neighbor ; ++neigh ) {

            const int jneigh = j + Neighbor[neigh][0] ;
            const int kneigh = k + Neighbor[neigh][1] ;

            if ( 0 < jneigh && jneigh <= ny &&
                 0 < kneigh && kneigh <= nz ) {

              /* Processor of the neighboring cell */

              const int p_neigh = vprcmap[ n0 + nym * kneigh + jneigh - 1 ];

              /* Neighbor needs this column & is not already in the list */

              if ( p_neigh < 0 || nproc < p_neigh ) {
                ; /* A "keyed out" or error valued column, skip it */
              }
              else if ( p_neigh != p_me && 
                 ( send[p_neigh][2] != j || send[p_neigh][3] != k ) ) {

                /* New column to send to 'p_neigh' */

                send[p_neigh][0]++ ;
                send[p_neigh][2] = j ;
                send[p_neigh][3] = k ;

		// mpesz debug
		fprintf(fmmodel,
			"\n send for p_neigh=%d j=%d k=%d",
			p_neigh,j,k);

              }
            }
          }
        }
      }
    }

    /* Check if this block was used */

    if ( klocdim && jlocdim ) {
      for ( ip = 0 ; ip < nproc ; ++ip ) {
        if ( ! ( ! send[ip][0] ) != ! ( ! recv[ip][0] ) ) {
          fprintf(stderr,"%s: Nonsymmetric communicatins\n",myname);
          exit(-1);
        }
        if ( send[ip][0] ) {
          block[ip]++ ;
          recv[ip][1] += recv[ip][0] ;
          send[ip][1] += send[ip][0] ;  /* Number of columns */
          recv[ip][0] = 0 ;
          send[ip][0] = 0 ;
        }
      }
      for ( ip = 0 ; ip < nproc ; ++ip ) 
	fprintf(fmmodel,
		"\nsend struct: blk=%d proc=%d send : %d %d %d %d recv: %d %d",
		nb,ip,send[ip][0],send[ip][1],send[ip][2],send[ip][3],
		recv[ip][0],recv[ip][1]);
    }
  }

  } // end for mmodel 

  // return;

  /*------------------------------------------------------------------*/
  /* Allocations */

  for (imod = 0 ; imod < nmodels ; imod++) {

    // =====================
    // mpesz : alias communication list array element 
    // to <message> (HCE name)

#define message mm_message [imod]

    if (isactive (&imod) ) {
      fuzzyline();
      fprintf(fmmodel, "\nModel %d is active, ALLOCATING LISTS.\n",imod);
    } else {
      //fprintf(fmmodel, 
      //"\n Model %d is not active, ... skipping alloc.\n",imod);
      continue;
    }
  // ======================

  nummessage  = 0 ;
  numblocks   = 0 ;
  numsendcell = 0 ;
  numrecvcell = 0 ;

  for ( ip = 0 ; ip < nproc ; ++ip ) {
    numblocks   += block[ip] ;
    numsendcell += send[ip][1] ;
    numrecvcell += recv[ip][1] ;

    if ( send[ip][1] ) nummessage++ ;
  }

  ptr = malloc( sizeall =
      sizeof(struct msgone)  * nummessage +
      sizeof(struct msgblk)  * numblocks +
      sizeof(struct msgcell) * ( numsendcell + numrecvcell ) +
      sizeof(int) * ( nummessage + 1 + *mpi_nstat ) );

#ifdef DEBUGGING
  fprintf(fpdbg,"nummessage  = %d\n",nummessage);
  fprintf(fpdbg,"numsendcell = %d\n",numsendcell);
  fprintf(fpdbg,"numrecvcell = %d\n",numrecvcell);
  fflush(fpdbg);
#endif

  fprintf(fmmodel,"nummessage  = %d\n",nummessage);
  fprintf(fmmodel,"numsendcell = %d\n",numsendcell);
  fprintf(fmmodel,"numrecvcell = %d\n",numrecvcell);

  memset( ptr , 0 , sizeall );

  message[id_template].sendbuf = 0 ;
  message[id_template].sendlen = 0 ;
  message[id_template].sendnum = 0 ;

  message[id_template].num = nummessage ;
  message[id_template].msg = msglist = (struct msgone *) ptr ;
    ptr += sizeof(struct msgone) * nummessage ;

  for ( im = ip = 0 ; ip < nproc ; ++ip ) {
    if ( send[ip][1] ) {

      msglist[im].destsrc = ip ;

      msglist[im].blk = (struct msgblk *) ptr ;
        ptr += sizeof(struct msgblk) * block[ip] ;

      msglist[im].sendcell = (struct msgcell *) ptr ;
        ptr += sizeof(struct msgcell) * send[ip][1] ;

      msglist[im].recvcell = (struct msgcell *) ptr ;
        ptr += sizeof(struct msgcell) * recv[ip][1] ;

      ++im ;
    }
  }

  message[id_template].mpi_req = (int *) ptr ;
    ptr += sizeof(int) * ( nummessage + 1 );

  message[id_template].mpi_stat = (int *) ptr ;
    ptr += sizeof(int) * ( *mpi_nstat );

  if ( ((char *) msglist) + sizeall != ptr ) {
    fprintf(stderr,"%s : memory partitioning problem\n",myname);
    exit(-1);
  }

#ifdef DEBUGGING
  fprintf(fpdbg,"Memory partitioning is OK\n");
  fflush(fpdbg);
#endif


  // ======================
  // mpesz : for Multi Model end of aliasing 
#undef message

  }

  /*------------------------------------------------------------------*/
  /* Fill in the data */

  for(imod = 0 ; imod < nmodels ; imod++) {

    // =====================
    // mpesz : alias communication list array element to <message> (HCE name)

#define message mm_message [imod]

    if (isactive (&imod) ) {
      fuzzyline();
      fprintf(fmmodel, 
	      "\nModel %d is active, FILLING THE DATA.\n",imod);
    } else {
      //fprintf(fmmodel, 
      //"\n Model %d is not active, ... skipping filling.\n",imod);
      continue;
    }
  // ======================

  memset( send , 0 , sizeof(int) * nproc * 4 );
  memset( recv , 0 , sizeof(int) * nproc * 2 );
  memset( block, 0 , sizeof(int) * nproc );

  im = 0 ;

  for ( nb = 1 ; nb <= numblk ; ++nb ) {

    const int n0  = vn0map[nb - 1];
    const int nym = vnymap[nb - 1];
    int kbeg , kend , jbeg , jend ;

    // if the model is ALL or if the model is equal to the blockmodel then
    // loop over the block elements, otherwise, skip that block

    if ( (imod != 0) && (imod != get_blkmodel(nb-1) )  ){
      //fprintf(fmmodel,
      //"\n Skipping block %d when filling for model %d\n",nb,imod);
      continue;

    } else {      
      fprintf(fmmodel,
	      "\n\nContinuing for block %d for filling for model %d %d msgs \n",
	      nb,imod,message[id_template].num);
	
    }

    _blkdim( &nb, &nx, &ny, &nz, ierr );
    if ( *ierr ) {
      fprintf(stderr,"%s: BLKDIM error #%d\n",myname,*ierr);
      exit(-1);
    }

    _blklocal( &nb, &ilocdim, &jlocdim, &klocdim, &ioff, &joff, &koff, ierr );
    if ( *ierr ) {
      fprintf(stderr,"%s: BLKLOCAL error #%d\n",myname,*ierr);
      exit(-1);
    }

    stride = ilocdim * jlocdim * klocdim ;

    /* Loop over local interior columns and ghost columns */

    kbeg = 1 + koff ; if ( kbeg < 1 ) kbeg = 1 ;
    kend = klocdim + koff ; if ( nz < kend ) kend = nz ;

    jbeg = 1 + joff ; if ( jbeg < 1 ) jbeg = 1 ;
    jend = jlocdim + joff ; if ( ny < jend ) jend = ny ;

    for ( k = kbeg ; k <= kend ; ++k ) {
      for ( j = jbeg ; j <= jend ; ++j ) {

        const int locoff = ( j - joff - 1 ) * ilocdim +
                           ( k - koff - 1 ) * jlocdim * ilocdim ;
        const int loclen = ilocdim ;

        const int p_this = vprcmap[ n0 + nym * k + j - 1 ];

        if ( p_this < 0 || nproc < p_this ) {
          ; /* A "keyed out" or error valued column, skip it */
        }
        else if ( p_this != p_me ) {

          for ( neigh = 0 ; neigh < num_neighbor ; ++neigh ) {

            const int jneigh = j + Neighbor[neigh][0] ;
            const int kneigh = k + Neighbor[neigh][1] ;

            if ( 0 < jneigh && jneigh <= ny &&
                 0 < kneigh && kneigh <= nz ) {

              const int p_neigh = vprcmap[ n0 + nym * kneigh + jneigh - 1 ];

              if ( p_neigh == p_me ) {

                /* Find the particular message */

                if ( msglist[im].destsrc != p_this )
                  for ( im = nummessage ;
                        im > 0 && msglist[--im].destsrc != p_this ; );

                /* Find the particular block */

                for ( ib = 0 ; ib < msglist[im].nblk &&
                               msglist[im].blk[ib].blk != nb ; ++ib );

                if ( ib == msglist[im].nblk ) {
                  msglist[im].nblk++ ;
                  msglist[im].blk[ib].blk = nb ;
                  msglist[im].blk[ib].stride = stride ;
                }

                msglist[im].recvcell[ recv[p_this][0] ].off = locoff ;
                msglist[im].recvcell[ recv[p_this][0] ].len = loclen ;
                msglist[im].blk[ib].recvncell++ ;
                msglist[im].recvnum += loclen ;

                recv[p_this][0]++ ;

#ifdef DEBUGGING
  fprintf(fpdbg,"msg %2d, blk %2d, recv[%3d][0] = %4d is (%4d,%4d)\n",
    im,ib,p_this,recv[p_this][0],j,k);
  fflush(fpdbg);
#endif
  // =====================
  // mpesz debug
  fprintf(fmmodel,"\nRECV message:%d blk =%d offset=%d",
	  im,nb,locoff);

                break ;
              }
            }
          }
        }
        else { /* Send ? */

          for ( neigh = 0 ; neigh < num_neighbor ; ++neigh ) {

            const int jneigh = j + Neighbor[neigh][0] ;
            const int kneigh = k + Neighbor[neigh][1] ;

            if ( 0 < jneigh && jneigh <= ny &&
                 0 < kneigh && kneigh <= nz ) {

              const int p_neigh = vprcmap[ n0 + nym * kneigh + jneigh - 1 ];

              if ( p_neigh < 0 || nproc < p_neigh ) {
                ; /* A "keyed out" or error valued column, skip it */
              }
              else if ( p_neigh != p_me && 
                 ( send[p_neigh][2] != j || send[p_neigh][3] != k ) ) {

                /* New column to send to 'p_neigh' */

                send[p_neigh][2] = j ;
                send[p_neigh][3] = k ;

                /* Find the particular message */

                if ( msglist[im].destsrc != p_neigh )
                  for ( im = nummessage ;
                        im > 0 && msglist[--im].destsrc != p_neigh ; );

                /* Find the particular block */

                for ( ib = 0 ; ib < msglist[im].nblk &&
                               msglist[im].blk[ib].blk != nb ; ++ib );

                if ( ib == msglist[im].nblk ) {
                  msglist[im].nblk++ ;
                  msglist[im].blk[ib].blk = nb ;
                  msglist[im].blk[ib].stride = stride ;
                }

                msglist[im].sendcell[ send[p_neigh][0] ].off = locoff ;
                msglist[im].sendcell[ send[p_neigh][0] ].len = loclen ;
                msglist[im].blk[ib].sendncell++ ;
                msglist[im].sendnum += loclen ;

                send[p_neigh][0]++ ;

#ifdef DEBUGGING
  fprintf(fpdbg,"msg %2d, blk %2d, send[%3d][0] = %4d is (%4d,%4d)\n",
    im,ib,p_neigh,send[p_neigh][0],j,k);
  fflush(fpdbg);
#endif
  // =================
  // mpesz debug
  fprintf(fmmodel,"\nSEND message:%d blk =%d offset=%d",
	  im,nb,locoff);
              }
            }
          }
        }
      }
    }
  }

  /* Maximum send buffer */

  for ( im = 0 ; im < nummessage ; ++im )
    if ( message[id_template].sendnum < msglist[im].sendnum )
      message[id_template].sendnum = msglist[im].sendnum ;

  /* Free the scratch space */

  free( send );

  } // end for mmodel

  // ======================
  // mpesz : for Multi Model : summary of debugging output

  fuzzyline();
  fprintf(fmmodel,"\nSUMMARY of created communication lists:\n");
  fuzzyline();
  /*qlu
  for (imod =0 ; imod < nmodels; imod++) {
    int nm;
    fprintf(fmmodel,
	    "\nModel %d num=%d sendnum=%d recvnum=%d ",
	    imod,
	    message[id_template].num,
	    message[id_template].msg->sendnum,
	    message[id_template].msg->recvnum);
    for (nm =0;nm < message[id_template].num;nm++) {
      struct msgone * msg = message[id_template].msg + nm ;

      fprintf(fmmodel,
	      "\n ---- to proc %d msg ncells=%d in block=%d stride =%d",
	      msg->destsrc,msg->blk->sendncell,
	      msg->blk->blk,
	      msg->blk->stride
	      );
    }
  }
  qlu*/
  fuzzyline();
  fprintf(fmmodel,"\nend SUMMARY \n");
  fuzzyline();
  // ======================
  // mpesz : for Multi Model end of aliasing

#undef send
#undef recv
#undef block
#undef ptr
#undef msglist

#undef message

#undef nummessage  
#undef numblocks   
#undef numsendcell 
#undef numrecvcell 


  // ======================
  // mpesz : for Multi Model end of aliasing

#ifdef DEBUGGING
  fprintf(fpdbg,"%s END\n\n",myname);
  fflush(fpdbg);
#endif
}

/* ------------------------------------------------------------------ */

void _updatec(
  _F_INTEGER * mpi_comm ,/* IN: MPI communicator  */
  _F_INTEGER * mpi_tag , /* IN: MPI message tag   */
  _F_INTEGER * mpi_type ,/* IN: MPI data type     */
  _F_INTEGER * kind ,    /* IN: IPARS 'kind' code */
  _F_INTEGER * arynum ,  /* IN: Array number      */
  _F_INTEGER * iv1 ,     /* IN: First variable    */
  _F_INTEGER * iv2 ,     /* IN: Last variable     */
  _F_INTEGER * ktmp ,    /* IN: Template number   */
  _F_INTEGER * ierr )
{
  const char myname[] = "UPDATEC" ;
  const int nv1  = *iv1 - 1 ;
  const int nv2  = *iv2 ;
  const int numv = nv2 - nv1 ;

  /* ---------------------------------*/
  /* mpesz : kludge for keyout update */
  const int update_keyout = ( (*arynum) == 0 ? 1 : 0);

  const int mymodel = get_arymodel(*arynum);
  const int currmodel = get_CurrentModel();

  // ======================
  // mpesz for Multi Model : find the communication list index
  // and alias the appropriate comm.list.array element to <message>
  // 
  int imod = ( NactiveModel == 1 ? 0 : currmodel );

#define message mm_message [imod]
  // ======================
  
  struct msgall * const msga = message + *ktmp - 1 ;

  const int nummsg = msga->num ;

  int sizev ;
  int nm , nb , nc , nv ;
  int nmrecv , nmsend , which , ic , icend ;

  // =====================
  // mpesz debug for Multi Model : report on what's going on 
  // using the test function

#ifdef MM_DEBUG
  test_updatec(
	       mpi_comm ,/* IN: MPI communicator  */
	       mpi_tag , /* IN: MPI message tag   */
	       mpi_type ,/* IN: MPI data type     */
	       kind ,    /* IN: IPARS 'kind' code */
	       arynum ,  /* IN: Array number      */
	       iv1 ,     /* IN: First variable    */
	       iv2 ,     /* IN: Last variable     */
	       ktmp ,    /* IN: Template number   */
	       ierr );
  return;
#endif

  // ======================
  // mpesz for Multi Model: check for error : inconsistency
  // between the model that is currently run and the model
  // that the grid array has been allocated for

  if ( (currmodel*mymodel !=0) && (currmodel != mymodel) ) {
    fprintf(
	    stderr,
	    "\n Error in Update : current model is%d and arymod=%d\n",
	    currmodel,mymodel);
    exit(-1);
  }
  // ==================

#ifdef DEBUGGING
  fprintf(fpdbg,"%s BEGIN\n",myname);
  fflush(fpdbg);
#endif
  
#ifdef MM_DEBUG

  fprintf(fmmodel,
	  "\n UPDATE ary:%d (mod=%d) curr.mod =%d #actmod:%d #list:%d\n",
	  *arynum,mymodel,currmodel,NactiveModel,imod);
#endif  

  switch( *kind ) {
  case IPARS_TYPE_REAL_4:     sizev = sizeof(_F_REAL_4); break ;
  case IPARS_TYPE_REAL_8:     sizev = sizeof(_F_REAL_8); break ;
  case IPARS_TYPE_INTEGER_2:  sizev = sizeof(_F_INTEGER); break ;
  case IPARS_TYPE_INTEGER_4:  sizev = sizeof(_F_INTEGER); break ;
  case IPARS_TYPE_LOGICAL_2:  sizev = sizeof(_F_INTEGER); break ;
  case IPARS_TYPE_LOGICAL_4:  sizev = sizeof(_F_INTEGER); break ;
  default: /* ERROR: Bad 'kind' */
    fprintf(stderr,"%s: Bad IPARS kind = %d\n",myname,*kind);
    exit(-1);
  }

  /* Size the send and receive buffers */
  
  {
    const int sendsize = msga->sendnum * numv * sizev ;

    if ( msga->sendlen < sendsize ) {
      if ( ! msga->sendbuf ) free( msga->sendbuf );
      if ( ! ( msga->sendbuf = malloc( msga->sendlen = sendsize ) ) ) {
        fprintf(stderr,"%s: Failed malloc\n",myname);
        exit(-1);
      }
    }
  }

  for ( nm = 0 ; nm < nummsg ; nm++ ) {
    struct msgone * const msg = msga->msg + nm ;
    const int recvsize = msg->recvnum * numv * sizev ;

    if ( msg->recvlen < recvsize ) {
      if ( ! msg->recvbuf ) free( msg->recvbuf );
      if ( ! ( msg->recvbuf = malloc( msg->recvlen = recvsize ) ) ) {
        fprintf(stderr,"%s: Failed malloc\n",myname);
        exit(-1);
      }
    }
  }

  /* Post all of the receive operations */

  for ( nmrecv = 0 ; nmrecv < nummsg ; nmrecv++ ) {
    struct msgone * const msg = msga->msg + nmrecv ;
    char                * buf = msg->recvbuf ;
    _F_INTEGER            num = msg->recvnum * numv ;
    _F_INTEGER            src = msg->destsrc ;

#ifdef DEBUGGING
  fprintf(fpdbg,"  msga->mpi_irecv[%d](buf,%d,%d,%d,%d,...)\n",
    nmrecv,num,*mpi_type,src,*mpi_tag);
  fflush(fpdbg);
#endif

    _mpi_irecv( msg->recvbuf, &num, mpi_type,
                &src, mpi_tag, mpi_comm,
                msga->mpi_req + nmrecv, ierr );
  }

  /* Receive/unpack messages and Pack/send messages */

  nmsend = nummsg ;
  nmrecv = nummsg ;
  which  = nummsg ;

  while ( nmsend || nmrecv ) {

    if ( nmsend && which == nummsg ) { /* Pack a new message */
      struct msgone * const msg  = msga->msg + nummsg - nmsend ;
      char                * buf  = msga->sendbuf ;
      _F_INTEGER            num  = msg->sendnum * numv ;
      _F_INTEGER            dest = msg->destsrc ;

      const int                    nblk = msg->nblk ;
      const struct msgcell * const cell = msg->sendcell ;
      const struct msgblk  * const blk  = msg->blk ;

      for ( icend = ic = nb = 0 ; nb < nblk ; ++nb ) {
        const struct msgblk * const blk = msg->blk + nb ;

        const int stride = blk->stride * sizev ;
        const int ncell  = icend += blk->sendncell ;

        char * ary ;

        _aryptr( &(blk->blk), arynum, &ary, ierr );

	// mpesz debug

        for ( ; ic < ncell ; ++ic ) {
          const int          npack =       cell[ic].len * sizev ;
          const char * const ptr   = ary + cell[ic].off * sizev ;

          for ( nv = nv1 ; nv < nv2 ; ++nv ) {
	    /** MPeszynska : kludge for keyout update **/

	    if(update_keyout)
	      keyout_intcpy( buf , ptr + nv * stride , npack, cell[ic].len);
	    else
	      memcpy( buf , ptr + nv * stride , npack );
            buf += npack ;
          }
        }
      }

#ifdef DEBUGGING
  fprintf(fpdbg,"  mpi_isend(buf,%d,%d,%d,%d,...)\n",
    num,*mpi_type,dest,*mpi_tag);
  fflush(fpdbg);
#endif

      _mpi_isend( msga->sendbuf, &num, mpi_type, &dest,
                  mpi_tag, mpi_comm, msga->mpi_req + nummsg, ierr );
    }

    /* Wait for the send or any receive to complete */

    {
      _F_INTEGER nreq = nummsg + 1 ;

#ifdef DEBUGGING
    fprintf(fpdbg,"  mpi_waitany\n");
    {
      int iw ;
      for ( iw = 0 ; iw < nreq ; ++iw ) {
        fprintf(fpdbg,"  msga->mpi_req[%d] = %d\n",iw,msga->mpi_req[iw]);
      }
    }
    fflush(fpdbg);
#endif

      _mpi_waitany( &nreq, msga->mpi_req, &which, msga->mpi_stat, ierr );

#ifdef DEBUGGING
    fprintf(fpdbg,"  mpi_waitany( which = %d )\n",which);
    fflush(fpdbg);
#endif

      --which ; /* FORTRAN index ? */
    }

    if ( which == nummsg ) { /* Send completed */
      --nmsend ;
    }
    else { /* Receive completed */
      struct msgone * const msg  = msga->msg + which ;
      char                * buf  = msg->recvbuf ;
      int                   num  = msg->sendnum * numv ;

      const int                    nblk = msg->nblk ;
      const struct msgcell * const cell = msg->recvcell ;
      const struct msgblk  * const blk  = msg->blk ;

      --nmrecv ;

      for ( nb = 0 ; nb < nblk ; ++nb ) {
        const struct msgblk * const blk = msg->blk + nb ;
        const int stride = blk->stride * sizev ;
        const int ncell  = blk->recvncell ;
        char * ary ;

        _aryptr( &(blk->blk), arynum , &ary, ierr );

	// mpesz debug

        for ( ic = 0 ; ic < ncell ; ++ic ) {
          const int          npack =       cell[ic].len * sizev ;
          char * const ptr   = ary + cell[ic].off * sizev ;

          for ( nv = nv1 ; nv < nv2 ; ++nv ) {
            memcpy( ptr + nv * stride , buf , npack );
            buf += npack ;
          }
        }
      }
    } /* End receive */
  } /* End while sending & receiving */

  // ======================
  // mpesz : for Multi Model end of aliasing 

#undef message

  // ======================

#ifdef DEBUGGING
  fprintf(fpdbg,"%s END\n",myname);
  fflush(fpdbg);
#endif

  return;
}


/* ------------------------------------------------------------------ */

static void test_updatec(
  _F_INTEGER * mpi_comm ,/* IN: MPI communicator  */
  _F_INTEGER * mpi_tag , /* IN: MPI message tag   */
  _F_INTEGER * mpi_type ,/* IN: MPI data type     */
  _F_INTEGER * kind ,    /* IN: IPARS 'kind' code */
  _F_INTEGER * arynum ,  /* IN: Array number      */
  _F_INTEGER * iv1 ,     /* IN: First variable    */
  _F_INTEGER * iv2 ,     /* IN: Last variable     */
  _F_INTEGER * ktmp ,    /* IN: Template number   */
  _F_INTEGER * ierr )
{
  const char myname[] = "TEST_UPDATEC" ;
  const int nv1  = *iv1 - 1 ;
  const int nv2  = *iv2 ;
  const int numv = nv2 - nv1 ;
  
  /* ---------------------------------*/
  /* mpesz : kludge for keyout update */
  const int update_keyout = ( (*arynum) == 0 ? 1 : 0);

  const int mymodel = get_arymodel(*arynum);
  const int currmodel = get_CurrentModel();

  // ======================
  // mpesz for Multi Model : find the communication list index
  // and alias the appropriate comm.list.array element to <message>
  // 
  int imod = ( NactiveModel == 1 ? 0 : currmodel );

#define message mm_message [imod]
  // ======================
  
  struct msgall * const msga = message + *ktmp - 1 ;

  const int nummsg = msga->num ;

  int sizev ;
  int nm , nb , nc , nv ;
  int nmrecv , nmsend , which , ic , icend ;

  // ======================
  // mpesz for Multi Model: check for error : inconsistency
  // between the model that is currently run and the model
  // that the grid array has been allocated for

  if ( (currmodel*mymodel !=0) && (currmodel != mymodel) ) {
    fprintf(stderr,
	    "\n Error in Update : current model is%d and arymod=%d\n",
	    currmodel,mymodel);
    exit(-1);
  } else {
    fprintf(fmmodel,
"\nTest of UPDATE : current mod=%d, arymod=%d number of list=%d\n",
	    currmodel,mymodel,imod);
  }
  
  // ==================

#ifdef DEBUGGING
  fprintf(fpdbg,"%s BEGIN\n",myname);
  fflush(fpdbg);
#endif
  
  // mpesz debug 
  fprintf(fmmodel,
	  "\n UPDATE ary:%d (mod=%d) curr.mod =%d #actmod:%d #list:%d\n",
	  *arynum,mymodel,currmodel,NactiveModel,imod);

  switch( *kind ) {
  case IPARS_TYPE_REAL_4:     sizev = sizeof(_F_REAL_4); break ;
  case IPARS_TYPE_REAL_8:     sizev = sizeof(_F_REAL_8); break ;
  case IPARS_TYPE_INTEGER_2:  sizev = sizeof(_F_INTEGER); break ;
  case IPARS_TYPE_INTEGER_4:  sizev = sizeof(_F_INTEGER); break ;
  case IPARS_TYPE_LOGICAL_2:  sizev = sizeof(_F_INTEGER); break ;
  case IPARS_TYPE_LOGICAL_4:  sizev = sizeof(_F_INTEGER); break ;
  default: /* ERROR: Bad 'kind' */
    fprintf(stderr,"%s: Bad IPARS kind = %d\n",myname,*kind);
    exit(-1);
  }

  /* Size the send and receive buffers */


  fprintf(fmmodel,
	  "\n For this model we have nummsg=%d nsend=%d\n",
	  nummsg,msga->sendnum);

  if ( (nummsg == 0) || (msga->sendnum == 0) )
    return;

  {
    const int sendsize = msga->sendnum * numv * sizev ;

    if ( msga->sendlen < sendsize ) {
      if ( ! msga->sendbuf ) free( msga->sendbuf );
      if ( ! ( msga->sendbuf = malloc( msga->sendlen = sendsize ) ) ) {
        fprintf(stderr,"%s: Failed malloc\n",myname);
        exit(-1);
      }
    }
  }

  for ( nm = 0 ; nm < nummsg ; nm++ ) {
    struct msgone * const msg = msga->msg + nm ;
    const int recvsize = msg->recvnum * numv * sizev ;

  fprintf(fmmodel,
	  "\n For nm =%d we have nrecv =%d\n",
	  nm, msg->recvnum);

    if ( msg->recvlen < recvsize ) {
      if ( ! msg->recvbuf ) free( msg->recvbuf );
      if ( ! ( msg->recvbuf = malloc( msg->recvlen = recvsize ) ) ) {
        fprintf(stderr,"%s: Failed malloc\n",myname);
        exit(-1);
      }
    }
  }

  /* Post all of the receive operations */

  for ( nmrecv = 0 ; nmrecv < nummsg ; nmrecv++ ) {
    struct msgone * const msg = msga->msg + nmrecv ;
    char                * buf = msg->recvbuf ;
    _F_INTEGER            num = msg->recvnum * numv ;
    _F_INTEGER            src = msg->destsrc ;

#ifdef DEBUGGING
  fprintf(fpdbg,"  msga->mpi_irecv[%d](buf,%d,%d,%d,%d,...)\n",
    nmrecv,num,*mpi_type,src,*mpi_tag);
  fflush(fpdbg);
#endif

  _mpi_irecv( msg->recvbuf, &num, mpi_type,
	      &src, mpi_tag, mpi_comm,
	      msga->mpi_req + nmrecv, ierr );
  }

  /* Receive/unpack messages and Pack/send messages */

  nmsend = nummsg ;
  nmrecv = nummsg ;
  which  = nummsg ;

  while ( nmsend || nmrecv ) {

    fprintf(fmmodel,
	    "\nCurrently : nmsend=%d nmrecv =%d which =%d",
	    nmsend,nmrecv,which);

    if ( nmsend && which == nummsg ) { /* Pack a new message */
      struct msgone * const msg  = msga->msg + nummsg - nmsend ;
      char                * buf  = msga->sendbuf ;
      _F_INTEGER            num  = msg->sendnum * numv ;
      _F_INTEGER            dest = msg->destsrc ;

      const int                    nblk = msg->nblk ;
      const struct msgcell * const cell = msg->sendcell ;
      const struct msgblk  * const blk  = msg->blk ;

      for ( icend = ic = nb = 0 ; nb < nblk ; ++nb ) {
        const struct msgblk * const blk = msg->blk + nb ;

        const int stride = blk->stride * sizev ;
        const int ncell  = icend += blk->sendncell ;

        char * ary ;

        _aryptr( &(blk->blk), arynum, &ary, ierr );

        for ( ; ic < ncell ; ++ic ) {
          const int          npack =       cell[ic].len * sizev ;
          const char * const ptr   = ary + cell[ic].off * sizev ;

          for ( nv = nv1 ; nv < nv2 ; ++nv ) {
	    /** MPeszynska : kludge for keyout update **/

	    fprintf(fmmodel,
		    "\n packing nv=%d elements with npack=%d",
		    nv,npack);

	    if(update_keyout)
	      keyout_intcpy( buf , 
			     ptr + nv * stride , 
			     npack, 
			     cell[ic].len);
	    else
	      test_memcpy( buf , ptr + nv * stride , npack , sizev);

            buf += npack ;
          }
        }
      }

#ifdef DEBUGGING
  fprintf(fpdbg,"  mpi_isend(buf,%d,%d,%d,%d,...)\n",
    num,*mpi_type,dest,*mpi_tag);
  fflush(fpdbg);
#endif
  
  _mpi_isend( msga->sendbuf, &num, mpi_type, &dest,
	      mpi_tag, mpi_comm, msga->mpi_req + nummsg, ierr );
    }

    /* Wait for the send or any receive to complete */

    {
      _F_INTEGER nreq = nummsg + 1 ;

#ifdef DEBUGGING
    fprintf(fpdbg,"  mpi_waitany\n");
    {
      int iw ;
      for ( iw = 0 ; iw < nreq ; ++iw ) {
        fprintf(fpdbg,"  msga->mpi_req[%d] = %d\n",iw,msga->mpi_req[iw]);
      }
    }
    fflush(fpdbg);
#endif

    _mpi_waitany( &nreq, msga->mpi_req, &which, msga->mpi_stat, ierr );

#ifdef DEBUGGING
    fprintf(fpdbg,"  mpi_waitany( which = %d )\n",which);
    fflush(fpdbg);
#endif

      --which ; /* FORTRAN index ? */
    }

    if ( which == nummsg ) { /* Send completed */
      --nmsend ;
    }
    else { /* Receive completed */
      struct msgone * const msg  = msga->msg + which ;
      char                * buf  = msg->recvbuf ;
      int                   num  = msg->sendnum * numv ;

      const int                    nblk = msg->nblk ;
      const struct msgcell * const cell = msg->recvcell ;
      const struct msgblk  * const blk  = msg->blk ;

      --nmrecv ;

      for ( nb = 0 ; nb < nblk ; ++nb ) {
        const struct msgblk * const blk = msg->blk + nb ;
        const int stride = blk->stride * sizev ;
        const int ncell  = blk->recvncell ;
        char * ary ;

        _aryptr( &(blk->blk), arynum , &ary, ierr );

        for ( ic = 0 ; ic < ncell ; ++ic ) {
          const int          npack =       cell[ic].len * sizev ;
          const char * const ptr   = ary + cell[ic].off * sizev ;

          for ( nv = nv1 ; nv < nv2 ; ++nv ) {
	    
	    fprintf(fmmodel,
		    "\n unpacking %d numbers with npack =%d",nv,npack);

            test_memcpy( ptr + nv * stride , buf , npack , sizev);
            buf += npack ;
          }
        }
      }
    } /* End receive */
  } /* End while sending & receiving */

  // ======================
  // mpesz : for Multi Model end of aliasing 

#undef message

  // ======================

#ifdef DEBUGGING
  fprintf(fpdbg,"%s END\n",myname);
  fflush(fpdbg);
#endif

  return;
}

/** 
MPeszynska, 6/23/98
the function below assumes that our data was originally integer 
and copies the values as if they were integers 
and applies minus sign : this is necessary to achieve 
appropriate keyout values over mutliple processors,
see John Wheeler's kludge in his many.c
--------
n should be in x sizeof(int) 
*/


static void keyout_intcpy(char *s, char *ct, size_t n, size_t in)
{
  /** cast the character pointers to integers */
  int *is = (int *) s;
  int *ict = (int *) ct;
  int inn = n / sizeof(int);
  int i;

  if(in !=inn) return;

  for(i=0;i<in;i++) is[i]=-ict[i];

}


static void test_memcpy(char *dest, char *src, size_t nn, int sizev ) {
  if (sizev == 8) {
    _F_REAL_8 *ptr = (_F_REAL_8 *) src;
    int n = nn / sizev ;
    int i;

    fprintf(fmmodel,
	    "\n Copy %d numbers ",n);

    for(i=0;i<n;i++) 
      fprintf(fmmodel," %g",ptr[i]);

  }

  memcpy (dest, src, nn);
	
}

