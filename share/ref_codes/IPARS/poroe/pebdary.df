C PEBDARY.F - INPUT POROELASTIC MODEL BOUNDARY CONDITION DATA
C
C ROUTINES IN THIS FILE:
C
C     SUBROUTINE PEBDARY(NTIME,NERR)        
C
C     SUBROUTINE PEBDARY_BE(VNAM,N_ARY,KARY,NFACE,NDIR,NTYP,
C                NUMRET,NERR)
C
C     SUBROUTINE PEBDARY_SCAL(VNAM,VAL,VTYP,NFACE,NDIR,NTYP,
C                ND1,ND2,ND3,ND4,NUMRET,NERR)
C
C     SUBROUTINE SETVNAM(VNAM,VNAMC,NB)
C
C     SUBROUTINE PEBDARY_BEWR8(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
C                KL1,KL2,KEYOUT,NBLKA,BD_VAL)
C
C     SUBROUTINE PEBDARY_FACES(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
C                KL1,KL2,KEYOUT,NBLK)
C
C     SUBROUTINE PEBDARY_UPDATE(KERR)
C
C     SUBROUTINE PEBDARY_BE_WRK(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
C                KL1,KL2,KEYOUT,NBLK,BDARY_WRK,BD_VAL)
C
C     SUBROUTINE PEBDARY_WRK_BE(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
C                KL1,KL2,KEYOUT,NBLK,BDARY_WRK,BD_VAL)
C
C     SUBROUTINE TRACTION_TOP(KERR)
C
C     SUBROUTINE TRACTION_TOPW(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
C                      KL1,KL2,KEYOUT,NBLK,DEPTH,BD_VAL)

C     SUBROUTINE TRACTION_SIDE(KERR)

C     SUBROUTINE PEGETVAL  (VNAM,VAL,VTYP,NDIM1,NDIM2,NDIM3,NDIM4,NUMRET,NERR)
C     ENTRY      GETVALS (VNAM,SVAL,VTYP,NDIM1,NDIM2,NDIM3,NDIM4,NUMRET,NERR)
C
C CODE HISTORY:
C     XIULI GAI  12/02/2001
C***********************************************************************
      SUBROUTINE PEBDARY(NTIME,NERR)
C***********************************************************************
C Get poroelastic model boundary condition data
C
C NTIME = BOUNDARY CONDITION READING TIME
C       = 1 INITIALIZATION
C       = 2 TRANSIENT
C 
C NERR  = ERROR KEY STEPED BY ONE FOR EACH ERROR (INPUT & OUTPUT, INTEGER)
C     ITYPE_BOUNDARY(1,1,NBLK) = -X SIDE, X-DIRECTION
C     ITYPE_BOUNDARY(1,2,NBLK) = -X SIDE, Y-DIRECTION
C     ITYPE_BOUNDARY(1,3,NBLK) = -X SIDE, Z-DIRECTION
C     ITYPE_BOUNDARY(2,:,NBLK) = +X SIDE,
C     ITYPE_BOUNDARY(3,1,NBLK) = -Y SIDE, X-DIRECTION
C     ITYPE_BOUNDARY(3,2,NBLK) = -Y SIDE, Y-DIRECTION
C     ITYPE_BOUNDARY(3,3,NBLK) = -Y SIDE, Z-DIRECTION
C     ITYPE_BOUNDARY(4,:,NBLK) = +Y SIDE,
C     ITYPE_BOUNDARY(5,:,NBLK) = -Z SIDE,
C     ITYPE_BOUNDARY(6,:,NBLK) = +Z SIDE,
C************************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'blkary.h'
      INCLUDE 'readdat.h'
      INCLUDE 'unitsex.h'
      INCLUDE 'pemodel.h'
      INCLUDE 'pebdary.h'
      
      EXTERNAL PEBDARY_FACES,PEDISP_FACES
      INTEGER  NERR
     
      INTEGER  I,J,K,JBD(2),KERR,NDUM,JINIT(4)
      REAL*8   DUM(6,3,$MXBLKS)
      CHARACTER*12 JTYPE(3),JSIDE(6)
      CHARACTER*50 TITL
      LOGICAL  DPTYP
     
C FIND BOUNDARY FACES AND ALLOCATE MEMORY FOR BOUNDARY ELEMENTS
     
      IF (NTIME.EQ.1) THEN
         DO K=1,NUMBLK
            DO J=1,3
               DO I=1,6
                  ITYPE_BOUNDARY(I,J,K)=0
               ENDDO
            ENDDO
            DO I=1,6
               IBD_FACE(I,K)=.FALSE.
               DP_FACE(I,K)=.FALSE.
            ENDDO   
         ENDDO 
  
         JBD(1)=0       
         CALL CALLWORK(PEBDARY_FACES,JBD)
         CALL CALLWORK(PEDISP_FACES,JBD)

         N_BDARY(1)=0
         N_BDARY(2)=0
         N_BDARY(3)=0
         N_BDARY(4)=0
         N_BDARY(5)=0
         N_BDARY(6)=0

         N_DISPBD(1) = 0
         N_DISPBD(2) = 0
         N_DISPBD(3) = 0
         N_DISPBD(4) = 0
         N_DISPBD(5) = 0
         N_DISPBD(6) = 0
         DO K=1,NUMBLK
            IF (DP_FACE(1,K)) THEN
               CALL PEALCBEA('BDX1 ',2,3,N_BDARY(1),1,KERR)
               GO TO 1
            ENDIF    
         ENDDO
   1     DO K=1,NUMBLK
            IF (DP_FACE(2,K)) THEN
               CALL PEALCBEA('BDXN ',2,3,N_BDARY(2),1,KERR)
               GO TO 2
            ENDIF
         ENDDO
   2     DO K=1,NUMBLK
            IF (DP_FACE(3,K)) THEN
               CALL PEALCBEA('BDY1 ',2,3,N_BDARY(3),2,KERR)
               GO TO 3
            ENDIF
         ENDDO
   3     DO K=1,NUMBLK
            IF (DP_FACE(4,K)) THEN
               CALL PEALCBEA('BDYN ',2,3,N_BDARY(4),2,KERR)
               GO TO 4
            ENDIF
         ENDDO
   4     DO K=1,NUMBLK
            IF (DP_FACE(5,K)) THEN
               CALL PEALCBEA('BDZ1 ',2,3,N_BDARY(5),3,KERR)
               GO TO 5
            ENDIF
         ENDDO
   5     DO K=1,NUMBLK
            IF (DP_FACE(6,K)) THEN
               CALL PEALCBEA('BDZN ',2,3,N_BDARY(6),3,KERR)
               GO TO 6
            ENDIF
         ENDDO
   6     CONTINUE           
      ENDIF

cbw MEMORY ALLOCATION FOR NON-ZERO DISPLACEMENT BOUNDARY CONDITION
      CALL PEALCBEA('DISPX1 ',2,12,N_DISPBD(1),1,KERR)
      CALL PEALCBEA('DISPXN ',2,12,N_DISPBD(2),1,KERR)
      CALL PEALCBEA('DISPY1 ',2,12,N_DISPBD(3),2,KERR)
      CALL PEALCBEA('DISPYN ',2,12,N_DISPBD(4),2,KERR)
      CALL PEALCBEA('DISPZ1 ',2,12,N_DISPBD(5),3,KERR)
      CALL PEALCBEA('DISPZN ',2,12,N_DISPBD(6),3,KERR)
CBW
      WRITE(*,*) 'myprc=',myprc,' BOUNDARY FACE FLAG'
      DO K=1,6
         WRITE(*,*) K,IBD_FACE(K,1)
      ENDDO
cbw



C GET ZERO DISPLACEMENT BOUNDARY CONDITIONS

      KERR = 0 
      
C -X SIDE IN X,Y,Z DIRECTION

      DPTYP=.FALSE.
      CALL PEBDARY_SCAL('XXDP ',DPTYP,'FG',1,1,1,0,0,0,0,NDUM,KERR)
      CALL PEBDARY_SCAL('XYDP ',DPTYP,'FG',1,2,1,0,0,0,0,NDUM,KERR)
      CALL PEBDARY_SCAL('XZDP ',DPTYP,'FG',1,3,1,0,0,0,0,NDUM,KERR)
    
C +X SIDE IN X,Y,Z DIRECTION

      CALL PEBDARY_SCAL('XXDPN ',DPTYP,'FG',2,1,1,0,0,0,0,NDUM,KERR)
      CALL PEBDARY_SCAL('XYDPN ',DPTYP,'FG',2,2,1,0,0,0,0,NDUM,KERR)
      CALL PEBDARY_SCAL('XZDPN ',DPTYP,'FG',2,3,1,0,0,0,0,NDUM,KERR)

C -Y SIDE IN X,Y,Z DIRECTION

      CALL PEBDARY_SCAL('YXDP ',DPTYP,'FG',3,1,1,0,0,0,0,NDUM,KERR)
      CALL PEBDARY_SCAL('YYDP ',DPTYP,'FG',3,2,1,0,0,0,0,NDUM,KERR)
      CALL PEBDARY_SCAL('YZDP ',DPTYP,'FG',3,3,1,0,0,0,0,NDUM,KERR)

C +Y SIDE IN X,Y,Z DIRECTION

      CALL PEBDARY_SCAL('YXDPN ',DPTYP,'FG',4,1,1,0,0,0,0,NDUM,KERR)
      CALL PEBDARY_SCAL('YYDPN ',DPTYP,'FG',4,2,1,0,0,0,0,NDUM,KERR)
      CALL PEBDARY_SCAL('YZDPN ',DPTYP,'FG',4,3,1,0,0,0,0,NDUM,KERR)

C -Z SIDE IN X,Y,Z DIRECTION

      CALL PEBDARY_SCAL('ZXDP ',DPTYP,'FG',5,1,1,0,0,0,0,NDUM,KERR)
      CALL PEBDARY_SCAL('ZYDP ',DPTYP,'FG',5,2,1,0,0,0,0,NDUM,KERR)
      CALL PEBDARY_SCAL('ZZDP ',DPTYP,'FG',5,3,1,0,0,0,0,NDUM,KERR)

C +Z SIDE IN X,Y,Z DIRECTION

      CALL PEBDARY_SCAL('ZXDPN ',DPTYP,'FG',6,1,1,0,0,0,0,NDUM,KERR)
      CALL PEBDARY_SCAL('ZYDPN ',DPTYP,'FG',6,2,1,0,0,0,0,NDUM,KERR)
      CALL PEBDARY_SCAL('ZZDPN ',DPTYP,'FG',6,3,1,0,0,0,0,NDUM,KERR)

cbw INPUT NON-ZERO DISPLACEMENT BOUNDARY CONDITION

C -X SIDE IN X,Y,Z DIRECTION
      CALL PEBDARY_DP('XXDI[in] ',N_DISPBD(1),1,1,1,2,NDUM,KERR)
      CALL PEBDARY_DP('XYDI[in] ',N_DISPBD(1),1,1,2,2,NDUM,KERR)
      CALL PEBDARY_DP('XZDI[in] ',N_DISPBD(1),1,1,3,2,NDUM,KERR)

C +X SIDE IN X,Y,Z DIRECTION
      CALL PEBDARY_DP('XXDIN[in] ',N_DISPBD(2),1,2,1,2,NDUM,KERR)
      CALL PEBDARY_DP('XYDIN[in] ',N_DISPBD(2),1,2,2,2,NDUM,KERR)
      CALL PEBDARY_DP('XZDIN[in] ',N_DISPBD(2),1,2,3,2,NDUM,KERR)

C -Y SIDE IN X,Y,Z DIRECTION
      CALL PEBDARY_DP('YYDI[in] ',N_DISPBD(3),1,3,2,2,NDUM,KERR)
      CALL PEBDARY_DP('YXDI[in] ',N_DISPBD(3),1,3,1,2,NDUM,KERR)
      CALL PEBDARY_DP('YZDI[in] ',N_DISPBD(3),1,3,3,2,NDUM,KERR)

C +Y SIDE IN X,Y,Z DIRECTION
      CALL PEBDARY_DP('YYDIN[in] ',N_DISPBD(4),1,4,2,2,NDUM,KERR)
      CALL PEBDARY_DP('YXDIN[in] ',N_DISPBD(4),1,4,1,2,NDUM,KERR)
      CALL PEBDARY_DP('YZDIN[in] ',N_DISPBD(4),1,4,3,2,NDUM,KERR)

C -Z SIDE IN X,Y,Z DIRECTION
      CALL PEBDARY_DP('ZZDI[in] ',N_DISPBD(5),1,5,3,2,NDUM,KERR)
      CALL PEBDARY_DP('ZXDI[in] ',N_DISPBD(5),1,5,1,2,NDUM,KERR)
      CALL PEBDARY_DP('ZYDI[in] ',N_DISPBD(5),1,5,2,2,NDUM,KERR)

C +Z SIDE IN X,Y,Z DIRECTION
      CALL PEBDARY_DP('ZZDIN[in] ',N_DISPBD(6),1,6,3,2,NDUM,KERR)
      CALL PEBDARY_DP('ZXDIN[in] ',N_DISPBD(6),1,6,1,2,NDUM,KERR)
      CALL PEBDARY_DP('ZYDIN[in] ',N_DISPBD(6),1,6,2,2,NDUM,KERR)
cbw


C SET INDICATOR OF STRESS AT THE TOP OF RESERVOIR
      
      ISTTOP=.FALSE.
      CALL GETVAL('STTOP ',ISTTOP,'FG',0,0,0,0,NDUM,KERR)
      IF(ISTTOP) THEN
         IF (INIT_STRESS.EQ.1) THEN
            WRITE(NFOUT,7)
            NERR = NERR + 1
         ELSE
            DO K=1,NUMBLK
               ITYPE_BOUNDARY(1,1,K) = 4
            ENDDO
         ENDIF
      ENDIF
   7  FORMAT (/'ERR(PE): STTOP IS NOT ALLOWED WITH STRXX,YY,ZZ')

C SET INDICATOR OF STRESS AT THE SIDES OF THE RESERVOIR
                                                                                
      ISTSIDE=.FALSE.
      CALL GETVAL('STSIDE ',ISTSIDE,'FG',0,0,0,0,NDUM,KERR)
      IF(ISTSIDE) THEN
         DO K=1,NUMBLK
            ITYPE_BOUNDARY(3,2,K) = 4
            ITYPE_BOUNDARY(4,2,K) = 4
            ITYPE_BOUNDARY(5,3,K) = 4
            ITYPE_BOUNDARY(6,3,K) = 4
         ENDDO
      ENDIF
      
C GET BOUNDARY TRACTION DATA

      CALL DEFAULT(EXTPRES)

C -X SIDE X,Y,Z DIRECTION TRACTION

cbw      CALL PEBDARY_BE('XXST[psi] ',N_BDARY(1),1,1,1,2,NDUM,KERR)
      CALL PEBDARY_BE('XXST[psi] ',N_BDARY(1),1,1,1,4,NDUM,KERR)
      IF (NDUM.GT.0) THEN
          IF (ISTTOP) THEN
             IF (LEVELC) THEN
                 WRITE(NFOUT,8)
                 NERR=NERR+1
                 RETURN
             ENDIF
          ENDIF
      ENDIF

   8  FORMAT ('/ERROR: XXST1 IS NOT ALLOWED WITH ISTTOP')
      CALL PEBDARY_BE('XYST[psi] ',N_BDARY(1),1,1,2,4,NDUM,KERR)
      CALL PEBDARY_BE('XZST[psi] ',N_BDARY(1),1,1,3,4,NDUM,KERR)

C +X SIDE X,Y,Z DIRECTION TRACTION
      CALL PEBDARY_BE('XXSTN[psi] ',N_BDARY(2),1,2,1,4,NDUM,KERR)
      CALL PEBDARY_BE('XYSTN[psi] ',N_BDARY(2),1,2,2,4,NDUM,KERR)
      CALL PEBDARY_BE('XZSTN[psi] ',N_BDARY(2),1,2,3,4,NDUM,KERR)

C -Y SIDE X,Y,Z DIRECTION TRACTION
      CALL PEBDARY_BE('YXST[psi] ',N_BDARY(3),1,3,1,4,NDUM,KERR)
      CALL PEBDARY_BE('YYST[psi] ',N_BDARY(3),1,3,2,4,NDUM,KERR)
      CALL PEBDARY_BE('YZST[psi] ',N_BDARY(3),1,3,3,4,NDUM,KERR)
      IF (NDUM.GT.0) THEN
          IF (ISTSIDE) THEN
             IF (LEVELC) THEN
                 WRITE(NFOUT,9)
                 NERR=NERR+1
                 RETURN
             ENDIF
          ENDIF
      ENDIF
  9   FORMAT ('/ERROR: YYST1 IS NOT ALLOWED WITH ISTSIDE')
     
C +Y SIDE X,Y,Z DIRECTION TRACTION
      CALL PEBDARY_BE('YXSTN[psi] ',N_BDARY(4),1,4,1,4,NDUM,KERR)
      CALL PEBDARY_BE('YZSTN[psi] ',N_BDARY(4),1,4,3,4,NDUM,KERR)
      CALL PEBDARY_BE('YYSTN[psi] ',N_BDARY(4),1,4,2,4,NDUM,KERR)
      IF (NDUM.GT.0) THEN
          IF (ISTSIDE) THEN
             IF (LEVELC) THEN
                 WRITE(NFOUT,10)
                 NERR=NERR+1
                 RETURN
             ENDIF
          ENDIF
      ENDIF
  10  FORMAT ('/ERROR: YYSTN IS NOT ALLOWED WITH ISTSIDE')

C -Z SIDE X,Y,Z DIRECTION TRACTION
      CALL PEBDARY_BE('ZXST[psi] ',N_BDARY(5),1,5,1,4,NDUM,KERR)
      CALL PEBDARY_BE('ZYST[psi] ',N_BDARY(5),1,5,2,4,NDUM,KERR)
      CALL PEBDARY_BE('ZZST[psi] ',N_BDARY(5),1,5,3,4,NDUM,KERR)
      IF (NDUM.GT.0) THEN
          IF (ISTSIDE) THEN
             IF (LEVELC) THEN
                 WRITE(NFOUT,11)
                 NERR=NERR+1
                 RETURN
             ENDIF
          ENDIF
      ENDIF
  11  FORMAT ('/ERROR: ZZST1 IS NOT ALLOWED WITH ISTSIDE')

C +Z SIDE X,Y,Z DIRECTION TRACTION
      CALL PEBDARY_BE('ZXSTN[psi] ',N_BDARY(6),1,6,1,4,NDUM,KERR)
      CALL PEBDARY_BE('ZYSTN[psi] ',N_BDARY(6),1,6,2,4,NDUM,KERR)
      CALL PEBDARY_BE('ZZSTN[psi] ',N_BDARY(6),1,6,3,4,NDUM,KERR)
      IF (NDUM.GT.0) THEN
          IF (ISTSIDE) THEN
             IF (LEVELC) THEN
                 WRITE(NFOUT,12)
                 NERR=NERR+1
                 RETURN
             ENDIF
          ENDIF
      ENDIF
  12  FORMAT ('/ERROR: ZZSTN IS NOT ALLOWED WITH ISTSIDE')

      NERR=NERR+KERR

C SET ELASTIC DEFAULT BOUNDARY CONDITIONS AND PRINT
      NDIM_ELASTIC=3
      DO K=1,NUMBLK
         DO I = 1,2*NDIM_ELASTIC
            IF (IBD_FACE(I,K)) THEN 
               DO J = 1,NDIM_ELASTIC
                  IF(ITYPE_BOUNDARY(I,J,K).EQ.0) THEN
cbw                 IF(I.NE.2*J.AND.I.NE.2*J-1) ITYPE_BOUNDARY(I,J,K)=99
                  IF(I.NE.2*J.AND.I.NE.2*J-1) ITYPE_BOUNDARY(I,J,K)=3
                  ENDIF
               ENDDO
            ENDIF
         ENDDO
      ENDDO
      JSIDE(1) = '-X'
      JSIDE(2) = '+X'
      JSIDE(3) = '-Y'
      JSIDE(4) = '+Y'
      JSIDE(5) = '-Z'
      JSIDE(6) = '+Z'
      IZEROG(1) = -1.D0
      IZEROG(2) = -1.D0
      IZEROG(3) = -1.D0

cbw
c below part is cut from the part originally below the line
c "14 FORMAT (2X ..."
c the purpose is to output boundary conditions correctly

$MANY      CALL TIMON(30)
$MANY      IF(NUMPRC.GT.1) THEN
$MANY         NDIM=NDIM_ELASTIC
$MANY         DO K=1,NUMBLK
$MANY            DO J=1,NDIM
$MANY               DO I=1,2*NDIM
$MANY                  DUM(I,J,K)=ITYPE_BOUNDARY(I,J,K)
$MANY               ENDDO
$MANY            ENDDO
$MANY         ENDDO
$MANY         CALL MAXIT(3*6*$MXBLKS,DUM)
$MANY         NDIM=NDIM_ELASTIC
$MANY         DO K=1,NUMBLK
$MANY            DO J=1,NDIM
$MANY               DO I=1,2*NDIM
$MANY                  ITYPE_BOUNDARY(I,J,K)=DUM(I,J,K)+.1D0
$MANY               ENDDO
$MANY            ENDDO
$MANY         ENDDO
$MANY         CALL SPREAD(3*6*$MXBLKS,ITYPE_BOUNDARY)
$MANY         CALL TIMOFF(30)
$MANY      ENDIF

cbw



      IF(LEVELC) THEN
         WRITE(NFOUT,*)
         TITL = '*******'
         CALL PRTTIT(TITL)
         TITL = 'ELASTIC BOUNDARY CONDITIONS'
         CALL PRTTIT(TITL)
         WRITE(NFOUT,13)
      ENDIF
         DO K=1,NUMBLK
            DO I = 1,2*NDIM_ELASTIC
                  DO J = 1,NDIM_ELASTIC
                     IF (ITYPE_BOUNDARY(I,J,K).LE.2) THEN
                        IF (ITYPE_BOUNDARY(I,J,K).LE.1) THEN
                           JTYPE(J) = 'ZERO_DISP'
                           IZEROG(J) = 1.D0
                        ELSE
                           JTYPE(J) = 'DISPLACEMENT'
                           IZEROG(J) = 1.D0
                        ENDIF
                     ELSE
                        IF (ITYPE_BOUNDARY(I,J,K).EQ.3) THEN
                           JTYPE(J) = 'ZERO_TRAC'
                        ELSE
                           JTYPE(J) = 'TRACTION'
                        ENDIF
                     ENDIF
                  ENDDO
               IF (LEVELC) THEN
                  WRITE(NFOUT,14) K,JSIDE(I),(JTYPE(J),J=1,NDIM_ELASTIC)
               ENDIF
            ENDDO
         ENDDO
  13  FORMAT(/2X,'NBLK   SIDE    DIRECTION X    
     &     DIRECTION Y     DIRECTION Z')
  14  FORMAT(2X,I3,5X,A4,3X,A,4X,A,4X,A)

cbw READ IN USER-SPECIFIED POINT DISPLACEMENTS
      DO K = 1,NUMBLK
         DO J = 1,4
            DO I = 1,3
               XPOINTIND(I,J,K) = 0
               YPOINTIND(I,J,K) = 0
               ZPOINTIND(I,J,K) = 0
            ENDDO
            XPOINTDP(J,K) = 0.D0
            YPOINTDP(J,K) = 0.D0
            ZPOINTDP(J,K) = 0.D0
         ENDDO
      ENDDO
      ISFIXDPX = .FALSE.
      ISFIXDPY = .FALSE.
      ISFIXDPZ = .FALSE.

      CALL GETVAL('XPTIND ',XPOINTIND,'I4',3,4,$MXBLKS,0,NDUM,KERR)
      IF (NDUM .GT. 0) THEN
         ISFIXDPX = .TRUE.
cbw         IZEROG(1) = 1.D0
cbw         WRITE(*,*)"XPTIIND(,1,)=",(XPOINTIND(III,1,1),III=1,3)
cbw         WRITE(*,*)"XPTIIND(,2,)=",(XPOINTIND(III,2,1),III=1,3)
cbw         WRITE(*,*)"XPTIIND(,3,)=",(XPOINTIND(III,3,1),III=1,3)
      ENDIF
      CALL GETVAL('XPTDISP[in] ',XPOINTDP,'R8',4,$MXBLKS,0,0,NDUM,KERR)

      CALL GETVAL('YPTIND ',YPOINTIND,'I4',3,4,$MXBLKS,0,NDUM,KERR)
      IF (NDUM .GT. 0) THEN
         ISFIXDPY = .TRUE.
         IZEROG(2) = 1.D0
cbw         WRITE(*,*)"YPTIIND(,1,)=",(YPOINTIND(III,1,1),III=1,3)
cbw         WRITE(*,*)"YPTIIND(,2,)=",(YPOINTIND(III,2,1),III=1,3)
cbw         WRITE(*,*)"YPTIIND(,3,)=",(YPOINTIND(III,3,1),III=1,3)
      ENDIF
      CALL GETVAL('YPTDISP[in] ',YPOINTDP,'R8',4,$MXBLKS,0,0,NDUM,KERR)

      CALL GETVAL('ZPTIND ',ZPOINTIND,'I4',3,4,$MXBLKS,0,NDUM,KERR)
      IF (NDUM .GT. 0) THEN
         ISFIXDPZ = .TRUE.
         IZEROG(3) = 1.D0
cbw         WRITE(*,*)"ZPTIIND(,1,)=",(ZPOINTIND(III,1,1),III=1,3)
cbw         WRITE(*,*)"ZPTIIND(,2,)=",(ZPOINTIND(III,2,1),III=1,3)
cbw         WRITE(*,*)"ZPTIIND(,3,)=",(ZPOINTIND(III,3,1),III=1,3)
      ENDIF
      CALL GETVAL('ZPTDISP[in] ',ZPOINTDP,'R8',4,$MXBLKS,0,0,NDUM,KERR)
cbw




cbw $MANY      CALL TIMON(30)
cbw $MANY      IF(NUMPRC.GT.1) THEN
cbw $MANY         CALL MAXIT(3,IZEROG)
cbw $MANY         CALL SPREAD(3,IZEROG)
cbw $MANY         CALL TIMOFF(30)
cbw $MANY      ENDIF

cbw $MANY      CALL TIMON(30)
cbw $MANY      IF(NUMPRC.GT.1) THEN
cbw $MANY         NDIM=NDIM_ELASTIC
cbw $MANY         DO K=1,NUMBLK
cbw $MANY            DO J=1,NDIM
cbw $MANY               DO I=1,2*NDIM
cbw $MANY                  DUM(I,J,K)=ITYPE_BOUNDARY(I,J,K)
cbw $MANY               ENDDO
cbw $MANY            ENDDO
cbw $MANY         ENDDO
cbw $MANY         CALL MAXIT(3*6*$MXBLKS,DUM)
cbw $MANY         NDIM=NDIM_ELASTIC
cbw $MANY         DO K=1,NUMBLK
cbw $MANY            DO J=1,NDIM
cbw $MANY               DO I=1,2*NDIM
cbw $MANY                  ITYPE_BOUNDARY(I,J,K)=DUM(I,J,K)+.1D0
cbw $MANY               ENDDO
cbw $MANY            ENDDO
cbw $MANY         ENDDO
cbw $MANY         CALL SPREAD(3*6*$MXBLKS,ITYPE_BOUNDARY)
cbw $MANY         CALL MAXIT(3,IZEROG)
cbw $MANY         CALL TIMOFF(30)
cbw $MANY      ENDIF

C SETUP TRACTION BOUNDARY CONDITION ON TOP OF THE RESERVOIR
                                                                                
c     IF(ISTTOP.AND.N_BDARY(1).GT.0) THEN
c        JINIT(1) = 2
c        JINIT(2) = N_DEPTH
c        JINIT(3) = N_BDARY(1)
c        CALL CALLWORK(TRACTION_TOP,JINIT)
c     ENDIF

C UPDATE TRACTION BOUNDARY CONDITIONS    
       
cbw $MANY      IF(NTIME.GT.1) CALL PEBDARY_UPDATE(KERR)

      END

C***********************************************************************
      SUBROUTINE PEBDARY_BE(VNAM,N_ARY,KARY,NFACE,NDIR,NTYP,
     &           NUMRET,NERR)
C***********************************************************************
C Poroelastic model boundary element input 
C
C VNAM = CHARACTER STRING TO BE READ IN THE INPUT FILE
C        (INPUT, CHARACTER*$MAXUL)
C
C N_ARY = BOUNDARY ELEMENT ARRAY NUMBER (INPUT,INTEGER)
C
C KARY = ARRAY KEY (INPUT,INTEGER)
C      = 1 ==> BLOCK CENTER ARRAY
C      = 2 ==> BLOCK CORNER ARRAY
C
C NFACE = BOUNDARY FACE NUMBER TO BE READ (INPUT,INTEGER)
C       = 1 ==> -X SIDE
C       = 2 ==> +X SIDE
C       = 3 ==> -Y SIDE
C       = 4 ==> +Y SIDE
C       = 5 ==> -Z SIDE
C       = 6 ==> +Z SIDE
C
C NDIR = DIRECTION NUMBER ON A BOUNDARY FACE (INPUT,INTEGER)
C       = 1 ==> X DIRECTION
C       = 2 ==> Y DIRECTION
C       = 3 ==> Z DIRECTION
C
C NTYP = BOUNDARY CONDITION TYPE
C       = 1 ==> ZERO DISPLACEMENT
C       = 3 ==> ZERO TRACTION
C       = 4 ==> TRACTION       
C
C NUMRET = NUMBER OF VALUES READ TO THE ARRAY (OUTPUT, INTEGER)
C
C NERR = ERROR NUMBER STEPPED BY 1 FOR EACH DATA ERROR INCOUNTERED
C        (INPUT AND OUTPUT, INTEGER)
C **********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'readdat.h'
      INCLUDE 'pebdary.h'

      PARAMETER (MAXCHR=$MXREAD)
      CHARACTER*1 VNAM(*)
      INTEGER N_ARY,KARY,NFACE,NDIR,NTYP,NUMRET,NERR

      INTEGER  I,J,KA(2),NMOD,DIM4,KERR
      EXTERNAL PEBDARY_BEWR8
cbw
      INTEGER PEMOD
cbw

      IF(N_ARY.EQ.0) RETURN 
cbw      CALL ARYTYPE(N_ARY,NTYPGA,NDIM4,KERR)     
      CALL ARYTYPE(N_ARY,NTYPGA,NDIM4,PEMOD,KERR)     
      IF(KERR.GT.0) THEN
         NERR=NERR+1
         RETURN
      ENDIF
      J=0
      DO I=1,$MAXUL
         VNAMGA(I)=VNAM(I)
         IF (VNAMGA(I).EQ.']'.OR.(VNAMGA(I).EQ.' '.AND.J.EQ.0)) GO TO 2
         IF (VNAMGA(I).EQ.'[') J=1
      ENDDO

   2  NUMRGA=0
      KERRGA=0
      KNDARY=KARY
      IFACE=NFACE
      IBD_DIR=NDIR
      IBD_TYPE=NTYP

      KA(1)=1
      KA(2)=N_ARY
      CALL ALLBLOCKS()
      IF (NTYPGA.NE.2) THEN
         NERR=NERR+1
         IF (LEVELC) WRITE(NFOUT,3)
         RETURN
      ELSE
         CALL CALLWORK(PEBDARY_BEWR8,KA)
      ENDIF
      NUMRET=NUMRGA
      NERR=NERR+KERRGA
     
   3  FORMAT('/ERR(PE100): ONLY REAL*8 TYPE OF BOUNDARY DATA ALLOWED')
      END

C***********************************************************************
      SUBROUTINE PEBDARY_SCAL(VNAM,VAL,VTYP,NFACE,NDIR,NTYP,
     &           ND1,ND2,ND3,ND4,NUMRET,NERR)
C***********************************************************************
C Poroelastic model boundary condition scalar input 
C
C VNAM = CHARACTER STRING TO BE READ IN THE INPUT FILE
C        (INPUT, CHARACTER*$MAXUL)
C
C VAL = SCALAR VALUE RETURNED (OUTPUT)
C
C VTYP = VARIABLE TYPE (INPUT, CHARACTER*2).
C      = I2 ==> INTEGER
C      = I4 ==> INTEGER
C      = R4 ==> REAL*4
C      = R8 ==> REAL*8
C      = L2 ==> LOGICAL
C      = L4 ==> LOGICAL
C      = CS ==> CHARACTER STRING (MAX LENGTH GIVEN BY DIM4)
C      = FG ==> FLAG VARIABLE, LOGICAL
C      = BT ==> BLOCK TEXT (MAX LENGTH GIVEN BY DIM4)
C
C NFACE = BOUNDARY FACE NUMBER TO BE READ (INPUT,INTEGER)
C       = 1 ==> -X SIDE
C       = 2 ==> +X SIDE
C       = 3 ==> -Y SIDE
C       = 4 ==> +Y SIDE
C       = 5 ==> -Z SIDE
C       = 6 ==> +Z SIDE
C
C NDIR = DIRECTION NUMBER ON A BOUNDARY FACE (INPUT,INTEGER)
C       = 1 ==> X DIRECTION
C       = 2 ==> Y DIRECTION
C       = 3 ==> Z DIRECTION
C
C NTYP = BOUNDARY CONDITION TYPE
C       = 1 ==> ZERO DISPLACEMENT
C       = 3 ==> ZERO TRACTION
C       = 4 ==> TRACTION          
C
C ND1 = FIRST DIMENSION OF VAL. UNUSED DIMENSIONS ARE INDICATED BY 0
C ND2 = SECOND DIMENSION OF VAL. UNUSED DIMENSIONS ARE INDICATED BY 0
C ND3 = THIRD DIMENSION OF VAL. UNUSED DIMENSIONS ARE INDICATED BY 0
C ND4 = FOURTH DIMENSION OF VAL. UNUSED DIMENSIONS ARE INDICATED BY 0
C
C NUMRET = NUMBER OF VALUES READ TO THE ARRAY (OUTPUT, INTEGER)
C
C NERR = ERROR NUMBER STEPPED BY 1 FOR EACH DATA ERROR INCOUNTERED
C        (INPUT AND OUTPUT, INTEGER)
C***********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'layout.h'
      INCLUDE 'readdat.h'
      INCLUDE 'pebdary.h'

      PARAMETER (NVN=$MAXUL+4)
      CHARACTER*1 VNAM(*),VNAMC(NVN)
      CHARACTER*2 VTYP
      LOGICAL VAL
      INTEGER NFACE,NDIR,NTYP,ND1,ND2,ND3,ND4,NUMRET,NERR
      INTEGER  NB,NMOD,DIM4,KERR,N

C LOOP OVER FAULT BLOCKS TO GET SCALAR BOUNDARY CONDITIONS
      DO I=1,$MAXUL
         VNAMGA(I)=VNAM(I)
         IF (VNAMGA(I).EQ.']'.OR.(VNAMGA(I).EQ.' '.AND.J.EQ.0)) GO TO 2
         IF (VNAMGA(I).EQ.'[') J=1
      ENDDO

  2   NUMRET=0
      DO NB=1,NUMBLK
         KERR=0
         N=0
         CALL SETVNAM(VNAMGA,VNAMC,NB)
         CALL GETVAL(VNAMC,VAL,VTYP,ND1,ND2,ND3,ND4,N,KERR)
         IF (KERR.GT.0) THEN
            NERR=NERR+1
            RETURN
         ELSE IF (N.GT.0) THEN
            ITYPE_BOUNDARY(NFACE,NDIR,NB)=NTYP
            NUMRET=NUMRET+N
         ENDIF
      ENDDO

      END

C**********************************************************************
      SUBROUTINE SETVNAM(VNAM,VNAMC,NB)
C**********************************************************************
C PUT VARIABLE NAME AND BLOCK NUMBER TOGETER
C
C VNAM = VARIABLE NAME (INPUT, CHARACTER*)
C
C VNAMC = NEW VARIABLE NAME (OUTPUT, CHARACTER*)
C
C NB = FAULT BLOCK NUMBER (INPUT,INTEGER)
C**********************************************************************
      CHARACTER*1 VNAM(*),VNAMC(*)
      INTEGER NB

      INTEGER I,J
      CHARACTER*1 DIGITS(10)
      DATA DIGITS/'0','1','2','3','4','5','6','7','8','9'/
      PARAMETER (NVN=$MAXUL+4)

      DO I=1,$MAXUL
         L=I
         IF (VNAM(I).EQ.'['.OR.VNAM(I).EQ.' ') GO TO 2
         VNAMC(L)=VNAM(I)
      ENDDO
   2  J=L
      IF (NB.GT.99) THEN
         VNAMC(L)=DIGITS(1+NB/100)
         L=L+1
      ENDIF
      IF (NB.GT.9) THEN
         VNAMC(L)=DIGITS(1+MOD(NB,100)/10)
         L=L+1
      ENDIF
      VNAMC(L)=DIGITS(1+MOD(NB,10))
      L=L+1

      IF (VNAM(J).EQ.'[') THEN
         DO I=J,$MAXUL
            VNAMC(L)=VNAM(I)
            L=L+1
            IF (VNAM(I).EQ.']') GO TO 4
         ENDDO
      ELSE 
         IF (L.LE.NVN) VNAMC(L)=' '
      ENDIF
   4  CONTINUE
      END
C**********************************************************************
      SUBROUTINE PEBDARY_BEWR8(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &           KL1,KL2,KEYOUT,NBLKA,BD_VAL)
C**********************************************************************
C Poroelastic model boundary element input
C
C OUTPUT: 
C   BD_VAL(J) = TRACTION VALUES ON A BOUNDARY FACE
C**********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'readdat.h'
      INCLUDE 'pebdary.h'

      PARAMETER (NVN=$MAXUL+4)
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLKA
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  BD_VAL(*)

      INTEGER I,J,L,KERR,ILOC
      CHARACTER*1 VNAMC(NVN)
      CHARACTER*2 VTYP(6)
      DATA VTYP/'R4','R8','I2','I4','L2','L4'/

      IF (.NOT.IBD_FACE(IFACE,NBLKA)) RETURN
      IF (IFACE.LE.0.OR.IFACE.GT.6) THEN
         KERRGA=KERRGA+1
         RETURN
      ENDIF
      IF (IBD_DIR.LE.0.OR.IBD_DIR.GT.3) THEN
         KERRGA=KERRGA+1
         RETURN
      ENDIF

C BUILD VARIABLE NAME FOR A SPECIFIC GRID BLOCK

      CALL SETVNAM(VNAMGA,VNAMC,NBLKA)
 
C GET GRID BLOCK GLOBAL DIMENSIONS

   4  CALL BLKDIM(NBLKA,IDIMG,JDIMG,KDIMG,KERR)
      IF(KERR.NE.0) THEN
         KERRGA=KERRGA+1
         RETURN
      ENDIF

      IF (KNDARY.EQ.2) THEN
         IDIMG=IDIMG+1
         JDIMG=JDIMG+1
         KDIMG=KDIMG+1
      ENDIF

C PUT LOCAL-GLOBAL OFFSETS AND LOCAL DIMENSIONS IN /READAT/

      CALL BLKOFF(NBLKA,IGLT,JGLT,KGLT,NERR)
      IDIML=IDIM
      JDIML=JDIM
      KDIML=KDIM
      IF (IFACE.EQ.1.OR.IFACE.EQ.2) THEN
         IDIMG=1
         IDIML=1
         ILOC=(IBD_DIR-1)*JDIM*KDIM+1
      ELSE IF(IFACE.EQ.3.OR.IFACE.EQ.4) THEN
         JDIMG=1
         JDIML=1
         ILOC=(IBD_DIR-1)*IDIM*KDIM+1
      ELSE
         KDIMG=1
         KDIML=1
         ILOC=(IBD_DIR-1)*IDIM*JDIM+1
      ENDIF

C GET DATA FOR THE BOUNDARY ELEMENTS

      KERR=0
      NBLKG=NBLKA
      CALL PEGETVAL (VNAMC,BD_VAL(ILOC),VTYP(NTYPGA),IDIMG,JDIMG,KDIMG,
     &     0,N,KERR)
      NUMRGA=NUMRGA+N
      IF(KERR.NE.0) THEN
         KERRGA=KERRGA+1
         RETURN
      ENDIF
      IF(NUMRGA.GT.0) ITYPE_BOUNDARY(IFACE,IBD_DIR,NBLKA) = IBD_TYPE

      NBLKG=0
      IFACE=0

      END
C**********************************************************************
      SUBROUTINE PEBDARY_FACES(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &           KL1,KL2,KEYOUT,NBLK)
C**********************************************************************
C Determine whether a processor owns a boundary face or not
C
C OUTPUT:
C   IBD_FACE(NDIR,NBLK) = INDICATOR OF A EXISTING BOUNDARY FACE
C                       = .TRUE.  INDICATES A BOUNDARY
C                       = .FALSE. NO BOUNDARY IN THE CURRENT PROCESSOR   
C**********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'readdat.h'
      INCLUDE 'pebdary.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      INTEGER IDIMG,JDIMG,KDIMG,IOFF,JOFF,KOFF,NERR,I,J,K,J1,J2

      CALL BLKDIM(NBLK,IDIMG,JDIMG,KDIMG,NERR)
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,NERR)

C X- SIDE

      DO K=KL1-1,KL2+1
         DO J=1,JDIM          
            DO I=IL1,IL2
Cbw               IF (KEYOUT(I,J,K).NE.0.AND.KEYOUT(I-1,J,K).EQ.0) THEN
               IF (KEYOUT(I,J,K).EQ.1.AND.KEYOUT(I-1,J,K).EQ.0) THEN
                  IBD_FACE(1,NBLK)=.TRUE.
                  GO TO 1
               ENDIF
            ENDDO
         ENDDO
      ENDDO
   1  CONTINUE

C X+ SIDE

      DO K=KL1-1,KL2+1
         DO J=1,JDIM
            DO I=IL2,IL1,-1
cbw               IF (KEYOUT(I,J,K).NE.0.AND.KEYOUT(I+1,J,K).EQ.0) THEN
               IF (KEYOUT(I,J,K).EQ.1.AND.KEYOUT(I+1,J,K).EQ.0) THEN
                  IBD_FACE(2,NBLK)=.TRUE.
                  GO TO 2
               ENDIF
            ENDDO
         ENDDO
      ENDDO
   2  CONTINUE

C Y- SIDE
      DO K=KL1-1,KL2+1
         DO I=IL1,IL2
            DO J=2,JDIM
cbw               IF (KEYOUT(I,J,K).NE.0.AND.KEYOUT(I,J-1,K).EQ.0) THEN
               IF (KEYOUT(I,J,K).EQ.1.AND.KEYOUT(I,J-1,K).EQ.0) THEN
                  IBD_FACE(3,NBLK)=.TRUE.
                  GO TO 3
               ENDIF
            ENDDO
         ENDDO
      ENDDO
   3  CONTINUE

C Y+ SIDE

      DO K=KL1-1,KL2+1
         DO I=IL1,IL2
            DO J=JDIM-1,1,-1
cbw               IF (KEYOUT(I,J,K).NE.0.AND.KEYOUT(I,J+1,K).EQ.0) THEN
               IF (KEYOUT(I,J,K).EQ.1.AND.KEYOUT(I,J+1,K).EQ.0) THEN
                  IBD_FACE(4,NBLK)=.TRUE. 
                  GO TO 4 
               ENDIF
            ENDDO
         ENDDO
      ENDDO
   4  CONTINUE

C Z- SIDE

      DO J=1,JDIM
         DO I=IL1,IL2
            DO K=KL1,KL2
cbw               IF(KEYOUT(I,J,K).NE.0.AND.KEYOUT(I,J,K-1).EQ.0) THEN
               IF(KEYOUT(I,J,K).EQ.1.AND.KEYOUT(I,J,K-1).EQ.0) THEN
                  IBD_FACE(5,NBLK)=.TRUE.
                  GO TO 5
               ENDIF
            ENDDO
         ENDDO
      ENDDO
   5  CONTINUE

C Z+ SIDE

      DO J=1,JDIM
         DO I=IL1,IL2
            DO K=KL2,KL1,-1
cbw               IF(KEYOUT(I,J,K).NE.0.AND.KEYOUT(I,J,K+1).EQ.0) THEN
               IF(KEYOUT(I,J,K).EQ.1.AND.KEYOUT(I,J,K+1).EQ.0) THEN
               IBD_FACE(6,NBLK)=.TRUE.
               GO TO 6 
               ENDIF
            ENDDO
         ENDDO
      ENDDO
   6  CONTINUE

      BDARYIJK(1,1,NBLK)=IL1+IOFF
      BDARYIJK(2,1,NBLK)=IL2+IOFF
      BDARYIJK(1,3,NBLK)=KL1+KOFF
      BDARYIJK(2,3,NBLK)=KL2+KOFF
      J1=JDIM
      J2=1
      DO K=KL1,KL2
         IF(JL1V(K).LT.J1) J1=JL1V(K)
         IF(JL2V(K).GT.J2) J2=JL2V(K)
      ENDDO
      BDARYIJK(1,2,NBLK)=J1+JOFF
      BDARYIJK(2,2,NBLK)=J2+JOFF
      END

C**********************************************************************
      SUBROUTINE PEBDARY_UPDATE(KERR)
C**********************************************************************
C Update boundary condtion values between processors 
C**********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'pemodel.h'
      INCLUDE 'pebdary.h'
      INCLUDE 'pearydat.h'

      INTEGER KERR,IBD,JCOPY(3),NDIM4
      REAL*8  ZERO
      EXTERNAL PEBDARY_BE_WRK,PEBDARY_WRK_BE

      NDIM4=NDIM_ELASTIC
      CALL ALCGEA('BDARY_WRK ',2,NDIM4,N_BDARY_WRK,KERR)

$MANY      CALL WAITALL()

      JCOPY(1)=2
      JCOPY(2)=N_BDARY_WRK

C X SIDES OF BOUNDARY

      IF(N_BDARY(1).GT.0) THEN
cbw      
         CALL PESETARYR8N(N_BDARY_WRK,0.D0,3)
cbw
         JCOPY(3)=N_BDARY(1)
         IFACE=1
         CALL CALLWORK(PEBDARY_BE_WRK,JCOPY)
      ENDIF
$MANY       CALL TIMON(30)
$MANY       CALL UPDATE(N_BDARY_WRK,2)
$MANY       CALL TIMOFF(30)
      IF(N_BDARY(1).GT.0) THEN
         CALL CALLWORK(PEBDARY_WRK_BE,JCOPY)
      ENDIF
      IF(N_BDARY(2).GT.0) THEN
cbw      
         CALL PESETARYR8N(N_BDARY_WRK,0.D0,3)
cbw
         JCOPY(3)=N_BDARY(2)
         IFACE=2
         CALL CALLWORK(PEBDARY_BE_WRK,JCOPY)
      ENDIF
$MANY       CALL TIMON(30)
$MANY       CALL UPDATE(N_BDARY_WRK,2)
$MANY       CALL TIMOFF(30)
      IF(N_BDARY(2).GT.0) THEN
         CALL CALLWORK(PEBDARY_WRK_BE,JCOPY)
      ENDIF

C Y SIDES OF BOUMDARY

      IF(N_BDARY(3).GT.0) THEN
cbw      
         CALL PESETARYR8N(N_BDARY_WRK,0.D0,3)
cbw
         JCOPY(3)=N_BDARY(3)
         IFACE=3
         CALL CALLWORK(PEBDARY_BE_WRK,JCOPY)
      ENDIF
$MANY       CALL TIMON(30)
$MANY       CALL UPDATE(N_BDARY_WRK,2)
$MANY       CALL TIMOFF(30)
      IF(N_BDARY(3).GT.0) THEN
         CALL CALLWORK(PEBDARY_WRK_BE,JCOPY)
      ENDIF
      IF(N_BDARY(4).GT.0) THEN
cbw      
         CALL PESETARYR8N(N_BDARY_WRK,0.D0,3)
cbw
         JCOPY(3)=N_BDARY(4)
         IFACE=4
         CALL CALLWORK(PEBDARY_BE_WRK,JCOPY)
      ENDIF
$MANY       CALL TIMON(30)
$MANY       CALL UPDATE(N_BDARY_WRK,2)
$MANY       CALL TIMOFF(30)
      IF(N_BDARY(4).GT.0) THEN
         CALL CALLWORK(PEBDARY_WRK_BE,JCOPY)
      ENDIF

C Z SIDES OF BOUNDARY

      IF(N_BDARY(5).GT.0) THEN
cbw      
         CALL PESETARYR8N(N_BDARY_WRK,0.D0,3)
cbw
         JCOPY(3)=N_BDARY(5)
         IFACE=5
         CALL CALLWORK(PEBDARY_BE_WRK,JCOPY)
      ENDIF
$MANY       CALL TIMON(30)
$MANY       CALL UPDATE(N_BDARY_WRK,2)
$MANY       CALL TIMOFF(30)
      IF(N_BDARY(5).GT.0) THEN
         CALL CALLWORK(PEBDARY_WRK_BE,JCOPY)
      ENDIF
      IF(N_BDARY(6).GT.0) THEN
cbw      
         CALL PESETARYR8N(N_BDARY_WRK,0.D0,3)
cbw
         JCOPY(3)=N_BDARY(6)
         IFACE=6
         CALL CALLWORK(PEBDARY_BE_WRK,JCOPY)
      ENDIF
$MANY       CALL TIMON(30)
$MANY       CALL UPDATE(N_BDARY_WRK,2)
$MANY       CALL TIMOFF(30)
      IF(N_BDARY(6).GT.0) THEN
         CALL CALLWORK(PEBDARY_WRK_BE,JCOPY)
      ENDIF

      END

C**********************************************************************
      SUBROUTINE PEBDARY_BE_WRK(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &                    KL1,KL2,KEYOUT,NBLK,BDARY_WRK,BD_VAL)
C**********************************************************************
C Copy values from a 2D boundary element array to 3D grid element array
C before update
C
C INPUT:
C   BD_VAL(*) = 2D GRID ELEMENT ARRAY
C
C OUTPUT:
C   DARY_WRK(I,J,K,L) = 3D GRID ELEMENT ARRAY
C**********************************************************************
      INCLUDE 'control.h'
      INCLUDE 'pebdary.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM), KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  BDARY_WRK(IDIM,JDIM,KDIM,3),BD_VAL(*)

      INTEGER I,J,K,L,JL1,JL2,LOC,LOFF

      IF(.NOT.IBD_FACE(IFACE,NBLK)) RETURN

      GO TO (1,2,3,4,5,6) IFACE

C COPY -X SIDE BOUNDARY VALUE TO BDARY_WRK
     
   1  NBP=JDIM*KDIM
      DO L=1,3
        LOFF=(L-1)*NBP
        IF(ITYPE_BOUNDARY(1,L,NBLK).EQ.4) THEN     
           DO K = KL1,KL2
              DO J = JL1V(K),JL2V(K)
                 DO I = IL1,IL2
                    IF(KEYOUT(I,J,K).EQ.1.AND.KEYOUT(I-1,J,K).EQ.0) THEN
                       BDARY_WRK(I,J,K,L)=BD_VAL(LOFF+(K-1)*JDIM+J) 
                       GO TO 11
                    ENDIF
                 ENDDO
  11             CONTINUE
              ENDDO
           ENDDO
        ENDIF
      ENDDO
      GO TO 20

C COPY + X SIDE BOUNDARY VALUE TO BDARY_WRK

   2  NBP = JDIM*KDIM          
      DO L=1,3
        LOFF=(L-1)*NBP
        IF(ITYPE_BOUNDARY(2,L,NBLK).EQ.4) THEN
           DO K = KL1,KL2
              DO J=JL1V(K),JL2V(K)
                 DO I=IL2,IL1,-1
                    IF(KEYOUT(I,J,K).EQ.1.AND.KEYOUT(I+1,J,K).EQ.0) THEN
                       BDARY_WRK(I,J,K,L)=BD_VAL(LOFF+(K-1)*JDIM+J)
                       GO TO 12
                    ENDIF
                 ENDDO
  12             CONTINUE
              ENDDO
           ENDDO
        ENDIF
      ENDDO
      GO TO 20

C COPY - Y SIDE BOUNDARY VALUE TO BDARY_WRK

   3  NBP = IDIM*KDIM
      DO L=1,3
         LOFF=(L-1)*NBP
         IF(ITYPE_BOUNDARY(3,L,NBLK).EQ.4) THEN
           DO K=KL1,KL2
              JL1=JL1V(K)
              JL2=JL2V(K)
              DO I=IL1,IL2
                 DO J=JL1,JL2
                    IF(KEYOUT(I,J,K).EQ.1.AND.KEYOUT(I,J-1,K).EQ.0) THEN
                       BDARY_WRK(I,J,K,L)=BD_VAL(LOFF+(K-1)*IDIM+I)
                       GO TO 13
                    ENDIF
                 ENDDO
  13             CONTINUE
              ENDDO
           ENDDO
         ENDIF
      ENDDO
      GO TO 20

C COPY + Y SIDE BOUNDARY VALUE TO BDARY_WRK

   4  NBP = IDIM*KDIM
      DO L=1,3
         LOFF=(L-1)*NBP
         IF(ITYPE_BOUNDARY(4,L,NBLK).EQ.4) THEN
           DO K=KL1,KL2
              JL1=JL1V(K)
              JL2=JL2V(K)
              DO I=IL1,IL2
                 DO J=JL2,JL1,-1
                    IF(KEYOUT(I,J,K).EQ.1.AND.KEYOUT(I,J+1,K).EQ.0) THEN
                       BDARY_WRK(I,J,K,L)=BD_VAL(LOFF+(K-1)*IDIM+I)
                       GO TO 14
                    ENDIF
                 ENDDO
  14             CONTINUE
              ENDDO
           ENDDO
         ENDIF
      ENDDO
      GO TO 20

C COPY - Z SIDE BOUNDARY VALUE TO BDARY_WRK

   5  NBP = IDIM*JDIM
      DO L=1,3
         LOFF=(L-1)*NBP
         IF(ITYPE_BOUNDARY(5,L,NBLK).EQ.4) THEN
cbw           DO J=1,JDIM
           DO J=1+$LAYERY,JDIM-$LAYERY
              DO I=IL1,IL2
                 DO K=KL1,KL2
                    IF(KEYOUT(I,J,K).EQ.1.AND.KEYOUT(I,J,K-1).EQ.0) THEN
                       BDARY_WRK(I,J,K,L)=BD_VAL(LOFF+(J-1)*IDIM+I)
                       GO TO 15
                    ENDIF
                 ENDDO
  15             CONTINUE
              ENDDO
           ENDDO
        ENDIF
      ENDDO
      GO TO 20
 
C COPY + Z SIDE BOUNDARY VALUE TO BDARY_WRK

   6  NBP = IDIM*JDIM
      DO L=1,3
         LOFF=(L-1)*NBP
         IF(ITYPE_BOUNDARY(6,L,NBLK).EQ.4) THEN
cbw           DO J=1,JDIM
           DO J=1+$LAYERY,JDIM-$LAYERY
              DO I=IL1,IL2
                 DO K=KL2,KL1,-1
                    IF(KEYOUT(I,J,K).EQ.1.AND.KEYOUT(I,J,K+1).EQ.0) THEN
                       BDARY_WRK(I,J,K,L)=BD_VAL(LOFF+(J-1)*IDIM+I)
                       GO TO 16
                    ENDIF
                 ENDDO
  16             CONTINUE
              ENDDO
           ENDDO
         ENDIF
      ENDDO

  20  CONTINUE
 
      END
C**********************************************************************
      SUBROUTINE PEBDARY_WRK_BE(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &                    KL1,KL2,KEYOUT,NBLK,BDARY_WRK,BD_VAL)
C**********************************************************************
C Copy values from a 3D grid element array to 2D boundary element array
C after update
C 
C INPUT:
C   DARY_WRK(I,J,K,L) = 3D GRID ELEMENT ARRAY
C
C OUTPUT:
C   BD_VAL(*) = 2D GRID ELEMENT ARRAY
C**********************************************************************
      INCLUDE 'control.h'
      INCLUDE 'pebdary.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM), KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  BDARY_WRK(IDIM,JDIM,KDIM,3),BD_VAL(*)

      INTEGER I,J,K,L,JL1,JL2,LOC,LOFF

cbw      IF(.NOT.IBD_FACE(IFACE,NBLK)) RETURN
      IF(.NOT.DP_FACE(IFACE,NBLK)) RETURN

      GO TO (1,2,3,4,5,6) IFACE

C COPY -X SIDE BOUNDARY VALUE TO BDARY_WRK

   1  NBP = JDIM*KDIM
      DO L=1,3
         LOFF=(L-1)*NBP
         IF(ITYPE_BOUNDARY(1,L,NBLK).EQ.4) THEN  
           DO K = 1,KDIM        
              DO J = 1,JDIM         
                 DO I = IL1,IL2
                    IF(KEYOUT(I,J,K).NE.0.AND.KEYOUT(I-1,J,K).EQ.0) THEN
                       BD_VAL(LOFF+(K-1)*JDIM+J)=BDARY_WRK(I,J,K,L) 
                       GO TO 11
                    ENDIF
                 ENDDO
  11             CONTINUE
              ENDDO
           ENDDO
         ENDIF
      ENDDO
      GO TO 20

C COPY + X SIDE BOUNDARY VALUE TO BDARY_WRK

   2  NBP = JDIM*KDIM
      DO L=1,3
         LOFF=(L-1)*NBP
         IF(ITYPE_BOUNDARY(2,L,NBLK).EQ.4) THEN
           DO K = 1,KDIM         
              DO J=1,JDIM             
                 DO I=IL2,IL1,-1
                    IF(KEYOUT(I,J,K).NE.0.AND.KEYOUT(I+1,J,K).EQ.0) THEN
                       BD_VAL(LOFF+(K-1)*JDIM+J)=BDARY_WRK(I,J,K,L)
                       GO TO 12
                    ENDIF
                 ENDDO
  12             CONTINUE
              ENDDO
           ENDDO
         ENDIF
      ENDDO
      GO TO 20

C COPY - Y SIDE BOUNDARY VALUE TO BDARY_WRK

   3  NBP = IDIM*KDIM
      DO L=1,3
         LOFF=(L-1)*NBP
         IF(ITYPE_BOUNDARY(3,L,NBLK).EQ.4) THEN
           DO K=1,KDIM          
              DO I=IL1,IL2
cbw                 DO J=1,JDIM     
                 DO J=2,JDIM     
                    IF(KEYOUT(I,J,K).NE.0.AND.KEYOUT(I,J-1,K).EQ.0) THEN
                       BD_VAL(LOFF+(K-1)*IDIM+I)=BDARY_WRK(I,J,K,L)
                       GO TO 13
                    ENDIF
                 ENDDO
  13             CONTINUE
              ENDDO
           ENDDO
         ENDIF
      ENDDO
      GO TO 20

C COPY + Y SIDE BOUNDARY VALUE TO BDARY_WRK

   4  NBP = IDIM*KDIM
      DO L=1,3
         LOFF=(L-1)*NBP
         IF(ITYPE_BOUNDARY(4,L,NBLK).EQ.4) THEN
           DO K=1,KDIM                
              DO I=IL1,IL2
                 DO J=JDIM-1,1,-1
                    IF(KEYOUT(I,J,K).NE.0.AND.KEYOUT(I,J+1,K).EQ.0) THEN
                       BD_VAL(LOFF+(K-1)*IDIM+I)=BDARY_WRK(I,J,K,L)
                       GO TO 14
                    ENDIF
                 ENDDO
  14             CONTINUE
              ENDDO         
           ENDDO
         ENDIF
      ENDDO
      GO TO 20

C COPY - Z SIDE BOUNDARY VALUE TO BDARY_WRK

   5  NBP = IDIM*JDIM
      DO L=1,3
         LOFF=(L-1)*NBP
         IF(ITYPE_BOUNDARY(5,L,NBLK).EQ.4) THEN
           DO J=1,JDIM
              DO I=IL1,IL2
cbw                 DO K=1,KDIM
                 DO K=2,KDIM
                    IF(KEYOUT(I,J,K).NE.0.AND.KEYOUT(I,J,K-1).EQ.0) THEN
                       BD_VAL(LOFF+(J-1)*IDIM+I)=BDARY_WRK(I,J,K,L)
                       GO TO 15
                    ENDIF
                 ENDDO
  15             CONTINUE
              ENDDO
           ENDDO
         ENDIF
      ENDDO
      GO TO 20

C COPY + Z SIDE BOUNDARY VALUE TO BDARY_WRK

   6  NBP = IDIM*JDIM
      DO L=1,3
         LOFF=(L-1)*NBP
         IF(ITYPE_BOUNDARY(6,L,NBLK).EQ.4) THEN
           DO J=1,JDIM
              DO I=IL1,IL2
                 DO K=KDIM-1,1,-1              
                    IF(KEYOUT(I,J,K).NE.0.AND.KEYOUT(I,J,K+1).EQ.0) THEN
                       BD_VAL(LOFF+(J-1)*IDIM+I)=BDARY_WRK(I,J,K,L)
                       GO TO 16
                    ENDIF
                 ENDDO
  16             CONTINUE
              ENDDO
           ENDDO
         ENDIF
      ENDDO
  20  CONTINUE
      
      END
C*********************************************************************
      SUBROUTINE TRACTION_TOP(KERR)
C*********************************************************************
C Routine call a work routine to setup the traction boundary condition
c on the top of the reservoir
C*********************************************************************
C INPUT:
C   KERR = ERROR NUMBER STEP BY ONE
C OUTPUT
C   KERR
C*********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'blkary.h'
      INCLUDE 'pemodel.h'
      INCLUDE 'pebdary.h'
   
      INTEGER KERR
      INTEGER IWORK(3)
      EXTERNAL TRACTION_TOPW

      IF(.NOT.ISTTOP.OR.N_BDARY(1).LE.0) RETURN

      IWORK(1) = 2
      IWORK(2) = N_DEPTH
      IWORK(3) = N_BDARY(1)
      CALL CALLWORK(TRACTION_TOPW,IWORK)

      END

C*********************************************************************
      SUBROUTINE TRACTION_TOPW(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &           KL1,KL2,KEYOUT,NBLK,DEPTH,BD_VAL)
C*********************************************************************
C Setup traction boundary condition on the top of a reservoir using
C input initial stress and gradient values if STTOP is specified.
C
C INPUT:
C   DEPTH(I,J,K) = DEPTH AT THE ELEMENT CENTER (FT)
C
C OUTPUT:
C   BD_VAL(J,K)  = TRACTIONS ON THE TOP SURFACE (PSI)
C*********************************************************************
$POWER       INCLUDE 'msjunk.h'
      INCLUDE 'layout.h'
                                                                                
      INCLUDE 'pemodel.h'
      INCLUDE 'pebdary.h'
                                                                                
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),     KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  DEPTH(IDIM,JDIM,KDIM),     BD_VAL(JDIM,KDIM,3)
                                                                                
      INTEGER I,J,K,IOFF,JOFF,KOFF,KERR
      REAL*8  DH,DX
                                                                                
      IF(.NOT.ISTTOP.OR.(.NOT.IBD_FACE(1,NBLK))) RETURN
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,KERR)
                                                                                
      DO K = KL1,KL2
         JL1 = JL1V(K)
         JL2 = JL2V(K)
         DO J = JL1,JL2
            DO I = IL1,IL2
               IF(KEYOUT(I,J,K).EQ.1.AND.KEYOUT(I-1,J,K).EQ.0) THEN
                  DX = DXREC(I+IOFF,NBLK)
                  DH = DEPTH(I,J,K) - 0.5D0 * DX - STDEPTH
                  BD_VAL(J,K,1)=-STINIT(1)-DH*STGRAD(1)
                  GO TO 1
               ENDIF
            ENDDO
  1         CONTINUE
         ENDDO
      ENDDO

      END
C*********************************************************************
      SUBROUTINE TRACTION_SIDE(KERR)
C*********************************************************************
C Routine call a work routine to setup the traction boundary condition
c on the top of the reservoir
C*********************************************************************
C INPUT:
C   KERR = ERROR NUMBER STEP BY ONE
C OUTPUT
C   KERR
C*********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'pemodel.h'
      INCLUDE 'pearydat.h'
      INCLUDE 'pebdary.h'

      INTEGER KERR
      INTEGER IWORK(4)
      EXTERNAL TRACTION_SIDEW

      IF(.NOT.ISTSIDE) RETURN
      DO IBD=3,6
         IF (N_BDARY(IBD).GT.0) THEN
            IWORK(1) = 3
            IWORK(2) = N_STRYY_INIT
            IWORK(3) = N_STRZZ_INIT
            IWORK(4) = N_BDARY(IBD)
            IFACE = IBD
            CALL CALLWORK(TRACTION_SIDEW,IWORK)
         ENDIF
      ENDDO

      END
C*********************************************************************
      SUBROUTINE TRACTION_SIDEW(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &                 KL1,KL2,KEYOUT,NBLK,STRYY,STRZZ,BD_VAL)
C*********************************************************************
C Applies trcation boundary condition for 3D rectangle grid using
C the initial stresses in the y znd z directions
C
C INPUT:
C   STRYY(I,J,K) = INITIAL NORMAL STRESS IN Y DIRECTION (PSI)
C   STRZZ(I,J,K) = INITIAL NORMAL STRESS IN Z DIRECTION (PSI)
C
C OUTPUT:
C   BD_VAL(L) = TRACTION VALUE ON THE BOUNDARIES (PSI)
C*********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'layout.h'

      INCLUDE 'pemodel.h'
      INCLUDE 'pebdary.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM), KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  STRYY(IDIM,JDIM,KDIM), STRZZ(IDIM,JDIM,KDIM)
      REAL*8  BD_VAL(*)

      INTEGER I,J,K,L,JL1,JL2,LOC,LOFF,NBP

      IF(.NOT.IBD_FACE(IFACE,NBLK)) RETURN

      GO TO (20,20,3,4,5,6) IFACE
      GOTO 20 

C COPY - Y SIDE BOUNDARY VALUE TO BDARY_WRK

   3  NBP = IDIM*KDIM
      L=2
      LOFF=(L-1)*NBP
      IF(ITYPE_BOUNDARY(3,L,NBLK).EQ.4) THEN
cbw         DO K=1,KDIM
         DO K=KL1,KL2
            DO I=IL1,IL2
cbw               DO J=1,JDIM
               DO J=JL1V(K),JL2V(K)
cbw                  IF(KEYOUT(I,J,K).NE.0.AND.KEYOUT(I,J-1,K).EQ.0) THEN
                  IF(KEYOUT(I,J,K).EQ.1.AND.KEYOUT(I,J-1,K).EQ.0) THEN
                     BD_VAL(LOFF+(K-1)*IDIM+I)=-STRYY(I,J,K)
                     GO TO 13
                  ENDIF
               ENDDO
  13           CONTINUE
            ENDDO
         ENDDO
      ENDIF
      GO TO 20

C COPY + Y SIDE BOUNDARY VALUE TO BDARY_WRK

   4  NBP = IDIM*KDIM
      L=2
      LOFF=(L-1)*NBP
      IF(ITYPE_BOUNDARY(4,L,NBLK).EQ.4) THEN
cbw         DO K=1,KDIM
         DO K=KL1,KL2
            DO I=IL1,IL2
cbw               DO J=JDIM-1,1,-1
               DO J=JL2V(K),JL1V(K),-1
cbw                  IF(KEYOUT(I,J,K).NE.0.AND.KEYOUT(I,J+1,K).EQ.0) THEN
                  IF(KEYOUT(I,J,K).EQ.1.AND.KEYOUT(I,J+1,K).EQ.0) THEN
                     BD_VAL(LOFF+(K-1)*IDIM+I)=STRYY(I,J,K)
                     GO TO 14
                  ENDIF
               ENDDO
  14           CONTINUE
            ENDDO
         ENDDO
      ENDIF
      GO TO 20

C COPY - Z SIDE BOUNDARY VALUE TO BDARY_WRK

   5  NBP = IDIM*JDIM
      L=3
      LOFF=(L-1)*NBP
      IF(ITYPE_BOUNDARY(5,L,NBLK).EQ.4) THEN
cbw         DO J=1,JDIM
         DO J=1+$LAYERY,JDIM-$LAYERY
            DO I=IL1,IL2
cbw               DO K=1,KDIM
               DO K=KL1,KL2
cbw                  IF(KEYOUT(I,J,K).NE.0.AND.KEYOUT(I,J,K-1).EQ.0) THEN
                  IF(KEYOUT(I,J,K).EQ.1.AND.KEYOUT(I,J,K-1).EQ.0) THEN
                     BD_VAL(LOFF+(J-1)*IDIM+I)=-STRZZ(I,J,K)
                     GO TO 15
                  ENDIF
               ENDDO
  15           CONTINUE
            ENDDO
         ENDDO
      ENDIF
      GO TO 20

C COPY + Z SIDE BOUNDARY VALUE TO BDARY_WRK

   6  NBP = IDIM*JDIM
      L=3
      LOFF=(L-1)*NBP
      IF(ITYPE_BOUNDARY(6,L,NBLK).EQ.4) THEN
cbw         DO J=1,JDIM
         DO J=1+$LAYERY,JDIM-$LAYERY
            DO I=IL1,IL2
cbw               DO K=KDIM-1,1,-1
               DO K=KL2,KL1,-1
cbw                  IF(KEYOUT(I,J,K).NE.0.AND.KEYOUT(I,J,K+1).EQ.0) THEN
                  IF(KEYOUT(I,J,K).EQ.1.AND.KEYOUT(I,J,K+1).EQ.0) THEN
                     BD_VAL(LOFF+(J-1)*IDIM+I)=STRZZ(I,J,K)
                     GO TO 16
                  ENDIF
               ENDDO
  16           CONTINUE
            ENDDO
         ENDDO
      ENDIF
  20  CONTINUE
     
      END
C*********************************************************************
      SUBROUTINE PEGETVAL (VNAM,VAL,VTYP,NDIM1,NDIM2,NDIM3,NDIM4,
     & NUMRET,NERR)
C*********************************************************************
C  EXTRACTS GRID ELEMENT DATA ON THE BOUNDARY FACES
C  TO DIRECTLY READ MEMORY MANAGED ARRAYS

C  VNAM   = VARIABLE NAME AND OPTIONAL UNITS (INPUT, CHARACTER*$MAXUL).
C           THE NAME MUST BE TERMINATED WITH A BLANK OR THE LEFT
C           BRACKET OF A UNITS SPECFICATION.  THE NAME CAN NOT INCLUDE
C           EMBEDDED BLANKS.  UNITS, IF ANY, MUST BE ENCLOSED IN
C           BRACKETS [] AND IMMEDIATELY FOLLOW THE NAME.  BLANKS MAY BE
C           INCLUDED BETWEEN THE BRACKETS.  EXAMPLES:
C           'NX '   'P[psi]'   'HC[Btu/lb F]'

C  VAL()  = VALUE RETURNED (OUTPUT).  MAY BE DIMENSIONED OR NOT.
C   OR      TYPE IS DETERMINED BY VTYP.  IF VNAM IS NOT FOUND THEN
C  SVAL()   VAL IS NOT CHANGED.  USE ENTRY GETVALS() TO READ CHARACTER
C           STRINGS AND BLOCK TEXT.

C  VTYP   = VARIABLE TYPE (INPUT, CHARACTER*2).
C         = I2 ==> INTEGER
C         = I4 ==> INTEGER
C         = R4 ==> REAL*4
C         = R8 ==> REAL*8
C         = L2 ==> LOGICAL
C         = L4 ==> LOGICAL
C         = CS ==> CHARACTER STRING (MAX LENGTH GIVEN BY DIM4)
C         = FG ==> FLAG VARIABLE, LOGICAL
C         = BT ==> BLOCK TEXT (MAX LENGTH GIVEN BY DIM4)

C  NDIM1  = DIMENSIONS OF VAL (INPUT, INTEGER).
C  NDIM2    UNUSED DIMENSIONS ARE INDICATED BY 0
C  NDIM3    FOR CHARACTER AND BLOCK VARIABLES, NDIM4 = MAX CHARACTERS.
C  NDIM4    CHARACTER VARIABLES ARE LIMITED TO 3 SUBSCRIPTS.
C           BLOCK VARIABLES MAY NOT BE SUBSCRIPTED IF GETVAL IS CALLED
C           DIRECTLY (CALL INDIRECTLY VIA GETBLK)
C           IF THE FILL OPTION FOR ARRAYS IS NOT TO BE USED THEN SET
C           NDIM1 EQUAL TO THE NEGATIVE OF THE FIRST DIMENSION.

C  NUMRET = NUMBER OF VALUES RETURNED IN VAL() (OUTPUT, INTEGER)

C  NERR   = ERROR NUMBER STEPPED BY 1 FOR EACH DATA ERROR INCOUNTERED
C           (INPUT AND OUTPUT, INTEGER)

C*********************************************************************
      USE scrat1mod

      PARAMETER (MAXCHR=$MXREAD)

      LOGICAL LQ,ENDAT,LV,SKIPIT,IN_I,IN_J,IN_K
      INTEGER NN(3,4),MUL(4),NGLT(3),L1REP(5),L2REP(5),NREP(5),IDIR(4)
      REAL*8 R8,VAL(*)
      CHARACTER*1 BLANK,QUOTE,COMMA,LEFT,RIGHT,EQUAL,COLON,ASTR,VNAM(*),
     & TOS(2),STP(4),TRU(4),FAL(5),III,JJJ,KKK,LLL,LBRAC,RBRAC,RECEND,
     & SVAL(*)
      CHARACTER*2 TYP(9),VTYP
      CHARACTER*50 E
      CHARACTER*$MAXUL UNTSTDS

      INCLUDE 'control.h'
      INCLUDE 'readdat.h'
!      INCLUDE 'scrat1.h'
      INCLUDE 'layout.h'
      INCLUDE 'pebdary.h'

      EQUIVALENCE (UNTSTD(1),UNTSTDS)

      DATA BLANK/' '/,QUOTE/'"'/,COMMA/','/,LEFT/'('/,RIGHT/')'/,
     & EQUAL/'='/,COLON/':'/,ASTR/'*'/,TOS/'T','O'/,LBRAC/'['/,
     & STP/'S','T','E','P'/,III/'I'/,JJJ/'J'/,KKK/'K'/,LLL/'L'/,
     & RBRAC/']'/,TYP/'I2','I4','R4','R8','L2','L4','CS','FG','BT'/,
     & TRU/'T','R','U','E'/,FAL/'F','A','L','S','E'/

      ENTRY PEGETVALS (VNAM,SVAL,VTYP,NDIM1,NDIM2,NDIM3,NDIM4,NUMRET,
     & NERR)

      NUMRET=0
      ISUNT=.FALSE.
      NOTINDX=.TRUE.
      UNTSTDS=' '
      LBLK=1

C  GET LENGTH OF VARIABLE NAME AND STANDARD UNITS, IF ANY

      DO 1 I=1,$MAXUL
      IF (VNAM(I).EQ.BLANK) GO TO 2
      IF (VNAM(I).EQ.LBRAC) THEN
         DO 42 J=1,$MAXUL
         UNTSTD(J)=VNAM(I+J)
         IF (UNTSTD(J).EQ.RBRAC) GO TO 2
 42      CONTINUE
         GO TO 2
      ENDIF
    1 NAML=I
    2 L1=1

C  FIND VARIABLE NAME

   97 LQ=.TRUE.
      LL=LAST-NAML+1
      DO 3 I=L1,LL
      IF (A(I).EQ.QUOTE) LQ=.NOT.LQ
      IF ((A(I).EQ.COLON).AND.LQ) THEN
         DO 4 J=1,NAML
         IF (A(I+J).NE.VNAM(J)) GO TO 3
    4    CONTINUE
         J=I+NAML+1
         IF (A(J).EQ.BLANK.OR.A(J).EQ.EQUAL.OR.A(J).EQ.LEFT.OR.
     &      A(J).EQ.COLON) THEN
            LV1=I
            L=I+NAML+1
            GO TO 5
         ENDIF
      ENDIF
    3 CONTINUE
C  EXIT IF VARIABLE NAME NOT FOUND

      ISUNTD=.FALSE.
      RETURN

C  SET VARIABLE TYPE CODE

    5 DO 6 I=1,9
      IF (VTYP.EQ.TYP(I)) THEN
         KVAR=I
         GO TO 7
      ENDIF
    6 CONTINUE
      LEVERR=2
      IF (LEVELC) WRITE(NFOUT,36) VTYP,(VNAM(I),I=1,NAML)
   36 FORMAT(' ERROR 121, PROGRAM ERROR: TYPE ',A2,' FOR VARIABLE ',
     & 20A1)
      NERR=NERR+1
      L=LV1+1
      GO TO 95

C  SET DEFAULT INDEX RANGES

    7 DO 40 I=1,4
      NN(1,I)=1
   40 NN(3,I)=1
      ND1A=MAX(IABS(NDIM1),1)
      ND2A=MAX(NDIM2,1)
      ND3A=MAX(NDIM3,1)
      ND4A=MAX(NDIM4,1)

C SET DIMENSIONS FOR BOUNDARY ELEMENT INPUT

      IF (KVAR.EQ.9) ND4A=1
      NN(2,1)=ND1A
      NN(2,2)=ND2A
      NN(2,3)=ND3A
      NN(2,4)=ND4A
      IF (KVAR.EQ.7) NN(2,4)=1
      I1=1
      I2=2
      I3=3
      I4=4
      MUL(1)=1
      IF (NBLKG.GT.0) THEN
         NGLT(1)=IGLT+1
         NGLT(2)=JGLT+1
         NGLT(3)=KGLT+1
         MUL(2)=IDIML
         MUL(3)=IDIML*JDIML
         MUL(4)=IDIML*JDIML*KDIML
         IF(IFACE.GT.0) THEN
            IF(IFACE.EQ.1.OR.IFACE.EQ.2) THEN
               MUL(1)=0
               I1=2
               I2=3
               I3=1
            ENDIF
            IF(IFACE.EQ.3.OR.IFACE.EQ.4) THEN
               MUL(2)=0
               I1=1
               I2=3
               I3=2
            ENDIF
            IF(IFACE.EQ.5.OR.IFACE.EQ.6) MUL(3)=0
         ENDIF
      ELSE
         MUL(2)=ND1A
         MUL(3)=ND1A*ND2A
         MUL(4)=ND1A*ND2A*ND3A
      ENDIF

C  TEST FOR SCALAR VARIABLE

      IF (NDIM1.EQ.0.AND.NDIM2.EQ.0.AND.NDIM3.EQ.0.AND.
     & NN(2,4).EQ.1) THEN
         IF (A(L).EQ.LEFT.OR.A(L+1).EQ.LEFT) THEN
            E='SUBSCRIPT ON A SCALAR VARIABLE'
            NER=118
            GO TO 90
         ENDIF
         GO TO 15
      ENDIF
C  PARSE ARRAY INDEXES

C  GET (
      IF (A(L).EQ.BLANK) L=L+1
      IF (A(L).NE.LEFT) GO TO 13
      L=L+1
C  LOOK FOR INDEX SEQUENCE CHARACTERS
      IF (A(L).EQ.BLANK) L=L+1
      IF (A(L).LT.III.OR.A(L).GT.LLL) GO TO 50
      IF (A(L).EQ.JJJ) I1=2
      IF (A(L).EQ.KKK) I1=3
      IF (A(L).EQ.LLL) I1=4
      L=L+1
      IF (A(L).EQ.BLANK) L=L+1
      IF (A(L).LT.III.OR.A(L).GT.LLL) GO TO 50
      IF (A(L).EQ.III) I2=1
      IF (A(L).EQ.KKK) I2=3
      IF (A(L).EQ.LLL) I2=4
      IF (IFACE.GT.0) GO TO 50
      L=L+1
      IF (A(L).EQ.BLANK) L=L+1
      IF (A(L).LT.III.OR.A(L).GT.LLL) GO TO 50
      IF (A(L).EQ.III) I3=1
      IF (A(L).EQ.JJJ) I3=2
      IF (A(L).EQ.LLL) I3=4
      L=L+1
      IF (A(L).EQ.BLANK) L=L+1
      IF (A(L).LT.III.OR.A(L).GT.LLL) GO TO 50
      IF (A(L).EQ.III) I4=1
      IF (A(L).EQ.JJJ) I4=2
      IF (A(L).EQ.KKK) I4=3
      L=L+1
   50 IF (I1.EQ.I2.OR.I1.EQ.I3.OR.I1.EQ.I4.OR.I2.EQ.I3.OR.I2.EQ.I4
     & .OR.I3.EQ.I4) THEN
         E='INVALID INDEX SEQUENCE'
         NER=117
         GO TO 90
      ENDIF
C  LOOP OVER THE INDEXES
      IDIR(1)=I1
      IDIR(2)=I2
      IDIR(3)=I3
      IDIR(4)=I4
      NDMAX=4
      IF (KVAR.EQ.7) NDMAX=3
      IF (KVAR.EQ.9) NDMAX=1
      IF (NBLAKG.GT.0.AND.IFACE.GT.0) NDMAX=2
      DO 16 I=1,NDMAX
      II=IDIR(I)
      IDUM=NN(2,II)
C  GET LOWER INDEX
      IF (A(L).EQ.BLANK) L=L+1
      IF (A(L).EQ.COMMA) GO TO 16
      NOTINDX=.FALSE.
      CALL GETNUM(R8,KEY,L,LL)
      NOTINDX=.TRUE.
      IF (KEY.EQ.0) THEN
         L=LL
         NN(1,II)=R8+1.0D-2
         IF (NN(1,II).LT.1.OR.NN(1,II).GT.IDUM) GO TO 41
         NN(2,II)=R8+1.0D-2
      ENDIF
C  CHECK FOR , OR )
      IF (A(L).EQ.BLANK) L=L+1
      IF (A(L).EQ.COMMA) GO TO 16
      IF (A(L).EQ.RIGHT) GO TO 14
C  GET TO
      IF (A(L).NE.TOS(1).OR.A(L+1).NE.TOS(2)) GO TO 13
      L=L+2
C  GET UPPER INDEX
      NN(2,II)=IDUM
      NOTINDX=.FALSE.
      CALL GETNUM(R8,KEY,L,LL)
      NOTINDX=.TRUE.
      IF (KEY.EQ.0) THEN
         L=LL
         NN(2,II)=R8+1.0D-2
         IF (NN(2,II).LT.1.OR.NN(2,II).GT.IDUM) GO TO 41
      ENDIF
C  CHECK FOR , OR )
      IF (A(L).EQ.BLANK) L=L+1
      IF (A(L).EQ.COMMA) GO TO 16
      IF (A(L).EQ.RIGHT) GO TO 14
C  GET STEP
      IF (A(L).NE.STP(1).OR.A(L+1).NE.STP(2).OR.A(L+2).NE.STP(3).OR.
     &   A(L+3).NE.STP(4)) GO TO 13
      L=L+4
C  GET STEP SIZE
      NOTINDX=.FALSE.
      CALL GETNUM(R8,KEY,L,LL)
      NOTINDX=.TRUE.
      IF (KEY.EQ.0) THEN
         L=LL-1
         NN(3,II)=R8+1.0D-2
      ELSE
         GO TO 13
      ENDIF
C  END OF INDEX LOOP
   16 L=L+1
C  GET )
      IF (A(L).EQ.BLANK) L=L+1
   14 IF (A(L).EQ.RIGHT) THEN
        L=L+1
        GO TO 11
      ENDIF
   13 E='INVALID ARRAY SYNTAX'
      NER=103
      GO TO 90
C  CHECK VALID INDEX RANGE(S)
   11 DO 35 I=1,NDMAX
      IF (NN(3,I)*(NN(2,I)-NN(1,I)).LT.0) GO TO 41
   35 CONTINUE
      GO TO 15
   41 E='INVALID SUBSCRIPT RANGE'
      NER=112
      GO TO 90

C  GET BLANK AND/OR = AFTER VARIABLE NAME AND SUBSCRIPTS

   15 IF (A(L).NE.BLANK.AND.A(L).NE.EQUAL) THEN
         IF (KVAR.NE.8) THEN
            E='BLANK OR EQUAL DOES NOT FOLLOW VARIABLE NAME'
            NER=104
            GO TO 90
         ENDIF
      ELSE
         L=L+1
      ENDIF
      IF (A(L).EQ.EQUAL) L=L+1
      IF (A(L).EQ.BLANK) L=L+1

C  START DATA LOOP

      NUMREP=0
      ENDAT=.FALSE.
      LFILL=0
      NETPRN=0
      NRETR=0
      NBLK=0

C RESET LOOP INDICES FOR BOUNDARY ELEMENT INPUT
      IF(NBLKG.GT.0.AND.IFACE.GT.0) THEN
         IF(IFACE.EQ.1) THEN
            NN(1,1)=BDARYIJK(1,1,NBLKG)
            NN(2,1)=NN(1,1)
         ELSE IF(IFACE.EQ.2) THEN
            NN(2,1)=BDARYIJK(2,1,NBLKG)
            NN(1,1)=NN(2,1)
         ELSE IF(IFACE.EQ.3) THEN
            NN(1,2)=BDARYIJK(1,2,NBLKG)
            NN(2,2)=NN(1,2)
         ELSE IF(IFACE.EQ.4) THEN
            NN(2,2)=BDARYIJK(2,2,NBLKG)
            NN(1,2)=NN(2,2)
         ELSE IF(IFACE.EQ.5) THEN
            NN(1,3)=BDARYIJK(1,3,NBLKG)
            NN(2,3)=NN(1,3)
         ELSE IF(IFACE.EQ.6) THEN
            NN(2,3)=BDARYIJK(2,3,NBLKG)
            NN(1,3)=NN(2,3)
         ENDIF
      ENDIF
      I1_BD=BDARYIJK(1,I1,NBLKG)
      I2_BD=BDARYIJK(2,I1,NBLKG)
      J1_BD=BDARYIJK(1,I2,NBLKG)
      J2_BD=BDARYIJK(2,I2,NBLKG)
      K1_BD=BDARYIJK(1,I3,NBLKG)
      K2_BD=BDARYIJK(2,I3,NBLKG)
      DO 20 ND4=NN(1,I4),NN(2,I4),NN(3,I4)
      DO 20 ND3=NN(1,I3),NN(2,I3),NN(3,I3)
      DO 20 ND2=NN(1,I2),NN(2,I2),NN(3,I2)
      DO 20 ND1=NN(1,I1),NN(2,I1),NN(3,I1)
      SKIPIT=.FALSE.
      IF (NBLKG.GT.0) THEN
         IF (I2.EQ.2) THEN
            MAPA=ND2
         ELSE
            IF (I1.EQ.2) THEN
               MAPA=ND1
            ELSE
               IF (I3.EQ.2) THEN
                  MAPA=ND3
               ELSE
                  MAPA=ND4
               ENDIF
            ENDIF
         ENDIF
         IF (I3.EQ.3) THEN
            MAPA=MAPA+N0MAP(NBLKG)+ND3*NYMAP(NBLKG)
         ELSE
            IF (I1.EQ.3) THEN
               MAPA=MAPA+N0MAP(NBLKG)+ND1*NYMAP(NBLKG)
            ELSE
               IF (I2.EQ.3) THEN
                  MAPA=MAPA+N0MAP(NBLKG)+ND2*NYMAP(NBLKG)
               ELSE
                  MAPA=MAPA+N0MAP(NBLKG)+ND4*NYMAP(NBLKG)
               ENDIF
            ENDIF
         ENDIF
         IF (PRCMAP(MAPA).EQ.MYPRC) THEN
            LOC=MUL(I1)*(ND1-NGLT(I1))+MUL(I2)*(ND2-NGLT(I2))
     &         +MUL(I3)*(ND3-NGLT(I3))+MUL(I4)*(ND4-1)+1

         ELSE IF (IFACE.GT.0.AND.PRCMAP(MAPA).EQ.-2) THEN
            IN_I=.FALSE.
            IN_J=.FALSE.
            IN_K=.FALSE.
            IF(ND1.GE.I1_BD.AND.ND1.LE.I2_BD)
     &         IN_I=.TRUE.
            IF(ND2.GE.J1_BD.AND.ND2.LE.J2_BD)
     &         IN_J=.TRUE.
            IF(ND3.GE.K1_BD.AND.ND3.LE.K2_BD)
     &         IN_K=.TRUE.
            IF(IN_I.AND.IN_J.AND.IN_K) THEN
               LOC=MUL(I1)*(ND1-NGLT(I1))+MUL(I2)*(ND2-NGLT(I2))
     &         +MUL(I3)*(ND3-NGLT(I3))+MUL(I4)*(ND4-1)+1
            ELSE
               SKIPIT=.TRUE.
            ENDIF
         ELSE
            SKIPIT=.TRUE.
         ENDIF
      ELSE
         LOC=MUL(I1)*(ND1-1)+MUL(I2)*(ND2-1)+MUL(I3)*(ND3-1)
     &      +MUL(I4)*(ND4-1)+1
      ENDIF
C  PROCESS FLAG VARIABLES
      IF (KVAR.EQ.8) THEN
         CALL PUTL4(.TRUE.,LOC,VAL)
         GO TO 20
      ENDIF

C  PROCESS BLOCK TEXT INPUT

      IF (KVAR.EQ.9) THEN
         IF (NBLK.EQ.0) THEN
            L=L+6
            CALL PUTBT(A(L),SVAL,NDIM4,LBLK,NUMRET9,KERR)
            NBLK=1
            LBLKO=LBLK
            LBLK=LBLK+NUMRET9
            IF (KERR.NE.0) THEN
               E='MAX TEXT BLOCK LENGTH EXCEEDED'
               NER=120
               GO TO 90
            ENDIF
            L=L+NUMRET9
         ENDIF
         LENBLK(ND1)=NUMRET9
         LOCBLK(ND1)=LBLKO
         GO TO 20
      ENDIF

C  CHECK FOR END OF A REPEAT SEQUENCE

   23 IF (NUMREP.GT.0) THEN
         IF (L.GE.L2REP(NUMREP)) THEN
            IF (NUMRET.EQ.NRETR) THEN
               E='NO DATA FOR REPEAT FACTOR'
               NER=115
               GO TO 90
            ENDIF
            IF (NREP(NUMREP).GT.1) THEN
               NREP(NUMREP)=NREP(NUMREP)-1
               L=L1REP(NUMREP)
               IF (A(L).EQ.LEFT) THEN
                  L=L+1
                  NETPRN=NETPRN+1
               ENDIF
            ELSE
               NUMREP=NUMREP-1
               IF (A(L).EQ.RIGHT) THEN
                  IF (NETPRN.LE.0) THEN
                     E='RIGHT PARENTHESIS NOT EXPECTED'
                     NER=108
                     GO TO 90
                  ENDIF
                  L=L+1
                  NETPRN=NETPRN-1
               ENDIF
               GO TO 23
            ENDIF
         ENDIF
      ENDIF

C  LOOK FOR A NUMBER

      CALL GETNUM(R8,KEY,L,LL)
      IF (KEY.EQ.0) GO TO 21

C  NUMBER NOT FOUND.  MAY BE END OF VARIABLE DATA, CHARACTER VARIABLE,
C  LOGICAL VARIABLE, OR ERROR

      IF (KEY.NE.1) GO TO 98
   45 IF (A(L).EQ.BLANK.OR.A(L).EQ.COMMA) THEN
         L=L+1
         GO TO 45
      ENDIF
      IF (A(L).EQ.COLON) GO TO 22
      IF (A(L).EQ.QUOTE) THEN
         IF (KVAR.EQ.7) GO TO 24
         E='QUOTE ENCOUNTERED, NUMBER EXPECTED'
         NER=107
         GO TO 90
      ENDIF
      IF (KVAR.EQ.5.OR.KVAR.EQ.6) THEN
         IF (NUMREP.EQ.0) LFILL=L
         DO 31 I=1,4
         IF (A(L+I-1).NE.TRU(I)) GO TO 32
   31    CONTINUE
         LV=.TRUE.
         L=L+4
         GO TO 27
   32    DO 33 I=1,5
         IF (A(L+I-1).NE.FAL(I)) GO TO 34
   33    CONTINUE
         LV=.FALSE.
         L=L+5
         GO TO 27
      ENDIF
   34 E='DATA SYNTAX ERROR'
      NER=109
      GO TO 90

C  NUMBER FOUND, MAY BE REPEAT FACTOR, DATA, OR ERROR

   21 IF (NUMREP.EQ.0) LFILL=L
      L=LL
      IF (A(L).EQ.BLANK) L=L+1
      IF (A(L).EQ.ASTR) GO TO 26
      IF (KVAR.LT.5) GO TO 28
      E='UNEXPECTED NUMBER ENCOUNTERED'
      NER=110
      GO TO 90

C  END OF VARIABLE DATA FOUND

   22 IF (LFILL.EQ.0) THEN
         E='EXPECTED DATA NOT FOUND'
         NER=111
         GO TO 90
      ENDIF
      IF (NDIM1.LT.0) GO TO 95
      L=LFILL
      GO TO 23

C  QUOTE FOUND AND EXPECTED

   24 IF (NUMREP.EQ.0) LFILL=L
      LOC=(LOC-1)*ND4A+1
      CALL PUTCS(A,L,ND4A,SVAL,LOC,L,NER)
      L=L+1
      IF (NER.EQ.0) GO TO 20
      E='CHARACTER STRING IS TOO LONG'
      NER=113
      GO TO 90

C  REPEAT FACTOR FOUND

   26 IF (NUMREP.GT.4) THEN
         E='MORE THAN 5 REPEAT FACTORS NESTED'
         NER=112
         GO TO 90
      ENDIF
      NRETR=NUMRET
      NUMREP=NUMREP+1
      NREP(NUMREP)=R8+1.0D-2
      L=L+1
      IF (A(L).EQ.BLANK) L=L+1
      IF (A(L).EQ.LEFT) THEN
         L1REP(NUMREP)=L
         NETPRN=NETPRN+1
         L=L+1
         LQ=.TRUE.
         NET=1
         DO 29 I=L,LAST
         IF (A(I).EQ.QUOTE) LQ=.NOT.LQ
         IF (LQ) THEN
            IF (A(I).EQ.RIGHT) THEN
               NET=NET-1
               IF (NET.EQ.0) THEN
                  L2REP(NUMREP)=I
                  GO TO 23
               ENDIF
            ENDIF
            IF (A(I).EQ.LEFT) NET=NET+1
            IF (A(I).EQ.COLON) GO TO 30
         ENDIF
   29    CONTINUE
   30    E='RIGHT PARENTHESES FOR REPEAT FACTOR NOT FOUND'
         NER=105
         GO TO 90
      ENDIF
      IF (A(L).EQ.COLON) THEN
         E='NO DATA AFTER REPEAT FACTOR'
         NER=114
         GO TO 90
      ENDIF
      L1REP(NUMREP)=L
      L2REP(NUMREP)=L+1
      GO TO 23

C  LOGICAL VARIABLE FOUND AND EXPECTED

   27 IF (SKIPIT) GO TO 20
      IF (KVAR.EQ.5) THEN
         CALL PUTL2(LV,LOC,VAL)
      ELSE
         CALL PUTL4(LV,LOC,VAL)
      ENDIF
      GO TO 20

C  NUMERIC DATA FOUND AND EXPECTED

   28 IF (SKIPIT) GO TO 20
      IF (KVAR.EQ.1) CALL PUTI2(R8,LOC,VAL)
      IF (KVAR.EQ.2) CALL PUTI4(R8,LOC,VAL)
      IF (KVAR.EQ.3) CALL PUTR4(R8,LOC,VAL)
      IF (KVAR.EQ.4) VAL(LOC)=R8

C  END OF DATA LOOP

   20 NUMRET=NUMRET+1

C  SET CORRECT SIZE FOR A SINGLE BLOCK READ BY GETVAL

      IF (KVAR.EQ.9) NUMRET=NUMRET9

C  CHECK FOR EXCESS DATA

   38 IF (A(L).EQ.BLANK.OR.A(L).EQ.COMMA.OR.A(L).EQ.RIGHT) THEN
         L=L+1
         GO TO 38
      ENDIF
      IF (A(L).EQ.COLON.OR.NUMREP.GT.0) GO TO 95
      E='EXCESS DATA ENCOUNTERED'
      NER=106

C  OUTPUT ERROR MESSAGE

   90 IF (L-LV1.GT.65) THEN
         NS=L-65
      ELSE
         NS=LV1+1
      ENDIF
      K=NS+75
      IF (K.GT.LAST) K=LAST
      M=L-NS
      RECEND=CHAR(30)
      DO 91 I=L,K
      IF (A(I).EQ.COLON.OR.A(I).EQ.RECEND) GO TO 92
   91 M=M+1
   92 CALL PUTERR(NER,E,A(NS),M,L-NS+1)
   98 NERR=NERR+1

C  ERASE ENTRY AND GO BACK TO LOOK FOR ANOTHER ENTRY

   95 LQ=.TRUE.
      L1=L
      LV1=LV1+1
      DO 96 I=LV1,LAST
      IF (A(I).EQ.QUOTE) LQ=.NOT.LQ
      IF ((A(I).EQ.COLON).AND.LQ) GO TO 97
      A(I)=BLANK
   96 CONTINUE
      ISUNTD=.FALSE.
      RETURN
      END

C**********************************************************************
C                    END OF PEBDARY.DF
C**********************************************************************




C**********************************************************************
      SUBROUTINE PEDISP_FACES(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &           KL1,KL2,KEYOUT,NBLK)
C**********************************************************************
C Determine whether a processor owns a boundary face or not
C
C OUTPUT:
C   DP_FACE(NDIR,NBLK) = INDICATOR OF A EXISTING BOUNDARY FACE
C                       = .TRUE.  INDICATES A BOUNDARY
C                       = .FALSE. NO BOUNDARY IN THE CURRENT PROCESSOR   
C**********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'readdat.h'
      INCLUDE 'pebdary.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      INTEGER IDIMG,JDIMG,KDIMG,IOFF,JOFF,KOFF,NERR,I,J,K,J1,J2


C X- SIDE

      DO K=KL1-1,KL2+1
         DO J=1,JDIM          
            DO I=IL1,IL2
               IF (KEYOUT(I,J,K).NE.0.AND.KEYOUT(I-1,J,K).EQ.0) THEN
                  DP_FACE(1,NBLK)=.TRUE.
                  GO TO 1
               ENDIF
            ENDDO
         ENDDO
      ENDDO
   1  CONTINUE

C X+ SIDE

      DO K=KL1-1,KL2+1
         DO J=1,JDIM
            DO I=IL2,IL1,-1
               IF (KEYOUT(I,J,K).NE.0.AND.KEYOUT(I+1,J,K).EQ.0) THEN
                  DP_FACE(2,NBLK)=.TRUE.
                  GO TO 2
               ENDIF
            ENDDO
         ENDDO
      ENDDO
   2  CONTINUE

C Y- SIDE
      DO K=KL1-1,KL2+1
         DO I=IL1,IL2
            DO J=2,JDIM
               IF (KEYOUT(I,J,K).NE.0.AND.KEYOUT(I,J-1,K).EQ.0) THEN
                  DP_FACE(3,NBLK)=.TRUE.
                  GO TO 3
               ENDIF
            ENDDO
         ENDDO
      ENDDO
   3  CONTINUE

C Y+ SIDE

      DO K=KL1-1,KL2+1
         DO I=IL1,IL2
            DO J=JDIM-1,1,-1
               IF (KEYOUT(I,J,K).NE.0.AND.KEYOUT(I,J+1,K).EQ.0) THEN
                  DP_FACE(4,NBLK)=.TRUE. 
                  GO TO 4 
               ENDIF
            ENDDO
         ENDDO
      ENDDO
   4  CONTINUE

C Z- SIDE

      DO J=1,JDIM
         DO I=IL1,IL2
            DO K=KL1-1,KL2+2
               IF(KEYOUT(I,J,K).NE.0.AND.KEYOUT(I,J,K-1).EQ.0) THEN
                  DP_FACE(5,NBLK)=.TRUE.
                  GO TO 5
               ENDIF
            ENDDO
         ENDDO
      ENDDO
   5  CONTINUE

C Z+ SIDE

      DO J=1,JDIM
         DO I=IL1,IL2
            DO K=KL2+1,KL1-2,-1
               IF(KEYOUT(I,J,K).NE.0.AND.KEYOUT(I,J,K+1).EQ.0) THEN
                  DP_FACE(6,NBLK)=.TRUE.
               GO TO 6 
               ENDIF
            ENDDO
         ENDDO
      ENDDO
   6  CONTINUE

      END





C***********************************************************************
      SUBROUTINE PEBDARY_DP(VNAM,N_ARY,KARY,NFACE,NDIR,NTYP,
     &           NUMRET,NERR)
C***********************************************************************
C Poroelastic model displacement boundary condition input 
C
C VNAM = CHARACTER STRING TO BE READ IN THE INPUT FILE
C        (INPUT, CHARACTER*$MAXUL)
C
C N_ARY = BOUNDARY ELEMENT ARRAY NUMBER (INPUT,INTEGER)
C
C KARY = ARRAY KEY (INPUT,INTEGER)
C      = 1 ==> BLOCK CENTER ARRAY
C      = 2 ==> BLOCK CORNER ARRAY
C
C NFACE = BOUNDARY FACE NUMBER TO BE READ (INPUT,INTEGER)
C       = 1 ==> -X SIDE
C       = 2 ==> +X SIDE
C       = 3 ==> -Y SIDE
C       = 4 ==> +Y SIDE
C       = 5 ==> -Z SIDE
C       = 6 ==> +Z SIDE
C
C NDIR = DIRECTION NUMBER ON A BOUNDARY FACE (INPUT,INTEGER)
C       = 1 ==> X DIRECTION
C       = 2 ==> Y DIRECTION
C       = 3 ==> Z DIRECTION
C
C NTYP = BOUNDARY CONDITION TYPE
C       = 1 ==> ZERO DISPLACEMENT
C       = 2 ==> USER SPECIFIED DISPLACEMENT
C       = 3 ==> ZERO TRACTION
C       = 4 ==> TRACTION       
C
C NUMRET = NUMBER OF VALUES READ TO THE ARRAY (OUTPUT, INTEGER)
C
C NERR = ERROR NUMBER STEPPED BY 1 FOR EACH DATA ERROR INCOUNTERED
C        (INPUT AND OUTPUT, INTEGER)
C **********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'readdat.h'
      INCLUDE 'pebdary.h'

      PARAMETER (MAXCHR=$MXREAD)
      CHARACTER*1 VNAM(*)
      INTEGER N_ARY,KARY,NFACE,NDIR,NTYP,NUMRET,NERR

      INTEGER  I,J,KA(2),NMOD,NDIM4,KERR
      EXTERNAL PEBDARY_DPWR8
cbw
      INTEGER PEMOD
cbw

      IF(N_ARY.EQ.0) RETURN 
cbw      CALL ARYTYPE(N_ARY,NTYPGA,NDIM4,KERR)     
      CALL ARYTYPE(N_ARY,NTYPGA,NDIM4,PEMOD,KERR)     
      IF(KERR.GT.0) THEN
         NERR=NERR+1
         RETURN
      ENDIF
      J=0
      DO I=1,$MAXUL
         VNAMGA(I)=VNAM(I)
         IF (VNAMGA(I).EQ.']'.OR.(VNAMGA(I).EQ.' '.AND.J.EQ.0)) GO TO 2
         IF (VNAMGA(I).EQ.'[') J=1
      ENDDO

   2  NUMRGA=0
      KERRGA=0
      KNDARY=KARY
      IFACE=NFACE
      IBD_DIR=NDIR
      IBD_TYPE=NTYP

      KA(1)=2
      KA(2)=N_ARY
      CALL ALLBLOCKS()
      IF (NTYPGA.NE.2) THEN
         NERR=NERR+1
         IF (LEVELC) WRITE(NFOUT,3)
         RETURN
      ELSE
         CALL CALLWORK(PEBDARY_DPWR8,KA)
      ENDIF
      NUMRET=NUMRGA
      NERR=NERR+KERRGA
     
   3  FORMAT('/ERR(PE100): ONLY REAL*8 TYPE OF BOUNDARY DATA ALLOWED')
      END



C**********************************************************************
      SUBROUTINE PEBDARY_DPWR8(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &           KL1,KL2,KEYOUT,NBLKA,BD_VAL)
C**********************************************************************
C Poroelastic model displacement boundary condition input
C
C OUTPUT: 
C   BD_VAL(J) = DISPLACEMENT VALUES ON A BOUNDARY FACE
C**********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'readdat.h'
      INCLUDE 'pebdary.h'

      PARAMETER (NVN=$MAXUL+4)
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLKA
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  BD_VAL(*)

      INTEGER I,J,L,KERR,ILOC
      CHARACTER*1 VNAMC(NVN)
      CHARACTER*2 VTYP(6)
      DATA VTYP/'R4','R8','I2','I4','L2','L4'/

      IF (.NOT.IBD_FACE(IFACE,NBLKA)) RETURN
      IF (IFACE.LE.0.OR.IFACE.GT.6) THEN
         KERRGA=KERRGA+1
         RETURN
      ENDIF
      IF (IBD_DIR.LE.0.OR.IBD_DIR.GT.3) THEN
         KERRGA=KERRGA+1
         RETURN
      ENDIF

C BUILD VARIABLE NAME FOR A SPECIFIC GRID BLOCK

      CALL SETVNAM(VNAMGA,VNAMC,NBLKA)
 
C GET GRID BLOCK GLOBAL DIMENSIONS

   4  CALL BLKDIM(NBLKA,IDIMG,JDIMG,KDIMG,KERR)
      IF(KERR.NE.0) THEN
         KERRGA=KERRGA+1
         RETURN
      ENDIF

      IF (KNDARY.EQ.2) THEN
         IDIMG=IDIMG+1
         JDIMG=JDIMG+1
         KDIMG=KDIMG+1
      ENDIF

C PUT LOCAL-GLOBAL OFFSETS AND LOCAL DIMENSIONS IN /READAT/

      CALL BLKOFF(NBLKA,IGLT,JGLT,KGLT,NERR)
      IDIML=IDIM
      JDIML=JDIM
      KDIML=KDIM
      IF (IFACE.EQ.1.OR.IFACE.EQ.2) THEN
         IDIMG=1
         IDIML=1
         ILOC=(IBD_DIR-1)*4*JDIM*KDIM+1
      ELSE IF(IFACE.EQ.3.OR.IFACE.EQ.4) THEN
         JDIMG=1
         JDIML=1
         ILOC=(IBD_DIR-1)*4*IDIM*KDIM+1
      ELSE
         KDIMG=1
         KDIML=1
         ILOC=(IBD_DIR-1)*4*IDIM*JDIM+1
      ENDIF

C GET DATA FOR THE BOUNDARY ELEMENTS

      KERR=0
      NBLKG=NBLKA
      CALL PEGETVAL (VNAMC,BD_VAL(ILOC),VTYP(NTYPGA),IDIMG,JDIMG,KDIMG,
     &     4,N,KERR)
      NUMRGA=NUMRGA+N
      IF(KERR.NE.0) THEN
         KERRGA=KERRGA+1
         RETURN
      ENDIF
      IF(NUMRGA.GT.0) ITYPE_BOUNDARY(IFACE,IBD_DIR,NBLKA) = IBD_TYPE

      NBLKG=0
      IFACE=0

      END
