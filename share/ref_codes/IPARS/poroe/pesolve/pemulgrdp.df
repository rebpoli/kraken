C PEMULGRDP.F - MULTIPROCESSOR ROUTINES FOR MULTIGRID PRECONDITIONER

C ROUTINE IN THIS MODULE:
C     SUBROUTINE PEMGP_COMMI(NERR)
C     SUBROUTINE PEMGP_COMMIE(N0MAPMG,PRCMAPMG,NERR)
C     SUBROUTINE PEMGP_EXMLST()
C     SUBROUTINE PEMGP_EXMLSTE()
C     SUBROUTINE PEMGWP_DISPUPD(MGLV,NBLK,IDMG,JDMG,KDMG,IMG1,IMG2,
C                    JMG1,JMG2,KMG1,KMG2,DXMG,DYMG,DZMG,KEYMG,KEYCRMG,
C                    EZNMG,EMDMG,EPSMG,EBMG,EDMG,ERMG,EUNKMG)
C     SUBROUTINE PEMGWP_ZNODUPD(MGLV,NBLK,IDMG,JDMG,KDMG,IMG1,IMG2,
C                    JMG1,JMG2,KMG1,KMG2,DXMG,DYMG,DZMG,KEYMG,
C                    KEYCRMG,EZNMG,EMDMG,EPSMG,EBMG,EDMG,ERMG,EUNKMG)
C     SUBROUTINE PEMGWP_COFUPDE(MGLV,NBLK,IDMG,JDMG,KDMG,IMG1,IMG2,
C                    JMG1,JMG2,KMG1,KMG2,DXMG,DYMG,DZMG,KEYMG,KEYCRMG,
C                    EZNMG,EMDMG,EPSMG,EBMG,EDMG,ERMG,EUNKMG)
C     SUBROUTINE PEMGWP_COFUPDG(MGLV,NBLK,IDMG,JDMG,KDMG,IMG1,IMG2,
C                    JMG1,JMG2,KMG1,KMG2,DXMG,DYMG,DZMG,KEYMG,KEYCRMG,
C                    EZNMG,EMDMG,EPSMG,EBMG,EDMG,ERMG,EUNKMG)
C     SUBROUTINE PEMGWP_COFUPDG0(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,
C                    JL2V,KL1,KL2,KEYOUT,NBLK,KEYCR2D,BCOF2D,DCOF2D,
C                    R2D,X2D)
C     SUBROUTINE PEMGWP_DISPUPD0(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,
C                    JL2V,KL1,KL2,KEYOUT,NBLK,KEYCR2D,BCOF2D,DCOF2D,
C                    R2D,X2D)
C     SUBROUTINE PEMGWP_RESUPDE(MGLV,NBLK,IDMG,JDMG,KDMG,IMG1,IMG2,
C                    JMG1,JMG2,KMG1,KMG2,DXMG,DYMG,DZMG,KEYMG,KEYCRMG,
C                    EZNMG,EMDMG,EPSMG,EBMG,EDMG,ERMG,EUNKMG)
C     SUBROUTINE PEMGWP_DISPUPDE(MGLV,NBLK,IDMG,JDMG,KDMG,IMG1,IMG2,
C                    JMG1,JMG2,KMG1,KMG2,DXMG,DYMG,DZMG,KEYMG,KEYCRMG,
C                    EZNMG,EMDMG,EPSMG,EBMG,EDMG,ERMG,EUNKMG)
C     SUBROUTINE PEMGWP_ZNODUPDE(MGLV,NBLK,IDMG,JDMG,KDMG,IMG1,IMG2,
C                    JMG1,JMG2,KMG1,KMG2,DXMG,DYMG,DZMG,KEYMG,
C                    KEYCRMG,EZNMG,EMDMG,EPSMG,EBMG,EDMG,ERMG,EUNKMG)
C     SUBROUTINE PEMGP_NOUPDATE(NBLK,IV1,IV2)
C     PSUBROUTINE PEMGP_KILLPRC(NERR)
C
C CODE HISTORY:
C     XIULI GAI: 06/20/02
C***********************************************************************
      SUBROUTINE PEMGP_COMMI (N0MAPMG,PRCMAPMG,NERR)
C***********************************************************************
C  Sets up message system for updating the communication layer around
C  the elements assigned to a processor.  This routine should not be
C  called for dynamic load balancing.  Template currently supported  
C  is corner point template (9-point stencil):
C
C          o-----o-----o
C          |     |     |
C          |     |     |
C          o-----X-----o
C          |     |     |
C          |     |     |
C          o-----o-----o
C
C  INPUT:
C     N0MAPMG(MGL,NBLK) = BASE LOCATION FOR BLOCK NBLK IN PRCMAP ON
C                         EACH MULTIGRID LEVEL
C     PRCMAPMG(M,MGL) = PROCESSOR ASSIGNMENTS FOR EACH GRID COLUMN IN EACH
C                       BLOCK ON EACH MULTIGRID LEVEL.
C     NERR = ERROR NUMBER STEPED BY ONE
C***********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'layout.h'

      INCLUDE 'pemulgrd.h'
      INCLUDE 'pemulgrdp.h'

      INTEGER JS2(8),KS2(8),PRCMAPMG($MXCOLS/4,$MXPEMGL),
     &        N0MAPMG($MXPEMGL,$MXBLKS)
      DATA JS2/-1,-1,-1,0,0,1,1,1/,KS2/-1,0,1,-1,1,-1,0,1/

C INITIALIZE

      DO J=1,$MXBLKS
         DO L=1,$MXPEMGL
            PEMSGSMG(L,J)=0
         ENDDO
      ENDDO
      IF (JLAY.LT.1.OR.KLAY.LT.1) RETURN

C BUILD LIST OF PROCESSOR TARGETS FOR CORNER POINT TEMPLATE ON
C EACH MULTIGRID LEVEL

      DO 1 ML=1,PEMGLEV+1
      PELSTINDMG(ML)=0
      DO 1 M=1,NUMBLK
      NX=PENXMG(ML,M)
      NY=PENYMG(ML,M)
      NZ=PENZMG(ML,M)
      N0=N0MAPMG(ML,M)
      NYM=PENYMG(ML,M)
      MG=0

      DO 2 J=1,NY
      DO 2 K=1,NZ
      MS=PRCMAPMG(N0+NYM*K+J,ML)
      IF (MS.EQ.MYPRC) THEN
         DO 3 MM=1,8
         JT=J+JS2(MM)
         KT=K+KS2(MM)
         IF (JT.GT.0.AND.JT.LE.NY.AND.KT.GT.0.AND.KT.LE.NZ) THEN
            MR=PRCMAPMG(N0+NYM*KT+JT,ML)
            IF (MR.NE.MYPRC.AND.MR.GE.0) THEN
               DO 4 L=1,MG
               IF (MR.EQ.PEMSGTRGMG(L,ML,M)) GO TO 3
   4           CONTINUE
               IF (MG.EQ.$MXMPP) GO TO 213
               MG=MG+1
               PEMSGTRGMG(MG,ML,M)=MR
            ENDIF
         ENDIF
   3     CONTINUE
      ENDIF
   2  CONTINUE
      PEMSGSMG(ML,M)=MG

C BUILD MESSAGE LISTS FOR CORNER POINT TEMPLATE ON EACH MULTIGRID LEVEL

      DO 5 MN=1,MG
      MR=PEMSGTRGMG(MN,ML,M)
      PEMSGSNDFMG(MN,ML,M)=PELSTINDMG(ML)+1
      PEMSGSNDLMG(MN,ML,M)=PELSTINDMG(ML)
      DO 5 J=1,NY+1
      DO 5 K=1,NZ+1
      IF(J.LE.NY.AND.K.LE.NZ) MS=PRCMAPMG(N0+NYM*K+J,ML)
      IF(J.EQ.NY+1.AND.K.LE.NZ) MS=PRCMAPMG(N0+NYM*K+NY,ML)
      IF(J.LE.NY.AND.K.EQ.NZ+1) MS=PRCMAPMG(N0+NYM*NZ+J,ML)
      IF(J.EQ.NY+1.AND.K.EQ.NZ+1) MS=PRCMAPMG(N0+NYM*NZ+NY,ML)
      IF (MS.EQ.MYPRC) THEN
         DO 6 MM=1,8
         JT=J+JS2(MM)
         KT=K+KS2(MM)
         IF (JT.GT.0.AND.JT.LE.NY+1.AND.KT.GT.0.AND.KT.LE.NZ+1) THEN
            IF(JT.LE.NY.AND.KT.LE.NZ) MF=PRCMAPMG(N0+NYM*KT+JT,ML)
            IF(JT.EQ.NY+1.AND.K.LE.NZ) MF=PRCMAPMG(N0+NYM*KT+NY,ML)
            IF(JT.LE.NY.AND.KT.EQ.NZ+1) MF=PRCMAPMG(N0+NYM*NZ+JT,ML)
            IF(JT.EQ.NY+1.AND.KT.EQ.NZ+1) MF=PRCMAPMG(N0+NYM*NZ+NY,ML)
            IF (MF.EQ.MR.AND.MF.GE.0) THEN
               MJK1=PEMSGSNDFMG(MN,ML,M)
               MJK2=PEMSGSNDLMG(MN,ML,M)
               DO 7 MJK=MJK1,MJK2
               IF (PEMSGINDMG(1,MJK,ML).EQ.J.AND.
     &            PEMSGINDMG(2,MJK,ML).EQ.K) GO TO 6
   7           CONTINUE
               IF (PELSTINDMG(ML).GE.$MXMGI) GO TO 113
               PELSTINDMG(ML)=PELSTINDMG(ML)+1
               PEMSGSNDLMG(MN,ML,M)=PELSTINDMG(ML)
               PEMSGINDMG(1,PELSTINDMG(ML),ML)=J
               PEMSGINDMG(2,PELSTINDMG(ML),ML)=K
            ENDIF
         ENDIF
   6     CONTINUE
      ENDIF
   5  CONTINUE

   1  CONTINUE

C BUILD LIST OF PROCESSOR SOURCES FOR CORNER POINT TEMPLATE ON
C EACH MULTIGRID LEVEL

C     MGR=0
c     DO 14 J=1,NY+1
c     DO 14 K=1,NZ+1
c     IF(J.LE.NY.AND.K.LE.NZ) MS=PRCMAPMG(N0+NYM*K+J,ML)
c     IF(J.EQ.NY+1.AND.K.LE.NZ) MS=PRCMAPMG(N0+NYM*K+NY,ML)
c     IF(J.LE.NY.AND.K.EQ.NZ+1)
c    &   MS=PRCMAPMG(N0+NYM*NZ+J,ML)
c     IF(J.EQ.NY+1.AND.K.EQ.NZ+1)
c    &   MS=PRCMAPMG(N0+NYM*NZ+NY,ML)
c     if(myprc.eq.0) write(*,*) j,k,ms
c     IF(MS.NE.MYPRC) THEN
c        if(myprc.eq.0) write(*,*) "???",ms
c        DO L=1,MGR
c           IF (MS.EQ.PEMSGSRCMG(L,ML,M)) GO TO 14
c        ENDDO
c        IF (MGR.EQ.$MXMPP) GO TO 213
c        MGR=MGR+1
c        PEMSGSRCMG(MGR,ML,M)=MS
c     ENDIF
c  14 CONTINUE
c     PEMSGRMG(ML,M)=MGR
 
c  10 CONTINUE

C EXCHANGE MESSAGE LISTS

   80 CALL PEMGP_EXMLST ()

      RETURN

  113 NERR=NERR+1
      WRITE (*,114) MYPRC
  114 FORMAT (/' ERROR # 201; TOO MANY MESSAGE ELEMENTS, PROC',I5)
      RETURN

  213 NERR=NERR+1
      WRITE (*,214) MYPRC
  214 FORMAT (/' ERROR # 201; TOO MANY MESSAGE TARGETS, PROC',I5)

      END

C***********************************************************************
      SUBROUTINE PEMGP_COMMIE (N0MAPMG,PRCMAPMG,NERR)
C***********************************************************************
C  Sets up message system for updating the vanished grid points belonging
C  to other processors. This type of communications are called extended 
C  communications. It serves as inter-grid-level communication. 
C 
C  Template supported are 12-point stencil for the coarsening of 2d matrix
C  However residual coarsening requires only standard 9-point stencil.  
C
C    |-----|-----|-----|-----|
C    |     |     |     |     |                   Vanishing grid 
C    |     |     |     |     |            
C    |-----o-----o-----o-----|           o----o----o        o---------o
C    |     |     |     |     |           |    |    |        |         |
C    |     |     |     |     |           | 0  | 1  |        |         |
C    o-----o-----X-----o-----|           o----o----o        |    0    |
C    |     |     |     |     |           |    |    |        |         |
C    |     |     |     |     |           | 1  | 1  |        |         |
C    o-----o-----o-----o-----|           o----o----o        o---------o        
C    |     |     |     |     |
C    |     |     |     |     |            Fine grid          Coarse grid
C    |-----|-----|-----|-----|         processor 1 has       processor 1  
C                                       three elements     has no element
C                                      
C                              Extended communication: 
C                              proc. 0 on the coarse <=> proc 1 on fine grid  
C  INPUT:
C     N0MAPMG(MGL,NBLK) = BASE LOCATION FOR BLOCK NBLK IN PRCMAP ON
C                         EACH MULTIGRID LEVEL
C     PRCMAPMG(M,MGL) = PROCESSOR ASSIGNMENTS FOR EACH GRID COLUMN IN EACH
C                       BLOCK ON EACH MULTIGRID LEVEL.
C     NERR = ERROR NUMBER STEP BY ONE 
C***********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'layout.h'

      INCLUDE 'pemulgrd.h'
      INCLUDE 'pemulgrdp.h'

      INTEGER JS1(12),KS1(12),PRCMAPMG($MXCOLS/4,$MXPEMGL),
     &        N0MAPMG($MXPEMGL,$MXBLKS)
      DATA JS1/-1,-1,-1,0,0,1,1,1,2,-2,-2,-2/
     &     KS1/-1,0,1,-1,1,-1,0,1,-1,0,1,2/

C INITIALIZATION 

      DO J=1,$MXBLKS
         DO L=1,$MXPEMGL
            PEMSGSMGE(L,J)=0
            PEMSGRMGE(L,J)=0
         ENDDO
      ENDDO
      IF (JLAY.LT.1.OR.KLAY.LT.1) RETURN

C BUILD LIST OF PROCESSOR TARGETS FOR EACH MULTIGRID LEVEL

      DO 1 ML=1,PEMGLEV+1
      PELSTINDMG(ML)=0
      DO 1 M=1,NUMBLK
      IF(ML.EQ.1) THEN
         CALL BLKDIM(M,NXF,NYF,NZF,KERR)
         N0F=N0MAP(M)
         NYMF=NYMAP(M)
      ELSE
         NXF=PENXMG(ML-1,M)
         NYF=PENYMG(ML-1,M)
         NZF=PENZMG(ML-1,M)
         N0F=N0MAPMG(ML-1,M)
         NYMF=PENYMG(ML-1,M)
      ENDIF
      NX=PENXMG(ML,M)
      NY=PENYMG(ML,M)
      NZ=PENZMG(ML,M)
      N0=N0MAPMG(ML,M)
      NYM=PENYMG(ML,M)
      MGE=0
      MG=PEMSGSMG(ML,M)
      DO 2 J=1,NY+1
      JF=J*2-1
      DO 2 K=1,NZ+1
      KF=K*2-1
      IF(J.LE.NY.AND.K.LE.NZ) MS=PRCMAPMG(N0+NYM*K+J,ML)
      IF(J.EQ.NY+1.AND.K.LE.NZ) MS=PRCMAPMG(N0+NYM*K+NY,ML)
      IF(J.LE.NY.AND.K.EQ.NZ+1)
     &   MS=PRCMAPMG(N0+NYM*NZ+J,ML)
      IF(J.EQ.NY+1.AND.K.EQ.NZ+1)
     &   MS=PRCMAPMG(N0+NYM*NZ+NY,ML)
      IF (MS.EQ.MYPRC) THEN
         DO 3 MM=1,12
         JT=JF+JS1(MM)
         KT=KF+KS1(MM)
         IF (JT.LE.0.OR.JT.GT.NYF+1.OR.KT.LE.0.OR.KT.GT.NZF+1) GO TO 3
         IF(ML.EQ.1) THEN
           IF(JT.LE.NYF.AND.KT.LE.NZF) MR=PRCMAP(N0F+NYMF*KT+JT)
           IF(JT.EQ.NYF+1.AND.KT.LE.NZF) MR=PRCMAP(N0F+NYMF*KT+NYF)
           IF(JT.LE.NYF.AND.KT.EQ.NZF+1) MR=PRCMAP(N0F+NYMF*NZF+JT)
           IF(JT.EQ.NYF+1.AND.KT.EQ.NZF+1)
     &        MR=PRCMAP(N0F+NYMF*NZF+NYF)
         ELSE
          IF(JT.LE.NYF.AND.KT.LE.NZF) MR=PRCMAPMG(N0F+NYMF*KT+JT,ML-1)
          IF(JT.EQ.NYF+1.AND.KT.LE.NZF)
     &       MR=PRCMAPMG(N0F+NYMF*KT+NYF,ML-1)
          IF(JT.LE.NYF.AND.KT.EQ.NZF+1)
     &       MR=PRCMAPMG(N0F+NYMF*NZF+JT,ML-1)
          IF(JT.EQ.NYF+1.AND.KT.EQ.NZF+1)
     &       MR=PRCMAPMG(N0F+NYMF*NZF+NYF,ML-1)
         ENDIF
         IF (MR.NE.MYPRC.AND.MR.GE.0) THEN
            DO 4 L=1,MGE
            IF (MR.EQ.PEMSGTRGMGE(L,ML,M)) GO TO 3
   4        CONTINUE
c           IF(ML.LE.PEMGLEVB) THEN
c              DO 5 L=1,MG
c              IF(MR.EQ.PEMSGTRGMG(L,ML,M)) THEN
c                 LI1=PEMSGSNDFMG(L,ML,M)
c                 LI2=PEMSGSNDLMG(L,ML,M)
c                 DO 6 LI=LI1,LI2
c                 JC=PEMSGINDMG(1,LI,ML)
c                 KC=PEMSGINDMG(2,LI,ML)
c                 IF(J.EQ.JC.AND.K.EQ.KC) GO TO 3
c  6              CONTINUE
c              ENDIF
c  5           CONTINUE
c           ENDIF
            IF (MGE.EQ.$MXMPP) GO TO 213
            MGE=MGE+1
            PEMSGTRGMGE(MGE,ML,M)=MR
         ENDIF
   3     CONTINUE
      ENDIF
   2  CONTINUE
      PEMSGSMGE(ML,M)=MGE

C BUILD MESSAGE LISTS FOR 11-POINT STENCIL TEMPLATE

      DO 7 MN=1,MGE
      MR=PEMSGTRGMGE(MN,ML,M)
      PEMSGSNDFMGE(MN,ML,M)=PELSTINDMG(ML)+1
      PEMSGSNDLMGE(MN,ML,M)=PELSTINDMG(ML)
      DO 7 J=1,NY+1
      JF=2*J-1
      DO 7 K=1,NZ+1
      KF=2*K-1
      IF(J.LE.NY.AND.K.LE.NZ) MS=PRCMAPMG(N0+NYM*K+J,ML)
      IF(J.EQ.NY+1.AND.K.LE.NZ) MS=PRCMAPMG(N0+NYM*K+NY,ML)
      IF(J.LE.NY.AND.K.EQ.NZ+1)
     &   MS=PRCMAPMG(N0+NYM*NZ+J,ML)
      IF(J.EQ.NY+1.AND.K.EQ.NZ+1)
     &   MS=PRCMAPMG(N0+NYM*NZ+NY,ML)
      IF(MS.EQ.MYPRC) THEN
         DO 8 MM=1,12
         JT=JF+JS1(MM)
         KT=KF+KS1(MM)
         IF(JT.LE.0.OR.JT.GT.NYF+1.OR.KT.LE.0.OR.KT.GT.NZF+1) GO TO 8
         IF(ML.EQ.1) THEN
           IF(JT.LE.NYF.AND.KT.LE.NZF) MF=PRCMAP(N0F+NYMF*KT+JT)
           IF(JT.EQ.NYF+1.AND.KT.LE.NZF) MF=PRCMAP(N0F+NYMF*KT+NYF)
           IF(JT.LE.NYF.AND.KT.EQ.NZF+1) MF=PRCMAP(N0F+NYMF*NZF+JT)
           IF(JT.EQ.NYF+1.AND.KT.EQ.NZF+1)
     &     MF=PRCMAP(N0F+NYMF*NZF+NYF)
         ELSE
           IF(JT.LE.NYF.AND.KT.LE.NZF) MF=PRCMAPMG(N0F+NYMF*KT+JT,ML-1)
           IF(JT.EQ.NYF+1.AND.KT.LE.NZF)
     &        MF=PRCMAPMG(N0F+NYMF*KT+NYF,ML-1)
           IF(JT.LE.NYF.AND.KT.EQ.NZF+1)
     &        MF=PRCMAPMG(N0F+NYMF*NZF+JT,ML-1)
           IF(JT.EQ.NYF+1.AND.KT.EQ.NZF+1)
     &        MF=PRCMAPMG(N0F+NYMF*NZF+NYF,ML-1)
         ENDIF
         IF(MF.EQ.MR.AND.MF.GE.0) THEN
            LI1=PEMSGSNDFMGE(MN,ML,M)
            LI2=PEMSGSNDLMGE(MN,ML,M)
            DO 9 LI=LI1,LI2
            JC=PEMSGINDMGE(1,LI,ML)
            KC=PEMSGINDMGE(2,LI,ML)
            IF(J.EQ.JC.AND.K.EQ.KC) GO TO 8
   9        CONTINUE
            IF(PELSTINDMG(ML).GE.$MXMGI) GO TO 113
            PELSTINDMG(ML)=PELSTINDMG(ML)+1
            PEMSGSNDLMGE(MN,ML,M)=PELSTINDMG(ML)
            PEMSGINDMGE(1,PELSTINDMG(ML),ML)=J
            PEMSGINDMGE(2,PELSTINDMG(ML),ML)=K
         ENDIF
   8     CONTINUE
      ENDIF
   7  CONTINUE


C BUILD LIST OF PROCESSOR SOURCES FOR EACH MULTIGRID LEVEL

      MGRE=0
      DO 21 J=1,NY+1
      JF=J*2-1
      DO 21 K=1,NZ+1
      KF=K*2-1
      IF(J.LE.NY.AND.K.LE.NZ) MS=PRCMAPMG(N0+NYM*K+J,ML)
      IF(J.EQ.NY+1.AND.K.LE.NZ) MS=PRCMAPMG(N0+NYM*K+NY,ML)
      IF(J.LE.NY.AND.K.EQ.NZ+1)
     &   MS=PRCMAPMG(N0+NYM*NZ+J,ML)
      IF(J.EQ.NY+1.AND.K.EQ.NZ+1)
     &   MS=PRCMAPMG(N0+NYM*NZ+NY,ML)
      DO 22 MM=1,12
      JT=JF+JS1(MM)
      KT=KF+KS1(MM)
      IF (JT.LE.0.OR.JT.GT.NYF+1.OR.KT.LE.0.OR.KT.GT.NZF+1) GO TO 22
      IF(ML.EQ.1) THEN
         IF(JT.LE.NYF.AND.KT.LE.NZF) MR=PRCMAP(N0F+NYMF*KT+JT)
         IF(JT.EQ.NYF+1.AND.KT.LE.NZF) MR=PRCMAP(N0F+NYMF*KT+NYF)
         IF(JT.LE.NYF.AND.KT.EQ.NZF+1) MR=PRCMAP(N0F+NYMF*NZF+JT)
         IF(JT.EQ.NYF+1.AND.KT.EQ.NZF+1)
     &      MR=PRCMAP(N0F+NYMF*NZF+NYF)
      ELSE
         IF(JT.LE.NYF.AND.KT.LE.NZF) MR=PRCMAPMG(N0F+NYMF*KT+JT,ML-1)
         IF(JT.EQ.NYF+1.AND.KT.LE.NZF)
     &      MR=PRCMAPMG(N0F+NYMF*KT+NYF,ML-1)
         IF(JT.LE.NYF.AND.KT.EQ.NZF+1)
     &      MR=PRCMAPMG(N0F+NYMF*NZF+JT,ML-1)
         IF(JT.EQ.NYF+1.AND.KT.EQ.NZF+1)
     &      MR=PRCMAPMG(N0F+NYMF*NZF+NYF,ML-1)
      ENDIF
      IF(MR.EQ.MYPRC.AND.MS.NE.MYPRC) THEN
         DO 23 L=1,MGRE
         IF (MS.EQ.PEMSGSRCMGE(L,ML,M)) GO TO 22
   23    CONTINUE
         IF (MGRE.EQ.$MXMPP) GO TO 213
         MGRE=MGRE+1
         PEMSGSRCMGE(MGRE,ML,M)=MS
      ENDIF
   22 CONTINUE
   21 CONTINUE
      PEMSGRMGE(ML,M)=MGRE

   1  CONTINUE

C EXCHANGE MESSAGE LISTS

   80 CALL PEMGP_EXMLSTE()

      RETURN

  113 NERR=NERR+1
      WRITE (*,114) MYPRC
  114 FORMAT (/' ERROR # 201; TOO MANY MESSAGE ELEMENTS, PROC',I5)
      RETURN

  213 NERR=NERR+1
      WRITE (*,214) MYPRC
  214 FORMAT (/' ERROR # 201; TOO MANY MESSAGE TARGETS, PROC',I5)


      END
C*********************************************************************
      SUBROUTINE PEMGP_EXMLST ()
C*********************************************************************

C  Exchanges message lists for updating the standard communication layer.

C*********************************************************************
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'pemulgrd.h'
      INCLUDE 'pemulgrdp.h'

$MPI      INCLUDE 'mpif.h'
$MPI      INTEGER IREQ($MXMPP),ISTAT(MPI_STATUS_SIZE)
$MPI      LOGICAL FLAG

      IF (LEVELE.AND.BUGKEY(1)) WRITE (*,*)'PROC',MYPRC,
     & ' ENTERING SUBROUTINE PE_EXMLST',', TAG',MSGTAG($PEMODEL+1)

C  LOOP OVER MULTIGRID LEVELS AND FAULT BLOCKS

      IERR=0
      CALL TIMON(2)
      DO 1 NL=1,PEMGLEV+1
      DO 1 NB=1,NUMBLK
      M2=PEMSGSMG(NL,NB)
      MR2=PEMSGSMG(NL,NB)

      MSGTAG($PEMODEL+1)=MSGTAG($PEMODEL+1)+1
      IF (MSGTAG($PEMODEL+1).GT.MSGTAG2($PEMODEL+1)) THEN
         MSGTAG($PEMODEL+1)=MSGTAG1($PEMODEL+1)
      ENDIF

C  SEND MESSAGE LISTS (NONBLOCKING)

      DO 2 NM=1,M2
      NE1=PEMSGSNDFMG(NM,NL,NB)
      NE2=PEMSGSNDLMG(NM,NL,NB)
      MLEN=(NE2-NE1+1)*2

$MPI      CALL MPI_ISEND(PEMSGINDMG(1,NE1,NL),MLEN,MPI_INTEGER,
$MPI     & PEMSGTRGMG(NM,NL,NB),MSGTAG($PEMODEL+1),MPI_COMM_WORLD,
$MPI     & IREQ(NM),IERR)

      IF (IERR.GT.0) GO TO 13
    2 CONTINUE

C  RECEIVE MESSAGE LISTS (BLOCKING, ANY SOURCE)

      DO 3 NM=1,MR2
      MLEN=($MXMGI-PELSTINDMG(NL))*2

$MPI      CALL MPI_RECV(PEMSGINDMG(1,PELSTINDMG(NL)+1,NL),MLEN,
$MPI     & MPI_INTEGER,MPI_ANY_SOURCE,MSGTAG($PEMODEL+1),
$MPI     & MPI_COMM_WORLD,ISTAT,IERR)
$MPI      CALL MPI_GET_COUNT(ISTAT,MPI_INTEGER,NI,IERR)
$MPI      MS=ISTAT(MPI_SOURCE)

      IF (IERR.GT.0) GO TO 13
      PEMSGSRCMG(NM,NL,NB)=MS
      PEMSGRCVFMG(NM,NL,NB)=PELSTINDMG(NL)+1
      PELSTINDMG(NL)=PELSTINDMG(NL)+NI/2
    3 PEMSGRCVLMG(NM,NL,NB)=PELSTINDMG(NL)

C  WAIT FOR SEND COMPLETION

      DO 7 NM=1,NM2
$MPI    9 CALL MPI_TEST(IREQ(NM),FLAG,ISTAT,IERR)
      IF (IERR.GT.0) GO TO 13
$MPI      IF (.NOT.FLAG) GO TO 9

    7 CONTINUE

    1 CONTINUE

C  EXITS

      CALL TIMOFF(2)
      IF (LEVELE) WRITE (*,6) MYPRC
    6 FORMAT('MESSAGE LIST EXCHANGE COMPLETE: MYPRC =',I5)

      RETURN
   13 WRITE (*,*) ' MESSAGE ERROR',IERR,' IN PEMGP_EXMLST FOR PROC',
     &              MYPRC
$MANY      CALL PEMGP_KILLPRC(IERR)

      END

C*********************************************************************
      SUBROUTINE PEMGP_EXMLSTE ()
C*********************************************************************

C  Exchanges message lists for updating the extended communication layer.

C*********************************************************************
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'pemulgrd.h'
      INCLUDE 'pemulgrdp.h'

$MPI      INCLUDE 'mpif.h'
$MPI      INTEGER IREQ($MXMPP),ISTAT(MPI_STATUS_SIZE)
$MPI      LOGICAL FLAG

      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)' PROC',MYPRC,
     & ' ENTERING SUBROUTINE PEMGP_EXMLSTE, OLD TAG =',
     &   MSGTAG($PEMODEL+1)

C  LOOP OVER MULTIGRID LEVEL AND FAULT BLOCKS

      IERR=0
      CALL TIMON(2)
      DO 1 NL=1,PEMGLEV+1
      DO 1 NB=1,NUMBLK
      NM2=PEMSGSMGE(NL,NB)
      NMR2=PEMSGRMGE(NL,NB)
   
      MSGTAG($PEMODEL+1)=MSGTAG($PEMODEL+1)+1
      IF (MSGTAG($PEMODEL+1).GT.MSGTAG2($PEMODEL+1)) THEN
         MSGTAG($PEMODEL+1)=MSGTAG1($PEMODEL+1)
      ENDIF


C  SEND MESSAGE LISTS (NONBLOCKING)

      DO 2 NM=1,NM2
      NE1=PEMSGSNDFMGE(NM,NL,NB)
      NE2=PEMSGSNDLMGE(NM,NL,NB)
      MLEN=(NE2-NE1+1)*2

$MPI      CALL MPI_ISEND(PEMSGINDMGE(1,NE1,NL),MLEN,MPI_INTEGER,
$MPI     & PEMSGTRGMGE(NM,NL,NB),MSGTAG($PEMODEL+1),MPI_COMM_WORLD,
$MPI     & IREQ(NM),IERR)

      IF (IERR.GT.0) GO TO 13
    2 CONTINUE

C  RECEIVE MESSAGE LISTS (BLOCKING, ANY SOURCE)

      DO 3 NM=1,NMR2
      MLEN=($MXMGI-PELSTINDMG(NL))*2

$MPI      CALL MPI_RECV(PEMSGINDMGE(1,PELSTINDMG(NL)+1,NL),MLEN,
$MPI     & MPI_INTEGER,MPI_ANY_SOURCE,MSGTAG($PEMODEL+1),
$MPI     & MPI_COMM_WORLD,ISTAT,IERR)


$MPI      CALL MPI_GET_COUNT(ISTAT,MPI_INTEGER,NI,IERR)
$MPI      MS=ISTAT(MPI_SOURCE)
      IF (IERR.GT.0) GO TO 13
      PEMSGSRCMGE(NM,NL,NB)=MS
      PEMSGRCVFMGE(NM,NL,NB)=PELSTINDMG(NL)+1
      PELSTINDMG(NL)=PELSTINDMG(NL)+NI/2
    3 PEMSGRCVLMGE(NM,NL,NB)=PELSTINDMG(NL)

C  WAIT FOR SEND COMPLETION

      DO 7 NM=1,NM2
$MPI    9 CALL MPI_TEST(IREQ(NM),FLAG,ISTAT,IERR)
      IF (IERR.GT.0) GO TO 13
$MPI      IF (.NOT.FLAG) GO TO 9

    7 CONTINUE

    1 CONTINUE

C  EXITS

      CALL TIMOFF(2)
      IF (LEVELE) WRITE (*,6) MYPRC
    6 FORMAT('MESSAGE LIST EXCHANGE COMPLETE: MYPRC =',I5)

      RETURN
   13 WRITE (*,*) ' MESSAGE ERROR',IERR,' IN PEMGP_EXMLSTE FOR PROC',
     &              MYPRC
$MANY      CALL PEMGP_KILLPRC(IERR)

      END

C***********************************************************************
      SUBROUTINE PEMGWP_DISPUPD(MGLV,NBLK,IDMG,JDMG,KDMG,IMG1,IMG2,
     &              JMG1,JMG2,KMG1,KMG2,DXMG,DYMG,DZMG,KEYMG,KEYCRMG,
     &              EZNMG,EMDMG,EPSMG,EBMG,EDMG,ERMG,EUNKMG)
C***********************************************************************
C  Porelastic model update routine for multigrid solver on 2d coarse grid.
C  Exchanges communication layer data for 1 fault block and 1 REAL*8 array.
C  This routine is called only by PEMGP_UPDATE.

C  IDMG,JDMG,KDMG,LDMG = First 4 dimensions of a grid element array on
C                        2d coarse level.  

C  MGLV = Multigrid level

C  NBLK = Grid block number (input,INTEGER)

C  ERMG(L,I,J,K) = RESIDUALS ON A 2D COARSE GRID
C*********************************************************************
      USE scrat1mod

      PARAMETER (NDB=$MXREAD/8)
      INCLUDE 'control.h'
!      INCLUDE 'scrat1.h'
      INCLUDE 'layout.h'
      INCLUDE 'pemulgrd.h'
      INCLUDE 'pemulgrdp.h'
      INCLUDE 'pesolve.h'

      INTEGER MGLV,NBLK,IDMG,JDMG,KDMG,IMG1,IMG2,JMG1,JMG2,KMG1,KMG2,
     &        KEYMG(IDMG,JDMG,KDMG),    KEYCRMG(IDMG,JDMG,KDMG)
      LOGICAL EZNMG(IDMG,JDMG,KDMG)
      REAL*8  DXMG(IDMG),DYMG(JDMG),    DZMG(KDMG),
     &        EMDMG(IDMG,JDMG,KDMG),    EPSMG(IDMG,JDMG,KDMG),
     &        EBMG(*),                  EDMG(*),
     &        ERMG(3,IDMG,JDMG,KDMG),   EUNKMG(3,IDMG,JDMG,KDMG)

$MPI      INCLUDE 'mpif.h'
$MPI      INTEGER IREQ($MXMPP),ISTATS(MPI_STATUS_SIZE,$MXMPP)
$MPI      INTEGER ISTATR(MPI_STATUS_SIZE)
      REAL*8 B(NDB)

      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)' PROC',MYPRC,
     & ' ENTERING SUBROUTINE PEMGWP_DISPUPD,BLOCK =',NBLK,
     & ', OLD TAG =',MSGTAG($PEMODEL+1)

      NL = MGLV
      MEQ = PE_MEQ
      IOFF=PEIOFFMG(NL,NBLK)
      JOFF=PEJOFFMG(NL,NBLK)
      KOFF=PEKOFFMG(NL,NBLK)
      M2=PEMSGSMG(NL,NBLK)

      MSGTAG($PEMODEL+1)=MSGTAG($PEMODEL+1)+1
      IF (MSGTAG($PEMODEL+1).GT.MSGTAG2($PEMODEL+1)) THEN
         MSGTAG($PEMODEL+1)=MSGTAG1($PEMODEL+1)
      ENDIF

      IF (M2.LE.0) GO TO 10

C  NONBLOCKING SENDS

      NFE1=1
      DO 2 M=1,M2
      LI1=PEMSGSNDFMG(M,NL,NBLK)
      LI2=PEMSGSNDLMG(M,NL,NBLK)
      NFE2=NFE1
      DO 21 L=LI1,LI2
      J=PEMSGINDMG(1,L,NL)
      K=PEMSGINDMG(2,L,NL)
c     IF(MOD(J,2).NE.KRBJ.OR.MOD(K,2).NE.KRBK) GO TO 21
      J=J-JOFF
      K=K-KOFF
      DO 1 I=1,IDMG
      DO 1 LL=1,MEQ
      B(NFE2)=EUNKMG(LL,I,J,K)
    1 NFE2=NFE2+1
   21 CONTINUE

$MPI      CALL MPI_ISEND(B(NFE1),NFE2-NFE1,MPI_DOUBLE_PRECISION,
$MPI     & PEMSGTRGMG(M,NL,NBLK),MSGTAG($PEMODEL+1),MPI_COMM_WORLD,
$MPI     & IREQ(M),IERR)

      IF (IERR.GT.0) GO TO 13
    2 NFE1=NFE2

C  RECEIVE

      LENM=NDB-NFE1+1
      DO 3 M=1,M2

$MPI      CALL MPI_RECV(B(NFE1),LENM,MPI_DOUBLE_PRECISION,
$MPI     & MPI_ANY_SOURCE,MSGTAG($PEMODEL+1),MPI_COMM_WORLD,
$MPI     & ISTATR,IERR)
$MPI      MS=ISTATR(MPI_SOURCE)

      IF (IERR.GT.0) GO TO 13
      DO 5 MM=1,M2
      IF (MS.EQ.PEMSGSRCMG(MM,NL,NBLK)) THEN
         LI1=PEMSGRCVFMG(MM,NL,NBLK)
         LI2=PEMSGRCVLMG(MM,NL,NBLK)
         GO TO 6
      ENDIF
    5 CONTINUE
      IERR=1
      GO TO 13

    6 NFE2=NFE1
      DO 41 L=LI1,LI2
      J=PEMSGINDMG(1,L,NL)
      K=PEMSGINDMG(2,L,NL)
c     IF(MOD(J,2).NE.KRBJ.OR.MOD(K,2).NE.KRBK) GO TO 41
      J=J-JOFF
      K=K-KOFF
      DO 4 I=1,IDMG
      DO 4 LL=1,MEQ
      EUNKMG(LL,I,J,K)=B(NFE2)
    4 NFE2=NFE2+1
   41 CONTINUE
    3 CONTINUE

C  WAIT FOR SEND COMPLETION

$MPI      CALL MPI_WAITALL (M2,IREQ,ISTATS,IERR)

      IF (IERR.GT.0) THEN
         NER1=4
         NER2=M2
         GO TO 13
      ENDIF

   10 CONTINUE

C  EXITS

      RETURN

   13 WRITE (*,*) ' MESSAGE ERROR',IERR,' IN PEMGWP_DISPUPD FOR PROC',
     & MYPRC,', BLOCK',NBLK,', LOC',NER1,', DATA',NER2
$MANY      CALL PEMGP_KILLPRC(IERR)

      END

C***********************************************************************
      SUBROUTINE PEMGWP_ZNODUPD(MGLV,NBLK,IDMG,JDMG,KDMG,IMG1,IMG2,
     &              JMG1,JMG2,KMG1,KMG2,DXMG,DYMG,DZMG,KEYMG,
     &              KEYCRMG,EZNMG,EMDMG,EPSMG,EBMG,EDMG,ERMG,EUNKMG)
C***********************************************************************
C  Porelastic model update routine for multigrid solver
C  Exchanges communication layer data for 1 fault block and 1 logical array.
C  This routine is called only by PEMGP_UPDATE.

C  IDMG,JDMG,KDMG,LDMG = First 4 dimensions of a grid element array on
C                        2d coarse level.

C  NMGL = Multigrid level

C  NBLK = Grid block number (input,INTEGER)

C  EZNMG = ZERO NODE ARRAY ON 2D COARSE GRIDS (input, LOGICAL)
C*********************************************************************
      USE scrat1mod

      INCLUDE 'control.h'
!      INCLUDE 'scrat1.h'
      INCLUDE 'layout.h'
      INCLUDE 'pemulgrd.h'
      INCLUDE 'pemulgrdp.h'
      INCLUDE 'pesolve.h'
$MPI      INCLUDE 'mpif.h'

      INTEGER MGLV,NBLK,IDMG,JDMG,KDMG,IMG1,IMG2,JMG1,JMG2,KMG1,KMG2,
     &        KEYMG(IDMG,JDMG,KDMG),    KEYCRMG(IDMG,JDMG,KDMG)
      LOGICAL EZNMG(IDMG,JDMG,KDMG)
      REAL*8  DXMG(IDMG),DYMG(JDMG),    DZMG(KDMG),
     &        EMDMG(IDMG,JDMG,KDMG),    EPSMG(IDMG,JDMG,KDMG),
     &        EBMG(*),                  EDMG(*),
     &        ERMG(3,IDMG,JDMG,KDMG),   EUNKMG(3,IDMG,JDMG,KDMG)
      PARAMETER (NDB=$MXREAD/8)
      LOGICAL B(NDB)
$MPI      INTEGER IREQ($MXMPP),ISTATS(MPI_STATUS_SIZE,$MXMPP)
$MPI      INTEGER ISTATR(MPI_STATUS_SIZE)

      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)' PROC',MYPRC,
     & ' ENTERING SUBROUTINE PEMGWP_ZNODUPD,BLOCK =',NBLK,
     & ', OLD TAG =',MSGTAG($PEMODEL+1)

      NL=NMGL
      IOFF=PEIOFFMG(NL,NBLK)
      JOFF=PEJOFFMG(NL,NBLK)
      KOFF=PEKOFFMG(NL,NBLK)
      M2=PEMSGSMG(NL,NBLK)

      MSGTAG($PEMODEL+1)=MSGTAG($PEMODEL+1)+1
      IF (MSGTAG($PEMODEL+1).GT.MSGTAG2($PEMODEL+1)) THEN
          MSGTAG($PEMODEL+1)=MSGTAG1($PEMODEL+1)
      ENDIF
     
      IF (M2.LE.0) GO TO 10

C NONBLOCKING SENDS

      NFE1=1
      DO 2 M=1,M2
      LI1=PEMSGSNDFMG(M,NL,NBLK)
      LI2=PEMSGSNDLMG(M,NL,NBLK)
      NFE2=NFE1
      DO 1 L=LI1,LI2
      J=PEMSGINDMG(1,L,NL)-JOFF
      K=PEMSGINDMG(2,L,NL)-KOFF
      DO 1 I=1,IDMG
      B(NFE2)=EZNMG(I,J,K)
    1 NFE2=NFE2+1

$MPI      CALL MPI_ISEND(B(NFE1),NFE2-NFE1,MPI_DOUBLE_PRECISION,
$MPI     & PEMSGTRGMG(M,NL,NBLK),MSGTAG($PEMODEL+1),MPI_COMM_WORLD,
$MPI     & IREQ(M),IERR)

      IF (IERR.GT.0) GO TO 13
    2 NFE1=NFE2

C RECEIVE

      LENM=NDB-NFE1+1
      DO 3 M=1,M2

$MPI      CALL MPI_RECV(B(NFE1),LENM,MPI_DOUBLE_PRECISION,
$MPI     & MPI_ANY_SOURCE,MSGTAG($PEMODEL+1),MPI_COMM_WORLD,ISTATR,IERR)
$MPI      MS=ISTATR(MPI_SOURCE)

      IF (IERR.GT.0) GO TO 13
      DO 5 MM=1,M2
      IF (MS.EQ.PEMSGSRCMG(MM,NL,NBLK)) THEN
         LI1=PEMSGRCVFMG(MM,NL,NBLK)
         LI2=PEMSGRCVLMG(MM,NL,NBLK)
         GO TO 6
      ENDIF
    5 CONTINUE
      IERR=1
      GO TO 13

    6 NFE2=NFE1
      DO 4 L=LI1,LI2
      J=PEMSGINDMG(1,L,NL)-JOFF
      K=PEMSGINDMG(2,L,NL)-KOFF
      DO 4 I=1,IDMG
      EZNMG(I,J,K)=B(NFE2)
    4 NFE2=NFE2+1

    3 CONTINUE

C  WAIT FOR SEND COMPLETION

$MPI      CALL MPI_WAITALL (M2,IREQ,ISTATS,IERR)

      IF (IERR.GT.0) THEN
         NER1=4
         NER2=M2
         GO TO 13
      ENDIF

   10 CONTINUE

C  EXITS

      RETURN

   13 WRITE (*,*) ' MESSAGE ERROR',IERR,' IN PEMGWP_ZNODUPD FOR PROC',
     & MYPRC,', BLOCK',NBLK,', LOC',NER1,', DATA',NER2
$MANY      CALL PEMGP_KILLPRC(IERR)

      END

C***********************************************************************
      SUBROUTINE PEMGWP_COFUPDE(MGLV,NBLK,IDMG,JDMG,KDMG,IMG1,IMG2,
     &              JMG1,JMG2,KMG1,KMG2,DXMG,DYMG,DZMG,KEYMG,KEYCRMG,
     &              EZNMG,EMDMG,EPSMG,EBMG,EDMG,ERMG,EUNKMG)
C***********************************************************************
C Transfers coarse grid matrix coefficients of the nodes, which are on
C a processor''s EXTENDED receiving message list, to its SOURCE 
C processors.
C Processors which receive the messages will add a transfered value
C to the original value on the same node.
C This is a PEWORKMG3 routine.
C
C Note: This communication is different from the usual message updates
C       on the communication layers, which are from SOURCE processors
C       to target processors.
C
C Arrays involved in message passing:
C
C   EBMG(L,M,I,J,K) = OFF DIAGONAL COEF. OF A 2D COARSE GRID MATRIX
C   EDMG(L,I,J,K) = DIAGONAL COEF. OF A 2D COARSE GRID MATRIX
C***********************************************************************      
      USE scrat1mod

      INCLUDE 'control.h'
!      INCLUDE 'scrat1.h'
      INCLUDE 'layout.h'
      INCLUDE 'pemulgrd.h'
      INCLUDE 'pemulgrdp.h'
      INCLUDE 'pesolve.h'
$MPI      INCLUDE 'mpif.h'

      INTEGER MGLV,NBLK,IDMG,JDMG,KDMG,IMG1,IMG2,JMG1,JMG2,KMG1,KMG2,
     &        KEYMG(IDMG,JDMG,KDMG), 
     &        KEYCRMG(IDMG,JDMG,KDMG)
      LOGICAL EZNMG(IDMG,JDMG,KDMG)
      REAL*8  DXMG(IDMG),DYMG(JDMG),    DZMG(KDMG),
     &        EMDMG(IDMG,JDMG,KDMG),    EPSMG(IDMG,JDMG,KDMG),
     &        EBMG(9,4,IDMG,JDMG,KDMG), EDMG(6,IDMG,JDMG,KDMG),
     &        ERMG(3,IDMG,JDMG,KDMG),   EUNKMG(3,IDMG,JDMG,KDMG)
      PARAMETER (NDB=$MXREAD/8)
      REAL*8 B(NDB)
$MPI      INTEGER IREQ($MXMPP),ISTATS(MPI_STATUS_SIZE,$MXMPP)
$MPI      INTEGER ISTATR(MPI_STATUS_SIZE)

      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)' PROC',MYPRC,
     & ' ENTERING SUBROUTINE PEMGWP_COFUPDE,BLOCK =',NBLK,
     & ', OLD TAG =',MSGTAG($PEMODEL+1)

      MEQ=PE_MEQ
      NB=MEQ*MEQ
      ND=(MEQ-1)*MEQ
      NOFF2D=4

      M2=PEMSGSMGE(MGLV,NBLK)
      MR2=PEMSGRMGE(MGLV,NBLK)

C FOR OFFDIAGONAL COEFFICIENTS

      DO 10, LLL=1,NB
      MSGTAG($PEMODEL+1)=MSGTAG($PEMODEL+1)+1
      IF (MSGTAG($PEMODEL+1).GT.MSGTAG2($PEMODEL+1)) THEN
         MSGTAG($PEMODEL+1)=MSGTAG1($PEMODEL+1)
      ENDIF

C  NONBLOCKING SENDS
     
      NFE1=1
      DO 2 M=1,MR2
      LI1=PEMSGRCVFMGE(M,MGLV,NBLK)
      LI2=PEMSGRCVLMGE(M,MGLV,NBLK)
      NFE2=NFE1
      DO 1 L=LI1,LI2
      J=PEMSGINDMGE(1,L,MGLV)-PEJOFFMG(MGLV,NBLK)
      K=PEMSGINDMGE(2,L,MGLV)-PEKOFFMG(MGLV,NBLK)
      DO 1 I=1,IDMG
      DO 1 LL=1,NOFF2D
      B(NFE2)=EBMG(LLL,LL,I,J,K)
    1 NFE2=NFE2+1

$MPI      CALL MPI_ISEND(B(NFE1),NFE2-NFE1,MPI_DOUBLE_PRECISION,
$MPI     &PEMSGSRCMGE(M,MGLV,NBLK),MSGTAG($PEMODEL+1),MPI_COMM_WORLD,
$MPI     &IREQ(M),IERR)

      IF (IERR.GT.0) GO TO 13
    2 NFE1=NFE2

C  RECEIVE
   
      LENM=NDB-NFE1+1
      DO 3 M=1,M2
$MPI      CALL MPI_RECV(B(NFE1),LENM,MPI_DOUBLE_PRECISION,
$MPI     & MPI_ANY_SOURCE,MSGTAG($PEMODEL+1),MPI_COMM_WORLD,
$MPI     & ISTATR,IERR)
$MPI      MS=ISTATR(MPI_SOURCE)

      IF (IERR.GT.0) GO TO 13
      DO 5 MM=1,M2
      IF (MS.EQ.PEMSGTRGMGE(MM,MGLV,NBLK)) THEN
         LI1=PEMSGSNDFMGE(MM,MGLV,NBLK)
         LI2=PEMSGSNDLMGE(MM,MGLV,NBLK)
         GO TO 6
      ENDIF
    5 CONTINUE
      IERR=1
      GO TO 13

    6 NFE2=NFE1
      DO 4 L=LI1,LI2
      J=PEMSGINDMGE(1,L,MGLV)-PEJOFFMG(MGLV,NBLK)
      K=PEMSGINDMGE(2,L,MGLV)-PEKOFFMG(MGLV,NBLK)
      DO 4 I=1,IDMG
      DO 4 LL=1,NOFF2D
      EBMG(LLL,LL,I,J,K)=EBMG(LLL,LL,I,J,K)+B(NFE2)
    4 NFE2=NFE2+1

    3 CONTINUE

C  WAIT FOR SEND COMPLETION

$MPI      CALL MPI_WAITALL (M2,IREQ,ISTATS,IERR)
      IF (IERR.GT.0) THEN
         NER1=4
         NER2=M2
         GO TO 13
      ENDIF

C  TERMINATE 4TH INDEX LOOP

  10  CONTINUE

C  FOR DIAGONAL COEFFICIENTS

      MSGTAG($PEMODEL+1)=MSGTAG($PEMODEL+1)+1
      IF (MSGTAG($PEMODEL+1).GT.MSGTAG2($PEMODEL+1)) THEN
          MSGTAG($PEMODEL+1)=MSGTAG1($PEMODEL+1)
      ENDIF

C  NONBLOCKING SENDS

      NFE1=1
      DO 12 M=1,MR2
      LI1=PEMSGRCVFMGE(M,MGLV,NBLK)
      LI2=PEMSGRCVLMGE(M,MGLV,NBLK)
      NFE2=NFE1
      DO 11 L=LI1,LI2
      J=PEMSGINDMGE(1,L,MGLV)-PEJOFFMG(MGLV,NBLK)
      K=PEMSGINDMGE(2,L,MGLV)-PEKOFFMG(MGLV,NBLK)
      DO 11 I=1,IDMG
      DO 11 LL=1,ND
      B(NFE2)=EDMG(LL,I,J,K)
   11 NFE2=NFE2+1

$MPI      CALL MPI_ISEND(B(NFE1),NFE2-NFE1,MPI_DOUBLE_PRECISION,
$MPI     &PEMSGSRCMGE(M,MGLV,NBLK),MSGTAG($PEMODEL+1),MPI_COMM_WORLD,
$MPI     &IREQ(M),IERR)

      IF (IERR.GT.0) GO TO 13
   12 NFE1=NFE2

C  RECEIVE

      LENM=NDB-NFE1+1
      DO 17 M=1,M2

$MPI      CALL MPI_RECV(B(NFE1),LENM,MPI_DOUBLE_PRECISION,
$MPI     & MPI_ANY_SOURCE,MSGTAG($PEMODEL+1),MPI_COMM_WORLD,
$MPI     & ISTATR,IERR)
$MPI      MS=ISTATR(MPI_SOURCE)

      IF (IERR.GT.0) GO TO 13
      DO 15 MM=1,M2
      IF (MS.EQ.PEMSGTRGMGE(MM,MGLV,NBLK)) THEN
         LI1=PEMSGSNDFMGE(MM,MGLV,NBLK)
         LI2=PEMSGSNDLMGE(MM,MGLV,NBLK)
         GO TO 16
      ENDIF
   15 CONTINUE
      IERR=1
      GO TO 13

   16 NFE2=NFE1
      DO 14 L=LI1,LI2
      J=PEMSGINDMGE(1,L,MGLV)-PEJOFFMG(MGLV,NBLK)
      K=PEMSGINDMGE(2,L,MGLV)-PEKOFFMG(MGLV,NBLK)
      DO 14 I=1,IDMG
      DO 14 LL=1,ND
      EDMG(LL,I,J,K)=EDMG(LL,I,J,K)+B(NFE2)
   14 NFE2=NFE2+1

   17 CONTINUE

C  WAIT FOR SEND COMPLETION

$MPI      CALL MPI_WAITALL (M2,IREQ,ISTATS,IERR)

      IF (IERR.GT.0) THEN
         NER1=4
         NER2=M2
         GO TO 13
      ENDIF

  20  CONTINUE

C  EXITS

      RETURN

   13 WRITE (*,*) ' MSG ERROR',IERR,' IN PEMGWP_COFUPDE FOR PROC',MYPRC,
     & ', BLOCK',NBLK,', LOC',NER1,', DATA',NER2
      CALL PEMGP_KILLPRC(IERR)

      END

C***********************************************************************
      SUBROUTINE PEMGWP_COFUPDG(MGLV,NBLK,IDMG,JDMG,KDMG,IMG1,IMG2,
     &              JMG1,JMG2,KMG1,KMG2,DXMG,DYMG,DZMG,KEYMG,KEYCRMG,
     &              EZNMG,EMDMG,EPSMG,EBMG,EDMG,ERMG,EUNKMG)
C***********************************************************************
C Updating matrix coefficients of a coarse grid nodes which has 
C neighboring fine grid nodes which belong to other processors.
C It actually involves sending the summed coefficients in 
C PEMGWP_COFUPD back to the SOURCE processor.  
C This is a PEWORKMG3 routine.
C
C Note: This communication is the same as the usual message updates
C       on the communication layers
C
C   EBMG(L,M,I,J,K) = OFF DIAGONAL COEF. OF A 2D COARSE GRID MATRIX
C   EDMG(L,I,J,K) = DIAGONAL COEF. OF A 2D COARSE GRID MATRIX
C***********************************************************************
      USE scrat1mod
  
      INCLUDE 'control.h'
!      INCLUDE 'scrat1.h'
      INCLUDE 'layout.h'
      INCLUDE 'pemulgrd.h'
      INCLUDE 'pemulgrdp.h'
      INCLUDE 'pesolve.h'
$MPI      INCLUDE 'mpif.h'

      INTEGER MGLV,NBLK,IDMG,JDMG,KDMG,IMG1,IMG2,JMG1,JMG2,KMG1,KMG2,
     &        KEYMG(IDMG,JDMG,KDMG), 
     &        KEYCRMG(IDMG,JDMG,KDMG)
      LOGICAL EZNMG(IDMG,JDMG,KDMG)
      REAL*8  DXMG(IDMG),DYMG(JDMG),    DZMG(KDMG),
     &        EMDMG(IDMG,JDMG,KDMG),    EPSMG(IDMG,JDMG,KDMG),
     &        EBMG(9,4,IDMG,JDMG,KDMG), EDMG(6,IDMG,JDMG,KDMG),
     &        ERMG(3,IDMG,JDMG,KDMG),   EUNKMG(3,IDMG,JDMG,KDMG)
      PARAMETER (NDB=$MXREAD/8)
      REAL*8 B(NDB)
$MPI      INTEGER IREQ($MXMPP),ISTATS(MPI_STATUS_SIZE,$MXMPP)
$MPI      INTEGER ISTATR(MPI_STATUS_SIZE)
    
      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)' PROC',MYPRC,
     & ' ENTERING SUBROUTINE PEMGWP_COFUPDG,BLOCK =',NBLK,
     & ', OLD TAG =',MSGTAG($PEMODEL+1)

      MEQ=PE_MEQ
      NB=MEQ*MEQ
      ND=(MEQ-1)*MEQ
      NOFF2D=4
      M2=PEMSGSMG(MGLV,NBLK)
       
C FOR OFFDIAGONAL COEFFICIENTS
     
      DO 10 LLL=1,NB

      MSGTAG($PEMODEL+1)=MSGTAG($PEMODEL+1)+1
      IF (MSGTAG($PEMODEL+1).GT.MSGTAG2($PEMODEL+1)) THEN
         MSGTAG($PEMODEL+1)=MSGTAG1($PEMODEL+1)
      ENDIF
      IF (M2.LE.0) GO TO 10

C  NONBLOCKING SENDS

      NFE1=1
      DO 2 M=1,M2
      LI1=PEMSGSNDFMG(M,MGLV,NBLK)
      LI2=PEMSGSNDLMG(M,MGLV,NBLK)
      NFE2=NFE1
      DO 1 L=LI1,LI2
      J=PEMSGINDMG(1,L,MGLV)-PEJOFFMG(MGLV,NBLK)
      K=PEMSGINDMG(2,L,MGLV)-PEKOFFMG(MGLV,NBLK)
      DO 1 I=1,IDMG
      DO 1 LL=1,NOFF2D
      B(NFE2)=EBMG(LLL,LL,I,J,K)
    1 NFE2=NFE2+1

$MPI      CALL MPI_ISEND(B(NFE1),NFE2-NFE1,MPI_DOUBLE_PRECISION,
$MPI     &PEMSGTRGMG(M,MGLV,NBLK),MSGTAG($PEMODEL+1),MPI_COMM_WORLD,
$MPI     &IREQ(M),IERR)
      IF (IERR.GT.0) GO TO 13
    2 NFE1=NFE2

C  RECEIVE

      LENM=NDB-NFE1+1
      DO 3 M=1,M2
$MPI      CALL MPI_RECV(B(NFE1),LENM,MPI_DOUBLE_PRECISION,
$MPI     & MPI_ANY_SOURCE,MSGTAG($PEMODEL+1),MPI_COMM_WORLD,
$MPI     & ISTATR,IERR)
$MPI      MS=ISTATR(MPI_SOURCE)
     
      IF (IERR.GT.0) GO TO 13
      DO 5 MM=1,M2
      IF (MS.EQ.PEMSGSRCMG(MM,MGLV,NBLK)) THEN
         LI1=PEMSGRCVFMG(MM,MGLV,NBLK)
         LI2=PEMSGRCVLMG(MM,MGLV,NBLK)
         GO TO 6
      ENDIF
    5 CONTINUE
      IERR=1
      GO TO 13

    6 NFE2=NFE1
      DO 4 L=LI1,LI2
      J=PEMSGINDMG(1,L,MGLV)-PEJOFFMG(MGLV,NBLK)
      K=PEMSGINDMG(2,L,MGLV)-PEKOFFMG(MGLV,NBLK)
      DO 4 I=1,IDMG
      DO 4 LL=1,NOFF2D
      EBMG(LLL,LL,I,J,K)=B(NFE2)
    4 NFE2=NFE2+1

    3 CONTINUE

C  WAIT FOR SEND COMPLETION

$MPI      CALL MPI_WAITALL (M2,IREQ,ISTATS,IERR)

      IF (IERR.GT.0) THEN
         NER1=4
         NER2=M2
         GO TO 13
      ENDIF

C  TERMINATE 4TH INDEX LOOP

   10 CONTINUE

C  FOR DIAGONAL COEFFICIENTS

      MSGTAG($PEMODEL+1)=MSGTAG($PEMODEL+1)+1
      IF (MSGTAG($PEMODEL+1).GT.MSGTAG2($PEMODEL+1)) THEN
         MSGTAG($PEMODEL+1)=MSGTAG1($PEMODEL+1)
      ENDIF
      IF (M2.LE.0) GO TO 20

C  NONBLOCKING SENDS

      NFE1=1
      DO 12 M=1,M2
      LI1=PEMSGSNDFMG(M,MGLV,NBLK)
      LI2=PEMSGSNDLMG(M,MGLV,NBLK)
      NFE2=NFE1
      DO 11 L=LI1,LI2
      J=PEMSGINDMG(1,L,MGLV)-PEJOFFMG(MGLV,NBLK)
      K=PEMSGINDMG(2,L,MGLV)-PEKOFFMG(MGLV,NBLK)
      DO 11 I=1,IDMG
      DO 11 LL=1,ND
      B(NFE2)=EDMG(LL,I,J,K)
   11 NFE2=NFE2+1

$MPI      CALL MPI_ISEND(B(NFE1),NFE2-NFE1,MPI_DOUBLE_PRECISION,
$MPI     &PEMSGTRGMG(M,MGLV,NBLK),MSGTAG($PEMODEL+1),MPI_COMM_WORLD,
$MPI     &IREQ(M),IERR)

      IF (IERR.GT.0) GO TO 13
   12 NFE1=NFE2

C  RECEIVE

      LENM=NDB-NFE1+1
      DO 17 M=1,M2

$MPI      CALL MPI_RECV(B(NFE1),LENM,MPI_DOUBLE_PRECISION,
$MPI     & MPI_ANY_SOURCE,MSGTAG($PEMODEL+1),MPI_COMM_WORLD,
$MPI     & ISTATR,IERR)
$MPI      MS=ISTATR(MPI_SOURCE)

      IF (IERR.GT.0) GO TO 13
      DO 15 MM=1,M2
      IF (MS.EQ.PEMSGSRCMG(MM,MGLV,NBLK)) THEN
         LI1=PEMSGRCVFMG(MM,MGLV,NBLK)
         LI2=PEMSGRCVLMG(MM,MGLV,NBLK)
         GO TO 16
      ENDIF
   15 CONTINUE
      IERR=1
      GO TO 13

   16 NFE2=NFE1
      DO 14 L=LI1,LI2
      J=PEMSGINDMG(1,L,MGLV)-PEJOFFMG(MGLV,NBLK)
      K=PEMSGINDMG(2,L,MGLV)-PEKOFFMG(MGLV,NBLK)
      DO 14 I=1,IDMG
      DO 14 LL=1,ND
      EDMG(LL,I,J,K)=B(NFE2)
   14 NFE2=NFE2+1

   17 CONTINUE

C  WAIT FOR SEND COMPLETION

$MPI      CALL MPI_WAITALL (M2,IREQ,ISTATS,IERR)

      IF (IERR.GT.0) THEN
         NER1=4
         NER2=M2
         GO TO 13
      ENDIF

  20  CONTINUE

C  EXITS

      RETURN

   13 WRITE (*,*) ' MSG ERROR',IERR,' IN PEMGWP_COFUPDG FOR PROC',MYPRC,
     & ', BLOCK',NBLK,', LOC',NER1,', DATA',NER2
      CALL PEMGP_KILLPRC(IERR)

      END
C*********************************************************************
      SUBROUTINE PEMGWP_COFUPDG0(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,
     &           JL2V,KL1,KL2,KEYOUT,NBLK,KEYCR2D,BCOF2D,DCOF2D,
     &           R2D,X2D)
C***********************************************************************
C Updating matrix coefficients of 2d grid node which has
C neighboring fine grid nodes belonging to other processors.
C It actually involves sending the summed coefficients in
C PEMGWP_COFUPDE back to the SOURCE processor.
C This is a PEWORKMG3 routine.
C
C Note: This communication is the same as the usual message updates
C       on the communication layers
C
C  First 12 arguments = Same as the arguments in a gerneral CALLWORK routine
C
C  KEYCR2D(J,K) = KEYOUT VALUE FOR CORNER POINTS ON THE 2D GRID
C
C  BCOF2D(M,L,J,K) = OFF DIAGONAL COEF. OF THE 2D GRID MATRIX
C
C  DCOF2D(L,J,K) = DIAGONAL COEF. OF THE 2D GRID MATRIX
C
C  R2D(L,J,K) = RESIDUALS OF A LINEAR SYSTEM ON THE 2D GRID
C
C  X2D(L,J,K) = UNKNOWN VALUES ON THE 2D GRID
C***********************************************************************
     USE scrat1mod    
  
     PARAMETER (NDB=$MXREAD/8)
$MPI      INCLUDE 'mpif.h'
      INCLUDE 'control.h'
!      INCLUDE 'scrat1.h'
      INCLUDE 'layout.h'
      INCLUDE 'pemulgrd.h'
      INCLUDE 'pemulgrdp.h'
      INCLUDE 'pesolve.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK,
     &        JL1V(KDIM),JL2V(KDIM), KEYOUT(IDIM,JDIM,KDIM),
     &        KEYCR2D(JDIM,KDIM),    KEYCR(IDIM,JDIM,KDIM)
      LOGICAL ZNODE(IDIM,JDIM,KDIM)
      REAL*8  BCOF2D(4,9,JDIM,KDIM),     DCOF2D(6,JDIM,KDIM),
     &        R2D(3,JDIM,KDIM),          X2D(3,JDIM,KDIM)
$MPI      INTEGER IREQ($MXMPP),ISTATS(MPI_STATUS_SIZE,$MXMPP)
$MPI      INTEGER ISTATR(MPI_STATUS_SIZE)
      REAL*8 B(NDB)

      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)' PROC',MYPRC,
     & ' ENTERING SUBROUTINE PEMGWP_COFUPDG0,BLOCK =',NBLK,
     & ', OLD TAG =',MSGTAG($PEMODEL+1)

      NOFF2D=4
      MEQ=PE_MEQ
      NB=MEQ*MEQ
      ND=MEQ*(MEQ-1)

      KTMP=2
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,IERR)
      M2=MSGS(KTMP,NBLK)

      MSGTAG($PEMODEL+1)=MSGTAG($PEMODEL+1)+1
      IF (MSGTAG($PEMODEL+1).GT.MSGTAG2($PEMODEL+1)) THEN
         MSGTAG($PEMODEL+1)=MSGTAG1($PEMODEL+1)
      ENDIF
      IF (M2.LE.0) GO TO 10

C  NONBLOCKING SENDS

      NFE1=1
      DO 2 M=1,M2
      LI1=MSGSNDF(M,KTMP,NBLK)
      LI2=MSGSNDL(M,KTMP,NBLK)
      NFE2=NFE1
      DO 1 L=LI1,LI2
      J=MSGIND(1,L)-JOFF
      K=MSGIND(2,L)-KOFF
      DO 1 LL=1,NB
      DO 1 LLL=1,NOFF2D
      B(NFE2)=BCOF2D(LLL,LL,J,K)
    1 NFE2=NFE2+1

$MPI      CALL MPI_ISEND(B(NFE1),NFE2-NFE1,MPI_DOUBLE_PRECISION,
$MPI     & MSGTRG(M,KTMP,NBLK),MSGTAG($PEMODEL+1),MPI_COMM_WORLD,
$MPI     & IREQ(M),IERR)

      IF (IERR.GT.0) GO TO 13
    2 NFE1=NFE2

C  RECEIVE

      LENM=NDB-NFE1+1
      DO 3 M=1,M2
$MPI      CALL MPI_RECV(B(NFE1),LENM,MPI_DOUBLE_PRECISION,
$MPI     & MPI_ANY_SOURCE,MSGTAG($PEMODEL+1),MPI_COMM_WORLD,
$MPI     & ISTATR,IERR)
$MPI      MS=ISTATR(MPI_SOURCE)

      IF (IERR.GT.0) GO TO 13
      DO 5 MM=1,M2
      IF (MS.EQ.MSGSRC(MM,KTMP,NBLK)) THEN
         LI1=MSGRCVF(MM,KTMP,NBLK)
         LI2=MSGRCVL(MM,KTMP,NBLK)
         GO TO 6
      ENDIF
    5 CONTINUE
      IERR=1
      GO TO 13

    6 NFE2=NFE1
      DO 4 L=LI1,LI2
      J=MSGIND(1,L)-JOFF
      K=MSGIND(2,L)-KOFF
      DO 4 LL=1,NB
      DO 4 LLL=1,NOFF2D
      BCOF2D(LLL,LL,J,K)=B(NFE2)
    4 NFE2=NFE2+1

    3 CONTINUE

C  WAIT FOR SEND COMPLETION

$MPI      CALL MPI_WAITALL (M2,IREQ,ISTATS,IERR)

      IF (IERR.GT.0) THEN
         NER1=4
         NER2=M2
         GO TO 13
      ENDIF

C FOR DIAGONAL COEFFICIENTS

      MSGTAG($PEMODEL+1)=MSGTAG($PEMODEL+1)+1
      IF (MSGTAG($PEMODEL+1).GT.MSGTAG2($PEMODEL+1)) THEN
          MSGTAG($PEMODEL+1)=MSGTAG1($PEMODEL+1)
      ENDIF
      IF (M2.LE.0) GO TO 10

C  NONBLOCKING SENDS

      NFE1=1
      DO 12 M=1,M2
      LI1=MSGSNDF(M,KTMP,NBLK)
      LI2=MSGSNDL(M,KTMP,NBLK)
      NFE2=NFE1
      DO 11 L=LI1,LI2
      J=MSGIND(1,L)-JOFF
      K=MSGIND(2,L)-KOFF
      DO 11 LL=1,ND
      B(NFE2)=DCOF2D(LL,J,K)
   11 NFE2=NFE2+1

$MPI      CALL MPI_ISEND(B(NFE1),NFE2-NFE1,MPI_DOUBLE_PRECISION,
$MPI     & MSGTRG(M,KTMP,NBLK),MSGTAG($PEMODEL+1),MPI_COMM_WORLD,
$MPI     & IREQ(M),IERR)

      IF (IERR.GT.0) GO TO 13
   12 NFE1=NFE2

C  RECEIVE

      LENM=NDB-NFE1+1
      DO 14 M=1,M2
$MPI      CALL MPI_RECV(B(NFE1),LENM,MPI_DOUBLE_PRECISION,
$MPI     & MPI_ANY_SOURCE,MSGTAG($PEMODEL+1),MPI_COMM_WORLD,
$MPI     & ISTATR,IERR)
$MPI      MS=ISTATR(MPI_SOURCE)

      IF (IERR.GT.0) GO TO 13
      DO 15 MM=1,M2
      IF (MS.EQ.MSGSRC(MM,KTMP,NBLK)) THEN
         LI1=MSGRCVF(MM,KTMP,NBLK)
         LI2=MSGRCVL(MM,KTMP,NBLK)
         GO TO 16
      ENDIF
   15 CONTINUE
      IERR=1
      GO TO 13
   16 NFE2=NFE1
      DO 17 L=LI1,LI2
      J=MSGIND(1,L)-JOFF
      K=MSGIND(2,L)-KOFF
      DO 17 LL=1,ND
      DCOF2D(LL,J,K)=B(NFE2)

   17 NFE2=NFE2+1

   14 CONTINUE

C  WAIT FOR SEND COMPLETION

$MPI      CALL MPI_WAITALL (M2,IREQ,ISTATS,IERR)

   10 CONTINUE

C  EXITS

      RETURN

   13 WRITE (*,*) ' MESSAGE ERROR',IERR,' IN PEMGWP_COFUPDG0 FOR PROC'
     & ,MYPRC,', BLOCK',NBLK,', LOC',NER1,', DATA',NER2

$MPI        CALL PEMGP_KILLPRC()
      STOP 13

      END
C*********************************************************************
      SUBROUTINE PEMGWP_DISPUPD0(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,
     &           JL2V,KL1,KL2,KEYOUT,NBLK,KEYCR2D,BCOF2D,DCOF2D,
     &           R2D,X2D)
C***********************************************************************
C  Porelastic model update routine for multigrid solver on 2d grid.
C  Exchanges communication layer data for 1 fault block and 1 REAL*8 array.
C  This is PEWORKMG0 routine.
C
C  First 12 arguments = Same as the arguments in a gerneral CALLWORK routine 
C
C  KEYCR2D(J,K) = KEYOUT VALUE FOR CORNER POINTS ON THE 2D GRID
C 
C  BCOF2D(M,L,J,K) = OFF DIAGONAL COEF. OF THE 2D GRID MATRIX
C
C  DCOF2D(L,J,K) = DIAGONAL COEF. OF THE 2D GRID MATRIX
C
C  R2D(L,J,K) = RESIDUALS OF A LINEAR SYSTEM ON THE 2D GRID
C
C  X2D(L,J,K) = UNKNOWN VALUES ON THE 2D GRID
C***********************************************************************
      USE scrat1mod
  
      PARAMETER (NDB=$MXREAD/8)
$MPI      INCLUDE 'mpif.h'
      INCLUDE 'control.h'
!      INCLUDE 'scrat1.h'
      INCLUDE 'layout.h'
      INCLUDE 'pemulgrd.h'
      INCLUDE 'pemulgrdp.h'
      INCLUDE 'pesolve.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK,
     &        JL1V(KDIM),JL2V(KDIM), KEYOUT(IDIM,JDIM,KDIM),
     &        KEYCR2D(*),            KEYCR(IDIM*JDIM*KDIM)
      LOGICAL ZNODE(IDIM*JDIM*KDIM)
      REAL*8  BCOF2D(4,9,*),             DCOF2D(6,*),
     &        R2D(3,JDIM,KDIM),          X2D(3,JDIM,KDIM)
$MPI      INTEGER IREQ($MXMPP),ISTATS(MPI_STATUS_SIZE,$MXMPP)
$MPI      INTEGER ISTATR(MPI_STATUS_SIZE)
      REAL*8 B(NDB)

      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)' PROC',MYPRC,
     & ' ENTERING SUBROUTINE PEMGWP_DISPUPD0,BLOCK =',NBLK,
     & ', OLD TAG =',MSGTAG($PEMODEL+1)

      MEQ=PE_MEQ
      KTMP=2
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,KERR)
      M2=MSGS(KTMP,NBLK)

      MSGTAG($PEMODEL+1)=MSGTAG($PEMODEL+1)+1
      IF (MSGTAG($PEMODEL+1).GT.MSGTAG2($PEMODEL+1)) THEN
         MSGTAG($PEMODEL+1)=MSGTAG1($PEMODEL+1)
      ENDIF
      IF (M2.LE.0) GO TO 10

C  NONBLOCKING SENDS

      NFE1=1
      DO 2 M=1,M2
      LI1=MSGSNDF(M,KTMP,NBLK)
      LI2=MSGSNDL(M,KTMP,NBLK)
      NFE2=NFE1
      DO 1 L=LI1,LI2
      J=MSGIND(1,L)-JOFF
      K=MSGIND(2,L)-KOFF
c     IF(MOD(J,2).NE.KRBJ.OR.MOD(K,2).NE.KRBK) GO TO 1
      DO 21 LL=1,MEQ
      B(NFE2)=X2D(LL,J,K)
   21 NFE2=NFE2+1
    1 CONTINUE

$MPI      CALL MPI_ISEND(B(NFE1),NFE2-NFE1,MPI_DOUBLE_PRECISION,
$MPI     & MSGTRG(M,KTMP,NBLK),MSGTAG($PEMODEL+1),MPI_COMM_WORLD,
$MPI     & IREQ(M),IERR)

      IF (IERR.GT.0) GO TO 13
    2 NFE1=NFE2

C  RECEIVE

      LENM=NDB-NFE1+1
      DO 3 M=1,M2
$MPI      CALL MPI_RECV(B(NFE1),LENM,MPI_DOUBLE_PRECISION,
$MPI     & MPI_ANY_SOURCE,MSGTAG($PEMODEL+1),MPI_COMM_WORLD,
$MPI     & ISTATR,IERR)
$MPI      MS=ISTATR(MPI_SOURCE)

      IF (IERR.GT.0) GO TO 13
      DO 5 MM=1,M2
      IF (MS.EQ.MSGSRC(MM,KTMP,NBLK)) THEN
         LI1=MSGRCVF(MM,KTMP,NBLK)
         LI2=MSGRCVL(MM,KTMP,NBLK)
         GO TO 6
      ENDIF
    5 CONTINUE
      IERR=1
      GO TO 13

    6 NFE2=NFE1
      DO 4 L=LI1,LI2
      J=MSGIND(1,L)-JOFF
      K=MSGIND(2,L)-KOFF
c     IF(MOD(J,2).NE.KRBJ.OR.MOD(K,2).NE.KRBK) GO TO 4
       DO 41 LL=1,MEQ
      X2D(LL,J,K)=B(NFE2)
   41 NFE2=NFE2+1
   4  CONTINUE

    3 CONTINUE

C  WAIT FOR SEND COMPLETION

$MPI      CALL MPI_WAITALL (M2,IREQ,ISTATS,IERR)

      IF (IERR.GT.0) THEN
         NER1=4
         NER2=M2
         GO TO 13
      ENDIF

   10 CONTINUE

      RETURN

   13 WRITE (*,*) ' MESSAGE ERROR',IERR,' IN PEMGP_DISPUPD0 FOR PROC',
     & MYPRC,', BLOCK',NBLK,', LOC',NER1,', DATA',NER2
$MANY      CALL PEMGP_KILLPRC(IERR)


      END
C***********************************************************************
      SUBROUTINE PEMGWP_RESUPDE(MGLV,NBLK,IDMG,JDMG,KDMG,IMG1,IMG2,
     &              JMG1,JMG2,KMG1,KMG2,DXMG,DYMG,DZMG,KEYMG,KEYCRMG,
     &              EZNMG,EMDMG,EPSMG,EBMG,EDMG,ERMG,EUNKMG)
C***********************************************************************
C Transfers coarse grid residuals of the nodes, which are on
C a processor''s receiving message list in both standard and extended
C communication layers, to its SOURCE processors.
C Processors which receive the messages will add a transfered value
C to the original value on the same node.
C This is a PEWORKMG3 routine.
C
C Note: This communication is different from the usual message updates
C       on the communication layers, which are from SOURCE processors
C       to target processors.
C
C Arrays involved in message passing:
C
C   ERMG(L,I,J,K) = RESIDUALS ON A 2D COARSE GRID      
C***********************************************************************
      USE scrat1mod

      INCLUDE 'control.h'
!      INCLUDE 'scrat1.h'
      INCLUDE 'layout.h'
      INCLUDE 'pemulgrd.h'
      INCLUDE 'pemulgrdp.h'
      INCLUDE 'pesolve.h'
$MPI      INCLUDE 'mpif.h'

      INTEGER MGLV,NBLK,IDMG,JDMG,KDMG,IMG1,IMG2,JMG1,JMG2,KMG1,KMG2,
     &        KEYMG(IDMG,JDMG,KDMG),    KEYCRMG(IDMG,JDMG,KDMG)
      LOGICAL EZNMG(IDMG,JDMG,KDMG)
      REAL*8  DXMG(IDMG),DYMG(JDMG),    DZMG(KDMG),
     &        EMDMG(IDMG,JDMG,KDMG),    EPSMG(IDMG,JDMG,KDMG),
     &        EBMG(*),                  EDMG(*),
     &        ERMG(3,IDMG,JDMG,KDMG),   EUNKMG(3,IDMG,JDMG,KDMG)
      PARAMETER (NDB=$MXREAD/8)
      REAL*8 B(NDB)
$MPI      INTEGER IREQ($MXMPP),ISTATS(MPI_STATUS_SIZE,$MXMPP)
$MPI      INTEGER ISTATR(MPI_STATUS_SIZE)

      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)' PROC',MYPRC,
     & ' ENTERING SUBROUTINE PEMGWP_RESUPDE,BLOCK =',NBLK,
     & ', OLD TAG =',MSGTAG($PEMODEL+1)

      MEQ=PE_MEQ
      M2=PEMSGSMGE(MGLV,NBLK)
      MR2=PEMSGRMGE(MGLV,NBLK)

      MSGTAG($PEMODEL+1)=MSGTAG($PEMODEL+1)+1
      IF (MSGTAG($PEMODEL+1).GT.MSGTAG2($PEMODEL+1)) THEN
         MSGTAG($PEMODEL+1)=MSGTAG1($PEMODEL+1)
      ENDIF

      NFE1=1
      DO 2 M=1,MR2
      LI1=PEMSGRCVFMGE(M,MGLV,NBLK)
      LI2=PEMSGRCVLMGE(M,MGLV,NBLK)
      NFE2=NFE1
      DO 1 L=LI1,LI2
      J=PEMSGINDMGE(1,L,MGLV)-PEJOFFMG(MGLV,NBLK)
      K=PEMSGINDMGE(2,L,MGLV)-PEKOFFMG(MGLV,NBLK)
      DO 1 I=1,IDMG
      DO 1 LL=1,MEQ
      B(NFE2)=ERMG(LL,I,J,K)
    1 NFE2=NFE2+1

$MPI      CALL MPI_ISEND(B(NFE1),NFE2-NFE1,MPI_DOUBLE_PRECISION,
$MPI     &PEMSGSRCMGE(M,MGLV,NBLK),MSGTAG($PEMODEL+1),MPI_COMM_WORLD,
$MPI     &IREQ(M),IERR)

      IF (IERR.GT.0) GO TO 13
    2 NFE1=NFE2

C  RECEIVE

      LENM=NDB-NFE1+1
      DO 3 M=1,M2

$MPI      CALL MPI_RECV(B(NFE1),LENM,MPI_DOUBLE_PRECISION,
$MPI     & MPI_ANY_SOURCE,MSGTAG($PEMODEL+1),MPI_COMM_WORLD,
$MPI     & ISTATR,IERR)
$MPI      MS=ISTATR(MPI_SOURCE)

      IF (IERR.GT.0) GO TO 13
      DO 5 MM=1,M2
      IF (MS.EQ.PEMSGTRGMGE(MM,MGLV,NBLK)) THEN
         LI1=PEMSGSNDFMGE(MM,MGLV,NBLK)
         LI2=PEMSGSNDLMGE(MM,MGLV,NBLK)
         GO TO 6
      ENDIF
    5 CONTINUE
      IERR=1
      GO TO 13

    6 NFE2=NFE1
      DO 4 L=LI1,LI2
      J=PEMSGINDMGE(1,L,MGLV)-PEJOFFMG(MGLV,NBLK)
      K=PEMSGINDMGE(2,L,MGLV)-PEKOFFMG(MGLV,NBLK)
      DO 4 I=1,IDMG
      DO 4 LL=1,MEQ
      ERMG(LL,I,J,K)=ERMG(LL,I,J,K)+B(NFE2)
    4 NFE2=NFE2+1

    3 CONTINUE

C  WAIT FOR SEND COMPLETION

$MPI      CALL MPI_WAITALL (M2,IREQ,ISTATS,IERR)

      IF (IERR.GT.0) THEN
         NER1=4
         NER2=M2
         GO TO 13
      ENDIF
  10  CONTINUE

C  EXITS

      RETURN

   13 WRITE (*,*) ' MSG ERROR',IERR,' IN RESUPDE FOR PROC',MYPRC,
     & ', BLOCK',NBLK,', LOC',NER1,', DATA',NER2
      CALL PEMGP_KILLPRC(IERR)

      END

C***********************************************************************
      SUBROUTINE PEMGWP_DISPUPDE(MGLV,NBLK,IDMG,JDMG,KDMG,IMG1,IMG2,
     &              JMG1,JMG2,KMG1,KMG2,DXMG,DYMG,DZMG,KEYMG,KEYCRMG,
     &              EZNMG,EMDMG,EPSMG,EBMG,EDMG,ERMG,EUNKMG)
C***********************************************************************
C Updates displacement variables on the extended communication layers.
C This is a PEWORKMG3 routine.
C
C Note: This communication is the same as the usual message updates
C       on the communication layers.
C
C Arrays involved in message passing:
C
C   EUNKMG(L,I,J,K) = UNKNOWN VALUES ON A 2D COARSE GRID
C***********************************************************************
      USE scrat1mod
    
      INCLUDE 'control.h'
!      INCLUDE 'scrat1.h'
      INCLUDE 'layout.h'
      INCLUDE 'pemulgrd.h'
      INCLUDE 'pemulgrdp.h'
      INCLUDE 'pesolve.h'
$MPI      INCLUDE 'mpif.h'

      INTEGER MGLV,NBLK,IDMG,JDMG,KDMG,IMG1,IMG2,JMG1,JMG2,KMG1,KMG2,
     &        KEYMG(IDMG,JDMG,KDMG),    KEYCRMG(IDMG,JDMG,KDMG)
      LOGICAL EZNMG(IDMG,JDMG,KDMG)
      REAL*8  DXMG(IDMG),DYMG(JDMG),    DZMG(KDMG),
     &        EMDMG(IDMG,JDMG,KDMG),    EPSMG(IDMG,JDMG,KDMG),
     &        EBMG(*),                  EDMG(*),
     &        ERMG(3,IDMG,JDMG,KDMG),   EUNKMG(3,IDMG,JDMG,KDMG)
      PARAMETER (NDB=$MXREAD/8)
      REAL*8 B(NDB)
$MPI      INTEGER IREQ($MXMPP),ISTATS(MPI_STATUS_SIZE,$MXMPP)
$MPI      INTEGER ISTATR(MPI_STATUS_SIZE)

      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)' PROC',MYPRC,
     & ' ENTERING SUBROUTINE PEMGWP_DISPUPDE,BLOCK =',NBLK,
     & ', OLD TAG =',MSGTAG($PEMODEL+1)

      MEQ=PE_MEQ
      M2=PEMSGSMGE(MGLV,NBLK)
      MR2=PEMSGRMGE(MGLV,NBLK)

      MSGTAG($PEMODEL+1)=MSGTAG($PEMODEL+1)+1
      IF (MSGTAG($PEMODEL+1).GT.MSGTAG2($PEMODEL+1)) THEN
         MSGTAG($PEMODEL+1)=MSGTAG1($PEMODEL+1)
      ENDIF

C FOR OFFDIAGONAL COEFFICIENTS

      NFE1=1
      DO 2 M=1,M2
      LI1=PEMSGSNDFMGE(M,MGLV,NBLK)
      LI2=PEMSGSNDLMGE(M,MGLV,NBLK)
      NFE2=NFE1
      DO 1 L=LI1,LI2
      J=PEMSGINDMGE(1,L,MGLV)-PEJOFFMG(MGLV,NBLK)
      K=PEMSGINDMGE(2,L,MGLV)-PEKOFFMG(MGLV,NBLK)
      DO 1 I=1,IDMG
      DO 1 LL=1,MEQ
      B(NFE2)=EUNKMG(LL,I,J,K)
    1 NFE2=NFE2+1

$MPI      CALL MPI_ISEND(B(NFE1),NFE2-NFE1,MPI_DOUBLE_PRECISION,
$MPI     &PEMSGTRGMGE(M,MGLV,NBLK),MSGTAG($PEMODEL+1),MPI_COMM_WORLD,
$MPI     &IREQ(M),IERR)

      IF (IERR.GT.0) GO TO 13
    2 NFE1=NFE2

C  RECEIVE

      LENM=NDB-NFE1+1
      DO 3 M=1,MR2
$MPI      CALL MPI_RECV(B(NFE1),LENM,MPI_DOUBLE_PRECISION,
$MPI     & MPI_ANY_SOURCE,MSGTAG($PEMODEL+1),MPI_COMM_WORLD,
$MPI     & ISTATR,IERR)
$MPI      MS=ISTATR(MPI_SOURCE)

      IF (IERR.GT.0) GO TO 13
      DO 5 MM=1,MR2
      IF (MS.EQ.PEMSGSRCMGE(MM,MGLV,NBLK)) THEN
         LI1=PEMSGRCVFMGE(MM,MGLV,NBLK)
         LI2=PEMSGRCVLMGE(MM,MGLV,NBLK)
         GO TO 6
      ENDIF
    5 CONTINUE
      IERR=1
      GO TO 13

    6 NFE2=NFE1
      DO 4 L=LI1,LI2
      J=PEMSGINDMGE(1,L,MGLV)-PEJOFFMG(MGLV,NBLK)
      K=PEMSGINDMGE(2,L,MGLV)-PEKOFFMG(MGLV,NBLK)
      DO 4 I=1,IDMG
      DO 4 LL=1,MEQ
      EUNKMG(LL,I,J,K)=B(NFE2)
    4 NFE2=NFE2+1

    3 CONTINUE

C  WAIT FOR SEND COMPLETION

$MPI      CALL MPI_WAITALL (M2,IREQ,ISTATS,IERR)

      IF (IERR.GT.0) THEN
         NER1=4
         NER2=M2
         GO TO 13
      ENDIF

 10   CONTINUE

C  EXITS

      RETURN

   13 WRITE (*,*) ' MSG ERROR',IERR,' IN DISPUPDE FOR PROC',MYPRC,
     & ', BLOCK',NBLK,', LOC',NER1,', DATA',NER2
      CALL PEMGP_KILLPRC(IERR)

      END

C***********************************************************************
      SUBROUTINE PEMGWP_ZNODUPDE(MGLV,NBLK,IDMG,JDMG,KDMG,IMG1,IMG2,
     &              JMG1,JMG2,KMG1,KMG2,DXMG,DYMG,DZMG,KEYMG,
     &              KEYCRMG,EZNMG,EMDMG,EPSMG,EBMG,EDMG,ERMG,EUNKMG)
C***********************************************************************
C Routine updates zero_node values in the extended communication layers.
C This is PEWORKMG3 routine
C***********************************************************************
      USE scrat1mod

      INCLUDE 'control.h'
!      INCLUDE 'scrat1.h'
      INCLUDE 'layout.h'
      INCLUDE 'pemulgrd.h'
      INCLUDE 'pemulgrdp.h'
      INCLUDE 'pesolve.h'
$MPI      INCLUDE 'mpif.h'

      INTEGER MGLV,NBLK,IDMG,JDMG,KDMG,IMG1,IMG2,JMG1,JMG2,KMG1,KMG2,
     &        KEYMG(IDMG,JDMG,KDMG),    KEYCRMG(IDMG,JDMG,KDMG)
      LOGICAL EZNMG(IDMG,JDMG,KDMG)
      REAL*8  DXMG(IDMG),DYMG(JDMG),    DZMG(KDMG),
     &        EMDMG(IDMG,JDMG,KDMG),    EPSMG(IDMG,JDMG,KDMG),
     &        EBMG(*),                  EDMG(*),
     &        ERMG(3,IDMG,JDMG,KDMG),   EUNKMG(3,IDMG,JDMG,KDMG)
      PARAMETER (NDB=$MXREAD/8)
      LOGICAL B(NDB)
$MPI      INTEGER IREQ($MXMPP),ISTATS(MPI_STATUS_SIZE,$MXMPP)
$MPI      INTEGER ISTATR(MPI_STATUS_SIZE)

      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)' PROC',MYPRC,
     & ' ENTERING SUBROUTINE PEMGWP_ZNODUPDE,BLOCK =',NBLK,
     & ', OLD TAG =',MSGTAG($PEMODEL+1)

      MEQ=PE_MEQ
      M2=PEMSGSMGE(MGLV,NBLK)
      MR2=PEMSGRMGE(MGLV,NBLK)

      MSGTAG($PEMODEL+1)=MSGTAG($PEMODEL+1)+1
      IF (MSGTAG($PEMODEL+1).GT.MSGTAG2($PEMODEL+1)) THEN
         MSGTAG($PEMODEL+1)=MSGTAG1($PEMODEL+1)
      ENDIF

      NFE1=1
      DO 2 M=1,M2
      LI1=PEMSGSNDFMGE(M,MGLV,NBLK)
      LI2=PEMSGSNDLMGE(M,MGLV,NBLK)
      NFE2=NFE1
      DO 1 L=LI1,LI2
      J=PEMSGINDMGE(1,L,MGLV)-PEJOFFMG(MGLV,NBLK)
      K=PEMSGINDMGE(2,L,MGLV)-PEKOFFMG(MGLV,NBLK)
      DO 1 I=1,IDMG
      B(NFE2)=EZNMG(I,J,K)
    1 NFE2=NFE2+1

$MPI      CALL MPI_ISEND(B(NFE1),NFE2-NFE1,MPI_DOUBLE_PRECISION,
$MPI     &PEMSGTRGMGE(M,MGLV,NBLK),MSGTAG($PEMODEL+1),MPI_COMM_WORLD,
$MPI     &IREQ(M),IERR)

      IF (IERR.GT.0) GO TO 13
    2 NFE1=NFE2

C  RECEIVE

      LENM=NDB-NFE1+1
      DO 3 M=1,MR2
$MPI      CALL MPI_RECV(B(NFE1),LENM,MPI_DOUBLE_PRECISION,
$MPI     & MPI_ANY_SOURCE,MSGTAG($PEMODEL+1),MPI_COMM_WORLD,
$MPI     & ISTATR,IERR)
$MPI      MS=ISTATR(MPI_SOURCE)

      IF (IERR.GT.0) GO TO 13
      DO 5 MM=1,MR2
      IF (MS.EQ.PEMSGSRCMGE(MM,MGLV,NBLK)) THEN
         LI1=PEMSGRCVFMGE(MM,MGLV,NBLK)
         LI2=PEMSGRCVLMGE(MM,MGLV,NBLK)
         GO TO 6
      ENDIF
    5 CONTINUE
      IERR=1
      GO TO 13

    6 NFE2=NFE1
      DO 4 L=LI1,LI2
      J=PEMSGINDMGE(1,L,MGLV)-PEJOFFMG(MGLV,NBLK)
      K=PEMSGINDMGE(2,L,MGLV)-PEKOFFMG(MGLV,NBLK)
      DO 4 I=1,IDMG
      EZNMG(I,J,K)=B(NFE2)
    4 NFE2=NFE2+1

    3 CONTINUE

C  WAIT FOR SEND COMPLETION

$MPI      CALL MPI_WAITALL (M2,IREQ,ISTATS,IERR)
      IF (IERR.GT.0) THEN
         NER1=4
         NER2=M2
         GO TO 13
      ENDIF

C  EXITS

      RETURN

   13 WRITE (*,*) ' MSG ERROR',IERR,' IN PEMGWP_ZNODUPD FOR PROC',
     & MYPRC,', BLOCK',NBLK,', LOC',NER1,', DATA',NER2
      CALL PEMGP_KILLPRC(IERR)

      END
C*********************************************************************
      SUBROUTINE PEMGP_NOUPD (NBLK,IV1,IV2)
C*********************************************************************

C  Steps MSGTAG if no update data is to be transmitted
C  This routine is called only by PEMGP_UPDATE

C*********************************************************************
      INCLUDE 'control.h'

      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)' PROC',MYPRC,
     & ' ENTERING SUBROUTINE PEMGP_NOUPD, BLOCK =',NBLK,
     & ', OLD TAG =',MSGTAG($PEMODEL+1)

      IV1A=IV1
      IF (IV1A.LT.1) IV1A=1

      DO 1 I=IV1A,IV2

      MSGTAG($PEMODEL+1)=MSGTAG($PEMODEL+1)+1
      IF (MSGTAG($PEMODEL+1).GT.MSGTAG2($PEMODEL+1)) THEN
         MSGTAG($PEMODEL+1)=MSGTAG1($PEMODEL+1)
      ENDIF

    1 CONTINUE

      END
C*********************************************************************
      SUBROUTINE PEMGP_KILLPRC (NERR)
C*********************************************************************

C  Routine terminates a multiprocessor simulation.

C*********************************************************************
      INCLUDE 'control.h'
$MPI      INCLUDE 'mpif.h'

      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)' PROC',MYPRC,
     & ' ENTERING SUBROUTINE PEMGP_KILLPRC'

c      IF (NERR.EQ.0) CALL WAITALL()

$MPI      IERR=0
$MPI      CALL MPI_FINALIZE(IERR)

      IF (NERR.EQ.0) THEN
         STOP 0
      ELSE
         STOP 13
      ENDIF

      END

C***********************************************************************
C                END OF FILE PEMANY.DF
C***********************************************************************
