C POROELASTIC.F 
C ROUTINES IN THIS FILE:
C
C     SUBROUTINE TRACTION_3D(NERR)
C
C     SUBROUTINE TRACTION_3DW(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
C                KL1,KL2,KEYOUT,NBLK,MODUL,ERESID,BD_VAL)
C
C     SUBROUTINE DISPLACEMENT_3D(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
C                KL1,KL2,KEYOUT,NBLK,KEYOUT_CR,EDIAG,EBEFORE,ERESID,
C                ZERO_NODE)
C
C     SUBROUTINE DISPLACEMENT_ZERO(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,
C                JL2V,KL1,KL2,KEYOUT,NBLK,KEYOUT_CR,ERESID,ZERO_NODE)
C
C     SUBROUTINE ADD_PRESS_3D(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
C                KL1,KL2,KEYOUT,NBLK,EPCONN,ERESID,PREF,PRESS)
C
C     SUBROUTINE BODY3D_3PH(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
C                KL2,KEYOUT,NBLK,BODY_FORCE,ROCK_WEIGHT,PV,DUNK,SAT1,SAT2)
C
C     SUBROUTINE BODY3D_1PH(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
C                KL2,KEYOUT,NBLK,BODY_FORCE,ROCK_WEIGHT,PV,DUNK)
C
C     SUBROUTINE ADD_BODY3D(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
C                KL1,KL2,KEYOUT,NBLK,BODY_FORCE,DIR_COS,ERESID)
C
C     SUBROUTINE ELASTIC3D_SUBTRACT(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,
C                JL2V,KL1,KL2,KEYOUT,NBLK,KEYOUT_CR,ZERO_NODE,EDIAG,
C                RHS,EBEFORE,EDISP)
C
C     SUBROUTINE INITIAL_STRESS_3D(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,
C                JL2V,KL1,KL2,KEYOUT,NBLK,MODUL,STRXX_INIT,STRYY_INIT
C                STRZZ_INIT,FORCE_INIT)
C
C     SUBROUTINE SUBTRACT_FINIT3D(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
C                KL1,KL2,KEYOUT,NBLK,KEYOUT_CR,ERESID,FORCE_INIT)
C
C     SUBROUTINE PEUPSOL(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                KEYOUT,NBLK,KEYOUT_CR,EDISP,VARD)
C
C     SUBROUTINE AVERAGE_DISP(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
C                KL1,KL2,KEYOUT,NBLK,EDISP,AVGDISP)
C
C     SUBROUTINE AVERAGE_STRAIN(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
C                KL1,KL2,KEYOUT,NBLK,EDISP,AVGSTRN)
C
C     SUBROUTINE AVERAGE_STRESS(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
C                KL1,KL2,KEYOUT,NBLK,MODUL,POISS,BIOTA,STRXX_INIT,
C                STRYY_INIT,STRZZ_INIT,PREF,AVGSTRN,PRESS)
C
C     SUBROUTINE STRESS_3D(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                KEYOUT,NBLK,KEYCR,MODUL,POISS,BIOTA,STRXX_INIT,BIOTA
C                STRXX_INIT,STRYY_INIT,STRZZ_INIT,EDISP,PREF,PRESS,
C                STRESS,INTEG)
C
C     SUBROUTINE EFFECTIVE_STRESS(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
C                KL1,KL2,KEYOUT,NBLK,BIOTA,STRESS,PRESS,PREF)
C
C
C     SUBROUTINE EFFEC_MEAN_STRESS(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
C                KL1,KL2,KEYOUT,NBLK,MODUL,POISS,BIOTA,STRXX_INIT,
C                STRYY_INIT,STRZZ_INIT,AVGSTRN,EMSTRESS)
C
C      
C     SUBROUTINE INITEMSTRESS(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
C                KL1,KL2,KEYOUT,NBLK,STRXX_INIT,STRYY_INIT,STRZZ_INIT)
C
C     SUBROUTINE PEUPPERM(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                KEYOUT,NBLK,TYPE,PARA,ARRAY1,ARRAY2,XPERM,YPERM,ZPERM)
C CODE HISTORY:
C     XIULI      05/10/2001
C     Bin Wang   
C*********************************************************************
      SUBROUTINE TRACTION_3D(NERR)
C*********************************************************************
C Call work routine to compute residuals due to tractions on the 
C boundary faces
C
C  NERR = ERROR KEY STEPPED BY ONE FOR EACH ERROR
C         (INPUT AND OUTPUT, INTEGER)
C*********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'pearydat.h'
      INCLUDE 'pemodel.h'
      INCLUDE 'pebdary.h'

      INTEGER NERR
       
      INTEGER IBD,JTRAC(4)
      EXTERNAL TRACTION_3DW
      
      JTRAC(1)=3
      JTRAC(2)=N_MODUL
      JTRAC(3)=N_ERESID
      DO IBD=1,6
         IF (N_BDARY(IBD).GT.0) THEN
            NERRC = 0
            JTRAC(4)=N_BDARY(IBD)
            IFACE=IBD
            CALL CALLWORK(TRACTION_3DW,JTRAC)
         ENDIF
      ENDDO  
      
      END
C*********************************************************************
      SUBROUTINE TRACTION_3DW(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &                       KL1,KL2,KEYOUT,NBLK,MODUL,ERESID,BD_VAL)
C*********************************************************************
C Applies trcation boundary condition for 3D rectangle grid
C
C INPUT:
C   MODUL(I,J,K) = LAME''S CONSTANT LAMBDA (PSI)
C   BD_VAL(L) = TRACTION VALUE ON THE BOUNDARIES (PSI)
C  
C OUTPUT:
C   ERESID(I,J,K) = RESIDUALS OF THE FORCE BALANCE EQUATION
C*********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
   
      INCLUDE 'pemodel.h'
      INCLUDE 'pebdary.h'
   
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM), KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  MODUL(IDIM,JDIM,KDIM), ERESID(IDIM,JDIM,KDIM,3)
      REAL*8  BD_VAL(*)
     
      INTEGER I1,I2,I3,K,L,LOC,JL1,JL2,IOFF,JOFF,KOFF,KERR,NBP
      REAL*8  DX,DY,DZ,U,U1,ZERO,UNITS_CONVERT,QUARTER
      PARAMETER(ZERO=0.0D0, QUARTER=0.25D0)
       
cbw      IF(.NOT.IBD_FACE(IFACE,NBLK)) RETURN
      IF(.NOT.DP_FACE(IFACE,NBLK)) RETURN

      UNITS_CONVERT = QUARTER/(CONV_INCHES*CONV_INCHES)
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,KERR)
      
      GO TO (1,2,3,4,5,6) IFACE
     
C SET UP -X SIDE OF THE RECTANGLE

   1  NBP = JDIM*KDIM
      DO K = 1,3
         IF(ITYPE_BOUNDARY(1,K,NBLK).NE.4) GOTO 21
         DO I3 = KL1-1,KL2+1
            IF(I3.EQ.KL1-1) THEN
               JL1=JL1V(KL1)
cbw               JL2=JL2V(KL1)
               JL2=JL2V(KL1)+1
            ELSE IF(I3.LT.KL2) THEN
cbw               JL1=MIN(JL1V(I3),JL1V(I3+1))
cbw               JL2=MAX(JL2V(I3),JL2V(I3+1))
               JL1=MIN(JL1V(I3-1),JL1V(I3),JL1V(I3+1))
               JL2=MAX(JL2V(I3-1),JL2V(I3),JL2V(I3+1))+1
            ELSE
               JL1 = JL1V(KL2)
               JL2 = JL2V(KL2)+1
            ENDIF
cbw            DZ = DZREC(I3 + KOFF, NBLK)
            DO I2 = JL1-1,JL2
cbw               DY = DYREC(I2 + JOFF, NBLK)
               DO I1 = IL1,IL2
               IF(KEYOUT(I1,I2,I3).NE.0.AND.
     &                             KEYOUT(I1-1,I2,I3).EQ.0) THEN
                  IF(MODUL(I1,I2,I3).GT.ZERO) THEN 
                     DZ = DZREC(I3 + KOFF, NBLK)
                     DY = DYREC(I2 + JOFF, NBLK)
                     U = UNITS_CONVERT * DY * DZ
                     L = I1
                     LOC = (K - 1) * NBP + (I3 - 1) * JDIM + I2
                     U1 = U * BD_VAL(LOC)
                     ERESID(L,I2,I3,K)=ERESID(L,I2,I3,K)+U1
                     ERESID(L,I2+1,I3,K)=ERESID(L,I2+1,I3,K)+U1
                     ERESID(L,I2,I3+1,K)=ERESID(L,I2,I3+1,K) + U1
                     ERESID(L,I2+1,I3+1,K)=ERESID(L,I2+1,I3+1,K)+U1  
                  ENDIF
                  GO TO 11
               ENDIF
               ENDDO
  11           CONTINUE
            ENDDO
         ENDDO
  21     CONTINUE
      ENDDO
      GO TO 20

C SET UP +X SIDE OF THE RECTANGLE

   2  NBP= JDIM * KDIM
      DO K = 1,3
         IF(ITYPE_BOUNDARY(2,K,NBLK).NE.4) GOTO 22
         DO I3 = KL1-1,KL2+1
            IF(I3.EQ.(KL1-1)) THEN
               JL1=JL1V(KL1)
cbw               JL2=JL2V(KL1)
               JL2=JL2V(KL1)+1
            ELSE IF(I3.LT.KL2) THEN
cbw               JL1=MIN(JL1V(I3),JL1V(I3+1))
cbw               JL2=MAX(JL2V(I3),JL2V(I3+1))
               JL1=MIN(JL1V(I3-1),JL1V(I3),JL1V(I3+1))
               JL2=MAX(JL2V(I3-1),JL2V(I3),JL2V(I3+1))+1
            ELSE
               JL1 = JL1V(KL2)
               JL2 = JL2V(KL2)+1
            ENDIF
cbw            DZ = DZREC(I3 + KOFF, NBLK)
            DO I2 = JL1-1,JL2
cbw               DY = DYREC(I2 + JOFF, NBLK)
               DO I1 = IL2,IL1,-1
               IF(KEYOUT(I1,I2,I3).NE.0.AND.
     &                             KEYOUT(I1+1,I2,I3).EQ.0) THEN  
                  IF(MODUL(I1,I2,I3).GT.ZERO) THEN
                     DZ = DZREC(I3 + KOFF, NBLK)
                     DY = DYREC(I2 + JOFF, NBLK)
                     U = UNITS_CONVERT * DY * DZ
                     L = I1 + 1
                     LOC = (K - 1) * NBP + (I3 - 1) * JDIM + I2
                     U1 = U * BD_VAL(LOC)
                     ERESID(L,I2,I3,K)=ERESID(L,I2,I3,K)+U1
                     ERESID(L,I2+1,I3,K)=ERESID(L,I2+1,I3,K)+U1
                     ERESID(L,I2,I3+1,K)=ERESID(L,I2,I3+1,K)+U1
                     ERESID(L,I2+1,I3+1,K)=ERESID(L,I2+1,I3+1,K)+U1
                  ENDIF
                  GO TO 12
               ENDIF
               ENDDO
  12           CONTINUE
            ENDDO
         ENDDO
  22     CONTINUE
      ENDDO
      GO TO 20

C SET UP -Y SIDES OF RECTANGLE

   3  NBP = IDIM * KDIM
      DO K = 1,3
         IF(ITYPE_BOUNDARY(3,K,NBLK).NE.4) GOTO 23
         DO I3 = KL1-1,KL2+1
            IF(I3.EQ.(KL1-1)) THEN
               JL1=JL1V(KL1)
cbw               JL2=JL2V(KL1)
               JL2=JL2V(KL1)+1
            ELSE IF(I3.LT.KL2) THEN
               JL1=MIN(JL1V(I3-1),JL1V(I3),JL1V(I3+1))
               JL2=MAX(JL2V(I3-1),JL2V(I3),JL2V(I3+1))+1
            ELSE
               JL1 = MIN(JL1V(KL2-1),JL1V(KL2))
               JL2 = MAX(JL2V(KL2-1),JL2V(KL2))+1
cbw            ELSE
cbw               JL1 = JL1V(I3)
cbw               JL2 = JL2V(I3)
            ENDIF
cbw            DZ = DZREC(I3 + KOFF, NBLK)
            DO I1 = IL1,IL2
cbw               DX = DXREC(I1 + IOFF, NBLK)
               DO I2 = JL1,JL2
               IF(KEYOUT(I1,I2,I3).NE.0.AND.
     &                             KEYOUT(I1,I2-1,I3).EQ.0) THEN
                  IF(MODUL(I1,I2,I3).GT.ZERO) THEN  
                     DZ = DZREC(I3 + KOFF, NBLK)
                     DX = DXREC(I1 + IOFF, NBLK)
                     U = UNITS_CONVERT * DX * DZ
                     L = I2 
                     LOC = (K - 1) * NBP + (I3 - 1) * IDIM + I1
                     U1 = U * BD_VAL(LOC)
                     ERESID(I1,L,I3,K)=ERESID(I1,L,I3,K)+U1 
                     ERESID(I1+1,L,I3,K)=ERESID(I1+1,L,I3,K)+U1
                     ERESID(I1,L,I3+1,K)=ERESID(I1,L,I3+1,K)+U1 
                     ERESID(I1+1,L,I3+1,K)=ERESID(I1+1,L,I3+1,K)+U1
                  ENDIF
                  GO TO 13
               ENDIF
               ENDDO
  13           CONTINUE
            ENDDO
         ENDDO
  23     CONTINUE
      ENDDO
      GO TO 20

C SET UP +Y SIDES OF RECTANGLE

   4  NBP = IDIM * KDIM
      DO K = 1,3
         IF(ITYPE_BOUNDARY(4,K,NBLK).NE.4) GOTO 24
         DO I3 = KL1-1,KL2+1
            IF(I3.EQ.KL1-1) THEN
              JL1=JL1V(KL1)-1
cbw              JL2=JL2V(KL1)
              JL2=JL2V(KL1)
            ELSE IF(I3.LT.KL2) THEN
               JL1=MIN(JL1V(I3-1),JL1V(I3),JL1V(I3+1))-1
               JL2=MAX(JL2V(I3-1),JL2V(I3),JL2V(I3+1))
            ELSE
               JL1 = MIN(JL1V(KL2-1),JL1V(KL2))-1
               JL2 = MAX(JL2V(KL2-1),JL2V(KL2))
cbw            ELSE
cbw              JL1 = JL1V(I3)-1
cbw              JL2 = JL2V(I3)
            ENDIF
cbw            DZ = DZREC(I3 + KOFF, NBLK)
            DO I1 = IL1,IL2
cbw               DX = DXREC(I1 + IOFF, NBLK)
               DO I2 = JL2,JL1,-1
               IF(KEYOUT(I1,I2,I3).NE.0.AND.
     &                             KEYOUT(I1,I2+1,I3).EQ.0) THEN
                  IF(MODUL(I1,I2,I3).GT.ZERO) THEN
                     DZ = DZREC(I3 + KOFF, NBLK)
                     DX = DXREC(I1 + IOFF, NBLK)
                     U = UNITS_CONVERT * DX * DZ
                     L = I2 + 1
                     LOC = (K - 1) * NBP + (I3 - 1) * IDIM + I1
                     U1 = U * BD_VAL(LOC)
                     ERESID(I1,L,I3,K)=ERESID(I1,L,I3,K)+U1
                     ERESID(I1+1,L,I3,K)=ERESID(I1+1,L,I3,K)+U1
                     ERESID(I1,L,I3+1,K)=ERESID(I1,L,I3+1,K)+U1
                     ERESID(I1+1,L,I3+1,K)=ERESID(I1+1,L,I3+1,K)+U1
                  ENDIF
                  GO TO 14
               ENDIF
               ENDDO
  14           CONTINUE
            ENDDO
         ENDDO
  24     CONTINUE
      ENDDO
      GO TO 20

C SET UP -Z SIDES OF RECTANGLE

   5  NBP = IDIM * JDIM
      DO K = 1,3
         IF(ITYPE_BOUNDARY(5,K,NBLK).NE.4) GOTO 25
cbw         DO I2 = 1,JDIM 
         DO I2 = $LAYERY,JDIM-$LAYERY+1
cbw            DY = DYREC(I2 + JOFF, NBLK)
            DO I1 = IL1,IL2
cbw               DX = DXREC(I1 + IOFF, NBLK)
               DO I3 = KL1,KL2+1
cbw               IF(KEYOUT(I1,I2,I3).EQ.1.AND.
               IF(KEYOUT(I1,I2,I3).NE.0.AND.
     &                             KEYOUT(I1,I2,I3-1).EQ.0) THEN
                  IF(MODUL(I1,I2,I3).GT.ZERO) THEN
                     DY = DYREC(I2 + JOFF, NBLK)
                     DX = DXREC(I1 + IOFF, NBLK)
                     U = UNITS_CONVERT * DX * DY
                     L = I3
                     LOC = (K - 1) * NBP + (I2 - 1) * IDIM + I1
                     U1 = U * BD_VAL(LOC)
                     ERESID(I1,I2,L,K)=ERESID(I1,I2,L,K)+U1
                     ERESID(I1+1,I2,L,K)=ERESID(I1+1,I2,L,K)+U1
                     ERESID(I1,I2+1,L,K)=ERESID(I1,I2+1,L,K)+U1
                     ERESID(I1+1,I2+1,L,K)=ERESID(I1+1,I2+1,L,K)+U1 
                  ENDIF
                  GO TO 15
               ENDIF
               ENDDO
  15           CONTINUE
            ENDDO
         ENDDO
  25     CONTINUE
      ENDDO
      GO TO 20

C SET UP +Z SIDE OF RECTANGLE

   6  NBP = IDIM * JDIM
      DO K = 1,3
         IF(ITYPE_BOUNDARY(6,K,NBLK).NE.4) GOTO 26
cbw         DO I2 = 1,JDIM 
         DO I2 = $LAYERY,JDIM-$LAYERY+1
cbw            DY = DYREC(I2 + JOFF, NBLK)
            DO I1 = IL1,IL2
cbw               DX = DXREC(I1 + IOFF, NBLK)
               DO I3 = KL2,KL1-1,-1
cbw               IF(KEYOUT(I1,I2,I3).EQ.1.AND.
               IF(KEYOUT(I1,I2,I3).NE.0.AND.
     &                             KEYOUT(I1,I2,I3+1).EQ.0) THEN
                  IF(MODUL(I1,I2,I3).GT.ZERO) THEN
                     DY = DYREC(I2 + JOFF, NBLK)
                     DX = DXREC(I1 + IOFF, NBLK)
                     U = UNITS_CONVERT * DX * DY               
                     L = I3 + 1
                     LOC = (K - 1) * NBP + (I2 - 1) * IDIM + I1
                     U1 = U * BD_VAL(LOC)
                     ERESID(I1,I2,L,K)=ERESID(I1,I2,L,K)+U1
                     ERESID(I1+1,I2,L,K)=ERESID(I1+1,I2,L,K)+U1
                     ERESID(I1,I2+1,L,K)=ERESID(I1,I2+1,L,K)+U1
                     ERESID(I1+1,I2+1,L,K)=ERESID(I1+1,I2+1,L,K)+U1
                  ENDIF
                  GO TO 16
               ENDIF
               ENDDO
   16          CONTINUE
            ENDDO
         ENDDO
   26    CONTINUE
      ENDDO
   20 CONTINUE

      END
C*********************************************************************
      SUBROUTINE DISPLACEMENT_3D(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &           KL1,KL2,KEYOUT,NBLK,KEYOUT_CR,EDIAG,EBEFORE,ERESID,
     &           ZERO_NODE,
     &           EDISP,BDVAL1,BDVAL2,BDVAL3,BDVAL4,BDVAL5,BDVAL6)
C*********************************************************************
C Enforces zero displacement boundary conditions for 3D
C Modifies residuals and stiffness matrix coefficients
C
C INPUT:
C   KEYOUT_CR(J) = KEYOUT VALUES FOR CORNER POINTS
C   ZERO_NODE(J) = FLAG OF WHETHER ELASTICITY CALCULATION APPLIES
C
C OUTPUT:
C   EDIAG(L,J) = DIAGONAL COEF. OF GLOBAL STIFFNESS MATRIX
C   EBEFORE(L,K,J) = OFF DIAGONAL COEF. OF GLOBAL STIFFNESS MATRIX 
C   ERESID(J,L) = RESIDUALS
C*********************************************************************
      INCLUDE 'control.h'
      
      INCLUDE 'pemodel.h'
      INCLUDE 'pebdary.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(*),KEYOUT_CR(*)
      REAL*8  EDIAG(6,*),EBEFORE(9,13,*),ERESID(IDIM*JDIM*KDIM,3)
      LOGICAL ZERO_NODE(*)

      INTEGER I,J,K,I1,I2,I3,N1P,N2P,N12P,N123P,JL1,JL2,IOF,JOF,KOF
      INTEGER L1,L2,K1,M1,LL(4,3)
      LOGICAL BD_NODE
      DATA    LL /2,3,1,1,2,5,2,4,3,5,3,7/
      REAL*8  ZERO
      PARAMETER(ZERO = 0.0D0)
CBW
      INTEGER LOOP
      REAL*8  BDVAL1(*),BDVAL2(*),BDVAL3(*),BDVAL4(*),BDVAL5(*),
     &        BDVAL6(*),EDISP(IDIM*JDIM*KDIM,3)
      INTEGER NBP,LOFF,OFFSET(2,4),INDEX,NEIGH,ELEM,TOTL,III,JJJ,KKK
      INTEGER NODE

      DATA    OFFSET /-1,-1, 0,-1, -1,0, 0,0/
CBW
      N1P = IDIM 
      N2P = JDIM    
      N12P = N1P * N2P
      N123P = N12P * KDIM
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,KERR)

CBW
      TOTL = 1.D-15
CBW

C SET UP -X SIDE OF RECTANGLE
    
      DO L = 1,3
         NBP = JDIM*KDIM
         LOFF = (L-1)*NBP*4
         IF(DP_FACE(1,NBLK).AND.ITYPE_BOUNDARY(1,L,NBLK).LE.2) THEN
            L1 = LL(1,L)
            L2 = LL(2,L)
            K1 = LL(3,L)
            M1 = LL(4,L)
            KOF = (KL1 - 3) * N12P
            DO I3 = KL1-1,KL2 + 2
               IF(I3.EQ.KL1-1) THEN
                  JL1=JL1V(KL1-1)
                  JL2=JL2V(KL1-1)
               ELSE IF(I3.GE.KL2+1) THEN
                  JL1=JL1V(KL2)
                  JL2=JL2V(KL2)
               ELSE
                  JL1=MIN(JL1V(I3),JL1V(I3-1),JL1V(I3+1))
                  JL2=MAX(JL2V(I3),JL2V(I3-1),JL2V(I3+1))
               ENDIF
               KOF = KOF + N12P
               JOF = KOF + (JL1 - 3) * N1P  
               DO I2 = JL1-1,JL2 + 2
                  JOF = JOF + N1P    
                  J = JOF + IL1 - 1
                  DO I1 = IL1,IL2
                     J = J + 1   
                     BD_NODE=.FALSE.
                     IF(KEYOUT(J).NE.0.AND.KEYOUT(J-1).EQ.0) 
     &                  BD_NODE=.TRUE.
                     IF(KEYOUT(J).EQ.0.AND.KEYOUT_CR(J).NE.0)
     &                  BD_NODE=.TRUE.
                     IF(BD_NODE) THEN
                        ERESID(J,L) = ZERO
                        EDIAG(L1,J) = ZERO
                        EDIAG(L2,J) = ZERO
                        DO K = 1,NDIM_BEFORE
                           EBEFORE(K1,K,J) = ZERO
                           EBEFORE(K1+3,K,J) = ZERO
                           EBEFORE(K1+6,K,J) = ZERO
                        ENDDO
                        DO K = 1,NDIM_BEFORE
                           I = IOFFSET(K,NBLK) + J
                           IF(I.LE.N123P) THEN
                              IF (KEYOUT_CR(I).NE.0) THEN  
                              EBEFORE(M1,K,I) = ZERO
                              EBEFORE(M1+1,K,I) = ZERO
                              EBEFORE(M1+2,K,I) = ZERO
                              ENDIF
                           ENDIF
                        ENDDO
cbw USER-SPECIFIED DISPLACEMENT BOUNDARY CONDITIONS
                        IF (ITYPE_BOUNDARY(1,L,NBLK).EQ.2) THEN
                        IF(KEYOUT_CR(J).EQ.1.AND.EDIAG(1,J).NE.ZERO) 
     &                  THEN
                          DO ELEM = 1,4
                            NODE = 5-ELEM
                            JJJ = I2+OFFSET(1,ELEM)
                            KKK = I3+OFFSET(2,ELEM)
                            NEIGH = (KKK-1)*JDIM+JJJ
                            IF(NEIGH.GT.0) THEN
                              INDEX=LOFF+(NODE-1)*NBP+NEIGH
                              IF(ABS(BDVAL1(INDEX)).GT.TOTL) THEN
                                EDISP(J,L) = BDVAL1(INDEX)
                                GOTO 1
                              ENDIF
                            ENDIF
                          ENDDO
                        ENDIF
                        ENDIF
cbw
                        GO TO 1
                     ENDIF                   
                  ENDDO
   1              CONTINUE
               ENDDO
            ENDDO
         ENDIF
      ENDDO 

C SET UP +X SIDE OF RECTANGLE      

      DO L = 1,3
         NBP = JDIM*KDIM
         LOFF = (L-1)*NBP*4
         IF(DP_FACE(2,NBLK).AND.ITYPE_BOUNDARY(2,L,NBLK).LE.2) THEN
            L1 = LL(1,L)
            L2 = LL(2,L)
            K1 = LL(3,L)
            M1 = LL(4,L)
            KOF = (KL1 - 3) * N12P 
            DO I3 = KL1-1,KL2 + 2
               IF(I3.EQ.KL1-1) THEN
                  JL1=JL1V(KL1-1)
                  JL2=JL2V(KL1-1)
               ELSE IF(I3.GE.KL2+1) THEN
                  JL1=JL1V(KL2)
                  JL2=JL2V(KL2)
               ELSE
                  JL1=MIN(JL1V(I3),JL1V(I3-1),JL1V(I3+1))
                  JL2=MAX(JL2V(I3),JL2V(I3-1),JL2V(I3+1))
               ENDIF
               KOF = KOF + N12P
               JOF = KOF + (JL1 - 3) * N1P 
               DO I2 = JL1-1,JL2 + 2 
                  JOF = JOF + N1P
                  J = JOF + IL2 + 2
                  DO I1= IL2+1,IL1,-1
                     J = J - 1
                     BD_NODE=.FALSE.
                     IF(KEYOUT(J).EQ.0.AND.KEYOUT_CR(J).NE.0) 
     &                  BD_NODE=.TRUE. 
                     IF(BD_NODE) THEN
                        ERESID(J,L) = ZERO
                        EDIAG(L1,J) = ZERO
                        EDIAG(L2,J) = ZERO
                        DO K = 1,NDIM_BEFORE
                           EBEFORE(K1,K,J) = ZERO
                           EBEFORE(K1+3,K,J) = ZERO
                           EBEFORE(K1+6,K,J) = ZERO
                        ENDDO
                        DO K = 1,NDIM_BEFORE
                           I = IOFFSET(K,NBLK) + J
                           IF(I.LE.N123P) THEN
                              IF(KEYOUT_CR(I).NE.0) THEN   
                              EBEFORE(M1,K,I) = ZERO
                              EBEFORE(M1+1,K,I) = ZERO
                              EBEFORE(M1+2,K,I) = ZERO
                              ENDIF
                           ENDIF
                        ENDDO
cbw USER-SPECIFIED DISPLACEMENT BOUNDARY CONDITIONS
                        IF (ITYPE_BOUNDARY(2,L,NBLK).EQ.2) THEN
                        IF(KEYOUT_CR(J).EQ.1.AND.EDIAG(1,J).NE.ZERO) 
     &                  THEN
                          DO ELEM = 1,4
                            NODE = 5-ELEM
                            JJJ = I2+OFFSET(1,ELEM)
                            KKK = I3+OFFSET(2,ELEM)
                            NEIGH = (KKK-1)*JDIM+JJJ
                            IF(NEIGH.GT.0) THEN
                              INDEX=LOFF+(NODE-1)*NBP+NEIGH
                              IF(ABS(BDVAL2(INDEX)).GT.TOTL) THEN
                                EDISP(J,L) = BDVAL2(INDEX)
                                GOTO 2
                              ENDIF
                            ENDIF
                          ENDDO
                        ENDIF
                        ENDIF
cbw
                        GO TO 2
                     ENDIF
                  ENDDO
   2              CONTINUE
               ENDDO
            ENDDO 
         ENDIF
      ENDDO      

C SET UP -Y SIDE OF RECTANGLE    

      DO L = 1,3
         NBP = IDIM*KDIM
         LOFF = (L-1)*NBP*4
         IF(DP_FACE(3,NBLK).AND.ITYPE_BOUNDARY(3,L,NBLK).LE.2) THEN
            L1 = LL(1,L)
            L2 = LL(2,L)
            K1 = LL(3,L)
            M1 = LL(4,L)
            KOF = (KL1 - 3) * N12P
            DO I3 = KL1-1,KL2 + 2
cbw
               IF (I3.EQ.(KL1-1)) THEN
                  JL2=JL2V(I3)+2
               ELSE
                  JL2 = JL2V(I3)+2
               ENDIF
cbw
cbw               IF(I3.EQ.(KL1-1)) THEN
cbw                  JL1=JL1V(KL1)
cbw                  JL2=JL2V(KL1)
cbw               ELSE IF(I3.LT.KL2) THEN
cbw                  JL1=MIN(JL1V(I3),JL1V(I3+1))
cbw                  JL2=MAX(JL2V(I3),JL2V(I3+1))
cbw               ELSE
cbw                  JL1=JL1V(KL2)
cbw                  JL2=JL2V(KL2)
cbw               ENDIF
               KOF = KOF + N12P
               IOF = KOF + IL1 - 1
               DO I1 = IL1,IL2 + 1
                  IOF = IOF + 1
                  J = IOF - N1P
                  DO I2 = 1,JL2
                     J = J + N1P
                     BD_NODE = .FALSE.
cbw
                     IF (I2.GT.1) THEN
                        IF(KEYOUT(J).EQ.0.AND.KEYOUT(J-N1P).NE.0) THEN
                           GOTO 3
                        ENDIF
                        IF(KEYOUT(J).NE.0.AND.KEYOUT(J-N1P).EQ.0)
     &                     BD_NODE = .TRUE.
                     ENDIF
cbw
                     IF(KEYOUT(J).EQ.0.AND.KEYOUT_CR(J).NE.0)
     &                  BD_NODE = .TRUE.
                     IF(BD_NODE) THEN
                        ERESID(J,L) = ZERO
                        EDIAG(L1,J) = ZERO
                        EDIAG(L2,J) = ZERO
                        DO K = 1,NDIM_BEFORE
                           EBEFORE(K1,K,J) = ZERO
                           EBEFORE(K1+3,K,J) = ZERO
                           EBEFORE(K1+6,K,J) = ZERO
                        ENDDO
                        DO K = 1,NDIM_BEFORE
                           I = IOFFSET(K,NBLK) + J
                           IF(I.LE.N123P) THEN
                              IF(KEYOUT_CR(I).NE.0) THEN
                              EBEFORE(M1,K,I) = ZERO
                              EBEFORE(M1+1,K,I) = ZERO
                              EBEFORE(M1+2,K,I) = ZERO
                              ENDIF
                           ENDIF
                        ENDDO
cbw USER-SPECIFIED DISPLACEMENT BOUNDARY CONDITIONS
                        IF (ITYPE_BOUNDARY(3,L,NBLK).EQ.2) THEN
                        IF(KEYOUT_CR(J).EQ.1.AND.EDIAG(1,J).NE.ZERO) 
     &                  THEN
                          DO ELEM = 1,4
                            NODE = 5-ELEM
                            III = I1+OFFSET(1,ELEM)
                            KKK = I3+OFFSET(2,ELEM)
                            NEIGH = (KKK-1)*IDIM+III
                            IF(NEIGH.GT.0) THEN
                              INDEX=LOFF+(NODE-1)*NBP+NEIGH
                              IF(ABS(BDVAL3(INDEX)).GT.TOTL) THEN
                                EDISP(J,L) = BDVAL3(INDEX)
                                GOTO 3
                              ENDIF
                            ENDIF
                          ENDDO
                        ENDIF
                        ENDIF
cbw
                        GO TO 3
                     ENDIF
                  ENDDO
   3              CONTINUE
               ENDDO
            ENDDO                      
         ENDIF
      ENDDO
   
C SET UP +Y SIDE OF RECTANGLE      

      DO L = 1,3
         NBP = IDIM*KDIM
         LOFF = (L-1)*NBP*4
         IF(DP_FACE(4,NBLK).AND.ITYPE_BOUNDARY(4,L,NBLK).LE.2) THEN
            L1 = LL(1,L)
            L2 = LL(2,L)
            K1 = LL(3,L)
            M1 = LL(4,L)
            KOF = (KL1 - 3) * N12P
            DO I3 = KL1-1,KL2 + 2
cbw
               IF (I3.EQ.(KL1-1)) THEN
                  JL1 = JL1V(I3)-2
               ELSE
                  JL1 = JL1V(I3)-2
               ENDIF
cbw

cbw               IF(I3.EQ.(KL1-1)) THEN
cbw                  JL1=JL1V(KL1)
cbw                  JL2=JL2V(KL1)
cbw               ELSE IF(I3.LT.KL2) THEN
cbw                  JL1=MIN(JL1V(I3),JL1V(I3+1))
cbw                  JL2=MAX(JL2V(I3),JL2V(I3+1))
cbw               ELSE
cbw                  JL1=JL1V(KL2)
cbw                  JL2=JL2V(KL2)
cbw               ENDIF
               KOF = KOF + N12P
               IOF = KOF + IL1 - 1
               DO I1 = IL1,IL2 + 1
                  IOF = IOF + 1
                  J = IOF + JDIM * N1P
                  DO I2 = JDIM,JL1,-1
                     J = J - N1P
                     BD_NODE = .FALSE.
cbw
                     IF(I2.LT.JDIM) THEN
                        IF(KEYOUT(J).EQ.0.AND.KEYOUT(J+N1P).NE.0) THEN
                           GOTO 4
                        ENDIF
                     ENDIF
cbw
                     IF(KEYOUT(J).EQ.0.AND.KEYOUT_CR(J).NE.0) 
     &                  BD_NODE = .TRUE.
                     IF(BD_NODE) THEN
                        ERESID(J,L) = ZERO
                        EDIAG(L1,J) = ZERO
                        EDIAG(L2,J) = ZERO
                        DO K=1,NDIM_BEFORE
                           EBEFORE(K1,K,J) = ZERO
                           EBEFORE(K1+3,K,J) = ZERO
                           EBEFORE(K1+6,K,J) = ZERO
                        ENDDO
                        DO K = 1,NDIM_BEFORE
                           I = IOFFSET(K,NBLK) + J
                           IF(I.LE.N123P) THEN
                              IF(KEYOUT_CR(I).NE.0) THEN
                              EBEFORE(M1,K,I) = ZERO
                              EBEFORE(M1+1,K,I) = ZERO
                              EBEFORE(M1+2,K,I) = ZERO
                              ENDIF
                           ENDIF
                        ENDDO
cbw USER-SPECIFIED DISPLACEMENT BOUNDARY CONDITIONS
                        IF (ITYPE_BOUNDARY(4,L,NBLK).EQ.2) THEN
                        IF(KEYOUT_CR(J).EQ.1.AND.EDIAG(1,J).NE.ZERO) 
     &                  THEN
                          DO ELEM = 1,4
                            NODE = 5-ELEM
                            III = I1+OFFSET(1,ELEM)
                            KKK = I3+OFFSET(2,ELEM)
                            NEIGH = (KKK-1)*IDIM+III
                            IF(NEIGH.GT.0) THEN
                              INDEX=LOFF+(NODE-1)*NBP+NEIGH
                              IF(ABS(BDVAL4(INDEX)).GT.TOTL) THEN
                                EDISP(J,L) = BDVAL4(INDEX)
                                GOTO 4
                              ENDIF
                            ENDIF
                          ENDDO
                        ENDIF
                        ENDIF
cbw
                        GO TO 4
                     ENDIF
                  ENDDO
   4              CONTINUE
               ENDDO
            ENDDO                                
         ENDIF
      ENDDO

C SET UP -Z SIDE OF RECTANGLE     

      DO L = 1,3
         NBP = IDIM*JDIM
         LOFF = (L-1)*NBP*4
         IF(DP_FACE(5,NBLK).AND.ITYPE_BOUNDARY(5,L,NBLK).LE.2) THEN
            L1 = LL(1,L)
            L2 = LL(2,L)
            K1 = LL(3,L)
            M1 = LL(4,L)
            JOF = - N1P
            DO I2 = 1,JDIM     
               JOF = JOF + N1P
               IOF = JOF + IL1 - 1
               DO I1 = IL1,IL2 + 1
                  IOF = IOF + 1
                  J = IOF + (KL1 - 4) * N12P
                  DO I3 = KL1-2,KL2+2
                     J = J + N12P
                     BD_NODE = .FALSE.
cbw
                     IF (I3.GT.(KL1-2)) THEN
                        IF(KEYOUT(J).EQ.0.AND.KEYOUT(J-N12P).NE.0) THEN
                           GOTO 5
                        ENDIF
                        IF(KEYOUT(J).NE.0.AND.KEYOUT(J-N12P).EQ.0) 
     &                     BD_NODE = .TRUE.
                     ENDIF
cbw
                     IF(KEYOUT(J).EQ.0.AND.KEYOUT_CR(J).NE.0) 
     &                  BD_NODE = .TRUE.
                     IF(BD_NODE) THEN
                        ERESID(J,L) = ZERO 
                        EDIAG(L1,J) = ZERO
                        EDIAG(L2,J) = ZERO
                        DO K = 1,NDIM_BEFORE
                           EBEFORE(K1,K,J) = ZERO
                           EBEFORE(K1+3,K,J) = ZERO
                           EBEFORE(K1+6,K,J) = ZERO
                        ENDDO
                        DO K = 1,NDIM_BEFORE
                           I = IOFFSET(K,NBLK) + J
                           IF(I.LE.N123P) THEN
                              IF(KEYOUT_CR(I).NE.0) THEN
                              EBEFORE(M1,K,I) = ZERO
                              EBEFORE(M1+1,K,I) = ZERO
                              EBEFORE(M1+2,K,I) = ZERO
                              ENDIF
                           ENDIF
                        ENDDO
cbw USER-SPECIFIED DISPLACEMENT BOUNDARY CONDITIONS
                        IF (ITYPE_BOUNDARY(5,L,NBLK).EQ.2) THEN
                        IF(KEYOUT_CR(J).EQ.1.AND.EDIAG(1,J).NE.ZERO) 
     &                  THEN
                          DO ELEM = 1,4
                            NODE = 5-ELEM
                            III = I1+OFFSET(1,ELEM)
                            JJJ = I2+OFFSET(2,ELEM)
                            NEIGH = (JJJ-1)*IDIM+III
                            IF(NEIGH.GT.0) THEN
                              INDEX=LOFF+(NODE-1)*NBP+NEIGH
                              IF(ABS(BDVAL5(INDEX)).GT.TOTL) THEN
                                EDISP(J,L) = BDVAL5(INDEX)
                                GOTO 5
                              ENDIF
                            ENDIF
                          ENDDO
                        ENDIF
                        ENDIF
cbw
                        GO TO 5
                     ENDIF
                  ENDDO
   5              CONTINUE
               ENDDO
            ENDDO
         ENDIF
      ENDDO
      
C SETUP +Z SIDE OF RECTANGLE      

      DO L = 1,3
         NBP = IDIM*JDIM
         LOFF  = (L-1)*NBP*4
         IF(DP_FACE(6,NBLK).AND.ITYPE_BOUNDARY(6,L,NBLK).LE.2) THEN
            L1 = LL(1,L)
            L2 = LL(2,L)
            K1 = LL(3,L)
            M1 = LL(4,L)
            JOF = - N1P
            DO I2 = 1,JDIM        
               JOF = JOF + N1P
               IOF = JOF + IL1 - 1
               DO I1 = IL1,IL2 + 1
                  IOF = IOF + 1
                  J = IOF + (KL2 + 2) * N12P
                  DO I3 = KL2+2,KL1-2,-1
                     J = J - N12P
                     BD_NODE = .FALSE.
cbw
                     IF (I3.LT.(KL2+2)) THEN
                       IF(KEYOUT(J).EQ.0.AND.KEYOUT(J+N12P).NE.0) THEN
                          GOTO 6
                       ENDIF
                     ENDIF
cbw
                     IF(KEYOUT(J).EQ.0.AND.KEYOUT_CR(J).NE.0) 
     &                  BD_NODE = .TRUE.
                     IF(BD_NODE) THEN
                        ERESID(J,L) = ZERO
                        EDIAG(L1,J) = ZERO
                        EDIAG(L2,J) = ZERO
                        DO K = 1,NDIM_BEFORE
                           EBEFORE(K1,K,J) = ZERO
                           EBEFORE(K1+3,K,J) = ZERO
                           EBEFORE(K1+6,K,J) = ZERO
                        ENDDO
                        DO K = 1,NDIM_BEFORE
                           I = IOFFSET(K,NBLK) + J
                           IF(I.LE.N123P) THEN
                              IF(KEYOUT_CR(I).NE.0) THEN
                              EBEFORE(M1,K,I) = ZERO
                              EBEFORE(M1+1,K,I) = ZERO
                              EBEFORE(M1+2,K,I) = ZERO
                              ENDIF
                           ENDIF
                        ENDDO
cbw USER-SPECIFIED DISPLACEMENT BOUNDARY CONDITIONS
                        IF (ITYPE_BOUNDARY(6,L,NBLK).EQ.2) THEN
                        IF(KEYOUT_CR(J).EQ.1.AND.EDIAG(1,J).NE.ZERO) 
     &                  THEN
                          DO ELEM = 1,4
                            NODE = 5-ELEM
                            III = I1+OFFSET(1,ELEM)
                            JJJ = I2+OFFSET(2,ELEM)
                            NEIGH = (JJJ-1)*IDIM+III
                            IF(NEIGH.GT.0) THEN
                              INDEX=LOFF+(NODE-1)*NBP+NEIGH
                              IF(ABS(BDVAL6(INDEX)).GT.TOTL) THEN
                                EDISP(J,L) = BDVAL6(INDEX)
                                GOTO 6
                              ENDIF
                            ENDIF
                          ENDDO
                        ENDIF
                        ENDIF
cbw
                        GO TO 6
                     ENDIF
                  ENDDO
   6              CONTINUE
               ENDDO
            ENDDO
         ENDIF
      ENDDO


      RETURN

C ELIMINATE RIGID BODY DISPLACEMENTS   
      
      IF(MYPRC.NE.0) GO TO 7

cbw
      WRITE(*,*) 'MYPRC =',MYPRC,'IZEROG=',(IZEROG(LOOP),LOOP=1,3)
cbw      return
cbw

      IF(IZEROG(1).LT.0.D0) THEN
         I = 0
         IOF = IL1 - 1
         DO I1 = IL1,IL2 + 1
            IOF = IOF + 1
cbw
            KOF = IOF + (KL1 - 2) * N12P
            DO I3 = KL1,KL2+1
               KOF = KOF + N12P
               JL1 = JL1V(I3)
               JL2 = JL2V(I3)
               J = KOF + (JL1-2)*N1P
               DO I2 = JL1,JL2+1
                  J = J + N1P
cbw
cbw            JOF = IOF - N1P
cbw         DO I2 = 1,JDIM 
cbw            JOF = JOF + N1P
cbw            J = JOF + (KL1 - 2) * N12P
cbw            DO I3 = KL1,KL2 + 1
cbw               J = J + N12P 
                  IF(KEYOUT_CR(J).GT.0.AND.EDIAG(1,J).GT.ZERO) THEN    
                     ERESID(J,1) = ZERO
                     EDIAG(2,J) = ZERO
                     EDIAG(3,J) = ZERO
                     DO K = 1,NDIM_BEFORE
                        EBEFORE(1,K,J) = ZERO
                        EBEFORE(4,K,J) = ZERO
                        EBEFORE(7,K,J) = ZERO
                     ENDDO
                     DO K = 1,NDIM_BEFORE
                        I = IOFFSET(K,NBLK) + J
                        IF(I.LE.N123P.AND.KEYOUT_CR(I).NE.0) THEN
                           EBEFORE(1,K,I) = ZERO
                           EBEFORE(2,K,I) = ZERO
                           EBEFORE(3,K,I) = ZERO
                        ENDIF     
                     ENDDO
                     I = J
                     GOTO 11
                  ENDIF   
               ENDDO
            ENDDO
         ENDDO 
  11     CONTINUE 

         IF(IZEROG(2).LT.0.D0.OR.IZEROG(3).LT.0.D0) THEN
         IF(IZEROG(3).LT.0.D0) THEN
            IOF = IL1 - 1
            DO I1 = IL1,IL2 + 1
               IOF = IOF + 1
cbw               KOF = IOF + (KL2 + 1) * N12P
cbw               DO I3 = KL2 + 1,KL1,-1
               KOF = IOF + (KL1-1)*N12P
               DO I3 = KL1+1,KL2+1    
                  JL1 = JL1V(I3)
                  JL2 = JL2V(I3)
cbw                  KOF = KOF - N12P
                  KOF = KOF + N12P
                  J = KOF + (JL1 - 2) * N1P
                  DO I2 = JL1,JL2 + 1
                     J = J + N1P
                     IF(KEYOUT_CR(J).GT.0) THEN
                        IF(EDIAG(1,J).GT.ZERO.AND.I.NE.J) THEN     
                           ERESID(J,1) = ZERO
                           EDIAG(2,J) = ZERO
                           EDIAG(3,J) = ZERO
                           DO K = 1,NDIM_BEFORE
                              EBEFORE(1,K,J) = ZERO
                              EBEFORE(4,K,J) = ZERO
                              EBEFORE(7,K,J) = ZERO
                           ENDDO
                           DO K = 1,NDIM_BEFORE
                              I = IOFFSET(K,NBLK) + J
                              IF(I.LE.N123P.AND.KEYOUT_CR(I).NE.0) THEN
                                 EBEFORE(1,K,I) = ZERO
                                 EBEFORE(2,K,I) = ZERO
                                 EBEFORE(3,K,I) = ZERO
                              ENDIF
                           ENDDO
                           GOTO 12
                        ENDIF
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO 
  12        CONTINUE 
         ELSE
            IOF = IL1 - 1
            DO I1 = IL1,IL2 + 1
               IOF = IOF + 1
cbw
               KOF = IOF + (KL1 - 2) * N12P
               DO I3 = KL1,KL2+1
                  KOF = KOF + N12P
                  JL1 = JL1V(I3)
                  JL2 = JL2V(I3)
                  J = KOF + (JL1-1)*N1P
                  DO I2 = JL1+1,JL2+1
                     J = J + N1P
cbw
cbw               JOF = IOF + JDIM * N1P
cbw               DO I2 = JDIM,1,-1
cbw                  JOF = JOF - N1P
cbw                  KOF = JOF + (KL1 - 2) * N12P
cbw                  DO I3 = KL1,KL2+1
cbw                     J = KOF + N12P
                     IF(KEYOUT_CR(J).GT.0) THEN
                        IF(EDIAG(1,J).GT.ZERO.AND.I.NE.J) THEN
                           ERESID(J,1) = ZERO
                           EDIAG(2,J) = ZERO
                           EDIAG(3,J) = ZERO
                           DO K = 1,NDIM_BEFORE
                              EBEFORE(1,K,J) = ZERO
                              EBEFORE(4,K,J) = ZERO
                              EBEFORE(7,K,J) = ZERO
                           ENDDO
                           DO K = 1,NDIM_BEFORE
                              I = IOFFSET(K,NBLK) + J
                              IF(I.LE.N123P.AND.KEYOUT_CR(I).NE.0) THEN
                                 EBEFORE(1,K,I) = ZERO
                                 EBEFORE(2,K,I) = ZERO
                                 EBEFORE(3,K,I) = ZERO
                              ENDIF
                           ENDDO
                           GOTO 13
                        ENDIF
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO
  13        CONTINUE 
         ENDIF
         ENDIF
      ENDIF  

      IF(IZEROG(2).LT.0.D0) THEN
         I = 0 
cbw
         IOF = IL1 - 1
         DO I1 = IL1,IL2 + 1
            IOF = IOF + 1
            KOF = IOF + (KL1 - 2) * N12P
            DO I3 = KL1,KL2+1
               KOF = KOF + N12P
               JL1 = JL1V(I3)
               JL2 = JL2V(I3)
               J = KOF + (JL1-2)*N1P
               DO I2 = JL1,JL2+1
                  J = J + N1P
cbw
cbw         JOF = -N1P
cbw         DO I2 = 1,N2P
cbw            JOF = JOF + N1P
cbw            KOF = JOF + (KL1 - 2) * N12P
cbw            DO I3 = KL1,KL2 + 1
cbw               KOF = KOF + N12P
cbw               J = KOF + IL1 - 1
cbw               DO I1 = IL1,IL2 + 1
cbw                  J = J + 1
                  IF(KEYOUT_CR(J).GT.0.AND.EDIAG(1,J).GT.ZERO) THEN
                     ERESID(J,2) = ZERO
                     EDIAG(2,J) = ZERO
                     EDIAG(5,J) = ZERO
                     DO K = 1,NDIM_BEFORE
                        EBEFORE(2,K,J) = ZERO
                        EBEFORE(5,K,J) = ZERO
                        EBEFORE(8,K,J) = ZERO
                     ENDDO
                     DO K = 1,NDIM_BEFORE
                        I = IOFFSET(K,NBLK) + J
                        IF(I.LE.N123P.AND.KEYOUT_CR(I).NE.0) THEN
                           EBEFORE(4,K,I) = ZERO
                           EBEFORE(5,K,I) = ZERO
                           EBEFORE(6,K,I) = ZERO
                        ENDIF
                     ENDDO
                     I = J 
                     GOTO 14
                  ENDIF
               ENDDO
            ENDDO
         ENDDO 
   14    CONTINUE

         IF(IZEROG(1).LT.0.D0.AND.IZEROG(3).LT.0.D0) THEN
cbw
            IOF = IL1
            DO I1 = IL1 + 1,IL2 + 1
               IOF = IOF + 1
               KOF = IOF + (KL1 - 2) * N12P
               DO I3 = KL1,KL2+1
                  KOF = KOF + N12P
                  JL1 = JL1V(I3)
                  JL2 = JL2V(I3)
                  J = KOF + (JL1-2)*N1P
                  DO I2 = JL1,JL2+1
                     J = J + N1P
cbw
cbw            JOF = -N1P      
cbw            DO I2 = 1,N2P
cbw               JOF = JOF + N1P
cbw               IOF = JOF + IL2 + 2
cbw               DO I1 = IL2 + 1,IL1,-1
cbw                  IOF = IOF - 1
cbw                  J = IOF + (KL1 - 2) * N12P
cbw                  DO I3 = KL1,KL2 + 1
cbw                     J = J + N12P
                     IF(KEYOUT_CR(J).GT.0) THEN
                        IF(EDIAG(1,J).GT.ZERO.AND.I.NE.J) THEN
                           ERESID(J,2) = ZERO
                           EDIAG(2,J) = ZERO
                           EDIAG(5,J) = ZERO
                           DO K = 1,NDIM_BEFORE
                              EBEFORE(2,K,J) = ZERO
                              EBEFORE(5,K,J) = ZERO
                              EBEFORE(8,K,J) = ZERO
                           ENDDO
                           DO K = 1,NDIM_BEFORE
                              I = IOFFSET(K,NBLK) + J
                              IF(I.LE.N123P.AND.KEYOUT_CR(I).NE.0) THEN
                                 EBEFORE(4,K,I) = ZERO
                                 EBEFORE(5,K,I) = ZERO
                                 EBEFORE(6,K,I) = ZERO
                              ENDIF
                           ENDDO
                           GOTO 15
                        ENDIF
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO 
  15        CONTINUE
         ENDIF
      ENDIF
      
      IF(IZEROG(3).LT.0.D0) THEN
         I = 0
cbw
         IOF = IL1 - 1
         DO I1 = IL1,IL2 + 1
            IOF = IOF + 1
            KOF = IOF + (KL1 - 2) * N12P
            DO I3 = KL1,KL2+1
               KOF = KOF + N12P
               JL1 = JL1V(I3)
               JL2 = JL2V(I3)
               J = KOF + (JL1-2)*N1P
               DO I2 = JL1,JL2+1
                  J = J + N1P
cbw
cbw         KOF = (KL1 - 2) * N12P
cbw         DO I3 = KL1,KL2 + 1  
cbw            JL1 = JL1V(I3)
cbw            JL2 = JL2V(I3)
cbw            KOF = KOF + N12P
cbw            JOF = KOF + (JL1 - 2) * N1P
cbw            DO I2 = JL1,JL2 + 1
cbw               JOF = JOF + N1P
cbw               J = JOF + IL1 - 1
cbw               DO I1 = IL1,IL2 + 1
cbw                  J = J + 1
                  IF(KEYOUT_CR(J).GT.0.AND.EDIAG(1,J).GT.ZERO) THEN
                     ERESID(J,3) = ZERO
                     EDIAG(3,J) = ZERO
                     EDIAG(5,J) = ZERO
                     DO K = 1,NDIM_BEFORE
                        EBEFORE(3,K,J) = ZERO
                        EBEFORE(6,K,J) = ZERO
                        EBEFORE(9,K,J) = ZERO
                     ENDDO
                     DO K = 1,NDIM_BEFORE
                        I = IOFFSET(K,NBLK) + J
                        IF(I.LE.N123P.AND.KEYOUT_CR(I).NE.0) THEN
                           EBEFORE(7,K,I) = ZERO
                           EBEFORE(8,K,I) = ZERO
                           EBEFORE(9,K,I) = ZERO
                        ENDIF
                     ENDDO
                     I = J
                     GOTO 16
                  ENDIF
               ENDDO
            ENDDO
         ENDDO 
  16     CONTINUE

         IF(IZEROG(2).LT.0.D0) THEN
cbw
            IOF = IL1 - 1
            DO I1 = IL1,IL2 + 1
               IOF = IOF + 1
               KOF = IOF + (KL1 - 2) * N12P
               DO I3 = KL1,KL2+1
                  KOF = KOF + N12P
                  JL1 = JL1V(I3)
                  JL2 = JL2V(I3)
                  J = KOF + (JL1-1)*N1P
                  DO I2 = JL1+1,JL2+1
                     J = J + N1P
cbw
cbw            KOF = (KL1 - 2) * N12P
cbw            DO I3 = KL1,KL2 + 1
cbw               JL1 = JL1V(I3)
cbw               JL2 = JL2V(I3)
cbw               KOF = KOF + N12P
cbw               JOF = KOF + (JL2 + 1) * N1P
cbw               DO I2 = JL2 + 1,JL1,-1
cbw                  JOF = JOF - N1P
cbw                  J = JOF + IL1 - 1
cbw                  DO I1 = IL1,IL2 + 1
cbw                     J = J + 1
                     IF(KEYOUT_CR(J).GT.0) THEN
                        IF(EDIAG(1,J).GT.ZERO.AND.I.NE.J) THEN
                           ERESID(J,3) = ZERO
                           EDIAG(3,J) = ZERO
                           EDIAG(5,J) = ZERO
                           DO K = 1,NDIM_BEFORE
                              EBEFORE(3,K,J) = ZERO
                              EBEFORE(6,K,J) = ZERO
                              EBEFORE(9,K,J) = ZERO
                           ENDDO
                           DO K = 1,NDIM_BEFORE
                              I = IOFFSET(K,NBLK) + J
                              IF(I.LE.N123P.AND.KEYOUT_CR(I).NE.0) THEN
                                 EBEFORE(7,K,I) = ZERO
                                 EBEFORE(8,K,I) = ZERO
                                 EBEFORE(9,K,I) = ZERO
                              ENDIF
                           ENDDO
                           GOTO 17
                        ENDIF
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO 
  17        CONTINUE
         ENDIF
      ENDIF
  7   CONTINUE
  
      END
C*********************************************************************
      SUBROUTINE DISPLACEMENT_ZERO(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,
     &           JL2V,KL1,KL2,KEYOUT,NBLK,KEYOUT_CR,ERESID,ZERO_NODE)
C*********************************************************************
C Enforce zero displacement boundary conditions for 3D rectanglar grid
C Modifies residual and but not matrix coefficients
C
C INPUT:
C   KEYOUT_CR(J) = KEYOUT VALUES FOR CORNER POINTS
C   ZERO_NODE(J) = FLAG OF WHETHER ELASTICITY CALCULATION APPLIES
C
C OUTPUT:
C   ERESID(J,L) = RESIDUALS
C*********************************************************************
      INCLUDE 'control.h'
      INCLUDE 'pemodel.h'
      INCLUDE 'pebdary.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      INTEGER KEYOUT_CR(IDIM,JDIM,KDIM)
      REAL*8  ERESID(IDIM,JDIM,KDIM,3)
      LOGICAL ZERO_NODE(IDIM,JDIM,KDIM)

      INTEGER I,J,K,I1,I2,I3,N1P,N2P,N12P,JL1,JL2
      LOGICAL BD_NODE
      REAL*8  ZERO
      PARAMETER(ZERO = 0.0D0)

      N1P = IDIM 
      N2P = JDIM 
      N12P = N1P * N2P

      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,KERR)

C  SET UP -X SIDE OF RECTANGLE        

      DO K = 1,3
         IF(IBD_FACE(1,NBLK).AND.ITYPE_BOUNDARY(1,K,NBLK).LE.2) THEN
            DO I3 = KL1,KL2 + 1
               JL1 = JL1V(I3)
               JL2 = JL2V(I3)
               DO I2 = JL1,JL2 + 1
                  DO I1 = IL1,IL2 
                     BD_NODE = .FALSE.
                     IF(KEYOUT(I1,I2,I3).GT.0.AND.
     &                  KEYOUT(I1-1,I2,I3).EQ.0)  BD_NODE = .TRUE.
                     IF(KEYOUT(I1,I2,I3).EQ.0.AND.
     &                  KEYOUT_CR(I1,I2,I3).GT.0) BD_NODE = .TRUE.
                     IF(BD_NODE) THEN
                        ERESID(I1,I2,I3,K) = ZERO
                        GO TO 1
                     ENDIF
                  ENDDO
   1              CONTINUE
               ENDDO
            ENDDO
         ENDIF
      ENDDO

C SET UP +X SIDE OF RECTANGLE

      DO K = 1,3
         IF (IBD_FACE(2,NBLK).AND.ITYPE_BOUNDARY(2,K,NBLK).LE.2) THEN
            DO I3 = KL1,KL2 + 1
               JL1 = JL1V(I3)
               JL2 = JL2V(I3)
               DO I2 = JL1,JL2 + 1
                  DO I1 = IL2+1,IL1,-1
                     BD_NODE = .FALSE.
                     IF(KEYOUT(I1,I2,I3).EQ.0.AND.
     &                  KEYOUT_CR(I1,I2,I3).GT.0) BD_NODE = .TRUE.
                     IF(BD_NODE) THEN
                        ERESID(I1,I2,I3,K) = ZERO
                        GO TO 2
                     ENDIF
                  ENDDO
   2              CONTINUE
               ENDDO
            ENDDO
         ENDIF
      ENDDO

C SET UP -Y SIDE OF RECTANGLE      

      DO K = 1,3
         IF(IBD_FACE(3,NBLK).AND.ITYPE_BOUNDARY(3,K,NBLK).LE.2) THEN
            DO I3 = KL1,KL2 + 1
               JL1 = JL1V(I3)
               JL2 = JL2V(I3)
               DO I1 = IL1,IL2 + 1
                  DO I2 = 2,JL2
                     BD_NODE = .FALSE.
cbw
                     IF(KEYOUT(I1,I2,I3).EQ.0.AND.
     &                     KEYOUT(I1,I2-1,I3).NE.0) THEN
                           GOTO 3
                     ENDIF
cbw
                     IF(KEYOUT(I1,I2,I3).NE.0.AND.
     &                  KEYOUT(I1,I2-1,I3).EQ.0)  BD_NODE = .TRUE.
                     IF(KEYOUT(I1,I2,I3).EQ.0.AND.
     &                  KEYOUT_CR(I1,I2,I3).NE.0) BD_NODE = .TRUE.
                     IF(BD_NODE) THEN
                        ERESID(I1,I2,I3,K) = ZERO
                        GO TO 3
                     ENDIF
                  ENDDO
   3              CONTINUE
               ENDDO
            ENDDO
         ENDIF
      ENDDO

C SET UP +Y SIDE OF RECTANGLE     

      DO K = 1,3
         IF(IBD_FACE(4,NBLK).AND.ITYPE_BOUNDARY(4,K,NBLK).LE.2) THEN
            DO I3 = KL1,KL2 + 1
               JL1 = JL1V(I3)
               JL2 = JL2V(I3)
               DO I1 = IL1,IL2 + 1
                  DO I2 = JDIM-1,JL1,-1
                     BD_NODE = .FALSE.
cbw
                     IF(KEYOUT(I1,I2,I3).EQ.0.AND.
     &                     KEYOUT(I1,I2+1,I3).NE.0) THEN
                           GOTO 4
                     ENDIF
cbw
                     IF(KEYOUT(I1,I2,I3).EQ.0.AND.
     &                  KEYOUT_CR(I1,I2,I3).NE.0) BD_NODE = .TRUE.
                     IF(BD_NODE) THEN
                        ERESID(I1,I2,I3,K) = ZERO
                        GO TO 4
                     ENDIF
                 ENDDO
   4             CONTINUE
               ENDDO
            ENDDO
         ENDIF
      ENDDO     

C SET UP -Z SIDE OF RECTANGLE       

      DO K = 1,3
         IF(IBD_FACE(5,NBLK).AND.ITYPE_BOUNDARY(5,K,NBLK).LE.2) THEN
            DO I2 = 1,JDIM         
               DO I1 = IL1,IL2 + 1
                  DO I3 = KL1-2,KL2
                     BD_NODE = .FALSE.
cbw
                     IF (I3.GT.(KL1-2)) THEN
                     IF(KEYOUT(I1,I2,I3).EQ.0.AND.
     &                     KEYOUT(I1,I2,I3-1).NE.0) THEN
                           GOTO 5
                     ENDIF
                     IF(KEYOUT(I1,I2,I3).NE.0.AND.
     &                  KEYOUT(I1,I2,I3-1).EQ.0)  BD_NODE = .TRUE.
                     ENDIF
cbw
                     IF(KEYOUT(I1,I2,I3).EQ.0.AND.
     &                  KEYOUT_CR(I1,I2,I3).NE.0) BD_NODE = .TRUE.
                     IF(BD_NODE) THEN
                        ERESID(I1,I2,I3,K) = ZERO
                        GO TO 5
                     ENDIF
                  ENDDO
   5              CONTINUE
               ENDDO
            ENDDO
         ENDIF
      ENDDO

C SET UP +Z SIDE OF RECTANGLE      
        
      DO K = 1,3
         IF(IBD_FACE(6,NBLK).AND.ITYPE_BOUNDARY(6,K,NBLK).LE.2) THEN
            DO I2 = 1,JDIM        
               DO I1 = IL1, IL2+1
                  DO I3 = KL2+2,KL1,-1
                     BD_NODE = .FALSE.
cbw
                     IF(I3.LT.(KL2+2)) THEN
                     IF(KEYOUT(I1,I2,I3).EQ.0.AND.
     &                     KEYOUT(I1,I2,I3+1).NE.0) THEN
                           GOTO 6
                     ENDIF
                     ENDIF
cbw
                     IF(KEYOUT(I1,I2,I3).EQ.0.AND.
     &                  KEYOUT_CR(I1,I2,I3).NE.0) BD_NODE = .TRUE.
                     IF(BD_NODE) THEN
                        ERESID(I1,I2,I3,K) = ZERO
                        GO TO 6
                     ENDIF
                  ENDDO
   6              CONTINUE
               ENDDO
            ENDDO
         ENDIF
      ENDDO

      RETURN
 
C ELIMINATE RIGID BODY DISPLACEMENTS       

      IF(MYPRC.NE.0) GO TO 7
      IF(IZEROG(1).LT.0.D0) THEN
         I = 0
         J = 0
         K = 0
         DO I1 = IL1,IL2 + 1
            DO I3 = KL1,KL2 + 1
               JL1 = JL1V(I3)
               JL2 = JL2V(I3)
               DO I2 = JL1,JL2 + 1
cbw            DO I2 = 1,N2P
cbw               DO I3 = KL1,KL2 + 1
                  IF(KEYOUT_CR(I1,I2,I3).GT.0.AND.
     &              .NOT.ZERO_NODE(I1,I2,I3)) THEN
                     ERESID(I1,I2,I3,1) = ZERO
                     I = I1
                     J = I2
                     K = I3
                     GOTO 11         
                  ENDIF
               ENDDO
            ENDDO
         ENDDO 
  11     CONTINUE

         IF(IZEROG(2).LT.0.D0.OR.IZEROG(3).LT.0.D0) THEN
         IF(IZEROG(3).LT.0.D0) THEN
            DO I1 = IL1,IL2 + 1
cbw               DO I3 = KL2 + 1,KL1,-1
               DO I3 = KL1 + 1, KL2+1
                  JL1 = JL1V(I3)
                  JL2 = JL2V(I3)
                  DO I2 = JL1,JL2 + 1
                     IF(KEYOUT_CR(I1,I2,I3).GT.0.AND.
     &                 .NOT.ZERO_NODE(I1,I2,I3)) THEN
                        IF(I1.NE.I.OR.I2.NE.J.OR.I3.NE.K) THEN
                           ERESID(I1,I2,I3,1) = ZERO
                           GOTO 12            
                        ENDIF
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO 
   12       CONTINUE
         ELSE
            DO I1 = IL1,IL2 + 1
cbw               DO I2 = JDIM,1,-1
               DO I3 = KL1,KL2+1
                  JL1 = JL1V(I3)
                  JL2 = JL2V(I3)
                  DO I2 = JL1+1,JL2 
                     IF(KEYOUT_CR(I1,I2,I3).GT.0.AND.
     &                 .NOT.ZERO_NODE(I1,I2,I3)) THEN
                        IF(I1.NE.I.OR.I2.NE.J.OR.I3.NE.K) THEN
                           ERESID(I1,I2,I3,1) = ZERO
                           GOTO 13
                        ENDIF
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO 
  13        CONTINUE
         ENDIF
         ENDIF
      ENDIF      

      IF(IZEROG(2).LT.0.D0) THEN
         I = 0
         J = 0
         K = 0
         DO I1 = IL1,IL2 + 1
            DO I3 = KL1,KL2 + 1
               JL1 = JL1V(I3)
               JL2 = JL2V(I3)
               DO I2 = JL1,JL2+1
cbw         DO I2 = 1,JDIM
cbw            DO I3 = KL1,KL2 + 1
cbw               DO I1 = IL1,IL2 + 1
                  IF(KEYOUT_CR(I1,I2,I3).GT.0.AND.
     &              .NOT.ZERO_NODE(I1,I2,I3)) THEN
                     ERESID(I1,I2,I3,2) = ZERO
                     I = I1
                     J = I2
                     K = I3
                     GOTO 14
                  ENDIF
               ENDDO
            ENDDO
         ENDDO 
   14    CONTINUE

         IF(IZEROG(1).LT.0.D0.AND.IZEROG(3).LT.0.D0) THEN
            DO I1 = IL1 + 1,IL2 + 1
               DO I3 = KL1,KL2 + 1
                  JL1 = JL1V(I3)
                  JL2 = JL2V(I3)
                  DO I2 = JL1,JL2+1
cbw               DO I2 = 1,N2P
cbw               DO I1 = IL2 + 1,IL1,-1
cbw                  DO I3 = KL1,KL2 + 1
                     IF(KEYOUT_CR(I1,I2,I3).GT.0.AND.
     &                 .NOT.ZERO_NODE(I1,I2,I3)) THEN
                        IF(I1.NE.I.OR.I2.NE.J.OR.I3.NE.K) THEN
                           ERESID(I1,I2,I3,2) = ZERO
                           GOTO 15
                        ENDIF
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO 
  15        CONTINUE
         ENDIF
      ENDIF

      IF(IZEROG(3).LT.0.D0) THEN
         I = 0
         J = 0
         K = 0
         DO I1 = IL1,IL2 + 1
            DO I3 = KL1,KL2 + 1
               JL1 = JL1V(I3)
               JL2 = JL2V(I3)
               DO I2 = JL1,JL2+1
cbw         DO I3 = KL1,KL2 + 1
cbw           JL1 = JL1V(I3)
cbw           JL2 = JL2V(I3)
cbw           DO I2 = JL1,JL2 + 1
cbw              DO I1 = IL1,IL2 + 1
                 IF(KEYOUT_CR(I1,I2,I3).GT.0.AND.
     &             .NOT.ZERO_NODE(I1,I2,I3)) THEN
                    ERESID(I1,I2,I3,3) = ZERO
                    I = I1
                    J = I2
                    K = I3
                    GOTO 16
                 ENDIF
              ENDDO
           ENDDO
        ENDDO 
  16    CONTINUE

        IF(IZEROG(2).LT.0.D0) THEN
           DO I1 = IL1,IL2 + 1
              DO I3 = KL1,KL2 + 1
                 JL1 = JL1V(I3)
                 JL2 = JL2V(I3)
                 DO I2 = JL1+1,JL2+1
cbw           DO I3 = KL1,KL2 + 1
cbw              JL1 = JL1V(I3)
cbw              JL2 = JL2V(I3)
cbw              DO I2 = JL2 + 1,JL1,-1
cbw                 DO I1 = IL1, IL2 + 1
                    IF(KEYOUT_CR(I1,I2,I3).GT.0.AND.
     &                .NOT.ZERO_NODE(I1,I2,I3)) THEN
                       IF(I1.NE.I.OR.I2.NE.J.OR.I3.NE.K) THEN
                          ERESID(I1,I2,I3,3) = ZERO
                          GOTO 17
                       ENDIF
                    ENDIF
                 ENDDO
              ENDDO
           ENDDO 
  17       CONTINUE
        ENDIF
      ENDIF
   7  CONTINUE

      END

C*********************************************************************     
      SUBROUTINE ADD_PRESS_3D(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &                KL1,KL2,KEYOUT,NBLK,EPCONN,ERESID,PREF,PRESS,
     &                ROCKTHEXP,LAMBDA,MU,TEMPR,TEMPREF,BIOTA)
C*********************************************************************
C Add pressure contribution to elastic residual for 3D rectangular grid
C
C INPUT:
C   EPCONN(M,L,I,J,K)=INTEGRATION COEFFICIENTS FOR VOLUMETRIC STRAINS
C   PREF(I,J,K) = REFERENCE PORE PRESSURE (PSI)
C   PRESS(I,J,K) = PORE PRESSURE (PSI)
C   ROCKTHEXP(I,J,K) = ROCK THERMAL EXPANSION COEFFICIENT
C   LAMBDA(I,J,K) = LAMBDA
C   MU(I,J,K) = MU
C   TEMPR(I,J,K) = CURRENT RESERVOIR TEMPERATURE (F)
C   TEMPREF(I,J,K) = INITIAL RESERVOIR TEMPERATURE (F)
C
C OUTPUT:
C   ERESID(I,J,K,L) = RESIDUALS OF FORCE BALANCE EQUATIONS
C*********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'layout.h'
      INCLUDE 'control.h'
      INCLUDE 'pemodel.h'
$COMP      INCLUDE 'xthermal.h'
 
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),      KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  ERESID(IDIM,JDIM,KDIM,3),   EPCONN(3,8,IDIM,JDIM,KDIM)
      REAL*8  PRESS(IDIM,JDIM,KDIM),      PREF(IDIM,JDIM,KDIM)
      REAL*8  ROCKTHEXP(IDIM,JDIM,KDIM),  LAMBDA(IDIM,JDIM,KDIM)
      REAL*8  MU(IDIM,JDIM,KDIM),         TEMPR(IDIM,JDIM,KDIM)
      REAL*8  TEMPREF(IDIM,JDIM,KDIM),    BIOTA(IDIM,JDIM,KDIM)

      INTEGER I1,I2,I3,I,J,K,JL1,JL2,KL1P,JL1P,IOFF,JOFF,KOFF,KERR
      REAL*8  DELP

C ADD PRESSURE CONTRIBUTION TO GLOBAL STIFFNESS RESIDUAL       

      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,KERR)
      KL1P=KL1-1
      DO I3 = KL1P,KL2+1
         IF(I3.EQ.(KL1-1)) THEN
            JL1=JL1V(KL1-1)
cbw            JL2=JL2V(KL1-1)
            JL2=JL2V(KL1-1)+1
         ELSE IF(I3.LT.KL2) THEN
cbw            JL1=MIN(JL1V(I3),JL1V(I3+1))
cbw            JL2=MAX(JL2V(I3),JL2V(I3+1))
            JL1=MIN(JL1V(I3-1),JL1V(I3),JL1V(I3+1))
            JL2=MAX(JL2V(I3-1),JL2V(I3),JL2V(I3+1))+1
         ELSE
cbw            JL1=JL1V(KL2)
cbw            JL2=JL2V(KL2)
            JL1=MIN(JL1V(KL2-1),JL1V(KL2))
            JL2=MAX(JL2V(KL2-1),JL2V(KL2))+1
         ENDIF
         JL1P=JL1-1
         DO I2 = JL1P,JL2
            DO I1 = IL1,IL2
               I = I1 + 1
               J = I2 + 1
               K = I3 + 1
               IF(KEYOUT(I1,I2,I3).EQ.0) GOTO 1

!BW USE INITIAL PRESSURE AS PRESSURE LOADING
               DELP = BIOTA(I1,I2,I3)
     &                * (PRESS(I1,I2,I3)-PREF(I1,I2,I3))
$COMP               IF (PEFLOW.EQ.$XMODEL .AND. XTHERMAL) THEN
$COMP                  DELP = DELP
$COMP     &                   + ROCKTHEXP(I1,I2,I3)
$COMP     &                   * (3*LAMBDA(I1,I2,I3)+2*MU(I1,I2,I3))
$COMP     &                   * (TEMPR(I1,I2,I3)-TEMPREF(I1,I2,I3))
$COMP               ENDIF
               ERESID(I1,I2,I3,1) = ERESID(I1,I2,I3,1)  
     &                            + EPCONN(1,1,I1,I2,I3) * DELP
               ERESID(I1,I2,I3,2) = ERESID(I1,I2,I3,2) 
     &                            + EPCONN(2,1,I1,I2,I3) * DELP
               ERESID(I1,I2,I3,3) = ERESID(I1,I2,I3,3) 
     &                            + EPCONN(3,1,I1,I2,I3) * DELP

               ERESID(I,I2,I3,1) = ERESID(I,I2,I3,1)
     &                           + EPCONN(1,2,I1,I2,I3) * DELP
               ERESID(I,I2,I3,2) = ERESID(I,I2,I3,2) 
     &                           + EPCONN(2,2,I1,I2,I3) * DELP 
               ERESID(I,I2,I3,3) = ERESID(I,I2,I3,3) 
     &                           + EPCONN(3,2,I1,I2,I3) * DELP 

               ERESID(I1,J,I3,1) = ERESID(I1,J,I3,1) 
     &                           + EPCONN(1,3,I1,I2,I3) * DELP 
               ERESID(I1,J,I3,2) = ERESID(I1,J,I3,2) 
     &                           + EPCONN(2,3,I1,I2,I3) * DELP
               ERESID(I1,J,I3,3) = ERESID(I1,J,I3,3) 
     &                           + EPCONN(3,3,I1,I2,I3) * DELP
     
               ERESID(I,J,I3,1)  = ERESID(I,J,I3,1) 
     &                           + EPCONN(1,4,I1,I2,I3) * DELP
               ERESID(I,J,I3,2)  = ERESID(I,J,I3,2) 
     &                           + EPCONN(2,4,I1,I2,I3) * DELP
               ERESID(I,J,I3,3)  = ERESID(I,J,I3,3) 
     &                           + EPCONN(3,4,I1,I2,I3) * DELP

               ERESID(I1,I2,K,1) = ERESID(I1,I2,K,1)
     &                           + EPCONN(1,5,I1,I2,I3) * DELP
               ERESID(I1,I2,K,2) = ERESID(I1,I2,K,2)
     &                           + EPCONN(2,5,I1,I2,I3) * DELP
               ERESID(I1,I2,K,3) = ERESID(I1,I2,K,3)
     &                           + EPCONN(3,5,I1,I2,I3) * DELP

               ERESID(I,I2,K,1)  = ERESID(I,I2,K,1) 
     &                           + EPCONN(1,6,I1,I2,I3) * DELP
               ERESID(I,I2,K,2)  = ERESID(I,I2,K,2)
     &                           + EPCONN(2,6,I1,I2,I3) * DELP
               ERESID(I,I2,K,3)  = ERESID(I,I2,K,3)
     &                           + EPCONN(3,6,I1,I2,I3) * DELP

               ERESID(I1,J,K,1)  = ERESID(I1,J,K,1) 
     &                           + EPCONN(1,7,I1,I2,I3) * DELP
               ERESID(I1,J,K,2)  = ERESID(I1,J,K,2)
     &                           + EPCONN(2,7,I1,I2,I3) * DELP
               ERESID(I1,J,K,3)  = ERESID(I1,J,K,3)
     &                           + EPCONN(3,7,I1,I2,I3) * DELP

               ERESID(I,J,K,1) = ERESID(I,J,K,1) 
     &                         + EPCONN(1,8,I1,I2,I3) * DELP
               ERESID(I,J,K,2) = ERESID(I,J,K,2) 
     &                         + EPCONN(2,8,I1,I2,I3) * DELP
               ERESID(I,J,K,3) = ERESID(I,J,K,3) 
     &                         + EPCONN(3,8,I1,I2,I3) * DELP

  1            CONTINUE
            ENDDO
         ENDDO
      ENDDO

      END
C*********************************************************************
      SUBROUTINE BODY3D_3PH(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
     &                      KL2,KEYOUT,NBLK,BODY_FORCE,ROCK_WEIGHT,PV,
     &                      EPMD,SAT)
C*********************************************************************
C Compute body force for a three phase flow model
C
C INPUT:
C   ROCK_WEIGHT(I,J,K) = ROCK WEIGHT (LB)
C   PV(I,J,K) = ELEMENT PORE VOLUME (BBL)
C   DUNK(I,J,K,3) = PHASE DENSITIES (LB/BBL)
C   SAT1(I,J,K) = OIL PHASE SATURATION
C   SAT2(I,J,K) = GAS PHASE SATURATION
C
C OUTPUT:
C   BODY_FORCE(I,J,K) = BODY FORCE, FLUID WEIGHT+ROCK WEIGHT (LB)
C*********************************************************************
      INCLUDE 'control.h'

      INCLUDE 'pemodel.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xgendat.h'
      INCLUDE 'xresprop.h'


      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),      KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  ROCK_WEIGHT(IDIM,JDIM,KDIM)
      REAL*8  BODY_FORCE(IDIM,JDIM,KDIM), PV(IDIM,JDIM,KDIM)  
      REAL*8  EPMD(IDIM,JDIM,KDIM,NCINPH), SAT(IDIM,JDIM,KDIM,NPH)

    
      INTEGER I1,I2,I3,IC,LC,IPH
      REAL*8  U0,SATURA,PVOL,MOLWT,PHDEN($MXPHAS)

      U0 = CONV_RESVOL/1000.0D0
      DO I3 = KL1,KL2
         JL1 = JL1V(I3)
         JL2 = JL2V(I3)
         DO I2 = JL1,JL2
            DO I1 = IL1,IL2
               IF(KEYOUT(I1,I2,I3).GT.0) THEN
                  PVOL = PV(I1,I2,I3)
                  DO IPH=1,NPH 
                     PHDEN(IPH) = 0.D0
                     SATURA = SAT(I1,I2,I3,IPH)
                     DO IC=1,NC
                        LC=ICINPH(IC,IPH)
                        IF(LC.EQ. 0) CYCLE
                        IF(IC.EQ.1) THEN
                           MOLWT=WATMOLW
                        ELSE
                           MOLWT=WMOL(IC-1)
                        ENDIF
                        PHDEN(IPH) = PHDEN(IPH) + EPMD(I1,I2,I3,LC)*
     &                               MOLWT
                     ENDDO 
                     BODY_FORCE(I1,I2,I3) = BODY_FORCE(I1,I2,I3) +
     &                    PHDEN(IPH)*SATURA*PVOL
                  ENDDO
                  BODY_FORCE(I1,I2,I3) = BODY_FORCE(I1,I2,I3) +
     &                    ROCK_WEIGHT(I1,I2,I3)
cbw                                         PVOL*SO*DUNK(I1,I2,I3,1)
cbw     &                                 + PVOL*SW*DUNK(I1,I2,I3,2)
cbw     &                                 + PVOL*SG*DUNK(I1,I2,I3,3)*U0
cbw     &                                 + ROCK_WEIGHT(I1,I2,I3)
               ENDIF
            ENDDO
         ENDDO
      ENDDO

      END
C*********************************************************************
      SUBROUTINE BODY3D_1PH(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
     &                      KL2,KEYOUT,NBLK,BODY_FORCE,ROCK_WEIGHT,PV,
     &                      DUNK)
C*********************************************************************
C Compute body force for single phase flow model
C
C INPUT:
C   ROCK_WEIGHT(I,J,K) = ROCK WEIGHT (LB)
C   PV(I,J,K) = ELEMENT PORE VOLUME (BBL)
C   DUNK(I,J,K) = PHASE DENSITY (LB/BBL)
C
C OUTPUT:
C   BODY_FORCE(I,J,K) = BODY FORCE, FLUID WEIGHT+ROCK WEIGHT (LB)
C*********************************************************************
      INCLUDE 'control.h'

      INCLUDE 'pemodel.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),      KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  DUNK(IDIM,JDIM,KDIM),       ROCK_WEIGHT(IDIM,JDIM,KDIM)
      REAL*8  BODY_FORCE(IDIM,JDIM,KDIM), PV(IDIM,JDIM,KDIM)

      INTEGER I1,I2,I3
      REAL*8  U0,PVOL

      U0 = CONV_RESVOL/1000.0D0

      DO I3 = KL1,KL2
         JL1 = JL1V(I3)
         JL2 = JL2V(I3)
         DO I2 = JL1,JL2
            DO I1 = IL1,IL2
               IF(KEYOUT(I1,I2,I3).GT.0) THEN    
                  PVOL = PV(I1,I2,I3)
                  BODY_FORCE(I1,I2,I3) = PVOL*DUNK(I1,I2,I3)
     &                                 + ROCK_WEIGHT(I1,I2,I3)
               ENDIF
            ENDDO
         ENDDO
      ENDDO

      END
C*********************************************************************
      SUBROUTINE ADD_BODY3D(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &                  KL1,KL2,KEYOUT,NBLK,BODY_FORCE,DIR_COS,ERESID)
C*********************************************************************
C Add body force contribution to elastic residual for 
C 3D rectangular grid
C
C INPUT:
C   BODY_FORCE(I,J,K) = BODY FORCE, FLUID WEIGHT+ROCK WEIGHT (LB)
C   DIR_COS(I,J,K) = DIRECTION COSINE
C
C OUTPUT:
C   ERESID(I,J,K,L) = RESIDUALS OF FORCE BALANCE EQUATIONS
C*********************************************************************
      INCLUDE 'control.h'
 
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),    KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  ERESID(IDIM,JDIM,KDIM,3), DIR_COS(IDIM,JDIM,KDIM,3)
      REAL*8  BODY_FORCE(IDIM,JDIM,KDIM)
     
      INTEGER I1,I2,I3,I,J,K,JL1P,KL1P
      REAL*8  EIGHTH,U1,U2,U3
      PARAMETER(EIGHTH = 0.125D0)
      
      KL1P=KL1-1
      DO I3 = KL1P,KL2+1
         IF(I3.EQ.(KL1-1)) THEN
            JL1=JL1V(KL1)
cbw            JL2=JL2V(KL1)
            JL2=JL2V(KL1)+1
         ELSE IF(I3.LT.KL2) THEN
cbw            JL1=MIN(JL1V(I3),JL1V(I3+1))
cbw            JL2=MAX(JL2V(I3),JL2V(I3+1))
            JL1=MIN(JL1V(I3-1),JL1V(I3),JL1V(I3+1))
            JL2=MAX(JL2V(I3-1),JL2V(I3),JL2V(I3+1))+1
         ELSE
cbw            JL1=JL1V(KL2)
cbw            JL2=JL2V(KL2)
            JL1=MIN(JL1V(KL2-1),JL1V(KL2))
            JL2=MAX(JL2V(KL2-1),JL2V(KL2))+1
         ENDIF
         JL1P=JL1-1
         DO I2 = JL1P,JL2
            DO I1 = IL1,IL2
               IF(KEYOUT(I1,I2,I3).EQ.0) GOTO 1
               I = I1 + 1
               J = I2 + 1
               K = I3 + 1
               U1 = EIGHTH * DIR_COS(I1,I2,I3,1) * BODY_FORCE(I1,I2,I3)
               U2 = EIGHTH * DIR_COS(I1,I2,I3,2) * BODY_FORCE(I1,I2,I3)
               U3 = EIGHTH * DIR_COS(I1,I2,I3,3) * BODY_FORCE(I1,I2,I3)
               ERESID(I1,I2,I3,1) = ERESID(I1,I2,I3,1) + U1
               ERESID(I1,I2,I3,2) = ERESID(I1,I2,I3,2) + U2
               ERESID(I1,I2,I3,3) = ERESID(I1,I2,I3,3) + U3
             
               ERESID(I,I2,I3,1) = ERESID(I,I2,I3,1) + U1
               ERESID(I,I2,I3,2) = ERESID(I,I2,I3,2) + U2
               ERESID(I,I2,I3,3) = ERESID(I,I2,I3,3) + U3
          
               ERESID(I1,J,I3,1) = ERESID(I1,J,I3,1) + U1
               ERESID(I1,J,I3,2) = ERESID(I1,J,I3,2) + U2
               ERESID(I1,J,I3,3) = ERESID(I1,J,I3,3) + U3

               ERESID(I,J,I3,1) = ERESID(I,J,I3,1) + U1
               ERESID(I,J,I3,2) = ERESID(I,J,I3,2) + U2
               ERESID(I,J,I3,3) = ERESID(I,J,I3,3) + U3
             
               ERESID(I1,I2,K,1) = ERESID(I1,I2,K,1) + U1
               ERESID(I1,I2,K,2) = ERESID(I1,I2,K,2) + U2
               ERESID(I1,I2,K,3) = ERESID(I1,I2,K,3) + U3
               
               ERESID(I,I2,K,1) = ERESID(I,I2,K,1) + U1
               ERESID(I,I2,K,2) = ERESID(I,I2,K,2) + U2
               ERESID(I,I2,K,3) = ERESID(I,I2,K,3) + U3
              
               ERESID(I1,J,K,1) = ERESID(I1,J,K,1) + U1
               ERESID(I1,J,K,2) = ERESID(I1,J,K,2) + U2
               ERESID(I1,J,K,3) = ERESID(I1,J,K,3) + U3
               
               ERESID(I,J,K,1) = ERESID(I,J,K,1) + U1
               ERESID(I,J,K,2) = ERESID(I,J,K,2) + U2
               ERESID(I,J,K,3) = ERESID(I,J,K,3) + U3
   1           CONTINUE
            ENDDO
         ENDDO
      ENDDO

      END

C********************************************************************
      SUBROUTINE ELASTIC3D_SUBTRACT(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,
     &           JL2V,KL1,KL2,KEYOUT,NBLK,KEYOUT_CR,ZERO_NODE,EDIAG,
     &           RHS,EBEFORE,EDISP)
C*********************************************************************
C Subtracts stiffness times displacement from elastic residals
C RHS=RHS-(EDIAG+EBEFORE)*EDISP
C
C INPUT:
C   KEYOUT_CR(J) = KEYOUT VALUE FOR CORNER POINTS
C   ZERO_NODE(J) = FLAG TO TURN ON/OFF POROELASTIC CALCULATION
C   EDIAG(L,J) = DIAGONAL COEF. OF GLOBAL STIFFNESS MATRIX
C   EBEFORE(L,K,J) = OFF DIAGONAL COEF. OF GLOBAL STIFFNESS MATRIX
C   EDISP(J,L) = NODAL DISPLACEMENTS (IN)
C   RHS(J,L) = RESIDUALS

C OUTPUT:
C   RHS(J,L) = RESIDUALS

C*********************************************************************
      INCLUDE 'control.h'
      INCLUDE 'pemodel.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(*),KEYOUT_CR(*)
      REAL*8  EDIAG(6,*),RHS(IDIM*JDIM*KDIM,3)
      REAL*8  EDISP(IDIM*JDIM*KDIM,3),EBEFORE(9,13,*)
      LOGICAL ZERO_NODE(*)

      INTEGER I1,I2,I3,I,J,K,N1P,N12P,JL1,JL2,KOF,JOF,NOFFSET
      REAL*8  ZERO
      PARAMETER(ZERO = 0.0D0)

      N1P = IDIM
      N12P = JDIM * IDIM
      NOFFSET = NDIM_BEFORE

C CONTRIBUTION FROM DIAGONAL TERMS

      KOF = (KL1 - 2) * N12P
      DO I3 = KL1,KL2+1
         JL1=JL1V(I3)
         JL2=JL2V(I3)
         KOF = KOF + N12P
         JOF = KOF + (JL1 - 2) * N1P
         DO I2 = JL1,JL2 + 1
            JOF = JOF + N1P
            I = JOF + IL1 - 1
            DO I1 = IL1, IL2 + 1
               I = I + 1
               IF(KEYOUT_CR(I).GT.0.AND.EDIAG(1,I).GT.ZERO) THEN
                  RHS(I,1) = RHS(I,1) - EDIAG(1,I) * EDISP(I,1)
     &                                - EDIAG(2,I) * EDISP(I,2)
     &                                - EDIAG(3,I) * EDISP(I,3)
                  RHS(I,2) = RHS(I,2) - EDIAG(2,I) * EDISP(I,1)
     &                                - EDIAG(4,I) * EDISP(I,2)
     &                                - EDIAG(5,I) * EDISP(I,3)
                  RHS(I,3) = RHS(I,3) - EDIAG(3,I) * EDISP(I,1)
     &                                - EDIAG(5,I) * EDISP(I,2)
     &                                - EDIAG(6,I) * EDISP(I,3)
               ENDIF
            ENDDO
         ENDDO
      ENDDO
cbw
cbw      return
cbw

C CONTRIBUTION FROM OFF DIAGONAL TERMS

      KOF = (KL1 - 3) * N12P
      DO I3 = KL1-1,KL2+2
         IF(I3.EQ.KL1-1) THEN
            JL1=JL1V(KL1-1)
            JL2=JL2V(KL1-1)
         ELSE IF(I3.GE.KL2+1) THEN
            JL1=JL1V(KL2)
            JL2=JL2V(KL2)
         ELSE
            JL1=MIN(JL1V(I3),JL1V(I3-1),JL1V(I3+1))
            JL2=MAX(JL2V(I3),JL2V(I3-1),JL2V(I3+1))
         ENDIF
         KOF = KOF + N12P
         JOF = KOF + (JL1 - 3) * N1P
         DO I2 = JL1-1,JL2 + 2
            JOF = JOF + N1P
            I = JOF + IL1 - 1
            DO I1 = IL1, IL2 + 1
               I = I + 1
               IF(KEYOUT_CR(I).EQ.0.OR.ZERO_NODE(I)) GOTO 1
               DO K = 1,NOFFSET      
                  J = I - IOFFSET(K,NBLK)
                  IF(J.LE.0) GOTO 2
                  IF(KEYOUT_CR(J).EQ.0.OR.ZERO_NODE(J)) GOTO 2
                  IF(KEYOUT_CR(I).GT.0) THEN
                     RHS(I,1) = RHS(I,1) - EBEFORE(1,K,I) * EDISP(J,1)
     &                                   - EBEFORE(4,K,I) * EDISP(J,2)
     &                                   - EBEFORE(7,K,I) * EDISP(J,3)
                     RHS(I,2) = RHS(I,2) - EBEFORE(2,K,I) * EDISP(J,1)
     &                                   - EBEFORE(5,K,I) * EDISP(J,2)
     &                                   - EBEFORE(8,K,I) * EDISP(J,3)
                     RHS(I,3) = RHS(I,3) - EBEFORE(3,K,I) * EDISP(J,1)
     &                                   - EBEFORE(6,K,I) * EDISP(J,2)
     &                                   - EBEFORE(9,K,I) * EDISP(J,3)
                  ENDIF
                  IF(KEYOUT_CR(J).GT.0) THEN
                     RHS(J,1) = RHS(J,1) - EBEFORE(1,K,I) * EDISP(I,1)
     &                                   - EBEFORE(2,K,I) * EDISP(I,2)
     &                                   - EBEFORE(3,K,I) * EDISP(I,3)
                     RHS(J,2) = RHS(J,2) - EBEFORE(4,K,I) * EDISP(I,1)
     &                                   - EBEFORE(5,K,I) * EDISP(I,2)
     &                                   - EBEFORE(6,K,I) * EDISP(I,3)
                     RHS(J,3) = RHS(J,3) - EBEFORE(7,K,I) * EDISP(I,1)
     &                                   - EBEFORE(8,K,I) * EDISP(I,2)
     &                                   - EBEFORE(9,K,I) * EDISP(I,3)
                  ENDIF   
  2               CONTINUE
               ENDDO
  1            CONTINUE
            ENDDO
         ENDDO
      ENDDO

      END

C*********************************************************************
      SUBROUTINE INITIAL_STRESS_3D(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,
     &                    JL2V,KL1,KL2,KEYOUT,NBLK,MODUL,STRXX_INIT,
     &                    STRYY_INIT,STRZZ_INIT,FORCE_INIT)
C********************************************************************* 
C Compute initial forces due to initial stresses for 3-D rectangle
C 
C INPUT:
C   MODUL(I,J,K) = LAME''S CONSTANT LAMBDA (PSI)
C   STRXX_INIT(I,J,K) = INITIAL PRICIPLE STRESS IN X DIRECTION (PSI)
C   STRYY_INIT(I,J,K) = INITIAL PRICIPLE STRESS IN Y DIRECTION (PSI)
C   STRZZ_INIT(I,J,K) = INITIAL PRICIPLE STRESS IN Z DIRECTION (PSI)
C
C OUTPUT:
C   FORCE_INIT(L,I,J,K) = FORCES DUE TO INITIAL STRESSES (LB)
C*********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'pemodel.h'
      
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),      KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  STRXX_INIT(IDIM,JDIM,KDIM), STRYY_INIT(IDIM,JDIM,KDIM) 
      REAL*8  STRZZ_INIT(IDIM,JDIM,KDIM), FORCE_INIT(3,IDIM,JDIM,KDIM)
      REAL*8  MODUL(IDIM,JDIM,KDIM)

      INTEGER IOFF,JOFF,KOFF,I1,I2,I3,I,J,K,JL1,JL2,KERR
      INTEGER NPOINTS,NODES,INTEG
      REAL*8  POINTS(2),WEIGHT,VOL,X1,X2,X3,U1,U2,U3,V1
      REAL*8  ZERO,ONE,HALF,THREE
      PARAMETER(ZERO=0.D0,ONE=1.D0,HALF=0.5D0,THREE=3.D0)
 
      PARAMETER(NODES = 8)
      REAL*8  DHDX(NODES,NODES,3), DHDX_INTEG(3,NODES)
   
      INTEG = INTEGRATION_NODES
      IF(INTEG.EQ.1) THEN
         POINTS(1) = HALF
         WEIGHT = ONE
         NPOINTS = 1
      ELSE
         POINTS(1) = HALF * (ONE - ONE/SQRT(THREE))
         POINTS(2) = HALF * (ONE + ONE/SQRT(THREE))
         WEIGHT = ONE/INTEG
         NPOINTS = 2
      ENDIF

C SET UP (DH/DX1), (DH/DX2), AND (DH/DX3) AT INTEGRATION POINTS

      I = 0
      DO I1 = 1,NPOINTS
         DO I2 = 1,NPOINTS
            DO I3 = 1,NPOINTS
               I = I + 1
               DHDX(1,I,1) = - (ONE - POINTS(I2)) * (ONE-POINTS(I3))
               DHDX(2,I,1) = - DHDX(1,I,1)
               DHDX(3,I,1) = - POINTS(I2) * (ONE - POINTS(I3))
               DHDX(4,I,1) = - DHDX(3,I,1)
               DHDX(5,I,1) = - (ONE - POINTS(I2)) * POINTS(I3)
               DHDX(6,I,1) = - DHDX(5,I,1)
               DHDX(7,I,1) = - POINTS(I2) * POINTS(I3)
               DHDX(8,I,1) = - DHDX(7,I,1)

               DHDX(1,I,2) = - (ONE - POINTS(I1)) * (ONE-POINTS(I3))
               DHDX(2,I,2) = - POINTS(I1) * (ONE - POINTS(I3))
               DHDX(3,I,2) = - DHDX(1,I,2)
               DHDX(4,I,2) = - DHDX(2,I,2)
               DHDX(5,I,2) = - (ONE - POINTS(I1)) * POINTS(I3)
               DHDX(6,I,2) = - POINTS(I1) * POINTS(I3)
               DHDX(7,I,2) = - DHDX(5,I,2)
               DHDX(8,I,2) = - DHDX(6,I,2)
    
               DHDX(1,I,3) = - (ONE - POINTS(I1)) * (ONE-POINTS(I2))
               DHDX(2,I,3) = - POINTS(I1) * (ONE - POINTS(I2))
               DHDX(3,I,3) = - (ONE - POINTS(I1)) * POINTS(I2)
               DHDX(4,I,3) = - POINTS(I1) * POINTS(I2)
               DHDX(5,I,3) = - DHDX(1,I,3)
               DHDX(6,I,3) = - DHDX(2,I,3)
               DHDX(7,I,3) = - DHDX(3,I,3)
               DHDX(8,I,3) = - DHDX(4,I,3)
            END DO
         END DO
      END DO
 
C SUM (DH/DXI) OVER INTEGRATION POINTS

      DO I2 = 1,NODES
         DO I1 = 1,3
            DHDX_INTEG(I1,I2) = ZERO 
         ENDDO
      ENDDO
        
      DO I1 = 1,3
         DO I = 1,INTEG
            DO K = 1,NODES
               DHDX_INTEG(I1,K) = DHDX_INTEG(I1,K)+WEIGHT*DHDX(K,I,I1)
            ENDDO
         ENDDO
      ENDDO

      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,KERR)     

C INITIALIZE FORCE_INIT TO ZERO

      DO I3 = 1,KDIM           
         DO I2 = 1,JDIM              
            DO I1 = 1,IDIM                 
               FORCE_INIT(1,I1,I2,I3) = ZERO 
               FORCE_INIT(2,I1,I2,I3) = ZERO
               FORCE_INIT(3,I1,I2,I3) = ZERO
            ENDDO
         ENDDO
      ENDDO

C CALCULATE FORCE_INIT

      KL1P=KL1-1
      DO I3 = KL1P,KL2+1
         IF(I3.EQ.(KL1-1)) THEN
            JL1=JL1V(KL1)
cbw            JL2=JL2V(KL1)
            JL2=JL2V(KL1)+1
         ELSE IF(I3.LT.KL2) THEN
cbw            JL1=MIN(JL1V(I3),JL1V(I3+1))
cbw            JL2=MAX(JL2V(I3),JL2V(I3+1))
            JL1=MIN(JL1V(I3-1),JL1V(I3),JL1V(I3+1))
            JL2=MAX(JL2V(I3-1),JL2V(I3),JL2V(I3+1))+1
         ELSE
cbw            JL1=JL1V(KL2)
cbw            JL2=JL2V(KL2)
            JL1=MIN(JL1V(KL2-1),JL1V(KL2))
            JL2=MAX(JL2V(KL2-1),JL2V(KL2))+1
         ENDIF
         JL1P=JL1-1
cbw         X3 = DZREC(I3+KOFF,NBLK) / CONV_INCHES
         DO I2 = JL1P,JL2
cbw            X2 = DYREC(I2+JOFF,NBLK) / CONV_INCHES
cbw            V1 = X2 * X3
            DO I1 = IL1,IL2
               IF (KEYOUT(I1,I2,I3).EQ.0) GOTO 1
               X3 = DZREC(I3+KOFF,NBLK) / CONV_INCHES
               X2 = DYREC(I2+JOFF,NBLK) / CONV_INCHES
               V1 = X2 * X3
               X1 = DXREC(I1+IOFF,NBLK) / CONV_INCHES
               VOL = V1 * X1
               U1 = STRXX_INIT(I1,I2,I3) * VOL / X1
               U2 = STRYY_INIT(I1,I2,I3) * VOL / X2
               U3 = STRZZ_INIT(I1,I2,I3) * VOL / X3
               I = I1 + 1
               J = I2 + 1
               K = I3 + 1
               FORCE_INIT(1,I1,I2,I3) = FORCE_INIT(1,I1,I2,I3) 
     &                                + U1 * DHDX_INTEG(1,1)  
               FORCE_INIT(2,I1,I2,I3) = FORCE_INIT(2,I1,I2,I3)      
     &                                + U2 * DHDX_INTEG(2,1)    
               FORCE_INIT(3,I1,I2,I3) = FORCE_INIT(3,I1,I2,I3)        
     &                                + U3 * DHDX_INTEG(3,1)

               FORCE_INIT(1,I,I2,I3) = FORCE_INIT(1,I,I2,I3)
     &                               + U1 * DHDX_INTEG(1,2)
               FORCE_INIT(2,I,I2,I3) = FORCE_INIT(2,I,I2,I3)
     &                               + U2 * DHDX_INTEG(2,2) 
               FORCE_INIT(3,I,I2,I3) = FORCE_INIT(3,I,I2,I3)
     &                               + U3 * DHDX_INTEG(3,2)

               FORCE_INIT(1,I1,J,I3) = FORCE_INIT(1,I1,J,I3)
     &                               + U1 * DHDX_INTEG(1,3) 
               FORCE_INIT(2,I1,J,I3) = FORCE_INIT(2,I1,J,I3)
     &                               + U2 * DHDX_INTEG(2,3)
               FORCE_INIT(3,I1,J,I3) = FORCE_INIT(3,I1,J,I3)
     &                               + U3 * DHDX_INTEG(3,3)
          
               FORCE_INIT(1,I,J,I3) = FORCE_INIT(1,I,J,I3)
     &                               + U1 * DHDX_INTEG(1,4) 
               FORCE_INIT(2,I,J,I3) = FORCE_INIT(2,I,J,I3)
     &                               + U2 * DHDX_INTEG(2,4)
               FORCE_INIT(3,I,J,I3) = FORCE_INIT(3,I,J,I3)
     &                               + U3 * DHDX_INTEG(3,4)

               FORCE_INIT(1,I1,I2,K) = FORCE_INIT(1,I1,I2,K)
     &                               + U1 * DHDX_INTEG(1,5)
               FORCE_INIT(2,I1,I2,K) = FORCE_INIT(2,I1,I2,K)
     &                               + U2 * DHDX_INTEG(2,5) 
               FORCE_INIT(3,I1,I2,K) = FORCE_INIT(3,I1,I2,K)
     &                               + U3 * DHDX_INTEG(3,5)

               FORCE_INIT(1,I,I2,K) = FORCE_INIT(1,I,I2,K)
     &                               + U1 * DHDX_INTEG(1,6)
               FORCE_INIT(2,I,I2,K) = FORCE_INIT(2,I,I2,K)
     &                               + U2 * DHDX_INTEG(2,6)
               FORCE_INIT(3,I,I2,K) = FORCE_INIT(3,I,I2,K)
     &                               + U3 * DHDX_INTEG(3,6)

               FORCE_INIT(1,I1,J,K) = FORCE_INIT(1,I1,J,K)
     &                              + U1 * DHDX_INTEG(1,7)
               FORCE_INIT(2,I1,J,K) = FORCE_INIT(2,I1,J,K)
     &                              + U2 * DHDX_INTEG(2,7)
               FORCE_INIT(3,I1,J,K) = FORCE_INIT(3,I1,J,K)
     &                              + U3 * DHDX_INTEG(3,7)

               FORCE_INIT(1,I,J,K) = FORCE_INIT(1,I,J,K)
     &                             + U1 * DHDX_INTEG(1,8)
               FORCE_INIT(2,I,J,K) = FORCE_INIT(2,I,J,K)
     &                             + U2 * DHDX_INTEG(2,8)
               FORCE_INIT(3,I,J,K) = FORCE_INIT(3,I,J,K)
     &                             + U3 * DHDX_INTEG(3,8)
 1          CONTINUE
            ENDDO
         ENDDO
      ENDDO

      END

C************************************************************************
      SUBROUTINE SUBTRACT_FINIT3D(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &           KL1,KL2,KEYOUT,NBLK,KEYOUT_CR,ERESID,FORCE_INIT)
C************************************************************************
C Add initial force contribution to elastic residuals for 3D 
C rectangular grid
C
C INPUT:
C   KEYOUT_CR(I,J,K) = KEYOUT VALUE FOR A CORNER POINT
C   FORCE_INIT(L,I,J,K) = FORCES DUE TO INITIAL STRESSES (LB)
C
C OUTPUT:
C   ERESID(L.I,J,K) = RESIDUALS OF THE FORCE BALANCE EQUATION
C************************************************************************
      INCLUDE 'control.h'
      INCLUDE 'pemodel.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM), KEYOUT(IDIM,JDIM,KDIM)
      INTEGER KEYOUT_CR(IDIM,JDIM,KDIM)
      REAL*8  ERESID(IDIM,JDIM,KDIM,3) 
      REAL*8  FORCE_INIT(3,IDIM,JDIM,KDIM) 
    
      INTEGER I,J,K,JL1,JL2

      DO K = KL1,KL2 + 1
         JL1 = JL1V(K)
         JL2 = JL2V(K)
         DO J = JL1,JL2 + 1
            DO I = IL1,IL2 + 1
               IF(KEYOUT_CR(I,J,K).GT.0) THEN      
                  ERESID(I,J,K,1) = ERESID(I,J,K,1)-FORCE_INIT(1,I,J,K)
                  ERESID(I,J,K,2) = ERESID(I,J,K,2)-FORCE_INIT(2,I,J,K)
                  ERESID(I,J,K,3) = ERESID(I,J,K,3)-FORCE_INIT(3,I,J,K)
               ENDIF
            ENDDO
         ENDDO
      ENDDO

      END

C*********************************************************************
      SUBROUTINE PEUPSOL(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                   KEYOUT,NBLK,KEYOUT_CR,EDISP,VARD)
C*********************************************************************
C Update displacement after each newtonian step
C 
C INPUT:
C   KEYOUT_CR(I,J,K) = KEYOUT VALUE FOR A CORNER POINT
C   VARD(I,J,K,L) = CHANGES IN NODAL DISPLACEMENTS (IN)
C
C OUTPUT:
C   EDISP(L,I,J,K) = NODAL DISPLACEMENTS (IN)
C*********************************************************************
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      INTEGER KEYOUT_CR(IDIM,JDIM,KDIM)
      REAL*8  EDISP(IDIM,JDIM,KDIM,3)
      REAL*8  VARD(IDIM,JDIM,KDIM,3)

      INTEGER I,J,K,JL1,JL2
      DO K = KL1,KL2 + 1
         JL1 = JL1V(K)
         JL2 = JL2V(K)
         DO J = JL1,JL2 + 1
            DO I = IL1,IL2 + 1
               IF(KEYOUT_CR(I,J,K).GT.0) THEN
                  EDISP(I,J,K,1) = EDISP(I,J,K,1) + VARD(I,J,K,1)
                  EDISP(I,J,K,2) = EDISP(I,J,K,2) + VARD(I,J,K,2)
                  EDISP(I,J,K,3) = EDISP(I,J,K,3) + VARD(I,J,K,3)
               ENDIF
            ENDDO
         ENDDO
      ENDDO

      END
C************************************************************************
      SUBROUTINE AVERAGE_DISP(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &                        KL1,KL2,KEYOUT,NBLK,EDISP,AVGDISP)
C************************************************************************
C Calculate average displacements for a grid block
C DISPOUT = 1  ==> CENTER OF GRID BLOCK
C DISPOUT = 2  ==> TOP OF GRID BLOCK
C DISPOUT = 3  ==> BOTTOM OF GRID BLOCK
C
C INPUT:
C   EDISP(I,J,K,L) = NODAL DISPLACEMENTS (IN)
C
C OUTPUT:
C   AVGDISP(L,I,J,K) = AVERAGE DISPLACEMENTS (FT)
C************************************************************************
      INCLUDE 'pemodel.h'
      
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM), JL2V(KDIM), KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  EDISP(IDIM*JDIM*KDIM,3),AVGDISP(IDIM,JDIM,KDIM,*)
    
      INTEGER I1,I2,I3,J,K,JL1,JL2,KOF,JOF,N1P,N12P,N,L,NDIM,JMAP(8)
      REAL*8  WEIGHT,X,ZERO,ONE
      PARAMETER(ZERO=0.0D0, ONE=1.0D0)

      NDIM = NDIM_ELASTIC
      N1P = IDIM
      N12P = IDIM * JDIM

      IF(DISPOUT.EQ.1) THEN
         JMAP(1) = 0
         JMAP(2) = 1
         JMAP(3) = N1P
         JMAP(4) = N1P + 1
         JMAP(5) = N12P
         JMAP(6) = N12P + 1
         JMAP(7) = N12P + N1P
         JMAP(8) = N12P + N1P + 1
         N = 2**NDIM
      ELSE 
         IF(DISPOUT.EQ.2) THEN 
            JMAP(1) = 0
            JMAP(2) = N1P
            JMAP(3) = N12P
            JMAP(4) = N12P + N1P
            N = 2**(NDIM-1)
         ELSE
            JMAP(1) = 1
            JMAP(2) = N1P + 1
            JMAP(3) = N12P + 1
cbw            JMAP(3) = N12P + N1P + 1
            JMAP(4) = N12P + N1P + 1
            N = 2**(NDIM-1)
         ENDIF
      ENDIF

      WEIGHT = ONE*CONV_INCHES/N
      KOF = (KL1 - 2) * N12P
      DO I3 = KL1,KL2
         JL1 = JL1V(I3)
         JL2 = JL2V(I3)
         KOF = KOF + N12P
         JOF = KOF + (JL1 - 2) * N1P
         DO I2 = JL1,JL2
            JOF = JOF + N1P
            J = JOF + IL1 - 1
            DO I1 = IL1,IL2
               J = J + 1
               IF(KEYOUT(I1,I2,I3).LE.0) GO TO 1
cbw               J = J + 1
               DO L = 1,NDIM
                  X = ZERO
                  AVGDISP(I1,I2,I3,L) = ZERO
                  DO K = 1,N
                     X = X + EDISP(J+JMAP(K),L)    
                  ENDDO
                  AVGDISP(I1,I2,I3,L) = WEIGHT * X
               ENDDO
   1           CONTINUE
            ENDDO
         ENDDO
      ENDDO
      END
C************************************************************************
      SUBROUTINE AVERAGE_STRAIN(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &                          KL1,KL2,KEYOUT,NBLK,EDISP,AVGSTRN)
C************************************************************************
C Calculate average strains for a grid block.   
C 
C INPUT:
C   EDISP(I,J,K,L) = NODAL DISPLACEMENTS (IN)
C
C OUTPUT:
C   AVGSTRN(I,J,K,L) = AVERAGE STRAINS AT CELL CENTER
C************************************************************************
      IMPLICIT NONE
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'layout.h'

      INCLUDE 'pemodel.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),   KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  EDISP(IDIM*JDIM*KDIM,3), AVGSTRN(IDIM,JDIM,KDIM,*)
    
      INTEGER I1,I2,I3,JL1,JL2,J,KOF,JOF,N1P,N12P,NDIM,JMAP(8),K
      INTEGER IOFF,JOFF,KOFF,KERR
      REAL*8  X,U1,U2,U3,DUDX(3,3),ZERO,QUARTER
      PARAMETER(ZERO=0.0D0,QUARTER=0.25D0)

      NDIM = NDIM_ELASTIC
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,KERR)
      IF(NDIM.EQ.3) THEN
         N1P = IDIM
         N12P = IDIM * JDIM
         JMAP(1) = 0
         JMAP(2) = 1
         JMAP(3) = N1P 
         JMAP(4) = N1P + 1
         JMAP(5) = N12P
         JMAP(6) = N12P + 1
         JMAP(7) = N12P + N1P
         JMAP(8) = N12P + N1P + 1

         X = QUARTER * CONV_INCHES
         KOF = (KL1 - 2) * N12P
         DO I3 = KL1,KL2
            JL1 = JL1V(I3)
            JL2 = JL2V(I3)
            KOF = KOF + N12P
            JOF = KOF + (JL1 - 2) * N1P
cbw            U3 = X / DZREC(I3+KOFF,NBLK)
            DO I2 = JL1,JL2
               JOF = JOF + N1P
               J = JOF + IL1 - 1
cbw               U2 = X / DYREC(I2+JOFF,NBLK)
               DO I1 = IL1,IL2
                  J = J + 1
                  IF(KEYOUT(I1,I2,I3).LE.0) GOTO 1  
cbw                  J = J + 1
                  U3 = X / DZREC(I3+KOFF,NBLK)
                  U2 = X / DYREC(I2+JOFF,NBLK)
                  U1 = X / DXREC(I1+IOFF,NBLK)
                  DO K = 1,6
                     AVGSTRN(I1,I2,I3,K) = ZERO
                  ENDDO
                  DO K = 1,NDIM
                     DUDX(K,1)=((EDISP(J+JMAP(2),K)+EDISP(J+JMAP(4),K)
     &                   +  EDISP(J+JMAP(6),K)+EDISP(J+JMAP(8),K))
     &                   - (EDISP(J,K)+EDISP(J+JMAP(3),K)
     &                   +  EDISP(J+JMAP(5),K)+EDISP(J+JMAP(7),K)))*U1
 
                     DUDX(K,2)=((EDISP(J+JMAP(3),K)+EDISP(J+JMAP(4),K)
     &                   +  EDISP(J+JMAP(7),K)+EDISP(J+JMAP(8),K))
     &                   - (EDISP(J,K)+EDISP(J+JMAP(2),K)
     &                   +  EDISP(J+JMAP(5),K)+EDISP(J+JMAP(6),K)))*U2

                     DUDX(K,3)=((EDISP(J+JMAP(5),K)+EDISP(J+JMAP(6),K)
     &                   +  EDISP(J+JMAP(7),K)+EDISP(J+JMAP(8),K))
     &                   - (EDISP(J,K)+EDISP(J+JMAP(2),K)
     &                   +  EDISP(J+JMAP(3),K)+EDISP(J+JMAP(4),K)))*U3
                 ENDDO
                 AVGSTRN(I1,I2,I3,1) = DUDX(1,1) * 100.D0
                 AVGSTRN(I1,I2,I3,2) = DUDX(2,2) * 100.D0
                 AVGSTRN(I1,I2,I3,3) = DUDX(3,3) * 100.D0
                 AVGSTRN(I1,I2,I3,4) = (DUDX(1,2) + DUDX(2,1)) * 100.D0
                 AVGSTRN(I1,I2,I3,5) = (DUDX(1,3) + DUDX(3,1)) * 100.D0
                 AVGSTRN(I1,I2,I3,6) = (DUDX(2,3) + DUDX(3,2)) * 100.D0
   1             CONTINUE
              ENDDO
           ENDDO
        ENDDO
      ELSE
         IF(LEVELC) WRITE(NFOUT,10)
         NERRC = NERRC + 1
         RETURN
      ENDIF
   10 FORMAT(/'ERROR:NOT SETUP FOR 1D, 2D AVERAGE STRAIN CALCULATION')
      
      END
C************************************************************************
      SUBROUTINE AVERAGE_STRESS(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &                          KL1,KL2,KEYOUT,NBLK,MODUL,POISS,BIOTA,
     &                          STRXX_INIT,STRYY_INIT,STRZZ_INIT,
     &                          AVGSTRN,PREF,PRESS)
C************************************************************************
C Calculate total stresses from average strains.                 
C
C INPUT:
C   MODUL(I,J,K) = LAME'S CONSTANT LAMBDA (PSI)
C   POISS(I,J,K) = LAME'S CONSTANT MU (PSI)
C   BIOTA(I,J,K) = BIOT''S CONSTANT ALPHA 
C   STRXX_INIT(I,J,K) = INITIAL PRINCIPLE STRESS IN X DIRECTION (PSI)
C   STRYY_INIT(I,J,K) = INITIAL PRINCIPLE STRESS IN Y DIRECTION (PSI)
C   STRZZ_INIT(I,J,K) = INITIAL PRINCIPLE STRESS IN Z DIRECTION (PSI)
C   AVGSTRN(I,J,K,L) = AVERAGE STRAIN
C   PREF(I,J,K) = REFERENCE PORE PRESSURE (PSI)
C   PRESS(I,J,K) = PORE PRESSURE (PSI)
C
C OUTPUT:
C   AVGSTRN(I,J,K,L) = TOTAL STRESSES (PSI)
C************************************************************************
      INCLUDE 'control.h'
      INCLUDE 'pemodel.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),      KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  MODUL(IDIM,JDIM,KDIM),      POISS(IDIM,JDIM,KDIM)
      REAL*8  BIOTA(IDIM,JDIM,KDIM),      PREF(IDIM,JDIM,KDIM)
      REAL*8  PRESS(IDIM,JDIM,KDIM),      AVGSTRN(IDIM,JDIM,KDIM,*)
      REAL*8  STRXX_INIT(IDIM,JDIM,KDIM), STRYY_INIT(IDIM,JDIM,KDIM)
      REAL*8  STRZZ_INIT(IDIM,JDIM,KDIM)

      INTEGER I,J,K,JL1,JL2,NDIM
      REAL*8  U,V,W,X,ZERO,MU,V1,V2,V3
      PARAMETER(ZERO=0.0D0)
      NDIM = NDIM_ELASTIC
      IF(NDIM.EQ.3) THEN
         DO K = KL1,KL2
            JL1 = JL1V(K)
            JL2 = JL2V(K)
            DO J = JL1,JL2
               DO I = IL1,IL2
                  IF(KEYOUT(I,J,K).LE.0) GOTO 1 
                  IF(MODUL(I,J,K).GT.ZERO) THEN
                     MU = POISS(I,J,K)
                     V1 = AVGSTRN(I,J,K,1) / 100.D0
                     V2 = AVGSTRN(I,J,K,2) / 100.D0
                     V3 = AVGSTRN(I,J,K,3) / 100.D0
                     U = MODUL(I,J,K) * (V1 + V2 + V3)
                     V = 2.0D0 * MU
!bw                     W = BIOTA(I,J,K) * (PRESS(I,J,K)-PREF(I,J,K))
!bw   only care about effective stress
                     W = 0.D0
!bw
                     X = U - W
                     AVGSTRN(I,J,K,1) = X + V * V1 + STRXX_INIT(I,J,K)
                     AVGSTRN(I,J,K,2) = X + V * V2 + STRYY_INIT(I,J,K)
                     AVGSTRN(I,J,K,3) = X + V * V3 + STRZZ_INIT(I,J,K)
                     AVGSTRN(I,J,K,4) = MU * AVGSTRN(I,J,K,4) / 100.D0
                     AVGSTRN(I,J,K,5) = MU * AVGSTRN(I,J,K,5) / 100.D0
                     AVGSTRN(I,J,K,6) = MU * AVGSTRN(I,J,K,6) / 100.D0
                  ELSE
                     AVGSTRN(I,J,K,1) = ZERO
                     AVGSTRN(I,J,K,2) = ZERO
                     AVGSTRN(I,J,K,3) = ZERO
                     AVGSTRN(I,J,K,4) = ZERO
                     AVGSTRN(I,J,K,5) = ZERO
                     AVGSTRN(I,J,K,6) = ZERO
                  ENDIF
   1              CONTINUE
               ENDDO
            ENDDO
         ENDDO
      ELSE
         IF(LEVELC) WRITE(NFOUT,10)
         NERRC = NERRC + 1
         RETURN
      ENDIF
   10 FORMAT(/'ERROR:NOT SETUP FOR 1D, 2D AVERAGE STRESS CALCULATION')
  
      END 
C************************************************************************
      SUBROUTINE STRESS_3D(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &                     KL1,KL2,KEYOUT,NBLK,KEYCR,MODUL,POISS,
     &                     BIOTA,STRXX_INIT,STRYY_INIT,STRZZ_INIT,
     &                     EDISP,PREF,PRESS,STRESS,INTEG)
C************************************************************************
C Calculate total stresses. First stresses at integration points are 
C computed. Then stress at nodal points are extrapolated from those 
C Gauss points.
C
C INPUT:
C   KEYCR(I,J,K) = KEYOUT VALUE FOR CORNER POINT GRID
C   MODUL(I,J,K) = LAME'S CONSTANT LAMBDA (PSI)
C   POISS(I,J,K) = LAME'S CONSTANT MU (PSI)
C   BIOTA(I,J,K) = BIOT''S CONSTANT ALPHA
C   STRXX_INIT(I,J,K) = INITIAL PRINCIPLE STRESS IN X DIRECTION (PSI)
C   STRYY_INIT(I,J,K) = INITIAL PRINCIPLE STRESS IN Y DIRECTION (PSI)
C   STRZZ_INIT(I,J,K) = INITIAL PRINCIPLE STRESS IN Z DIRECTION (PSI)
C   EDISP(I,J,K,L) = NODAL DISPLACEMENT (IN.)
C   PREF(I,J,K) = REFERENCE PORE PRESSURE (PSI)
C   PRESS(I,J,K) = PORE PRESSURE (PSI)
C
C OUTPUT:
C   STRESS(I,J,K,L) = TOTAL STRESSES (PSI)
C************************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'pemodel.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),      KEYOUT(IDIM,JDIM,KDIM)
      INTEGER KEYCR(IDIM,JDIM,KDIM)
      REAL*8  MODUL(IDIM,JDIM,KDIM),      POISS(IDIM,JDIM,KDIM)
      REAL*8  BIOTA(IDIM,JDIM,KDIM),      PREF(IDIM,JDIM,KDIM)
      REAL*8  PRESS(IDIM,JDIM,KDIM),      EDISP(IDIM,JDIM,KDIM,3)
      REAL*8  STRXX_INIT(IDIM,JDIM,KDIM), STRYY_INIT(IDIM,JDIM,KDIM)
      REAL*8  STRZZ_INIT(IDIM,JDIM,KDIM), STRESS(IDIM,JDIM,KDIM,6)

      INTEGER I1,I2,I3,I,J,K,L,ND,IOFF,JOFF,KOFF,JL1,JL2,JL1P,KL1P
      INTEGER NPOINTS,NODES,INUM(IDIM,JDIM,KDIM)
      REAL*8  LAMBDA,MU,X1,X2,X3,DX1,DX2,DX3,DXG,ALPHA,POINTS(2) 
      REAL*8  STG(6,INTEG),GPOINTS(2),ZERO,HALF,ONE,TWO,THREE

      PARAMETER(NODES=8)
      REAL*8  DHDX(NODES,INTEG,3),STGN(6,NODES),DISP(3,NODES)
      REAL*8  H(INTEG,NODES)
      PARAMETER(ZERO=0.0D0,HALF=0.5D0,ONE=1.D0,TWO=2.D0,THREE=3.D0)

      ND = (NDIM_ELASTIC - 1) * NDIM_ELASTIC

      IF (INTEG.EQ.1) THEN
         NPOINTS = 1
         POINTS(1) = HALF
      ELSE
         NPOINTS = 2
         POINTS(1) = HALF * (ONE - ONE/SQRT(THREE))
         POINTS(2) = HALF * (ONE + ONE/SQRT(THREE))
         DXG = 1.D0 / (POINTS(2) - POINTS(1))
         GPOINTS(1) = - POINTS(1) * DXG
         GPOINTS(2) = (1 - POINTS(1)) * DXG
      ENDIF

C SETUP (DH/DX1),(DH/DX2), AND (DH/DX3) AT INTEGRATION POINTS

      I = 0
      DO I1 = 1,NPOINTS
         DO I2 = 1,NPOINTS
            DO I3 = 1,NPOINTS
               I = I + 1
               DHDX(1,I,1) = - (ONE - POINTS(I2)) * (ONE - POINTS(I3))
               DHDX(2,I,1) = - DHDX(1,I,1)
               DHDX(3,I,1) = - POINTS(I2) * (ONE - POINTS(I3))
               DHDX(4,I,1) = - DHDX(3,I,1)
               DHDX(5,I,1) = - (ONE - POINTS(I2)) * POINTS(I3)
               DHDX(6,I,1) = - DHDX(5,I,1)
               DHDX(7,I,1) = - POINTS(I2) * POINTS(I3)
               DHDX(8,I,1) = - DHDX(7,I,1)

               DHDX(1,I,2) = - (ONE - POINTS(I1)) * (ONE - POINTS(I3))
               DHDX(2,I,2) = - POINTS(I1) * (ONE - POINTS(I3))
               DHDX(3,I,2) = - DHDX(1,I,2)
               DHDX(4,I,2) = - DHDX(2,I,2)
               DHDX(5,I,2) = - (ONE - POINTS(I1)) * POINTS(I3)
               DHDX(6,I,2) = - POINTS(I1) * POINTS(I3)
               DHDX(7,I,2) = - DHDX(5,I,2)
               DHDX(8,I,2) = - DHDX(6,I,2)

               DHDX(1,I,3) = - (ONE - POINTS(I1)) * (ONE - POINTS(I2))
               DHDX(2,I,3) = - POINTS(I1) * (ONE - POINTS(I2))
               DHDX(3,I,3) = - (ONE - POINTS(I1)) * POINTS(I2)
               DHDX(4,I,3) = - POINTS(I1) * POINTS(I2)
               DHDX(5,I,3) = - DHDX(1,I,3)
               DHDX(6,I,3) = - DHDX(2,I,3)
               DHDX(7,I,3) = - DHDX(3,I,3)
               DHDX(8,I,3) = - DHDX(4,I,3)
            ENDDO
         ENDDO
      ENDDO

C SET UP H(X) VALUES AT 8 NODES FOR EXTRAPOLATION FROM INTEGRATION POINTS

      IF(INTEG.EQ.1) THEN     
         M = 0
         DO I1 = 1,NPOINTS
            DO I2 = 1,NPOINTS
               DO I3 = 1,NPOINTS
                  M = M + 1
                  DO N = 1,NODES
                     H(N,M) = ONE 
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
      ELSE
         M = 0
         DO I1 = 1,NPOINTS   
            DO I2 = 1,NPOINTS
               DO I3 = 1,NPOINTS   
                  M = M + 1
                  H(1,M) = (ONE - GPOINTS(I1)) * (ONE - GPOINTS(I2)) 
     &                   * (ONE - GPOINTS(I3))
                  H(2,M) =  GPOINTS(I1) * (ONE - GPOINTS(I2)) 
     &                   * (ONE - GPOINTS(I3))
                  H(3,M) = (ONE - GPOINTS(I1)) * GPOINTS(I2) 
     &                   * (ONE - GPOINTS(I3))
                  H(4,M) =  GPOINTS(I1) * GPOINTS(I2) 
     &                   * (ONE - GPOINTS(I3))
                  H(5,M) = (ONE - GPOINTS(I1)) * (ONE - GPOINTS(I2)) 
     &                   *  GPOINTS(I3)
                  H(6,M) =  GPOINTS(I1) * (ONE - GPOINTS(I2)) 
     &                   *  GPOINTS(I3)
                  H(7,M) = (ONE - GPOINTS(I1)) * GPOINTS(I2) 
     &                   *  GPOINTS(I3)
                  H(8,M) =  GPOINTS(I1) * GPOINTS(I2) * GPOINTS(I3) 
               ENDDO
            ENDDO
         ENDDO
      ENDIF
           
C CALCULATE STRAINS AT INTEGRATION POINTS AND EXTRAPOLATE THEM TO GET 
C STRAINS AT NODAL POINTS

      DO K = 1,KDIM
         DO J = 1,JDIM
            DO I = 1,IDIM
               DO L = 1,ND
                  STRESS(I,J,K,L) = 0.D0
               ENDDO
               INUM(I,J,K) = 0
            ENDDO
         ENDDO
      ENDDO

      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,KERR)

      KL1P=KL1-1
      DO I3 = KL1P,KL2
         IF(I3.EQ.(KL1-1)) THEN
            JL1=JL1V(KL1)
            JL2=JL2V(KL1)
         ELSE IF(I3.LT.KL2) THEN
cbw            JL1=MIN(JL1V(I3),JL1V(I3+1))
cbw            JL2=MAX(JL2V(I3),JL2V(I3+1))
            JL1=MIN(JL1V(I3-1),JL1V(I3),JL1V(I3+1))
            JL2=MAX(JL2V(I3-1),JL2V(I3),JL2V(I3+1))
         ELSE
cbw            JL1=JL1V(KL2)
cbw            JL2=JL2V(KL2)
            JL1=MIN(JL1V(KL2-1),JL1V(KL2))
            JL2=MAX(JL2V(KL2-1),JL2V(KL2))
         ENDIF
         JL1P=JL1-1
cbw         X3 = DZREC(I3+KOFF,NBLK) / CONV_INCHES
cbw         DO I2 = JL1P,JL2
         DO I2 = JL1P,JL2+1
cbw            X2 = DYREC(I2+JOFF,NBLK) / CONV_INCHES
            DO I1 = IL1,IL2
               IF (KEYOUT(I1,I2,I3).EQ.0) GO TO 1
               X3 = DZREC(I3+KOFF,NBLK) / CONV_INCHES
               X2 = DYREC(I2+JOFF,NBLK) / CONV_INCHES
               X1 = DXREC(I1+IOFF,NBLK) / CONV_INCHES
               LAMBDA = MODUL(I1,I2,I3)
               IF (LAMBDA.LE.ZERO) GO TO 1
               MU = POISS(I1,I2,I3)
               ALPHA = BIOTA(I1,I2,I3) 
               DX1 = ONE / X1
               DX2 = ONE / X2
               DX3 = ONE / X3
               I = I1 + 1
               J = I2 + 1
               K = I3 + 1
               DO L = 1,NDIM_ELASTIC
                  DISP(L,1) = EDISP(I1,I2,I3,L)
                  DISP(L,2) = EDISP(I,I2,I3,L)
                  DISP(L,3) = EDISP(I1,J,I3,L)
                  DISP(L,4) = EDISP(I,J,I3,L)
                  DISP(L,5) = EDISP(I1,I2,K,L)
                  DISP(L,6) = EDISP(I,I2,K,L)
                  DISP(L,7) = EDISP(I1,J,K,L)
                  DISP(L,8) = EDISP(I,J,K,L)
               ENDDO
               DO M = 1,INTEG
                  DO L = 1,ND
                     STG(L,M) = 0.D0
                  ENDDO
                  DO N = 1,NODES
                     STG(1,M) = STG(1,M) + DHDX(N,M,1) * DISP(1,N) * DX1
                     STG(2,M) = STG(2,M) + DHDX(N,M,2) * DISP(2,N) * DX2
                     STG(3,M) = STG(3,M) + DHDX(N,M,3) * DISP(3,N) * DX3
                     STG(4,M) = STG(4,M) + DHDX(N,M,2) * DISP(1,N) * DX2
     &                                   + DHDX(N,M,1) * DISP(2,N) * DX1
                     STG(5,M) = STG(5,M) + DHDX(N,M,3) * DISP(1,N) * DX3
     &                                   + DHDX(N,M,1) * DISP(3,N) * DX1
                     STG(6,M) = STG(6,M) + DHDX(N,M,3) * DISP(2,N) * DX3
     &                                   + DHDX(N,M,2) * DISP(3,N) * DX2
                  ENDDO
               ENDDO
               DO N = 1,NODES
                  DO L = 1,ND
                     STGN(L,N) = 0.D0
                  ENDDO
                  DO M = 1,INTEG
                     STGN(1,N) = STGN(1,N) + H(M,N) * STG(1,M)
                     STGN(2,N) = STGN(2,N) + H(M,N) * STG(2,M)
                     STGN(3,N) = STGN(3,N) + H(M,N) * STG(3,M)
                     STGN(4,N) = STGN(4,N) + H(M,N) * STG(4,M)
                     STGN(5,N) = STGN(5,N) + H(M,N) * STG(5,M)
                     STGN(6,N) = STGN(6,N) + H(M,N) * STG(6,M) 
                  ENDDO
                  SUM = STGN(1,N) + STGN(2,N) + STGN(3,N) 
!bw                  DELP = ALPHA * (PRESS(I1,I2,I3) - PREF(I1,I2,I3))
!bw   only care about EFFECTIVE STRESS
                  DELP = 0.D0
!bw
                  STGN(1,N) = LAMBDA * SUM + TWO * MU * STGN(1,N)
     &                      + DELP + STRXX_INIT(I1,I2,I3)
                  STGN(2,N) = LAMBDA * SUM + TWO * MU * STGN(2,N)
     &                      + DELP + STRYY_INIT(I1,I2,I3)
                  STGN(3,N) = LAMBDA * SUM + TWO * MU * STGN(3,N) 
     &                      + DELP + STRZZ_INIT(I1,I2,I3)
                  STGN(4,N) = MU * STGN(4,N) 
                  STGN(5,N) = MU * STGN(5,N)
                  STGN(6,N) = MU * STGN(6,N)
               ENDDO
               IF(KEYCR(I1,I2,I3).GT.0) THEN
                  DO L = 1,ND
                     STRESS(I1,I2,I3,L) = STRESS(I1,I2,I3,L) + STGN(L,1)
                  ENDDO
                  INUM(I1,I2,I3) = INUM(I1,I2,I3) + 1
               ENDIF
               IF(KEYCR(I,I2,I3).GT.0) THEN
                  DO L = 1,ND
                     STRESS(I,I2,I3,L) = STRESS(I,I2,I3,L) + STGN(L,2) 
                  ENDDO
                  INUM(I,I2,I3) = INUM(I,I2,I3) + 1
               ENDIF
               IF(KEYCR(I1,J,I3).GT.0) THEN
                  DO L = 1,ND
                     STRESS(I1,J,I3,L) = STRESS(I1,J,I3,L) + STGN(L,3)
                  ENDDO
                  INUM(I1,J,I3) = INUM(I1,J,I3) + 1
               ENDIF
               IF(KEYCR(I,J,I3).GT.0) THEN
                  DO L = 1,ND
                     STRESS(I,J,I3,L) = STRESS(I,J,I3,L) + STGN(L,4)
                  ENDDO
                  INUM(I,J,I3) = INUM(I,J,I3) + 1
               ENDIF
               IF(KEYCR(I1,I2,K).GT.0) THEN
                  DO L = 1,ND
                     STRESS(I1,I2,K,L) = STRESS(I1,I2,K,L) + STGN(L,5)
                  ENDDO
                  INUM(I1,I2,K) = INUM(I1,I2,K) + 1
               ENDIF
               IF(KEYCR(I,I2,K).GT.0) THEN
                  DO L = 1,ND
                     STRESS(I,I2,K,L) = STRESS(I,I2,K,L) + STGN(L,6)
                  ENDDO
                  INUM(I,I2,K) = INUM(I,I2,K) + 1
               ENDIF
               IF(KEYCR(I1,J,K).GT.0) THEN
                  DO L = 1,ND
                     STRESS(I1,J,K,L) = STRESS(I1,J,K,L) + STGN(L,7)
                  ENDDO
                  INUM(I1,J,K) = INUM(I1,J,K) + 1
               ENDIF
               IF(KEYCR(I,J,K).GT.0) THEN
                  DO L = 1,ND
                     STRESS(I,J,K,L) = STRESS(I,J,K,L) + STGN(L,8)
                  ENDDO
                  INUM(I,J,K) = INUM(I,J,K) + 1
               ENDIF
   1           CONTINUE
            ENDDO
         ENDDO
      ENDDO
     
      DO I3 = KL1,KL2+1
         DO I2 = JL1V(K), JL2V(K)+1
            DO I1 = IL1,IL2+1  
               IF(KEYCR(I1,I2,I3).GT.0) THEN
                  N = INUM(I1,I2,I3)
                  DO L = 1,ND
                     STRESS(I1,I2,I3,L) = STRESS(I1,I2,I3,L) / N
                  ENDDO
               ENDIF
            ENDDO
         ENDDO
      ENDDO
!bw debug
!      write(*,*) "PROCESSOR",MYPROC,"PRINTING N_STRESS"
!      write(*,*) STRESS

      END

C************************************************************************
      SUBROUTINE EFFECTIVE_STRESS(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &                 KL1,KL2,KEYOUT,NBLK,BIOTA,STRESS,PREF,PRESS)
C************************************************************************
C Calculate effective stress.                   
C 
C INPUT:
C   BIOTA(I,J,K) = BIOT'i'S CONSTANT ALPHA 
C   STRESS(I,J,K,L) = TOTAL STRESS (PSI)
C   PREF(I,J,K) = REFERCE PORE PRESSURE (PSI)
C   PRESS(I,J,K) = PORE PRESSURE (PSI)
C
C OUTPUT:
C   STRESS(I,J,K,L) = EFFECTIVE STRESS (PSI)
C************************************************************************
      INCLUDE 'control.h'

      INCLUDE 'pemodel.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),      KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  BIOTA(IDIM,JDIM,KDIM),      PRESS(IDIM,JDIM,KDIM)
      REAL*8  PREF(IDIM,JDIM,KDIM),      STRESS(IDIM,JDIM,KDIM,6)

      INTEGER I,J,K
      REAL*8  ALPHA

      DO K=KL1,KL2
         DO J=JL1V(K),JL2V(K)
            DO I=IL1,IL2
               IF(KEYOUT(I,J,K).GT.0) THEN
                  ALPHA=BIOTA(I,J,K)
                  STRESS(I,J,K,1)=STRESS(I,J,K,1)
     &                           +ALPHA*(PRESS(I,J,K)-PREF(I,J,K))
                  STRESS(I,J,K,2)=STRESS(I,J,K,2)
     &                           +ALPHA*(PRESS(I,J,K)-PREF(I,J,K))
                  STRESS(I,J,K,3)=STRESS(I,J,K,3)
     &                           +ALPHA*(PRESS(I,J,K)-PREF(I,J,K))
                ENDIF
            ENDDO
         ENDDO
      ENDDO

      END

C*********************************************************************
      SUBROUTINE PEWDATA (NERR,KINP)
C*********************************************************************

C  Inputs flow model well data (both initial and transient)

C  NERR = Error number stepped by 1 on error (input & output, INTEGER)

C  KINP = Input type
C       = 1 ==> initial data
C       = 2 ==> transient data

C*********************************************************************
      INCLUDE 'control.h'
      INCLUDE 'pemodel.h'
      INTEGER NERR,KINP

$COMP      MODACT=$XMODEL
$COMP      IF (PEFLOW.EQ.$XMODEL) CALL XWDATA(NERR,KINP)
$COMP      MODACT = $PEMODEL 

      END
C************************************************************************
C                        END OF POROELASTIC.F
C************************************************************************


cbw

C*********************************************************************
      SUBROUTINE PRTSYSTEM(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &           KL1,KL2,KEYOUT,NBLK,KEYOUT_CR,EDIAG,EBEFORE,ERESID,
     &           ZERO_NODE)
C*********************************************************************
      INCLUDE 'control.h'
      INCLUDE 'pemodel.h'
      INCLUDE 'pebdary.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM),
     &        KEYOUT_CR(IDIM,JDIM,KDIM)
      REAL*8  EDIAG(6,IDIM,JDIM,KDIM),EBEFORE(9,13,IDIM,JDIM,KDIM),
     &        ERESID(IDIM,JDIM,KDIM,3)
      LOGICAL ZERO_NODE(IDIM,JDIM,KDIM)
      INTEGER I,J,K,IOFF,JOFF,KOFF,NUMCR,NUMNZ,II,JJ,NERR
      INTEGER EDIAGNUM,EBEFORENUM,ERESIDNUM,INDEX,III,JJJ,KKK
      INTEGER N1P,N12P,N123P
      CHARACTER*6 EDIAGNAME
      CHARACTER*8 EBEFORENAME
      CHARACTER*7 ERESIDNAME
      INTEGER OFFSET(3,13)
      DATA OFFSET/-1,-1,-1,  0,-1,-1,  1,-1,-1, 
     &            -1, 0,-1,  0, 0,-1,  1, 0,-1, 
     &            -1, 1,-1,  0, 1,-1,  1, 1,-1,
     &            -1,-1, 0,  0,-1, 0,  1,-1, 0, 
     &            -1, 0, 0/
     
      EDIAGNUM = 200
      EBEFORENUM = 201
      ERESIDNUM = 202
           
      N1P = IDIM
      N12P = N1P*JDIM
      N123P = N12P*KDIM 

      IF(NUMPRC.EQ.1) THEN
         EDIAGNAME = 'DIAG_'//CHAR(48+9)
         EBEFORENAME = 'BEFORE_'//CHAR(48+9)
         ERESIDNAME = 'RESID_'//CHAR(48+9)
      ELSE
         EDIAGNAME = 'DIAG_'//CHAR(48+MYPRC)
         EBEFORENAME = 'BEFORE_'//CHAR(48+MYPRC)
         ERESIDNAME = 'RESID_'//CHAR(48+MYPRC)
      ENDIF

      OPEN(UNIT=EDIAGNUM,FILE=EDIAGNAME,STATUS='replace')
      OPEN(UNIT=EBEFORENUM,FILE=EBEFORENAME,STATUS='replace')
      OPEN(UNIT=ERESIDNUM,FILE=ERESIDNAME,STATUS='replace')


      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,NERR) 
      WRITE(EDIAGNUM,*) 'AT TIME =',TIM,'DELTIM=',DELTIM
      WRITE(EDIAGNUM,*) 'IOFF=',IOFF,'JOFF=',JOFF,'KOFF=',KOFF
      WRITE(EBEFORENUM,*) 'AT TIME =',TIM,'DELTIM=',DELTIM
      WRITE(EBEFORENUM,*) 'IOFF=',IOFF,'JOFF=',JOFF,'KOFF=',KOFF
      WRITE(ERESIDNUM,*) 'AT TIME =',TIM,'DELTIM=',DELTIM
      WRITE(ERESIDNUM,*) 'IOFF=',IOFF,'JOFF=',JOFF,'KOFF=',KOFF
      NUMCR = 0
      NUMNZ = 0
      DO K = 1,KDIM
         DO J = 1,JDIM
            DO I = 1,IDIM
              IF (KEYOUT_CR(I,J,K) .EQ. 1) THEN
               NUMCR = NUMCR+1
               WRITE(EDIAGNUM,*) 'AT NODE I=',I+IOFF,'J=',J+JOFF,
     &                           'K=',K+KOFF
               WRITE(EBEFORENUM,*) 'AT NODE I=',I+IOFF,'J=',J+JOFF,
     &                           'K=',K+KOFF
               WRITE(ERESIDNUM,*) 'AT NODE I=',I+IOFF,'J=',J+JOFF,
     &                           'K=',K+KOFF
               WRITE(EDIAGNUM,*) 'EDIAG=',(EDIAG(II,I,J,K),II=1,6)
               WRITE(ERESIDNUM,*) 'ERESID=',(ERESID(I,J,K,II),II=1,3)
               DO JJ = 1,NDIM_BEFORE
                  III = I + OFFSET(1,JJ)
                  JJJ = J + OFFSET(2,JJ)
                  KKK = K + OFFSET(3,JJ)
                  INDEX = (KKK-1)*N12P+(JJJ-1)*N1P+III 
                  IF (INDEX.GT.0.AND.KEYOUT_CR(III,JJJ,KKK).NE.0) THEN
                     WRITE(EBEFORENUM,100) -JJ,I+IOFF,J+JOFF,K+KOFF
                     WRITE(EBEFORENUM,*) (EBEFORE(II,JJ,I,J,K),II=1,9)
                  ENDIF
               ENDDO
               DO JJ = 1,NDIM_BEFORE
                  III = I - OFFSET(1,JJ)
                  JJJ = J - OFFSET(2,JJ)
                  KKK = K - OFFSET(3,JJ)
                  INDEX = (KKK-1)*N12P+(JJJ-1)*N1P+III 
                  IF (INDEX.LE.N123P.AND.KEYOUT_CR(III,JJJ,KKK).NE.0) 
     &               THEN
                     WRITE(EBEFORENUM,100) JJ,I+IOFF,J+JOFF,K+KOFF
                     WRITE(EBEFORENUM,*) 
     &                    (EBEFORE(II,JJ,III,JJJ,KKK),II=1,9)
                  ENDIF
               ENDDO
               ENDIF
            ENDDO
         ENDDO
      ENDDO
      WRITE(ERESIDNUM,*)'NUMCR=',NUMCR
     
      CLOSE(EDIAGNUM)
      CLOSE(EBEFORENUM)
      CLOSE(ERESIDNUM)       
cbw
      RETURN            
cbw
      WRITE(50+MYPRC,*) 'IOFF=',IOFF,'JOFF=',JOFF,'KOFF=',KOFF
      DO K = 1,KDIM
         DO J = 1,JDIM
            DO I = 1,IDIM
              IF (.NOT.ZERO_NODE(I,J,K)) THEN
               NUMNZ = NUMNZ+1
               WRITE(50+MYPRC,*) 'AT NODE I=',I+IOFF,'J=',J+JOFF,
     &                           'K=',K+KOFF
cbw               WRITE(50+MYPRC,*) 'EDIAG=',(EDIAG(II,I,J,K),II=1,6)
               WRITE(50+MYPRC,*) 'ERESID=',(ERESID(I,J,K,II),II=1,3)
               DO JJ = 1,13
cbw                  WRITE(50+MYPRC,100) JJ,I+IOFF,J+JOFF,K+KOFF
cbw                  WRITE(50+MYPRC,*) (EBEFORE(II,JJ,I,J,K),II=1,9)
               ENDDO
               ENDIF
            ENDDO
         ENDDO
      ENDDO              
 100  FORMAT('EBEFORE(,',I3,',',I3,',',I3,',',I3,')=') 
      WRITE(50+MYPRC,*)'NUMNZ=',NUMNZ

      END




C*********************************************************************
      SUBROUTINE PRTDISP(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                   KEYOUT,NBLK,KEYOUT_CR,EDISP)
C*********************************************************************
C Update displacement after each newtonian step
C 
C INPUT:
C   KEYOUT_CR(I,J,K) = KEYOUT VALUE FOR A CORNER POINT
C
C OUTPUT:
C   EDISP(L,I,J,K) = NODAL DISPLACEMENTS (IN)
C*********************************************************************

      INCLUDE 'control.h'
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      INTEGER KEYOUT_CR(IDIM,JDIM,KDIM)
      REAL*8  EDISP(IDIM,JDIM,KDIM,3)
      INTEGER IOFF,JOFF,KOFF,NERR
      INTEGER I,J,K,JL1,JL2,NUMCR
      INTEGER DISPNUM
      CHARACTER*6 DISPNAME

      DISPNUM = 100
      IF(NUMPRC.EQ.1) THEN
         DISPNAME = 'disp_'//CHAR(48+9)
      ELSE
         DISPNAME = 'disp_'//CHAR(48+MYPRC)
      ENDIF
      OPEN(UNIT=DISPNUM,FILE=DISPNAME,STATUS='replace')

      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,NERR)
      WRITE(DISPNUM,*) 'IOFF=',IOFF,'JOFF=',JOFF,'KOFF=',KOFF
      NUMCR = 0
      DO K = KL1,KL2 + 1
         JL1 = JL1V(K)
         JL2 = JL2V(K)
         DO J = JL1,JL2 + 1
            DO I = IL1,IL2 + 1
               IF(KEYOUT_CR(I,J,K).GT.0) THEN
                  NUMCR = NUMCR+1
                  WRITE(DISPNUM,*) 'AT I=',I+IOFF,'J=',J+JOFF,
     &                              'K=',K+KOFF
                  WRITE(DISPNUM,*) 'EDISP X Y Z=',EDISP(I,J,K,1),
     &                              EDISP(I,J,K,2),EDISP(I,J,K,3)
               ENDIF
            ENDDO
         ENDDO
      ENDDO

      WRITE(DISPNUM,*) 'NUMCR=',NUMCR
     
      CLOSE(DISPNUM)

cbw      DO K = 1,KDIM
cbw         WRITE(15+MYPRC,*) (KEYOUT(IL1,J,K),J=1,JDIM)
cbw      ENDDO
                
      END




C*********************************************************************
      SUBROUTINE PRTPRES(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                   KEYOUT,NBLK,PRES)
C*********************************************************************
C OUTPUT PRESSURE FROM FLOW MODEL
C 
C INPUT:
C   PRES(I,J,K) = PRESSURE FROM FLOW MODEL
C*********************************************************************

      INCLUDE 'control.h'
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  PRES(IDIM,JDIM,KDIM)
      INTEGER IOFF,JOFF,KOFF,NERR
      INTEGER I,J,K,JL1,JL2
      INTEGER PRESNUM
      CHARACTER*6 PRESNAME

      PRESNUM = 100
      IF(NUMPRC.EQ.1) THEN
         PRESNAME = 'PRES_'//CHAR(48+9)
      ELSE
         PRESNAME = 'PRES_'//CHAR(48+MYPRC)
      ENDIF
      OPEN(UNIT=PRESNUM,FILE=PRESNAME,STATUS='replace')

      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,NERR)
      WRITE(PRESNUM,*) 'AT TIME =',TIM,'DELTIM=',DELTIM
      WRITE(PRESNUM,*) 'IOFF=',IOFF,'JOFF=',JOFF,'KOFF=',KOFF
      DO K = KL1,KL2 
         JL1 = JL1V(K)
         JL2 = JL2V(K)
         DO J = JL1,JL2 
            DO I = IL1,IL2
               IF(KEYOUT(I,J,K).GT.0) THEN
                  WRITE(PRESNUM,*) 'AT I=',I+IOFF,'J=',J+JOFF,
     &                              'K=',K+KOFF
                  WRITE(PRESNUM,*) 'PRES=',PRES(I,J,K)
               ENDIF
            ENDDO
         ENDDO
      ENDDO
      CLOSE(PRESNUM)

      END




c======================================================================
      SUBROUTINE GET_GELEI_LSIZE(NERR)
c======================================================================
      IMPLICIT NONE
C
      INCLUDE 'blkary.h'
      INCLUDE 'control.h'
      INCLUDE 'pearydat.h'
C
C Assign GELEINDEX(IDIM,JDIM,KDIM,3) AND LSIZE
C
C gxue 12/14/09
C
      INTEGER NERR
C
      INTEGER IGELEI(4)
      LOGICAL ONCEONLY
      EXTERNAL calcGELEI
      EXTERNAL calcLELEI_LSIZE
      DATA IGELEI/4*0/, ONCEONLY/.TRUE./
      IF (ONCEONLY) THEN
         ONCEONLY = .FALSE.
         IGELEI(1) = 3
         IGELEI(2) = N_KEYOUT_CR
         IGELEI(3) = N_EDIAG
         IGELEI(4) = N_GELEI
      ENDIF


      call callwork(calcLELEI_LSIZE,IGELEI)
$MANY      call callwork(calcGELEI,IGELEI)
$MANY      CALL TIMON(30)
cbw $MANY      CALL NODE_UPDATE(N_GELEI,'I4')      
$MANY      CALL UPDATE(N_GELEI,4)      
$MANY      CALL TIMOFF(30)
     

      RETURN
      END


c======================================================================
      SUBROUTINE calcLELEI_LSIZE(idim,jdim,kdim,ldim,il1,il2,
     &     jl1v,jl2v,kl1,kl2,keyout,nblk,keyout_cr,ediag,geleindex)
c======================================================================
      IMPLICIT NONE
C
C Compute local dof index. Store in geleindex(i,j,k).
c Compute local # of dofs. Store in LSIZE
C gxue 12/04/09
C
      include 'control.h'
C
      integer idim,jdim,kdim,ldim,il1,il2,jl1v(kdim),
     &     jl2v(kdim),kl1,kl2,keyout(idim,jdim,kdim),nblk,
     &     keyout_cr(idim,jdim,kdim)
      integer geleindex(idim,jdim,kdim,3)
      real*8 ediag(6,idim,jdim,kdim)
C
      integer i,j,k,ne

      LSIZE = 0
      do 3 k=kl1-1,kl2+1
      do 3 j=jl1v(k)-1,jl2v(k)+1
      do 3 i=il1,il2+1
         if((keyout_cr(i,j,k).eq.1).and.(ediag(1,i,j,k).ne.0.d0)) then
            LSIZE = LSIZE + 3
         endif
    3 continue

cbw      LSIZE = 3*LSIZE
      
      ne = 0
      do 5 k = 1,kdim
      do 5 j = 1,jdim
      do 5 i = 1,idim
        geleindex(i,j,k,1) = 0
        geleindex(i,j,k,2) = 0
        geleindex(i,j,k,3) = 0
         if((keyout_cr(i,j,k).eq.1).and.(ediag(1,i,j,k).ne.0.d0)) then
            ne = ne + 1
            geleindex(i,j,k,1) = ne
            ne = ne + 1
            geleindex(i,j,k,2) = ne
            ne = ne + 1
            geleindex(i,j,k,3) = ne
         endif
cgxue
c      if (keyout(i,j,k).eq.0) cycle
c      write(0,19) 'myprc i j k eleindex(i,j,k)',myprc,i,j,k,
c     &            geleindex(i,j,k)
c   19 format(A40,2X,I2,2X,3(I4),2X,I4)
cgxue
    5 continue


      return
      end


c======================================================================
      SUBROUTINE calcGELEI(idim,jdim,kdim,ldim,il1,il2,
     &     jl1v,jl2v,kl1,kl2,keyout,nblk,keyout_cr,ediag,geleindex)
c======================================================================
      IMPLICIT NONE
C
C  Input: geleindex for local dof index
C Output: geleindex for global dof index 
C   Also, compute common variables: ilower and iupper
C
C gxue 12/04/09
C
      include 'mpif.h'
      include 'control.h'
      include 'layout.h'
C
      integer idim,jdim,kdim,ldim,il1,il2,jl1v(kdim),
     &     jl2v(kdim),kl1,kl2,keyout(idim,jdim,kdim),nblk,
     &     keyout_cr(idim,jdim,kdim)
      integer geleindex(idim,jdim,kdim,3)
      real*8 ediag(6,idim,jdim,kdim)
C
      integer i,j,k,nb, Psize(0:NUMPRC-1),m,ilowvec(0:NUMPRC-1),
     &        GJ,GK,KERR,IOFF,JOFF,KOFF,wsize,IERR
C

      call MPI_ALLGATHER(LSIZE,1,MPI_INTEGER,Psize,1,MPI_INTEGER,
     &                   MPI_COMM_WORLD,IERR)

c      CALL WAITALL()

      do i = 0, NUMPRC-1
         wsize = 0
         do m = 0, i-1
            wsize = wsize + Psize(m)
         enddo   
         ilowvec(i) = wsize + 1
      enddo

      ilower = ilowvec(myprc)
      iupper = ilower + LSIZE -1

cgxue dbg
      write(0,*) 'idata.f: myprc ilower iupper',myprc,ilower,iupper
cgxue dbg

C
C update global element indexs
C 1. Elements belong to current processor:
C             gelexinde + = ilower -1
C 2. Elements belong to neighbor processors: 
C       geleindex + = Psize( nb) - 1


C  prcmap(M)
C  M = N0MAP(NUMBLK) + GK * NYMAP(NUMBLK) + GJ 
C  NUMBLK = GRID-BLOCK NUMBER
C  GJ = Y INDEX IN THE BLOCK
C  GK = Z INDEX IN THE BLOCK

c      CALL BLKDIM (1,NX,NY,NZ,KERR)
cbw      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,KERR)
cgxue dbg
c      write(0,*)'myprc NUMBLK N0MAP NYMAP NX NY NZ IOFF,JOFF,KOFF',
c     &           myprc,numblk,N0MAP(NUMBLK), NYMAP(NUMBLK),NX,NY,NZ,
c     &           IOFF,JOFF,KOFF
cgxue dbg

      do 10 k= kl1-1, kl2+1
      do 10 j= jl1v(k)-1, jl2v(k)+1
      do 10 i= il1, il2+1  
cgxue dbg
c         if (keyout(i,j,k).eq.0) cycle
c         write(0,15) 'myprc i j k geleindex(i,j,k)',myprc,i,j,k,
c     &               geleindex(i,j,k)
c   15 format(A40,2X,I2,2X,3(I4),2X,I4)
cgxue dbg

cgxue dbg
c         write(0,16)'idata.df: myprc i j k keyout',myprc,i,j,k,
c     &                 keyout(i,j,k)
c   16 format(A30,2X,I2,2X,3(I4),2X,I4)
cgxue dbg

         if((keyout_cr(i,j,k).eq.1).and.(ediag(1,i,j,k).ne.0.d0)) then
            geleindex(i,j,k,1) = geleindex(i,j,k,1) + ilower - 1
            geleindex(i,j,k,2) = geleindex(i,j,k,2) + ilower - 1
            geleindex(i,j,k,3) = geleindex(i,j,k,3) + ilower - 1
         endif

   10 CONTINUE
      return
      end





!bw   C*********************************************************************
!bw         SUBROUTINE NODE_UPDATE(N_ARRAY,CTYPE)
!bw   C*********************************************************************
!bw   C  SUBROUTINE UPDATE NODAL-BASED ARRAY
!bw   C  THIS VERSION SUPPORT UPDATING N_GELEI,N_EDISP,N_ZERO_NODE
!bw   C  
!bw   C  BY BIN WANG, 06/09/2010
!bw         IMPLICIT NONE
!bw         INCLUDE 'pearydat.h'
!bw    
!bw         INTEGER N_ARRAY,ICOMP(5)
!bw         CHARACTER*2 CTYPE
!bw         EXTERNAL COMPACTI4,UNFOLDI4,COMPACTR8,UNFOLDR8,
!bw        &         COMPACTFG,UNFOLDFG
!bw   
!bw         ICOMP(1) = 4
!bw         ICOMP(2) = N_ARRAY
!bw         ICOMP(3) = N_KEYCR_ELE
!bw         ICOMP(4) = N_KEYOUT_CR
!bw   $MANY      CALL UPDATE(N_ARRAY,2)
!bw          
!bw   
!bw         IF (CTYPE.EQ.'I4') THEN
!bw            ICOMP(5) = N_UPDATE_I4
!bw            CALL CALLWORK(COMPACTI4,ICOMP) 
!bw   $MANY         CALL UPDATE(N_UPDATE_I4,2)
!bw   $MANY         CALL CALLWORK(UNFOLDI4,ICOMP)
!bw         ELSEIF (CTYPE.EQ.'R8') THEN
!bw            ICOMP(5) = N_UPDATE_R8
!bw            CALL CALLWORK(COMPACTR8,ICOMP)
!bw   $MANY         CALL UPDATE(N_UPDATE_R8,2)
!bw   $MANY         CALL CALLWORK(UNFOLDR8,ICOMP)
!bw         ELSEIF (CTYPE.EQ.'FG') THEN
!bw            ICOMP(5) = N_UPDATE_FG
!bw            CALL CALLWORK(COMPACTFG,ICOMP)
!bw   $MANY         CALL UPDATE(N_UPDATE_FG,2)
!bw   $MANY         CALL CALLWORK(UNFOLDFG,ICOMP)
!bw         ENDIF
!bw            
!bw   
!bw         END
!bw   
!bw   
!bw   C*********************************************************************
!bw         SUBROUTINE BUILDKEYCP(KERR)
!bw   C*********************************************************************
!bw         IMPLICIT NONE
!bw    
!bw         INCLUDE 'pearydat.h'
!bw         
!bw         INTEGER IBUILD(3),KERR
!bw         EXTERNAL BUILDKEYCPW
!bw   
!bw         IBUILD(1) = 2
!bw         IBUILD(2) = N_KEYOUT_CR
!bw         IBUILD(3) = N_KEYCR_ELE
!bw   
!bw   $MANY      CALL CALLWORK(BUILDKEYCPW,IBUILD)
!bw   $MANY      CALL UPDATE(N_KEYCR_ELE,2)
!bw   
!bw         END
!bw              
!bw   
!bw   
!bw   C*********************************************************************
!bw         SUBROUTINE BUILDKEYCPW(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
!bw        &                       KL1, KL2,KEYOUT,NBLK,KEYOUT_CR,KEYCR_ELE)
!bw   C*********************************************************************
!bw         IMPLICIT NONE
!bw   
!bw         INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
!bw         INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM),
!bw        &        KEYOUT_CR(IDIM,JDIM,KDIM)
!bw         INTEGER KEYCR_ELE(IDIM,JDIM,KDIM,8)
!bw         INTEGER I,J,K,L,NODE,II,JJ,KK
!bw         INTEGER OFFSET(3,8)
!bw         DATA OFFSET/0,0,0, 1,0,0, 0,1,0, 1,1,0, 
!bw        &            0,0,1, 1,0,1, 0,1,1, 1,1,1/ 
!bw   
!bw         DO K = KL1,KL2
!bw            DO J = JL1V(K),JL2V(K)
!bw               DO I = IL1,IL2
!bw                  IF (KEYOUT(I,J,K).EQ.1) THEN
!bw                     DO NODE = 1,8
!bw                        II = I+OFFSET(1,NODE)
!bw                        JJ = J+OFFSET(2,NODE)
!bw                        KK = K+OFFSET(3,NODE)
!bw                        KEYCR_ELE(I,J,K,NODE) = KEYOUT_CR(II,JJ,KK)
!bw                     ENDDO
!bw                  ENDIF
!bw               ENDDO
!bw            ENDDO
!bw         ENDDO
!bw    
!bw         END
!bw   
!bw   
!bw   
!bw   
!bw   C*********************************************************************
!bw         SUBROUTINE COMPACTI4(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
!bw        &           KL2,KEYOUT,NBLK,ORIGARR,KEYCR_ELE,KEYOUT_CR,COMPARR)
!bw   C*********************************************************************
!bw         IMPLICIT NONE
!bw   
!bw         INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
!bw         INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM),
!bw        &        KEYOUT_CR(IDIM,JDIM,KDIM)
!bw         INTEGER KEYCR_ELE(IDIM,JDIM,KDIM,8)
!bw         INTEGER I,J,K,L,NODE,II,JJ,KK
!bw         INTEGER ORIGARR(IDIM,JDIM,KDIM,3),COMPARR(IDIM,JDIM,KDIM,3,8)
!bw         INTEGER OFFSET(3,8)
!bw         DATA OFFSET/0,0,0, 1,0,0, 0,1,0, 1,1,0, 
!bw        &            0,0,1, 1,0,1, 0,1,1, 1,1,1/ 
!bw   
!bw         DO K = KL1,KL2
!bw            DO J = JL1V(K),JL2V(K)
!bw               DO I = IL1,IL2
!bw                  IF (KEYOUT(I,J,K).EQ.1) THEN
!bw                     DO NODE = 1,8
!bw                        II = I+OFFSET(1,NODE)
!bw                        JJ = J+OFFSET(2,NODE)
!bw                        KK = K+OFFSET(3,NODE)
!bw                        DO L = 1,3
!bw                           COMPARR(I,J,K,L,NODE) = ORIGARR(II,JJ,KK,L)
!bw                        ENDDO
!bw                     ENDDO
!bw                  ENDIF
!bw               ENDDO
!bw            ENDDO
!bw         ENDDO 
!bw   
!bw         END
!bw   
!bw   
!bw   
!bw   
!bw   C*********************************************************************
!bw         SUBROUTINE UNFOLDI4(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
!bw        &           KL2,KEYOUT,NBLK,ORIGARR,KEYCR_ELE,KEYOUT_CR,COMPARR)
!bw   C*********************************************************************
!bw         IMPLICIT NONE
!bw   
!bw         INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
!bw         INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
!bw         INTEGER KEYCR_ELE(IDIM,JDIM,KDIM,8)
!bw         INTEGER KEYOUT_CR(IDIM,JDIM,KDIM)
!bw         INTEGER I,J,K,L,NODE,II,JJ,KK,ELE,JL1,JL2
!bw         INTEGER ORIGARR(IDIM,JDIM,KDIM,3),COMPARR(IDIM,JDIM,KDIM,3,8)
!bw         INTEGER OFFSET(3,8)
!bw         DATA OFFSET/-1,-1,-1,  0,-1,-1,  -1, 0,-1,  0, 0,-1, 
!bw        &            -1,-1, 0,  0,-1, 0,  -1, 0, 0,  0, 0, 0/ 
!bw   
!bw         DO K = KL2+1,KL1-1,-1
!bw            IF (K.EQ.(KL2+1)) THEN
!bw               JL1 = MIN(JL1V(K),JL1V(K-1))
!bw               JL2 = MAX(JL2V(K),JL2V(K-1))
!bw            ELSEIF (K.EQ.(KL1-1)) THEN
!bw               JL1 = MIN(JL1V(K),JL1V(K+1))
!bw               JL2 = MAX(JL2V(K),JL2V(K+1))
!bw            ELSE
!bw               JL1 = MIN(JL1V(K-1),JL1V(K),JL1V(K+1))
!bw               JL2 = MAX(JL2V(K-1),JL2V(K),JL2V(K+1))
!bw            ENDIF 
!bw            DO J = JL2+1,JL1-1,-1
!bw               DO I = IL2+1,IL1,-1
!bw                  IF ((KEYOUT_CR(I,J,K).EQ.(-1)).
!bw        &             AND.(KEYOUT(I,J,K).EQ.0)) THEN
!bw                      DO ELE = 1,7
!bw                         II = I+OFFSET(1,ELE)
!bw                         JJ = J+OFFSET(2,ELE)
!bw                         KK = K+OFFSET(3,ELE)
!bw                         IF (KEYOUT(II,JJ,KK).EQ.(-1)) THEN
!bw                            NODE = 9-ELE
!bw                            IF (KEYCR_ELE(II,JJ,KK,NODE).EQ.1) THEN
!bw                               ORIGARR(I,J,K,1) = COMPARR(II,JJ,KK,1,NODE) 
!bw                               ORIGARR(I,J,K,2) = COMPARR(II,JJ,KK,2,NODE) 
!bw                               ORIGARR(I,J,K,3) = COMPARR(II,JJ,KK,3,NODE)
!bw                               GOTO 100
!bw                            ENDIF
!bw                         ENDIF
!bw                      ENDDO
!bw                  ENDIF
!bw    100           CONTINUE
!bw               ENDDO
!bw            ENDDO
!bw         ENDDO
!bw   
!bw   
!bw         END
!bw        
!bw   
!bw   
!bw   
!bw   
!bw   C*********************************************************************
!bw         SUBROUTINE COMPACTR8(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
!bw        &           KL2,KEYOUT,NBLK,ORIGARR,KEYCR_ELE,KEYOUT_CR,COMPARR)
!bw   C*********************************************************************
!bw         IMPLICIT NONE
!bw   
!bw         INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
!bw         INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM),
!bw        &        KEYOUT_CR(IDIM,JDIM,KDIM)
!bw         INTEGER KEYCR_ELE(IDIM,JDIM,KDIM,8)
!bw         INTEGER I,J,K,L,NODE,II,JJ,KK
!bw         REAL*8  ORIGARR(IDIM,JDIM,KDIM,3),COMPARR(IDIM,JDIM,KDIM,3,8)
!bw         INTEGER OFFSET(3,8)
!bw         DATA OFFSET/0,0,0, 1,0,0, 0,1,0, 1,1,0, 
!bw        &            0,0,1, 1,0,1, 0,1,1, 1,1,1/ 
!bw   
!bw         DO K = KL1,KL2
!bw            DO J = JL1V(K),JL2V(K)
!bw               DO I = IL1,IL2
!bw                  IF (KEYOUT(I,J,K).EQ.1) THEN
!bw                     DO NODE = 1,8
!bw                        II = I+OFFSET(1,NODE)
!bw                        JJ = J+OFFSET(2,NODE)
!bw                        KK = K+OFFSET(3,NODE)
!bw                        DO L = 1,3
!bw                           COMPARR(I,J,K,L,NODE) = ORIGARR(II,JJ,KK,L)
!bw                        ENDDO
!bw                     ENDDO
!bw                  ENDIF
!bw               ENDDO
!bw            ENDDO
!bw         ENDDO 
!bw   
!bw         END
!bw   
!bw   
!bw   
!bw   
!bw   C*********************************************************************
!bw         SUBROUTINE UNFOLDR8(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
!bw        &           KL2,KEYOUT,NBLK,ORIGARR,KEYCR_ELE,KEYOUT_CR,COMPARR)
!bw   C*********************************************************************
!bw         IMPLICIT NONE
!bw   
!bw         INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
!bw         INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
!bw         INTEGER KEYOUT_CR(IDIM,JDIM,KDIM)
!bw         INTEGER KEYCR_ELE(IDIM,JDIM,KDIM,8)
!bw         INTEGER I,J,K,L,NODE,II,JJ,KK,ELE,JL1,JL2
!bw         REAL*8  ORIGARR(IDIM,JDIM,KDIM,3),COMPARR(IDIM,JDIM,KDIM,3,8)
!bw         INTEGER OFFSET(3,8)
!bw         DATA OFFSET/-1,-1,-1,  0,-1,-1,  -1, 0,-1,  0, 0,-1, 
!bw        &            -1,-1, 0,  0,-1, 0,  -1, 0, 0,  0, 0, 0/ 
!bw   
!bw         DO K = KL2+1,KL1-1,-1
!bw            IF (K.EQ.(KL2+1)) THEN
!bw               JL1 = MIN(JL1V(K),JL1V(K-1))
!bw               JL2 = MAX(JL2V(K),JL2V(K-1))
!bw            ELSEIF (K.EQ.(KL1-1)) THEN
!bw               JL1 = MIN(JL1V(K),JL1V(K+1))
!bw               JL2 = MAX(JL2V(K),JL2V(K+1))
!bw            ELSE
!bw               JL1 = MIN(JL1V(K-1),JL1V(K),JL1V(K+1))
!bw               JL2 = MAX(JL2V(K-1),JL2V(K),JL2V(K+1))
!bw            ENDIF 
!bw            DO J = JL2+1,JL1-1,-1
!bw               DO I = IL2+1,IL1,-1
!bw                  IF ((KEYOUT_CR(I,J,K).EQ.(-1)).
!bw        &             AND.(KEYOUT(I,J,K).EQ.0)) THEN
!bw                      DO ELE = 1,7
!bw                         II = I+OFFSET(1,ELE)
!bw                         JJ = J+OFFSET(2,ELE)
!bw                         KK = K+OFFSET(3,ELE)
!bw                         IF (KEYOUT(II,JJ,KK).EQ.(-1)) THEN
!bw                            NODE = 9-ELE
!bw                            IF (KEYCR_ELE(II,JJ,KK,NODE).EQ.1) THEN
!bw                               ORIGARR(I,J,K,1) = COMPARR(II,JJ,KK,1,NODE)     
!bw                               ORIGARR(I,J,K,2) = COMPARR(II,JJ,KK,2,NODE)     
!bw                               ORIGARR(I,J,K,3) = COMPARR(II,JJ,KK,3,NODE)
!bw                               GOTO 100
!bw                            ENDIF
!bw                         ENDIF
!bw                      ENDDO
!bw                  ENDIF
!bw    100           CONTINUE
!bw               ENDDO
!bw            ENDDO
!bw         ENDDO
!bw   
!bw   
!bw         END
!bw   
!bw   
!bw   
!bw   
!bw   C*********************************************************************
!bw         SUBROUTINE COMPACTFG(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
!bw        &           KL2,KEYOUT,NBLK,ORIGARR,KEYCR_ELE,KEYOUT_CR,COMPARR)
!bw   C*********************************************************************
!bw         IMPLICIT NONE
!bw   
!bw         INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
!bw         INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM),
!bw        &        KEYOUT_CR(IDIM,JDIM,KDIM)
!bw         INTEGER KEYCR_ELE(IDIM,JDIM,KDIM,8)
!bw         INTEGER I,J,K,L,NODE,II,JJ,KK
!bw         LOGICAL ORIGARR(IDIM,JDIM,KDIM),COMPARR(IDIM,JDIM,KDIM,8)
!bw         INTEGER OFFSET(3,8)
!bw         DATA OFFSET/0,0,0, 1,0,0, 0,1,0, 1,1,0, 
!bw        &            0,0,1, 1,0,1, 0,1,1, 1,1,1/ 
!bw   
!bw         DO K = KL1,KL2
!bw            DO J = JL1V(K),JL2V(K)
!bw               DO I = IL1,IL2
!bw                  IF (KEYOUT(I,J,K).EQ.1) THEN
!bw                     DO NODE = 1,8
!bw                        II = I+OFFSET(1,NODE)
!bw                        JJ = J+OFFSET(2,NODE)
!bw                        KK = K+OFFSET(3,NODE)
!bw                        COMPARR(I,J,K,NODE) = ORIGARR(II,JJ,KK)
!bw                     ENDDO
!bw                  ENDIF
!bw               ENDDO
!bw            ENDDO
!bw         ENDDO 
!bw   
!bw         END
!bw   
!bw   
!bw   
!bw   
!bw   C*********************************************************************
!bw         SUBROUTINE UNFOLDFG(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
!bw        &           KL2,KEYOUT,NBLK,ORIGARR,KEYCR_ELE,KEYOUT_CR,COMPARR)
!bw   C*********************************************************************
!bw         IMPLICIT NONE
!bw   
!bw         INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
!bw         INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
!bw         INTEGER KEYOUT_CR(IDIM,JDIM,KDIM)
!bw         INTEGER KEYCR_ELE(IDIM,JDIM,KDIM,8)
!bw         INTEGER I,J,K,L,NODE,II,JJ,KK,ELE,JL1,JL2
!bw         LOGICAL ORIGARR(IDIM,JDIM,KDIM),COMPARR(IDIM,JDIM,KDIM,8)
!bw         INTEGER OFFSET(3,8)
!bw         DATA OFFSET/-1,-1,-1,  0,-1,-1,  -1, 0,-1,  0, 0,-1, 
!bw        &            -1,-1, 0,  0,-1, 0,  -1, 0, 0,  0, 0, 0/ 
!bw   
!bw         DO K = KL2+1,KL1-1,-1
!bw            IF (K.EQ.(KL2+1)) THEN
!bw               JL1 = MIN(JL1V(K),JL1V(K-1))
!bw               JL2 = MAX(JL2V(K),JL2V(K-1))
!bw            ELSEIF (K.EQ.(KL1-1)) THEN
!bw               JL1 = MIN(JL1V(K),JL1V(K+1))
!bw               JL2 = MAX(JL2V(K),JL2V(K+1))
!bw            ELSE
!bw               JL1 = MIN(JL1V(K-1),JL1V(K),JL1V(K+1))
!bw               JL2 = MAX(JL2V(K-1),JL2V(K),JL2V(K+1))
!bw            ENDIF 
!bw            DO J = JL2+1,JL1-1,-1
!bw               DO I = IL2+1,IL1,-1
!bw                  IF ((KEYOUT_CR(I,J,K).EQ.(-1)).
!bw        &             AND.(KEYOUT(I,J,K).EQ.0)) THEN
!bw                      DO ELE = 1,7
!bw                         II = I+OFFSET(1,ELE)
!bw                         JJ = J+OFFSET(2,ELE)
!bw                         KK = K+OFFSET(3,ELE)
!bw                         IF (KEYOUT(II,JJ,KK).EQ.(-1)) THEN
!bw                            NODE = 9-ELE
!bw                            IF (KEYCR_ELE(II,JJ,KK,NODE).EQ.1) THEN
!bw                               ORIGARR(I,J,K) = COMPARR(II,JJ,KK,NODE)     
!bw                               GOTO 100
!bw                            ENDIF
!bw                         ENDIF
!bw                      ENDDO
!bw                  ENDIF
!bw    100           CONTINUE
!bw               ENDDO
!bw            ENDDO
!bw         ENDDO
!bw   
!bw   
!bw         END


C**********************************************************************
      SUBROUTINE PRTBDDISP(KERR)
C**********************************************************************
      IMPLICIT NONE
      INCLUDE 'pebdary.h'
      INCLUDE 'pearydat.h'

      INTEGER KERR
      INTEGER IPRT(8)
      EXTERNAL PRTBDDISPW
      
      IPRT(1) = 7
      IPRT(2) = N_KEYOUT_CR
      IPRT(3) = N_DISPBD(1)
      IPRT(4) = N_DISPBD(2)
      IPRT(5) = N_DISPBD(3)
      IPRT(6) = N_DISPBD(4)
      IPRT(7) = N_DISPBD(5)
      IPRT(8) = N_DISPBD(6)
      
      CALL CALLWORK(PRTBDDISPW,IPRT)

      END


C**********************************************************************
      SUBROUTINE PRTBDDISPW(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &                    KL1,KL2,KEYOUT,NBLK,KEYOUT_CR,BDVAL1,BDVAL2,
     &                    BDVAL3,BDVAL4,BDVAL5,BDVAL6)
C**********************************************************************
      IMPLICIT NONE

      INCLUDE 'control.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM), KEYOUT(IDIM,JDIM,KDIM)
      INTEGER KEYOUT_CR(IDIM,JDIM,KDIM)
      REAL*8 BDVAL1(*),BDVAL2(*),BDVAL3(*),BDVAL4(*),BDVAL5(*),
     &       BDVAL6(*)
      INTEGER I,J,K,LOFF,L,NBP,IOFF,JOFF,KOFF,NERR,II

      INTEGER DISPNUM
      CHARACTER*8 DISPNAME
 
      DISPNUM = 100
      IF(NUMPRC.EQ.1) THEN
         DISPNAME = 'BDDISP_'//CHAR(48+9)
      ELSE
         DISPNAME = 'BDDISP_'//CHAR(48+MYPRC)
      ENDIF
      OPEN(UNIT=DISPNUM,FILE=DISPNAME,STATUS='replace')
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,NERR)
    
      WRITE(DISPNUM,*) "IDIM=",IDIM,"JDIM=",JDIM,"KDIM=",KDIM
      WRITE(DISPNUM,*) "IOFF=",IOFF,"JOFF=",JOFF,"KOFF=",KOFF
cbw -X SIDE
      NBP = JDIM*KDIM
      DO L = 1,3
         LOFF = (L-1)*NBP*4
         WRITE(DISPNUM,*) "-X SIDE,DIRECTION=",L
         DO K = 1,KDIM
            DO J = 1,JDIM
               WRITE(DISPNUM,*) "BDVAL1(",J+JOFF,K+KOFF,L,",1 TO 4)=",
     &              (BDVAL1(LOFF+(II-1)*NBP+(K-1)*JDIM+J),II=1,4)
            ENDDO
         ENDDO
      ENDDO

cbw +X SIDE
      NBP = JDIM*KDIM
      DO L = 1,3
         LOFF = (L-1)*NBP*4
         WRITE(DISPNUM,*) "+X SIDE,DIRECTION=",L
         DO K = 1,KDIM
            DO J = 1,JDIM
               WRITE(DISPNUM,*) "BDVAL2(",J+JOFF,K+KOFF,L,"1 TO 4)=",
     &              (BDVAL2(LOFF+(II-1)*NBP+(K-1)*JDIM+J),II=1,4)
            ENDDO
         ENDDO
      ENDDO

cbw -Y SIDE
      NBP = IDIM*KDIM
      DO L = 1,3
         LOFF = (L-1)*NBP*4
         WRITE(DISPNUM,*) "-Y SIDE,DIRECTION=",L
         DO K = 1,KDIM
            DO I = 1,IDIM
               WRITE(DISPNUM,*) "BDVAL3(",I+IOFF,K+KOFF,L,"1 TO 4)=",
     &              (BDVAL3(LOFF+(II-1)*NBP+(K-1)*IDIM+I),II=1,4)
            ENDDO
         ENDDO
      ENDDO

cbw +Y SIDE
      NBP = IDIM*KDIM
      DO L = 1,3
         LOFF = (L-1)*NBP*4
         WRITE(DISPNUM,*) "+Y SIDE,DIRECTION=",L
         DO K = 1,KDIM
            DO I = 1,IDIM
               WRITE(DISPNUM,*) "BDVAL4(",I+IOFF,K+KOFF,L,"1 TO 4)=",
     &              (BDVAL4(LOFF+(II-1)*NBP+(K-1)*IDIM+I),II=1,4)
            ENDDO
         ENDDO
      ENDDO

cbw -Z SIDE
      NBP = IDIM*JDIM
      DO L = 1,3
         LOFF = (L-1)*NBP*4
         WRITE(DISPNUM,*) "-Z SIDE,DIRECTION=",L
         DO J = 1,JDIM
            DO I = 1,IDIM
               WRITE(DISPNUM,*) "BDVAL5(",I+IOFF,J+JOFF,L,"1 TO 4)=",
     &              (BDVAL5(LOFF+(II-1)*NBP+(J-1)*IDIM+I),II=1,4)
            ENDDO
         ENDDO
      ENDDO

cbw +Z SIDE
      NBP = IDIM*JDIM
      DO L = 1,3
         LOFF = (L-1)*NBP*4
         WRITE(DISPNUM,*) "+Z SIDE,DIRECTION=",L
         DO J = 1,JDIM
            DO I = 1,IDIM
               WRITE(DISPNUM,*) "BDVAL6(",I+IOFF,J+JOFF,L,"1 TO 4)=",
     &              (BDVAL6(LOFF+(II-1)*NBP+(J-1)*IDIM+I),II=1,4)
            ENDDO
         ENDDO
      ENDDO

      CLOSE(DISPNUM)

      END


               
C*********************************************************************
      SUBROUTINE PRTKEYOUT(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &                   KL1,KL2,KEYOUT,NBLK)
C*********************************************************************
C Update displacement after each newtonian step
C 
C INPUT:
C   KEYOUT_CR(I,J,K) = KEYOUT VALUE FOR A CORNER POINT
C
C OUTPUT:
C   EDISP(L,I,J,K) = NODAL DISPLACEMENTS (IN)
C*********************************************************************

      INCLUDE 'control.h'
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      INTEGER I,J,K,JL1,JL2
      INTEGER DISPNUM
      CHARACTER*8 DISPNAME

      DISPNUM = 100
      IF(NUMPRC.EQ.1) THEN
         DISPNAME = 'keyout_'//CHAR(48+9)
      ELSE
         DISPNAME = 'keyout_'//CHAR(48+MYPRC)
      ENDIF
      OPEN(UNIT=DISPNUM,FILE=DISPNAME,STATUS='replace')

      DO K = 1,KDIM
         WRITE(DISPNUM,*) K,'||',
     &           (KEYOUT(IL1,J,K),J=1,JDIM)
         WRITE(DISPNUM,*) 
         WRITE(DISPNUM,*) 
      ENDDO

      WRITE(DISPNUM,*) 'NUMCR=',NUMCR
     
      CLOSE(DISPNUM)

cbw      DO K = 1,KDIM
cbw         WRITE(15+MYPRC,*) (KEYOUT(IL1,J,K),J=1,JDIM)
cbw      ENDDO
                
      END





C*********************************************************************
      SUBROUTINE FINDELE(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                   KEYOUT,NBLK)
C*********************************************************************
      IMPLICIT NONE

      INCLUDE 'control.h'
      INCLUDE 'mpif.h'
      INCLUDE 'pemodel.h'
      INCLUDE 'pebdary.h'
      
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      INTEGER IOFF,JOFF,KOFF,NERR,IERR
      INTEGER I,J,K,LOCAL_ELE(3),ALL_ELE(3,0:NUMPRC-1)
      INTEGER SK,SJ,SI,NOPRC
 
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,NERR)
      DO I = IL2,IL1,-1
         DO K = KL1,KL2
            DO J = JL1V(K),JL2V(K)
               IF (KEYOUT(I,J,K).EQ.1) THEN
                  LOCAL_ELE(1) = I+IOFF
                  LOCAL_ELE(2) = J+JOFF
                  LOCAL_ELE(3) = K+KOFF
                  GOTO 100
               ENDIF
            ENDDO
         ENDDO
      ENDDO

 100  CONTINUE

      call MPI_ALLGATHER(LOCAL_ELE,3,MPI_INTEGER,ALL_ELE,
     &                   3,MPI_INTEGER,MPI_COMM_WORLD,IERR)

      SK = ALL_ELE(3,0)
      SJ = ALL_ELE(2,0)
      SI = ALL_ELE(1,0)

      DO NOPRC = 0,NUMPRC-1
         IF (ALL_ELE(1,NOPRC).GT.SI) THEN
            SI = ALL_ELE(1,NOPRC)
            SK = ALL_ELE(3,NOPRC)
         ENDIF
      ENDDO
      
      DO NOPRC = 0,NUMPRC-1
         IF (ALL_ELE(1,NOPRC).EQ.SI) THEN
            IF (ALL_ELE(3,NOPRC).LT.SK) THEN 
               SK = ALL_ELE(3,NOPRC)
               SJ = ALL_ELE(2,NOPRC)
            ENDIF
         ENDIF
      ENDDO

      DO NOPRC = 0,NUMPRC-1
         IF ((ALL_ELE(1,NOPRC).EQ.SI).AND.(ALL_ELE(3,NOPRC).EQ.SK)) 
     &   THEN
            IF (ALL_ELE(2,NOPRC).LT.SJ) THEN
               SJ = ALL_ELE(2,NOPRC)
            ENDIF
         ENDIF
      ENDDO

      FIRSTELE(1,NBLK) = SI
      FIRSTELE(2,NBLK) = SJ
      FIRSTELE(3,NBLK) = SK

      END


C*********************************************************************
      SUBROUTINE RIGIDBODY_3D(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,
     &           JL2V,KL1,KL2,KEYOUT,NBLK,KEYOUT_CR,EDIAG,EBEFORE,
     &           EDISP,ERESID)
C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'pemodel.h'
      INCLUDE 'pebdary.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM*JDIM*KDIM)
      INTEGER KEYOUT_CR(IDIM*JDIM*KDIM)
      REAL*8  EDIAG(6,IDIM*JDIM*KDIM),EBEFORE(9,13,IDIM*JDIM*KDIM),
     &        EDISP(IDIM*JDIM*KDIM,3),ERESID(IDIM*JDIM*KDIM,3)
      INTEGER IOFF,JOFF,KOFF,KERR,NODE,II,JJ,KK,I1,J1,K1,
     &        I2,J2,K2,I3,J3,K3,I4,J4,K4
      INTEGER N1P,N12P,N123P,ICURR,IAF,NINDEX,LOOP
      REAL*8  ZERO
      PARAMETER (ZERO = 0.D0)
      CHARACTER*50 TITL

      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,KERR)
      N1P = IDIM
      N12P = N1P*JDIM
      N123P = N12P*KDIM


cbw   PROCESS USER-INPUT FIXED NODES DISPLACEMENTS

cbw   X DIRECTION

      IF (ISFIXDPX) THEN
         IF (LEVELC) THEN
            WRITE(NFOUT,*)
            TITL = '*******'
            CALL PRTTIT(TITL)
            TITL = 'USER-SPECIFIED X DIRECTION
     & RIGID BODY MOTION ELIMINATION'
            CALL PRTTIT(TITL)
         ENDIF

         DO NODE = 1,4
            II = XPOINTIND(1,NODE,NBLK)-IOFF
            JJ = XPOINTIND(2,NODE,NBLK)-JOFF
            KK = XPOINTIND(3,NODE,NBLK)-KOFF
            IF ((II.GE.1 .AND. II.LE.IDIM) .AND. 
     &          (JJ.GE.1 .AND. JJ.LE.JDIM) .AND.
     &          (KK.GE.1 .AND. KK.LE.KDIM)) THEN
               ICURR = (KK-1)*N12P+(JJ-1)*N1P+II

               IF (KEYOUT_CR(ICURR).EQ.1) THEN
                  EDISP(ICURR,1) = XPOINTDP(NODE,NBLK)
               ENDIF
                  
               IF (KEYOUT_CR(ICURR).NE.0) THEN
                  ERESID(ICURR,1) = ZERO
                  EDIAG(2,ICURR) = ZERO
                  EDIAG(3,ICURR) = ZERO
                  DO NINDEX = 1,NDIM_BEFORE
                     EBEFORE(1,NINDEX,ICURR) = ZERO
                     EBEFORE(4,NINDEX,ICURR) = ZERO
                     EBEFORE(7,NINDEX,ICURR) = ZERO
                  ENDDO
                  DO NINDEX = 1,NDIM_BEFORE
                     IAF = IOFFSET(NINDEX,NBLK) + ICURR
                     IF(IAF.LE.N123P) THEN
                        IF(KEYOUT_CR(IAF).NE.0) THEN
                        EBEFORE(1,NINDEX,IAF) = ZERO
                        EBEFORE(2,NINDEX,IAF) = ZERO
                        EBEFORE(3,NINDEX,IAF) = ZERO
                        ENDIF
                     ENDIF     
                  ENDDO
               ENDIF
            ENDIF
         ENDDO
      ENDIF

cbw   Y DIRECTION

      IF (ISFIXDPY) THEN
         IF (LEVELC) THEN
            WRITE(NFOUT,*)
            TITL = '*******'
            CALL PRTTIT(TITL)
            TITL = 'USER-SPECIFIED Y DIRECTION
     & RIGID BODY MOTION ELIMINATION'
            CALL PRTTIT(TITL)
         ENDIF

         DO NODE = 1,4
            II = YPOINTIND(1,NODE,NBLK)-IOFF
            JJ = YPOINTIND(2,NODE,NBLK)-JOFF
            KK = YPOINTIND(3,NODE,NBLK)-KOFF
            IF ((II.GE.1 .AND. II.LE.IDIM) .AND. 
     &          (JJ.GE.1 .AND. JJ.LE.JDIM) .AND.
     &          (KK.GE.1 .AND. KK.LE.KDIM)) THEN
               ICURR = (KK-1)*N12P+(JJ-1)*N1P+II

               IF (KEYOUT_CR(ICURR).EQ.1) THEN
                  EDISP(ICURR,2) = YPOINTDP(NODE,NBLK)
               ENDIF
                  
               IF (KEYOUT_CR(ICURR).NE.0) THEN
                  ERESID(ICURR,2) = ZERO
                  EDIAG(2,ICURR) = ZERO
                  EDIAG(5,ICURR) = ZERO
                  DO NINDEX = 1,NDIM_BEFORE
                     EBEFORE(2,NINDEX,ICURR) = ZERO
                     EBEFORE(5,NINDEX,ICURR) = ZERO
                     EBEFORE(8,NINDEX,ICURR) = ZERO
                  ENDDO
                  DO NINDEX = 1,NDIM_BEFORE
                     IAF = IOFFSET(NINDEX,NBLK) + ICURR
                     IF(IAF.LE.N123P) THEN
                        IF(KEYOUT_CR(IAF).NE.0) THEN
                        EBEFORE(4,NINDEX,IAF) = ZERO
                        EBEFORE(5,NINDEX,IAF) = ZERO
                        EBEFORE(6,NINDEX,IAF) = ZERO
                        ENDIF     
                     ENDIF     
                  ENDDO
               ENDIF
            ENDIF
         ENDDO
      ENDIF

cbw   Z DIRECTION

      IF (ISFIXDPZ) THEN
         IF (LEVELC) THEN
            WRITE(NFOUT,*)
            TITL = '*******'
            CALL PRTTIT(TITL)
            TITL = 'USER-SPECIFIED Z DIRECTION
     & RIGID BODY MOTION ELIMINATION'
            CALL PRTTIT(TITL)
         ENDIF

         DO NODE = 1,4
            II = ZPOINTIND(1,NODE,NBLK)-IOFF
            JJ = ZPOINTIND(2,NODE,NBLK)-JOFF
            KK = ZPOINTIND(3,NODE,NBLK)-KOFF
            IF ((II.GE.1 .AND. II.LE.IDIM) .AND. 
     &          (JJ.GE.1 .AND. JJ.LE.JDIM) .AND.
     &          (KK.GE.1 .AND. KK.LE.KDIM)) THEN
               ICURR = (KK-1)*N12P+(JJ-1)*N1P+II

               IF (KEYOUT_CR(ICURR).EQ.1) THEN
                  EDISP(ICURR,3) = ZPOINTDP(NODE,NBLK)
               ENDIF
                  
               IF (KEYOUT_CR(ICURR).NE.0) THEN
                  ERESID(ICURR,3) = ZERO
                  EDIAG(3,ICURR) = ZERO
                  EDIAG(5,ICURR) = ZERO
                  DO NINDEX = 1,NDIM_BEFORE
                     EBEFORE(3,NINDEX,ICURR) = ZERO
                     EBEFORE(6,NINDEX,ICURR) = ZERO
                     EBEFORE(9,NINDEX,ICURR) = ZERO
                  ENDDO
                  DO NINDEX = 1,NDIM_BEFORE
                     IAF = IOFFSET(NINDEX,NBLK) + ICURR
                     IF(IAF.LE.N123P) THEN
                        IF(KEYOUT_CR(IAF).NE.0) THEN
                        EBEFORE(7,NINDEX,IAF) = ZERO
                        EBEFORE(8,NINDEX,IAF) = ZERO
                        EBEFORE(9,NINDEX,IAF) = ZERO
                        ENDIF     
                     ENDIF     
                  ENDDO
               ENDIF
            ENDIF
         ENDDO
      ENDIF

cbw IF THERE ARE STILL DEGREE OF FREEDOM FOR RIGID BODY MOTION,USE
cbw DEFAULT ADDITIONAL BOUNDARY CONDITION TO ELIMINATE THE RIGID
cbw BODY MOTION AUTOMATICALLY

      WRITE(*,*) 'MYPRC =',MYPRC,'IZEROG=',(IZEROG(LOOP),LOOP=1,3)

      I1 = FIRSTELE(1,NBLK)+1-IOFF
      J1 = FIRSTELE(2,NBLK)-JOFF
      K1 = FIRSTELE(3,NBLK)-KOFF

      I2 = FIRSTELE(1,NBLK)+1-IOFF
      J2 = FIRSTELE(2,NBLK)+1-JOFF
      K2 = FIRSTELE(3,NBLK)-KOFF

      I3 = FIRSTELE(1,NBLK)+1-IOFF
      J3 = FIRSTELE(2,NBLK)-JOFF
      K3 = FIRSTELE(3,NBLK)+1-KOFF

cbw      I4 = FIRSTELE(1,NBLK)+1-IOFF
cbw      J4 = FIRSTELE(2,NBLK)-JOFF
cbw      K4 = FIRSTELE(3,NBLK)-KOFF

cbw X DIRECTION

      IF(IZEROG(1).LT.0.D0) THEN
         ITYPE_BOUNDARY(2,1,NBLK) = 1
         IF (LEVELC) THEN
            WRITE(NFOUT,*)
            TITL = '*******'
            CALL PRTTIT(TITL)
            TITL = 'WARNING: NO X-DISPLACEMENT BOUNDARY CONDITION'
            CALL PRTTIT(TITL)
            TITL = 'X-DISPLACEMENT IN +X FACE IS SET TO ZERO'
            CALL PRTTIT(TITL)
         ENDIF
      ENDIF


cbw   Y DIRECTION 
      IF(IZEROG(2).LT.0.D0) THEN
         IF (LEVELC) THEN
            WRITE(NFOUT,*)
            TITL = '*******'
            CALL PRTTIT(TITL)
            TITL = 'Y DIRECTION RIGID BODY MOTION ELIMINATION'
            CALL PRTTIT(TITL)
            WRITE(NFOUT,200)
     &            FIRSTELE(1,NBLK),FIRSTELE(2,NBLK),FIRSTELE(3,NBLK)
 200        FORMAT(' AT ELEMENT (I,J,K): ',I5,3X,I5,3X,I5)
         ENDIF
         IF ((I1.GE.1 .AND. I1.LE.IDIM) .AND. 
     &       (J1.GE.1 .AND. J1.LE.JDIM) .AND.
     &       (K1.GE.1 .AND. K1.LE.KDIM)) THEN
            ICURR = (K1-1)*N12P+(J1-1)*N1P+I1
                        
            IF (KEYOUT_CR(ICURR).EQ.1) THEN
               EDISP(ICURR,2) = ZERO
            ENDIF
         
            IF (KEYOUT_CR(ICURR).NE.0) THEN
               ERESID(ICURR,2) = ZERO
               EDIAG(2,ICURR) = ZERO
               EDIAG(5,ICURR) = ZERO
               DO NINDEX = 1,NDIM_BEFORE
                  EBEFORE(2,NINDEX,ICURR) = ZERO
                  EBEFORE(5,NINDEX,ICURR) = ZERO
                  EBEFORE(8,NINDEX,ICURR) = ZERO
               ENDDO
               DO NINDEX = 1,NDIM_BEFORE
                  IAF = IOFFSET(NINDEX,NBLK) + ICURR
                  IF(IAF.LE.N123P) THEN 
                     IF(KEYOUT_CR(IAF).NE.0) THEN
                     EBEFORE(4,NINDEX,IAF) = ZERO
                     EBEFORE(5,NINDEX,IAF) = ZERO
                     EBEFORE(6,NINDEX,IAF) = ZERO
                     ENDIF
                  ENDIF     
               ENDDO
            ENDIF
         ENDIF

         IF(IZEROG(3).LT.0.D0) THEN
            IF ((I3.GE.1 .AND. I3.LE.IDIM) .AND. 
     &          (J3.GE.1 .AND. J3.LE.JDIM) .AND.
     &          (K3.GE.1 .AND. K3.LE.KDIM)) THEN
               ICURR = (K3-1)*N12P+(J3-1)*N1P+I3
                          
               IF (KEYOUT_CR(ICURR).EQ.1) THEN
                  EDISP(ICURR,2) = ZERO
               ENDIF
           
               IF (KEYOUT_CR(ICURR).NE.0) THEN
                  ERESID(ICURR,2) = ZERO
                  EDIAG(2,ICURR) = ZERO
                  EDIAG(5,ICURR) = ZERO
                  DO NINDEX = 1,NDIM_BEFORE
                     EBEFORE(2,NINDEX,ICURR) = ZERO
                     EBEFORE(5,NINDEX,ICURR) = ZERO
                     EBEFORE(8,NINDEX,ICURR) = ZERO
                  ENDDO
                  DO NINDEX = 1,NDIM_BEFORE
                     IAF = IOFFSET(NINDEX,NBLK) + ICURR
                     IF(IAF.LE.N123P) THEN
                        IF(KEYOUT_CR(IAF).NE.0) THEN
                        EBEFORE(4,NINDEX,IAF) = ZERO
                        EBEFORE(5,NINDEX,IAF) = ZERO
                        EBEFORE(6,NINDEX,IAF) = ZERO
                        ENDIF     
                     ENDIF     
                  ENDDO
               ENDIF
            ENDIF
            IF ((I2.GE.1 .AND. I2.LE.IDIM) .AND. 
     &          (J2.GE.1 .AND. J2.LE.JDIM) .AND.
     &          (K2.GE.1 .AND. K2.LE.KDIM)) THEN
               ICURR = (K2-1)*N12P+(J2-1)*N1P+I2
                        
               IF (KEYOUT_CR(ICURR).EQ.1) THEN
                  EDISP(ICURR,2) = ZERO
               ENDIF

               IF (KEYOUT_CR(ICURR).NE.0) THEN
                  ERESID(ICURR,2) = ZERO
                  EDIAG(2,ICURR) = ZERO
                  EDIAG(5,ICURR) = ZERO
                  DO NINDEX = 1,NDIM_BEFORE
                     EBEFORE(2,NINDEX,ICURR) = ZERO
                     EBEFORE(5,NINDEX,ICURR) = ZERO
                     EBEFORE(8,NINDEX,ICURR) = ZERO
                  ENDDO
                  DO NINDEX = 1,NDIM_BEFORE
                     IAF = IOFFSET(NINDEX,NBLK) + ICURR
                     IF(IAF.LE.N123P) THEN
                        IF(KEYOUT_CR(IAF).NE.0) THEN
                        EBEFORE(4,NINDEX,IAF) = ZERO
                        EBEFORE(5,NINDEX,IAF) = ZERO
                        EBEFORE(6,NINDEX,IAF) = ZERO
                        ENDIF     
                     ENDIF     
                  ENDDO
               ENDIF
            ENDIF
         ENDIF
      ENDIF

cbw Z DIRECTION

      IF(IZEROG(3).LT.0.D0) THEN
         IF (LEVELC) THEN
            WRITE(NFOUT,*)
            TITL = '*******'
            CALL PRTTIT(TITL)
            TITL = 'Z DIRECTION RIGID BODY MOTION ELIMINATION'
            CALL PRTTIT(TITL)
            WRITE(NFOUT,300)
     &            FIRSTELE(1,NBLK),FIRSTELE(2,NBLK),FIRSTELE(3,NBLK)
 300        FORMAT(' AT ELEMENT (I,J,K): ',I5,3X,I5,3X,I5)
         ENDIF
         IF ((I1.GE.1 .AND. I1.LE.IDIM) .AND. 
     &       (J1.GE.1 .AND. J1.LE.JDIM) .AND.
     &       (K1.GE.1 .AND. K1.LE.KDIM)) THEN
            ICURR = (K1-1)*N12P+(J1-1)*N1P+I1
                        
            IF (KEYOUT_CR(ICURR).EQ.1) THEN
               EDISP(ICURR,3) = ZERO
            ENDIF
         
            IF (KEYOUT_CR(ICURR).NE.0) THEN
               ERESID(ICURR,3) = ZERO
               EDIAG(3,ICURR) = ZERO
               EDIAG(5,ICURR) = ZERO
               DO NINDEX = 1,NDIM_BEFORE
                  EBEFORE(3,NINDEX,ICURR) = ZERO
                  EBEFORE(6,NINDEX,ICURR) = ZERO
                  EBEFORE(9,NINDEX,ICURR) = ZERO
               ENDDO
               DO NINDEX = 1,NDIM_BEFORE
                  IAF = IOFFSET(NINDEX,NBLK) + ICURR
                  IF(IAF.LE.N123P) THEN
                     IF(KEYOUT_CR(IAF).NE.0) THEN
                     EBEFORE(7,NINDEX,IAF) = ZERO
                     EBEFORE(8,NINDEX,IAF) = ZERO
                     EBEFORE(9,NINDEX,IAF) = ZERO
                     ENDIF     
                  ENDIF     
               ENDDO
            ENDIF
         ENDIF

         IF(IZEROG(2).LT.0.D0) THEN
            IF ((I2.GE.1 .AND. I2.LE.IDIM) .AND. 
     &          (J2.GE.1 .AND. J2.LE.JDIM) .AND.
     &          (K2.GE.1 .AND. K2.LE.KDIM)) THEN
               ICURR = (K2-1)*N12P+(J2-1)*N1P+I2
                        
               IF (KEYOUT_CR(ICURR).EQ.1) THEN
                  EDISP(ICURR,3) = ZERO
               ENDIF

               IF (KEYOUT_CR(ICURR).NE.0) THEN
                  ERESID(ICURR,3) = ZERO
                  EDIAG(3,ICURR) = ZERO
                  EDIAG(5,ICURR) = ZERO
                  DO NINDEX = 1,NDIM_BEFORE
                     EBEFORE(3,NINDEX,ICURR) = ZERO
                     EBEFORE(6,NINDEX,ICURR) = ZERO
                     EBEFORE(9,NINDEX,ICURR) = ZERO
                  ENDDO
                  DO NINDEX = 1,NDIM_BEFORE
                     IAF = IOFFSET(NINDEX,NBLK) + ICURR
                     IF(IAF.LE.N123P) THEN
                        IF(KEYOUT_CR(IAF).NE.0) THEN
                        EBEFORE(7,NINDEX,IAF) = ZERO
                        EBEFORE(8,NINDEX,IAF) = ZERO
                        EBEFORE(9,NINDEX,IAF) = ZERO
                        ENDIF     
                     ENDIF     
                  ENDDO
               ENDIF
            ENDIF
            IF ((I3.GE.1 .AND. I3.LE.IDIM) .AND. 
     &          (J3.GE.1 .AND. J3.LE.JDIM) .AND.
     &          (K3.GE.1 .AND. K3.LE.KDIM)) THEN
               ICURR = (K3-1)*N12P+(J3-1)*N1P+I3
                          
               IF (KEYOUT_CR(ICURR).EQ.1) THEN
                  EDISP(ICURR,3) = ZERO
               ENDIF
           
               IF (KEYOUT_CR(ICURR).NE.0) THEN
                  ERESID(ICURR,3) = ZERO
                  EDIAG(3,ICURR) = ZERO
                  EDIAG(5,ICURR) = ZERO
                  DO NINDEX = 1,NDIM_BEFORE
                     EBEFORE(3,NINDEX,ICURR) = ZERO
                     EBEFORE(6,NINDEX,ICURR) = ZERO
                     EBEFORE(9,NINDEX,ICURR) = ZERO
                  ENDDO
                  DO NINDEX = 1,NDIM_BEFORE
                     IAF = IOFFSET(NINDEX,NBLK) + ICURR
                     IF(IAF.LE.N123P) THEN
                        IF(KEYOUT_CR(IAF).NE.0) THEN
                        EBEFORE(7,NINDEX,IAF) = ZERO
                        EBEFORE(8,NINDEX,IAF) = ZERO
                        EBEFORE(9,NINDEX,IAF) = ZERO
                        ENDIF     
                     ENDIF     
                  ENDDO
               ENDIF
            ENDIF
         ENDIF
      ENDIF

      RETURN

      IF(IZEROG(1).LT.0.D0) THEN
         IF (LEVELC) THEN
            WRITE(NFOUT,*)
            TITL = '*******'
            CALL PRTTIT(TITL)
            TITL = 'X DIRECTION RIGID BODY MOTION ELIMINATION'
            CALL PRTTIT(TITL)
            WRITE(NFOUT,100)
     &            FIRSTELE(1,NBLK),FIRSTELE(2,NBLK),FIRSTELE(3,NBLK)
 100        FORMAT(' AT ELEMENT (I,J,K): ',I5,3X,I5,3X,I5)
         ENDIF

         IF ((I1.GE.1 .AND. I1.LE.IDIM) .AND. 
     &       (J1.GE.1 .AND. J1.LE.JDIM) .AND.
     &       (K1.GE.1 .AND. K1.LE.KDIM)) THEN
            ICURR = (K1-1)*N12P+(J1-1)*N1P+I1
                        
            IF (KEYOUT_CR(ICURR).EQ.1) THEN
               EDISP(ICURR,1) = ZERO
            ENDIF
         
            IF (KEYOUT_CR(ICURR).NE.0) THEN
               ERESID(ICURR,1) = ZERO
               EDIAG(2,ICURR) = ZERO
               EDIAG(3,ICURR) = ZERO
               DO NINDEX = 1,NDIM_BEFORE
                  EBEFORE(1,NINDEX,ICURR) = ZERO
                  EBEFORE(4,NINDEX,ICURR) = ZERO
                  EBEFORE(7,NINDEX,ICURR) = ZERO
               ENDDO
               DO NINDEX = 1,NDIM_BEFORE
                  IAF = IOFFSET(NINDEX,NBLK) + ICURR
                  IF(IAF.LE.N123P) THEN
                     IF(KEYOUT_CR(IAF).NE.0) THEN
                     EBEFORE(1,NINDEX,IAF) = ZERO
                     EBEFORE(2,NINDEX,IAF) = ZERO
                     EBEFORE(3,NINDEX,IAF) = ZERO
                     ENDIF     
                  ENDIF     
               ENDDO
            ENDIF
         ENDIF

         IF(IZEROG(2).LT.0.D0.OR.IZEROG(3).LT.0.D0) THEN
            IF(IZEROG(3).LT.0.D0) THEN

               IF ((I3.GE.1 .AND. I3.LE.IDIM) .AND. 
     &             (J3.GE.1 .AND. J3.LE.JDIM) .AND.
     &             (K3.GE.1 .AND. K3.LE.KDIM)) THEN
                  ICURR = (K3-1)*N12P+(J3-1)*N1P+I3
                        
                  IF (KEYOUT_CR(ICURR).EQ.1) THEN
                     EDISP(ICURR,1) = ZERO
                  ENDIF

                  IF (KEYOUT_CR(ICURR).NE.0) THEN
                     ERESID(ICURR,1) = ZERO
                     EDIAG(2,ICURR) = ZERO
                     EDIAG(3,ICURR) = ZERO
                     DO NINDEX = 1,NDIM_BEFORE
                        EBEFORE(1,NINDEX,ICURR) = ZERO
                        EBEFORE(4,NINDEX,ICURR) = ZERO
                        EBEFORE(7,NINDEX,ICURR) = ZERO
                     ENDDO
                     DO NINDEX = 1,NDIM_BEFORE
                        IAF = IOFFSET(NINDEX,NBLK) + ICURR
                     IF(IAF.LE.N123P) THEN
                        IF(KEYOUT_CR(IAF).NE.0) THEN
                           EBEFORE(1,NINDEX,IAF) = ZERO
                           EBEFORE(2,NINDEX,IAF) = ZERO
                           EBEFORE(3,NINDEX,IAF) = ZERO
                        ENDIF     
                     ENDIF     
                     ENDDO
                  ENDIF
               ENDIF

            ELSE
               IF ((I2.GE.1 .AND. I2.LE.IDIM) .AND. 
     &             (J2.GE.1 .AND. J2.LE.JDIM) .AND.
     &             (K2.GE.1 .AND. K2.LE.KDIM)) THEN
                  ICURR = (K2-1)*N12P+(J2-1)*N1P+I2
                        
                  IF (KEYOUT_CR(ICURR).EQ.1) THEN
                     EDISP(ICURR,1) = ZERO
                  ENDIF

                  IF (KEYOUT_CR(ICURR).NE.0) THEN
                     ERESID(ICURR,1) = ZERO
                     EDIAG(2,ICURR) = ZERO
                     EDIAG(3,ICURR) = ZERO
                     DO NINDEX = 1,NDIM_BEFORE
                        EBEFORE(1,NINDEX,ICURR) = ZERO
                        EBEFORE(4,NINDEX,ICURR) = ZERO
                        EBEFORE(7,NINDEX,ICURR) = ZERO
                     ENDDO
                     DO NINDEX = 1,NDIM_BEFORE
                        IAF = IOFFSET(NINDEX,NBLK) + ICURR
                     IF(IAF.LE.N123P) THEN
                        IF(KEYOUT_CR(IAF).NE.0) THEN
                           EBEFORE(1,NINDEX,IAF) = ZERO
                           EBEFORE(2,NINDEX,IAF) = ZERO
                           EBEFORE(3,NINDEX,IAF) = ZERO
                        ENDIF     
                     ENDIF     
                     ENDDO
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDIF
            
      IF(IZEROG(2).LT.0.D0) THEN
         ITYPE_BOUNDARY(2,2,NBLK) = 1
         IF (LEVELC) THEN
            WRITE(NFOUT,*)
            TITL = '*******'
            CALL PRTTIT(TITL)
            TITL = 'WARNING: NO Y-DISPLACEMENT BOUNDARY CONDITION'
            CALL PRTTIT(TITL)
            TITL = 'Y-DISPLACEMENT IN +X FACE IS SET TO ZERO'
            CALL PRTTIT(TITL)
         ENDIF
      ENDIF

      IF(IZEROG(3).LT.0.D0) THEN
         ITYPE_BOUNDARY(2,3,NBLK) = 1
         IF (LEVELC) THEN
            WRITE(NFOUT,*)
            TITL = '*******'
            CALL PRTTIT(TITL)
            TITL = 'WARNING: NO Z-DISPLACEMENT BOUNDARY CONDITION'
            CALL PRTTIT(TITL)
            TITL = 'Z-DISPLACEMENT IN +X FACE IS SET TO ZERO'
            CALL PRTTIT(TITL)
         ENDIF
      ENDIF


      END




C*********************************************************************
      SUBROUTINE RIGIDBODY_ZERO(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,
     &           JL2V,KL1,KL2,KEYOUT,NBLK,KEYOUT_CR,ERESID)
C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'pemodel.h'
      INCLUDE 'pebdary.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM*JDIM*KDIM)
      INTEGER KEYOUT_CR(IDIM*JDIM*KDIM)
      REAL*8  ERESID(IDIM*JDIM*KDIM,3)
      INTEGER IOFF,JOFF,KOFF,KERR,NODE,II,JJ,KK,I1,J1,K1,
     &        I2,J2,K2,I3,J3,K3,I4,J4,K4
      INTEGER N1P,N12P,N123P,ICURR,NINDEX
      REAL*8  ZERO
      PARAMETER (ZERO = 0.D0)

      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,KERR)
      N1P = IDIM
      N12P = N1P*JDIM
      N123P = N12P*KDIM

cbw   PROCESS USER-INPUT FIXED NODES DISPLACEMENTS

cbw   X DIRECTION

      IF (ISFIXDPX) THEN
         DO NODE = 1,4
            II = XPOINTIND(1,NODE,NBLK)-IOFF
            JJ = XPOINTIND(2,NODE,NBLK)-JOFF
            KK = XPOINTIND(3,NODE,NBLK)-KOFF
            IF ((II.GE.1 .AND. II.LE.IDIM) .AND. 
     &          (JJ.GE.1 .AND. JJ.LE.JDIM) .AND.
     &          (KK.GE.1 .AND. KK.LE.KDIM)) THEN
               ICURR = (KK-1)*N12P+(JJ-1)*N1P+II
                  
               IF (KEYOUT_CR(ICURR).NE.0) THEN
                  ERESID(ICURR,1) = ZERO
               ENDIF
            ENDIF
         ENDDO
      ENDIF

cbw   Y DIRECTION

      IF (ISFIXDPY) THEN
         DO NODE = 1,4
            II = YPOINTIND(1,NODE,NBLK)-IOFF
            JJ = YPOINTIND(2,NODE,NBLK)-JOFF
            KK = YPOINTIND(3,NODE,NBLK)-KOFF
            IF ((II.GE.1 .AND. II.LE.IDIM) .AND. 
     &          (JJ.GE.1 .AND. JJ.LE.JDIM) .AND.
     &          (KK.GE.1 .AND. KK.LE.KDIM)) THEN
               ICURR = (KK-1)*N12P+(JJ-1)*N1P+II
                  
               IF (KEYOUT_CR(ICURR).NE.0) THEN
                  ERESID(ICURR,2) = ZERO
               ENDIF
            ENDIF
         ENDDO
      ENDIF

cbw   Z DIRECTION

      IF (ISFIXDPZ) THEN
         DO NODE = 1,4
            II = ZPOINTIND(1,NODE,NBLK)-IOFF
            JJ = ZPOINTIND(2,NODE,NBLK)-JOFF
            KK = ZPOINTIND(3,NODE,NBLK)-KOFF
            IF ((II.GE.1 .AND. II.LE.IDIM) .AND. 
     &          (JJ.GE.1 .AND. JJ.LE.JDIM) .AND.
     &          (KK.GE.1 .AND. KK.LE.KDIM)) THEN
               ICURR = (KK-1)*N12P+(JJ-1)*N1P+II
                  
               IF (KEYOUT_CR(ICURR).NE.0) THEN
                  ERESID(ICURR,3) = ZERO
               ENDIF
            ENDIF
         ENDDO
      ENDIF

cbw IF THERE ARE STILL DEGREE OF FREEDOM FOR RIGID BODY MOTION,USE
cbw DEFAULT ADDITIONAL BOUNDARY CONDITION TO ELIMINATE THE RIGID
cbw BODY MOTION AUTOMATICALLY

      I1 = FIRSTELE(1,NBLK)+1-IOFF
      J1 = FIRSTELE(2,NBLK)-JOFF
      K1 = FIRSTELE(3,NBLK)-KOFF

      I2 = FIRSTELE(1,NBLK)+1-IOFF
      J2 = FIRSTELE(2,NBLK)+1-JOFF
      K2 = FIRSTELE(3,NBLK)-KOFF

      I3 = FIRSTELE(1,NBLK)+1-IOFF
      J3 = FIRSTELE(2,NBLK)-JOFF
      K3 = FIRSTELE(3,NBLK)+1-KOFF

cbw      I4 = FIRSTELE(1,NBLK)+1-IOFF
cbw      J4 = FIRSTELE(2,NBLK)-JOFF
cbw      K4 = FIRSTELE(3,NBLK)-KOFF


cbw   Y DIRECTION 
      IF(IZEROG(2).LT.0.D0) THEN
         IF ((I1.GE.1 .AND. I1.LE.IDIM) .AND. 
     &       (J1.GE.1 .AND. J1.LE.JDIM) .AND.
     &       (K1.GE.1 .AND. K1.LE.KDIM)) THEN
            ICURR = (K1-1)*N12P+(J1-1)*N1P+I1
                        
            IF (KEYOUT_CR(ICURR).NE.0) THEN
               ERESID(ICURR,2) = ZERO
            ENDIF
         ENDIF

         IF(IZEROG(3).LT.0.D0) THEN
            IF ((I3.GE.1 .AND. I3.LE.IDIM) .AND. 
     &          (J3.GE.1 .AND. J3.LE.JDIM) .AND.
     &          (K3.GE.1 .AND. K3.LE.KDIM)) THEN
               ICURR = (K3-1)*N12P+(J3-1)*N1P+I3
                          
               IF (KEYOUT_CR(ICURR).NE.0) THEN
                  ERESID(ICURR,2) = ZERO
               ENDIF
            ENDIF
            IF ((I2.GE.1 .AND. I2.LE.IDIM) .AND. 
     &          (J2.GE.1 .AND. J2.LE.JDIM) .AND.
     &          (K2.GE.1 .AND. K2.LE.KDIM)) THEN
               ICURR = (K2-1)*N12P+(J2-1)*N1P+I2
                        
               IF (KEYOUT_CR(ICURR).NE.0) THEN
                  ERESID(ICURR,2) = ZERO
               ENDIF
            ENDIF
         ENDIF
      ENDIF

cbw Z DIRECTION

      IF(IZEROG(3).LT.0.D0) THEN
         IF ((I1.GE.1 .AND. I1.LE.IDIM) .AND. 
     &       (J1.GE.1 .AND. J1.LE.JDIM) .AND.
     &       (K1.GE.1 .AND. K1.LE.KDIM)) THEN
            ICURR = (K1-1)*N12P+(J1-1)*N1P+I1
                        
            IF (KEYOUT_CR(ICURR).NE.0) THEN
               ERESID(ICURR,3) = ZERO
            ENDIF
         ENDIF

         IF(IZEROG(2).LT.0.D0) THEN
            IF ((I2.GE.1 .AND. I2.LE.IDIM) .AND. 
     &          (J2.GE.1 .AND. J2.LE.JDIM) .AND.
     &          (K2.GE.1 .AND. K2.LE.KDIM)) THEN
               ICURR = (K2-1)*N12P+(J2-1)*N1P+I2
                        
               IF (KEYOUT_CR(ICURR).NE.0) THEN
                  ERESID(ICURR,3) = ZERO
               ENDIF
            ENDIF
            IF ((I3.GE.1 .AND. I3.LE.IDIM) .AND. 
     &          (J3.GE.1 .AND. J3.LE.JDIM) .AND.
     &          (K3.GE.1 .AND. K3.LE.KDIM)) THEN
               ICURR = (K3-1)*N12P+(J3-1)*N1P+I3
                          
               IF (KEYOUT_CR(ICURR).NE.0) THEN
                  ERESID(ICURR,3) = ZERO
               ENDIF
            ENDIF
         ENDIF
      ENDIF

      RETURN

cbw X DIRECTION

      IF(IZEROG(1).LT.0.D0) THEN
         IF ((I1.GE.1 .AND. I1.LE.IDIM) .AND. 
     &       (J1.GE.1 .AND. J1.LE.JDIM) .AND.
     &       (K1.GE.1 .AND. K1.LE.KDIM)) THEN
            ICURR = (K1-1)*N12P+(J1-1)*N1P+I1
         
            IF (KEYOUT_CR(ICURR).NE.0) THEN
               ERESID(ICURR,1) = ZERO
            ENDIF
         ENDIF

         IF(IZEROG(2).LT.0.D0.OR.IZEROG(3).LT.0.D0) THEN
            IF(IZEROG(3).LT.0.D0) THEN

               IF ((I3.GE.1 .AND. I3.LE.IDIM) .AND. 
     &             (J3.GE.1 .AND. J3.LE.JDIM) .AND.
     &             (K3.GE.1 .AND. K3.LE.KDIM)) THEN
                  ICURR = (K3-1)*N12P+(J3-1)*N1P+I3
                        
                  IF (KEYOUT_CR(ICURR).NE.0) THEN
                     ERESID(ICURR,1) = ZERO
                  ENDIF
               ENDIF

            ELSE
               IF ((I2.GE.1 .AND. I2.LE.IDIM) .AND. 
     &             (J2.GE.1 .AND. J2.LE.JDIM) .AND.
     &             (K2.GE.1 .AND. K2.LE.KDIM)) THEN
                  ICURR = (K2-1)*N12P+(J2-1)*N1P+I2
                        
                  IF (KEYOUT_CR(ICURR).NE.0) THEN
                     ERESID(ICURR,1) = ZERO
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDIF


      END










C*********************************************************************
      SUBROUTINE RIGIDBODY_3D_OLD(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,
     &           JL2V,KL1,KL2,KEYOUT,NBLK,KEYOUT_CR,EDIAG,EBEFORE,
     &           EDISP,ERESID)
C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'pemodel.h'
      INCLUDE 'pebdary.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM*JDIM*KDIM)
      INTEGER KEYOUT_CR(IDIM*JDIM*KDIM)
      REAL*8  EDIAG(6,IDIM*JDIM*KDIM),EBEFORE(9,13,IDIM*JDIM*KDIM),
     &        EDISP(IDIM*JDIM*KDIM,3),ERESID(IDIM*JDIM*KDIM,3)
      INTEGER IOFF,JOFF,KOFF,KERR,NODE,II,JJ,KK,I1,J1,K1,
     &        I2,J2,K2,I3,J3,K3,I4,J4,K4
      INTEGER N1P,N12P,N123P,ICURR,IAF,NINDEX,LOOP
      REAL*8  ZERO
      PARAMETER (ZERO = 0.D0)
      CHARACTER*50 TITL



      IF(IZEROG(1).LT.0.D0) THEN
         ITYPE_BOUNDARY(2,1,NBLK) = 1
         IF (LEVELC) THEN
            WRITE(NFOUT,*)
            TITL = '*******'
            CALL PRTTIT(TITL)
            TITL = 'WARNING: NO X-DISPLACEMENT BOUNDARY CONDITION'
            CALL PRTTIT(TITL)
            TITL = 'X-DISPLACEMENT IN +X FACE IS SET TO ZERO'
            CALL PRTTIT(TITL)
         ENDIF
      ENDIF
            
      IF(IZEROG(2).LT.0.D0) THEN
         ITYPE_BOUNDARY(2,2,NBLK) = 1
         IF (LEVELC) THEN
            WRITE(NFOUT,*)
            TITL = '*******'
            CALL PRTTIT(TITL)
            TITL = 'WARNING: NO Y-DISPLACEMENT BOUNDARY CONDITION'
            CALL PRTTIT(TITL)
            TITL = 'Y-DISPLACEMENT IN +X FACE IS SET TO ZERO'
            CALL PRTTIT(TITL)
         ENDIF
      ENDIF

      IF(IZEROG(3).LT.0.D0) THEN
         ITYPE_BOUNDARY(2,3,NBLK) = 1
         IF (LEVELC) THEN
            WRITE(NFOUT,*)
            TITL = '*******'
            CALL PRTTIT(TITL)
            TITL = 'WARNING: NO Z-DISPLACEMENT BOUNDARY CONDITION'
            CALL PRTTIT(TITL)
            TITL = 'Z-DISPLACEMENT IN +X FACE IS SET TO ZERO'
            CALL PRTTIT(TITL)
         ENDIF
      ENDIF

      RETURN









      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,KERR)
      N1P = IDIM
      N12P = N1P*JDIM
      N123P = N12P*KDIM

cbw   PROCESS USER-INPUT FIXED NODES DISPLACEMENTS

cbw   X DIRECTION

      IF (ISFIXDPX) THEN
         IF (LEVELC) THEN
            WRITE(NFOUT,*)
            TITL = '*******'
            CALL PRTTIT(TITL)
            TITL = 'USER-SPECIFIED X DIRECTION
     & RIGID BODY MOTION ELIMINATION'
            CALL PRTTIT(TITL)
         ENDIF

         DO NODE = 1,3
            II = XPOINTIND(1,NODE,NBLK)-IOFF
            JJ = XPOINTIND(2,NODE,NBLK)-JOFF
            KK = XPOINTIND(3,NODE,NBLK)-KOFF
            IF ((II.GE.1 .AND. II.LE.IDIM) .AND. 
     &          (JJ.GE.1 .AND. JJ.LE.JDIM) .AND.
     &          (KK.GE.1 .AND. KK.LE.KDIM)) THEN
               ICURR = (KK-1)*N12P+(JJ-1)*N1P+II

               IF (KEYOUT_CR(ICURR).EQ.1) THEN
                  EDISP(ICURR,1) = XPOINTDP(NODE,NBLK)
               ENDIF
                  
               IF (KEYOUT_CR(ICURR).NE.0) THEN
                  ERESID(ICURR,1) = ZERO
                  EDIAG(2,ICURR) = ZERO
                  EDIAG(3,ICURR) = ZERO
                  DO NINDEX = 1,NDIM_BEFORE
                     EBEFORE(1,NINDEX,ICURR) = ZERO
                     EBEFORE(4,NINDEX,ICURR) = ZERO
                     EBEFORE(7,NINDEX,ICURR) = ZERO
                  ENDDO
                  DO NINDEX = 1,NDIM_BEFORE
                     IAF = IOFFSET(NINDEX,NBLK) + ICURR
                     IF(IAF.LE.N123P.AND.KEYOUT_CR(IAF).NE.0) THEN
                        EBEFORE(1,NINDEX,IAF) = ZERO
                        EBEFORE(2,NINDEX,IAF) = ZERO
                        EBEFORE(3,NINDEX,IAF) = ZERO
                     ENDIF     
                  ENDDO
               ENDIF
            ENDIF
         ENDDO
      ENDIF

cbw   Y DIRECTION

      IF (ISFIXDPY) THEN
         IF (LEVELC) THEN
            WRITE(NFOUT,*)
            TITL = '*******'
            CALL PRTTIT(TITL)
            TITL = 'USER-SPECIFIED Y DIRECTION
     & RIGID BODY MOTION ELIMINATION'
            CALL PRTTIT(TITL)
         ENDIF

         DO NODE = 1,3
            II = YPOINTIND(1,NODE,NBLK)-IOFF
            JJ = YPOINTIND(2,NODE,NBLK)-JOFF
            KK = YPOINTIND(3,NODE,NBLK)-KOFF
            IF ((II.GE.1 .AND. II.LE.IDIM) .AND. 
     &          (JJ.GE.1 .AND. JJ.LE.JDIM) .AND.
     &          (KK.GE.1 .AND. KK.LE.KDIM)) THEN
               ICURR = (KK-1)*N12P+(JJ-1)*N1P+II

               IF (KEYOUT_CR(ICURR).EQ.1) THEN
                  EDISP(ICURR,2) = YPOINTDP(NODE,NBLK)
               ENDIF
                  
               IF (KEYOUT_CR(ICURR).NE.0) THEN
                  ERESID(ICURR,2) = ZERO
                  EDIAG(2,ICURR) = ZERO
                  EDIAG(5,ICURR) = ZERO
                  DO NINDEX = 1,NDIM_BEFORE
                     EBEFORE(2,NINDEX,ICURR) = ZERO
                     EBEFORE(5,NINDEX,ICURR) = ZERO
                     EBEFORE(8,NINDEX,ICURR) = ZERO
                  ENDDO
                  DO NINDEX = 1,NDIM_BEFORE
                     IAF = IOFFSET(NINDEX,NBLK) + ICURR
                     IF(IAF.LE.N123P.AND.KEYOUT_CR(IAF).NE.0) THEN
                        EBEFORE(4,NINDEX,IAF) = ZERO
                        EBEFORE(5,NINDEX,IAF) = ZERO
                        EBEFORE(6,NINDEX,IAF) = ZERO
                     ENDIF     
                  ENDDO
               ENDIF
            ENDIF
         ENDDO
      ENDIF

cbw   Z DIRECTION

      IF (ISFIXDPZ) THEN
         IF (LEVELC) THEN
            WRITE(NFOUT,*)
            TITL = '*******'
            CALL PRTTIT(TITL)
            TITL = 'USER-SPECIFIED Z DIRECTION
     & RIGID BODY MOTION ELIMINATION'
            CALL PRTTIT(TITL)
         ENDIF

         DO NODE = 1,3
            II = ZPOINTIND(1,NODE,NBLK)-IOFF
            JJ = ZPOINTIND(2,NODE,NBLK)-JOFF
            KK = ZPOINTIND(3,NODE,NBLK)-KOFF
            IF ((II.GE.1 .AND. II.LE.IDIM) .AND. 
     &          (JJ.GE.1 .AND. JJ.LE.JDIM) .AND.
     &          (KK.GE.1 .AND. KK.LE.KDIM)) THEN
               ICURR = (KK-1)*N12P+(JJ-1)*N1P+II

               IF (KEYOUT_CR(ICURR).EQ.1) THEN
                  EDISP(ICURR,3) = ZPOINTDP(NODE,NBLK)
               ENDIF
                  
               IF (KEYOUT_CR(ICURR).NE.0) THEN
                  ERESID(ICURR,3) = ZERO
                  EDIAG(3,ICURR) = ZERO
                  EDIAG(5,ICURR) = ZERO
                  DO NINDEX = 1,NDIM_BEFORE
                     EBEFORE(3,NINDEX,ICURR) = ZERO
                     EBEFORE(6,NINDEX,ICURR) = ZERO
                     EBEFORE(9,NINDEX,ICURR) = ZERO
                  ENDDO
                  DO NINDEX = 1,NDIM_BEFORE
                     IAF = IOFFSET(NINDEX,NBLK) + ICURR
                     IF(IAF.LE.N123P.AND.KEYOUT_CR(IAF).NE.0) THEN
                        EBEFORE(7,NINDEX,IAF) = ZERO
                        EBEFORE(8,NINDEX,IAF) = ZERO
                        EBEFORE(9,NINDEX,IAF) = ZERO
                     ENDIF     
                  ENDDO
               ENDIF
            ENDIF
         ENDDO
      ENDIF

cbw IF THERE ARE STILL DEGREE OF FREEDOM FOR RIGID BODY MOTION,USE
cbw DEFAULT ADDITIONAL BOUNDARY CONDITION TO ELIMINATE THE RIGID
cbw BODY MOTION AUTOMATICALLY

      WRITE(*,*) 'MYPRC =',MYPRC,'IZEROG=',(IZEROG(LOOP),LOOP=1,3)

      I1 = FIRSTELE(1,NBLK)-IOFF
      J1 = FIRSTELE(2,NBLK)-JOFF
      K1 = FIRSTELE(3,NBLK)-KOFF

      I2 = FIRSTELE(1,NBLK)-IOFF
      J2 = FIRSTELE(2,NBLK)+1-JOFF
      K2 = FIRSTELE(3,NBLK)-KOFF

      I3 = FIRSTELE(1,NBLK)-IOFF
      J3 = FIRSTELE(2,NBLK)-JOFF
      K3 = FIRSTELE(3,NBLK)+1-KOFF

      I4 = FIRSTELE(1,NBLK)+1-IOFF
      J4 = FIRSTELE(2,NBLK)-JOFF
      K4 = FIRSTELE(3,NBLK)-KOFF

cbw X DIRECTION

      IF(IZEROG(1).LT.0.D0) THEN
         IF (LEVELC) THEN
            WRITE(NFOUT,*)
            TITL = '*******'
            CALL PRTTIT(TITL)
            TITL = 'X DIRECTION RIGID BODY MOTION ELIMINATION'
            CALL PRTTIT(TITL)
            WRITE(NFOUT,100)
     &            FIRSTELE(1,NBLK),FIRSTELE(2,NBLK),FIRSTELE(3,NBLK)
 100        FORMAT(' AT ELEMENT (I,J,K): ',I5,3X,I5,3X,I5)
         ENDIF

         IF ((I1.GE.1 .AND. I1.LE.IDIM) .AND. 
     &       (J1.GE.1 .AND. J1.LE.JDIM) .AND.
     &       (K1.GE.1 .AND. K1.LE.KDIM)) THEN
            ICURR = (K1-1)*N12P+(J1-1)*N1P+I1
                        
            IF (KEYOUT_CR(ICURR).EQ.1) THEN
               EDISP(ICURR,1) = ZERO
            ENDIF
         
            IF (KEYOUT_CR(ICURR).NE.0) THEN
               ERESID(ICURR,1) = ZERO
               EDIAG(2,ICURR) = ZERO
               EDIAG(3,ICURR) = ZERO
               DO NINDEX = 1,NDIM_BEFORE
                  EBEFORE(1,NINDEX,ICURR) = ZERO
                  EBEFORE(4,NINDEX,ICURR) = ZERO
                  EBEFORE(7,NINDEX,ICURR) = ZERO
               ENDDO
               DO NINDEX = 1,NDIM_BEFORE
                  IAF = IOFFSET(NINDEX,NBLK) + ICURR
                  IF(IAF.LE.N123P.AND.KEYOUT_CR(IAF).NE.0) THEN
                     EBEFORE(1,NINDEX,IAF) = ZERO
                     EBEFORE(2,NINDEX,IAF) = ZERO
                     EBEFORE(3,NINDEX,IAF) = ZERO
                  ENDIF     
               ENDDO
            ENDIF
         ENDIF

         IF(IZEROG(2).LT.0.D0.OR.IZEROG(3).LT.0.D0) THEN
            IF(IZEROG(3).LT.0.D0) THEN

               IF ((I3.GE.1 .AND. I3.LE.IDIM) .AND. 
     &             (J3.GE.1 .AND. J3.LE.JDIM) .AND.
     &             (K3.GE.1 .AND. K3.LE.KDIM)) THEN
                  ICURR = (K3-1)*N12P+(J3-1)*N1P+I3
                        
                  IF (KEYOUT_CR(ICURR).EQ.1) THEN
                     EDISP(ICURR,1) = ZERO
                  ENDIF

                  IF (KEYOUT_CR(ICURR).NE.0) THEN
                     ERESID(ICURR,1) = ZERO
                     EDIAG(2,ICURR) = ZERO
                     EDIAG(3,ICURR) = ZERO
                     DO NINDEX = 1,NDIM_BEFORE
                        EBEFORE(1,NINDEX,ICURR) = ZERO
                        EBEFORE(4,NINDEX,ICURR) = ZERO
                        EBEFORE(7,NINDEX,ICURR) = ZERO
                     ENDDO
                     DO NINDEX = 1,NDIM_BEFORE
                        IAF = IOFFSET(NINDEX,NBLK) + ICURR
                        IF(IAF.LE.N123P.AND.KEYOUT_CR(IAF).NE.0) THEN
                           EBEFORE(1,NINDEX,IAF) = ZERO
                           EBEFORE(2,NINDEX,IAF) = ZERO
                           EBEFORE(3,NINDEX,IAF) = ZERO
                        ENDIF     
                     ENDDO
                  ENDIF
               ENDIF

            ELSE
               IF ((I2.GE.1 .AND. I2.LE.IDIM) .AND. 
     &             (J2.GE.1 .AND. J2.LE.JDIM) .AND.
     &             (K2.GE.1 .AND. K2.LE.KDIM)) THEN
                  ICURR = (K2-1)*N12P+(J2-1)*N1P+I2
                        
                  IF (KEYOUT_CR(ICURR).EQ.1) THEN
                     EDISP(ICURR,1) = ZERO
                  ENDIF

                  IF (KEYOUT_CR(ICURR).NE.0) THEN
                     ERESID(ICURR,1) = ZERO
                     EDIAG(2,ICURR) = ZERO
                     EDIAG(3,ICURR) = ZERO
                     DO NINDEX = 1,NDIM_BEFORE
                        EBEFORE(1,NINDEX,ICURR) = ZERO
                        EBEFORE(4,NINDEX,ICURR) = ZERO
                        EBEFORE(7,NINDEX,ICURR) = ZERO
                     ENDDO
                     DO NINDEX = 1,NDIM_BEFORE
                        IAF = IOFFSET(NINDEX,NBLK) + ICURR
                        IF(IAF.LE.N123P.AND.KEYOUT_CR(IAF).NE.0) THEN
                           EBEFORE(1,NINDEX,IAF) = ZERO
                           EBEFORE(2,NINDEX,IAF) = ZERO
                           EBEFORE(3,NINDEX,IAF) = ZERO
                        ENDIF     
                     ENDDO
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDIF

cbw   Y DIRECTION 
      IF(IZEROG(2).LT.0.D0) THEN
         IF (LEVELC) THEN
            WRITE(NFOUT,*)
            TITL = '*******'
            CALL PRTTIT(TITL)
            TITL = 'Y DIRECTION RIGID BODY MOTION ELIMINATION'
            CALL PRTTIT(TITL)
            WRITE(NFOUT,200)
     &            FIRSTELE(1,NBLK),FIRSTELE(2,NBLK),FIRSTELE(3,NBLK)
 200        FORMAT(' AT ELEMENT (I,J,K): ',I5,3X,I5,3X,I5)
         ENDIF
         IF ((I1.GE.1 .AND. I1.LE.IDIM) .AND. 
     &       (J1.GE.1 .AND. J1.LE.JDIM) .AND.
     &       (K1.GE.1 .AND. K1.LE.KDIM)) THEN
            ICURR = (K1-1)*N12P+(J1-1)*N1P+I1
                        
            IF (KEYOUT_CR(ICURR).EQ.1) THEN
               EDISP(ICURR,2) = ZERO
            ENDIF
         
            IF (KEYOUT_CR(ICURR).NE.0) THEN
               ERESID(ICURR,2) = ZERO
               EDIAG(2,ICURR) = ZERO
               EDIAG(5,ICURR) = ZERO
               DO NINDEX = 1,NDIM_BEFORE
                  EBEFORE(2,NINDEX,ICURR) = ZERO
                  EBEFORE(5,NINDEX,ICURR) = ZERO
                  EBEFORE(8,NINDEX,ICURR) = ZERO
               ENDDO
               DO NINDEX = 1,NDIM_BEFORE
                  IAF = IOFFSET(NINDEX,NBLK) + ICURR
                  IF(IAF.LE.N123P.AND.KEYOUT_CR(IAF).NE.0) THEN
                     EBEFORE(4,NINDEX,IAF) = ZERO
                     EBEFORE(5,NINDEX,IAF) = ZERO
                     EBEFORE(6,NINDEX,IAF) = ZERO
                  ENDIF     
               ENDDO
            ENDIF
         ENDIF

         IF(IZEROG(1).LT.0.D0.AND.IZEROG(3).LT.0.D0) THEN
            IF ((I4.GE.1 .AND. I4.LE.IDIM) .AND. 
     &          (J4.GE.1 .AND. J4.LE.JDIM) .AND.
     &          (K4.GE.1 .AND. K4.LE.KDIM)) THEN
               ICURR = (K4-1)*N12P+(J4-1)*N1P+I4
                          
               IF (KEYOUT_CR(ICURR).EQ.1) THEN
                  EDISP(ICURR,2) = ZERO
               ENDIF
           
               IF (KEYOUT_CR(ICURR).NE.0) THEN
                  ERESID(ICURR,2) = ZERO
                  EDIAG(2,ICURR) = ZERO
                  EDIAG(5,ICURR) = ZERO
                  DO NINDEX = 1,NDIM_BEFORE
                     EBEFORE(2,NINDEX,ICURR) = ZERO
                     EBEFORE(5,NINDEX,ICURR) = ZERO
                     EBEFORE(8,NINDEX,ICURR) = ZERO
                  ENDDO
                  DO NINDEX = 1,NDIM_BEFORE
                     IAF = IOFFSET(NINDEX,NBLK) + ICURR
                     IF(IAF.LE.N123P.AND.KEYOUT_CR(IAF).NE.0) THEN
                        EBEFORE(4,NINDEX,IAF) = ZERO
                        EBEFORE(5,NINDEX,IAF) = ZERO
                        EBEFORE(6,NINDEX,IAF) = ZERO
                     ENDIF     
                  ENDDO
               ENDIF
            ENDIF
         ENDIF
      ENDIF

cbw Z DIRECTION

      IF(IZEROG(3).LT.0.D0) THEN
         IF (LEVELC) THEN
            WRITE(NFOUT,*)
            TITL = '*******'
            CALL PRTTIT(TITL)
            TITL = 'Z DIRECTION RIGID BODY MOTION ELIMINATION'
            CALL PRTTIT(TITL)
            WRITE(NFOUT,300)
     &            FIRSTELE(1,NBLK),FIRSTELE(2,NBLK),FIRSTELE(3,NBLK)
 300        FORMAT(' AT ELEMENT (I,J,K): ',I5,3X,I5,3X,I5)
         ENDIF
         IF ((I1.GE.1 .AND. I1.LE.IDIM) .AND. 
     &       (J1.GE.1 .AND. J1.LE.JDIM) .AND.
     &       (K1.GE.1 .AND. K1.LE.KDIM)) THEN
            ICURR = (K1-1)*N12P+(J1-1)*N1P+I1
                        
            IF (KEYOUT_CR(ICURR).EQ.1) THEN
               EDISP(ICURR,3) = ZERO
            ENDIF
         
            IF (KEYOUT_CR(ICURR).NE.0) THEN
               ERESID(ICURR,3) = ZERO
               EDIAG(3,ICURR) = ZERO
               EDIAG(5,ICURR) = ZERO
               DO NINDEX = 1,NDIM_BEFORE
                  EBEFORE(3,NINDEX,ICURR) = ZERO
                  EBEFORE(6,NINDEX,ICURR) = ZERO
                  EBEFORE(9,NINDEX,ICURR) = ZERO
               ENDDO
               DO NINDEX = 1,NDIM_BEFORE
                  IAF = IOFFSET(NINDEX,NBLK) + ICURR
                  IF(IAF.LE.N123P.AND.KEYOUT_CR(IAF).NE.0) THEN
                     EBEFORE(7,NINDEX,IAF) = ZERO
                     EBEFORE(8,NINDEX,IAF) = ZERO
                     EBEFORE(9,NINDEX,IAF) = ZERO
                  ENDIF     
               ENDDO
            ENDIF
         ENDIF

         IF(IZEROG(2).LT.0.D0) THEN
            IF ((I2.GE.1 .AND. I2.LE.IDIM) .AND. 
     &          (J2.GE.1 .AND. J2.LE.JDIM) .AND.
     &          (K2.GE.1 .AND. K2.LE.KDIM)) THEN
               ICURR = (K2-1)*N12P+(J2-1)*N1P+I2
                        
               IF (KEYOUT_CR(ICURR).EQ.1) THEN
                  EDISP(ICURR,3) = ZERO
               ENDIF

               IF (KEYOUT_CR(ICURR).NE.0) THEN
                  ERESID(ICURR,3) = ZERO
                  EDIAG(3,ICURR) = ZERO
                  EDIAG(5,ICURR) = ZERO
                  DO NINDEX = 1,NDIM_BEFORE
                     EBEFORE(3,NINDEX,ICURR) = ZERO
                     EBEFORE(6,NINDEX,ICURR) = ZERO
                     EBEFORE(9,NINDEX,ICURR) = ZERO
                  ENDDO
                  DO NINDEX = 1,NDIM_BEFORE
                     IAF = IOFFSET(NINDEX,NBLK) + ICURR
                     IF(IAF.LE.N123P.AND.KEYOUT_CR(IAF).NE.0) THEN
                        EBEFORE(7,NINDEX,IAF) = ZERO
                        EBEFORE(8,NINDEX,IAF) = ZERO
                        EBEFORE(9,NINDEX,IAF) = ZERO
                     ENDIF     
                  ENDDO
               ENDIF
            ENDIF
         ENDIF
      ENDIF


      END




C*********************************************************************
      SUBROUTINE RIGIDBODY_ZERO_OLD(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,
     &           JL2V,KL1,KL2,KEYOUT,NBLK,KEYOUT_CR,ERESID)
C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'pemodel.h'
      INCLUDE 'pebdary.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM*JDIM*KDIM)
      INTEGER KEYOUT_CR(IDIM*JDIM*KDIM)
      REAL*8  ERESID(IDIM*JDIM*KDIM,3)
      INTEGER IOFF,JOFF,KOFF,KERR,NODE,II,JJ,KK,I1,J1,K1,
     &        I2,J2,K2,I3,J3,K3,I4,J4,K4
      INTEGER N1P,N12P,N123P,ICURR,NINDEX
      REAL*8  ZERO
      PARAMETER (ZERO = 0.D0)

      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,KERR)
      N1P = IDIM
      N12P = N1P*JDIM
      N123P = N12P*KDIM

cbw   PROCESS USER-INPUT FIXED NODES DISPLACEMENTS

cbw   X DIRECTION

      IF (ISFIXDPX) THEN
         DO NODE = 1,3
            II = XPOINTIND(1,NODE,NBLK)-IOFF
            JJ = XPOINTIND(2,NODE,NBLK)-JOFF
            KK = XPOINTIND(3,NODE,NBLK)-KOFF
            IF ((II.GE.1 .AND. II.LE.IDIM) .AND. 
     &          (JJ.GE.1 .AND. JJ.LE.JDIM) .AND.
     &          (KK.GE.1 .AND. KK.LE.KDIM)) THEN
               ICURR = (KK-1)*N12P+(JJ-1)*N1P+II
                  
               IF (KEYOUT_CR(ICURR).NE.0) THEN
                  ERESID(ICURR,1) = ZERO
               ENDIF
            ENDIF
         ENDDO
      ENDIF

cbw   Y DIRECTION

      IF (ISFIXDPY) THEN
         DO NODE = 1,3
            II = YPOINTIND(1,NODE,NBLK)-IOFF
            JJ = YPOINTIND(2,NODE,NBLK)-JOFF
            KK = YPOINTIND(3,NODE,NBLK)-KOFF
            IF ((II.GE.1 .AND. II.LE.IDIM) .AND. 
     &          (JJ.GE.1 .AND. JJ.LE.JDIM) .AND.
     &          (KK.GE.1 .AND. KK.LE.KDIM)) THEN
               ICURR = (KK-1)*N12P+(JJ-1)*N1P+II
                  
               IF (KEYOUT_CR(ICURR).NE.0) THEN
                  ERESID(ICURR,2) = ZERO
               ENDIF
            ENDIF
         ENDDO
      ENDIF

cbw   Z DIRECTION

      IF (ISFIXDPZ) THEN
         DO NODE = 1,3
            II = ZPOINTIND(1,NODE,NBLK)-IOFF
            JJ = ZPOINTIND(2,NODE,NBLK)-JOFF
            KK = ZPOINTIND(3,NODE,NBLK)-KOFF
            IF ((II.GE.1 .AND. II.LE.IDIM) .AND. 
     &          (JJ.GE.1 .AND. JJ.LE.JDIM) .AND.
     &          (KK.GE.1 .AND. KK.LE.KDIM)) THEN
               ICURR = (KK-1)*N12P+(JJ-1)*N1P+II
                  
               IF (KEYOUT_CR(ICURR).NE.0) THEN
                  ERESID(ICURR,3) = ZERO
               ENDIF
            ENDIF
         ENDDO
      ENDIF

cbw IF THERE ARE STILL DEGREE OF FREEDOM FOR RIGID BODY MOTION,USE
cbw DEFAULT ADDITIONAL BOUNDARY CONDITION TO ELIMINATE THE RIGID
cbw BODY MOTION AUTOMATICALLY

      I1 = FIRSTELE(1,NBLK)-IOFF
      J1 = FIRSTELE(2,NBLK)-JOFF
      K1 = FIRSTELE(3,NBLK)-KOFF

      I2 = FIRSTELE(1,NBLK)-IOFF
      J2 = FIRSTELE(2,NBLK)+1-JOFF
      K2 = FIRSTELE(3,NBLK)-KOFF

      I3 = FIRSTELE(1,NBLK)-IOFF
      J3 = FIRSTELE(2,NBLK)-JOFF
      K3 = FIRSTELE(3,NBLK)+1-KOFF

      I4 = FIRSTELE(1,NBLK)+1-IOFF
      J4 = FIRSTELE(2,NBLK)-JOFF
      K4 = FIRSTELE(3,NBLK)-KOFF

cbw X DIRECTION

      IF(IZEROG(1).LT.0.D0) THEN
         IF ((I1.GE.1 .AND. I1.LE.IDIM) .AND. 
     &       (J1.GE.1 .AND. J1.LE.JDIM) .AND.
     &       (K1.GE.1 .AND. K1.LE.KDIM)) THEN
            ICURR = (K1-1)*N12P+(J1-1)*N1P+I1
         
            IF (KEYOUT_CR(ICURR).NE.0) THEN
               ERESID(ICURR,1) = ZERO
            ENDIF
         ENDIF

         IF(IZEROG(2).LT.0.D0.OR.IZEROG(3).LT.0.D0) THEN
            IF(IZEROG(3).LT.0.D0) THEN

               IF ((I3.GE.1 .AND. I3.LE.IDIM) .AND. 
     &             (J3.GE.1 .AND. J3.LE.JDIM) .AND.
     &             (K3.GE.1 .AND. K3.LE.KDIM)) THEN
                  ICURR = (K3-1)*N12P+(J3-1)*N1P+I3
                        
                  IF (KEYOUT_CR(ICURR).NE.0) THEN
                     ERESID(ICURR,1) = ZERO
                  ENDIF
               ENDIF

            ELSE
               IF ((I2.GE.1 .AND. I2.LE.IDIM) .AND. 
     &             (J2.GE.1 .AND. J2.LE.JDIM) .AND.
     &             (K2.GE.1 .AND. K2.LE.KDIM)) THEN
                  ICURR = (K2-1)*N12P+(J2-1)*N1P+I2
                        
                  IF (KEYOUT_CR(ICURR).NE.0) THEN
                     ERESID(ICURR,1) = ZERO
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDIF

cbw   Y DIRECTION 
      IF(IZEROG(2).LT.0.D0) THEN
         IF ((I1.GE.1 .AND. I1.LE.IDIM) .AND. 
     &       (J1.GE.1 .AND. J1.LE.JDIM) .AND.
     &       (K1.GE.1 .AND. K1.LE.KDIM)) THEN
            ICURR = (K1-1)*N12P+(J1-1)*N1P+I1
                        
            IF (KEYOUT_CR(ICURR).NE.0) THEN
               ERESID(ICURR,2) = ZERO
            ENDIF
         ENDIF

         IF(IZEROG(1).LT.0.D0.AND.IZEROG(3).LT.0.D0) THEN
            IF ((I4.GE.1 .AND. I4.LE.IDIM) .AND. 
     &          (J4.GE.1 .AND. J4.LE.JDIM) .AND.
     &          (K4.GE.1 .AND. K4.LE.KDIM)) THEN
               ICURR = (K4-1)*N12P+(J4-1)*N1P+I4
                          
               IF (KEYOUT_CR(ICURR).NE.0) THEN
                  ERESID(ICURR,2) = ZERO
               ENDIF
            ENDIF
         ENDIF
      ENDIF

cbw Z DIRECTION

      IF(IZEROG(3).LT.0.D0) THEN
         IF ((I1.GE.1 .AND. I1.LE.IDIM) .AND. 
     &       (J1.GE.1 .AND. J1.LE.JDIM) .AND.
     &       (K1.GE.1 .AND. K1.LE.KDIM)) THEN
            ICURR = (K1-1)*N12P+(J1-1)*N1P+I1
                        
            IF (KEYOUT_CR(ICURR).NE.0) THEN
               ERESID(ICURR,3) = ZERO
            ENDIF
         ENDIF

         IF(IZEROG(2).LT.0.D0) THEN
            IF ((I2.GE.1 .AND. I2.LE.IDIM) .AND. 
     &          (J2.GE.1 .AND. J2.LE.JDIM) .AND.
     &          (K2.GE.1 .AND. K2.LE.KDIM)) THEN
               ICURR = (K2-1)*N12P+(J2-1)*N1P+I2
                        
               IF (KEYOUT_CR(ICURR).NE.0) THEN
                  ERESID(ICURR,3) = ZERO
               ENDIF
            ENDIF
         ENDIF
      ENDIF

      END

C************************************************************************
      SUBROUTINE EFFEC_MEAN_STRESS(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,
     &                   JL2V,KL1,KL2,KEYOUT,NBLK,MODUL,POISS,BIOTA,
     &                          STRXX_INIT,STRYY_INIT,STRZZ_INIT,
     &                          AVGSTRN,EMSTRESS,
     &                   ETEMPR,ETEMPREF,EROCKTHEXP)
C************************************************************************
C Calculate effective mean stresses at grid center           
C
C INPUT:
C   MODUL(I,J,K) = LAME'S CONSTANT LAMBDA (PSI)
C   POISS(I,J,K) = LAME'S CONSTANT MU (PSI)
C   BIOTA(I,J,K) = BIOT''S CONSTANT ALPHA 
C   STRXX_INIT(I,J,K) = INITIAL PRINCIPLE STRESS IN X DIRECTION (PSI)
C   STRYY_INIT(I,J,K) = INITIAL PRINCIPLE STRESS IN Y DIRECTION (PSI)
C   STRZZ_INIT(I,J,K) = INITIAL PRINCIPLE STRESS IN Z DIRECTION (PSI)
C   AVGSTRN(I,J,K,L) = AVERAGE STRAIN
C   PREF(I,J,K) = REFERENCE PORE PRESSURE (PSI)
C   PRESS(I,J,K) = PORE PRESSURE (PSI)
C
C OUTPUT:
C   EMSTRESS(I,J,K,L) = EFFECITVE MEAN STRESSES (PSI) AT GRID CENTER
C************************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'pemodel.h'
$COMP      INCLUDE 'xthermal.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),      KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  MODUL(IDIM,JDIM,KDIM),      POISS(IDIM,JDIM,KDIM)
      REAL*8  BIOTA(IDIM,JDIM,KDIM),      AVGSTRN(IDIM,JDIM,KDIM,6)
      REAL*8  STRXX_INIT(IDIM,JDIM,KDIM), STRYY_INIT(IDIM,JDIM,KDIM)
      REAL*8  STRZZ_INIT(IDIM,JDIM,KDIM)
      REAL*8  EMSTRESS(IDIM,JDIM,KDIM)
      REAL*8  ETEMPR(IDIM,JDIM,KDIM),     ETEMPREF(IDIM,JDIM,KDIM)
      REAL*8  EROCKTHEXP(IDIM,JDIM,KDIM)

      INTEGER I,J,K,JL1,JL2,NDIM
      REAL*8  U,V,W,X,ZERO,MU,V1,V2,V3
      PARAMETER(ZERO=0.0D0)
      NDIM = NDIM_ELASTIC
      IF(NDIM.EQ.3) THEN
         DO K = KL1,KL2
            JL1 = JL1V(K)
            JL2 = JL2V(K)
            DO J = JL1,JL2
               DO I = IL1,IL2
                  EMSTRESS(I,J,K)=0.D0
                  IF(KEYOUT(I,J,K).LE.0) GOTO 1 
                  MU = POISS(I,J,K)
                  IF(MODUL(I,J,K).GT.ZERO) THEN
                     V1 = AVGSTRN(I,J,K,1) / 100.D0
                     V2 = AVGSTRN(I,J,K,2) / 100.D0
                     V3 = AVGSTRN(I,J,K,3) / 100.D0
                     U = MODUL(I,J,K) * (V1 + V2 + V3)
                     V = 2.0D0 * MU
                     X=U
                     AVGSTRN(I,J,K,1) = X + V * V1 
                     AVGSTRN(I,J,K,2) = X + V * V2 
                     AVGSTRN(I,J,K,3) = X + V * V3 
                     AVGSTRN(I,J,K,4) = MU * AVGSTRN(I,J,K,4) / 100.D0
                     AVGSTRN(I,J,K,5) = MU * AVGSTRN(I,J,K,5) / 100.D0
                     AVGSTRN(I,J,K,6) = MU * AVGSTRN(I,J,K,6) / 100.D0
                     EMSTRESS(I,J,K)=1.D0/3.D0*(AVGSTRN(I,J,K,1)+
     &                            AVGSTRN(I,J,K,2)+AVGSTRN(I,J,K,3))
                  ELSE
                     AVGSTRN(I,J,K,1) = ZERO
                     AVGSTRN(I,J,K,2) = ZERO
                     AVGSTRN(I,J,K,3) = ZERO
                     AVGSTRN(I,J,K,4) = ZERO
                     AVGSTRN(I,J,K,5) = ZERO
                     AVGSTRN(I,J,K,6) = ZERO
                     EMSTRESS(I,J,K)=1.D0/3.D0*(AVGSTRN(I,J,K,1)+
     &                            AVGSTRN(I,J,K,2)+AVGSTRN(I,J,K,3))

                  ENDIF
$COMP                  IF (XTHERMAL) THEN
$COMP                     EMSTRESS(I,J,K)=EMSTRESS(I,J,K)-
$COMP     &                     (3*MODUL(I,J,K)+2*MU)*EROCKTHEXP(I,J,K)*
$COMP     &                     (ETEMPR(I,J,K)-ETEMPREF(I,J,K))
$COMP                  ENDIF
   1              CONTINUE
               ENDDO
            ENDDO
         ENDDO
      ELSE
         IF(LEVELC) WRITE(NFOUT,10)
         NERRC = NERRC + 1
         RETURN
      ENDIF
   10 FORMAT(/'ERROR:NOT SETUP FOR 1D, 2D AVERAGE STRESS CALCULATION')
  
      END 



C***********************************************************************
      SUBROUTINE INIT_EMSTRESS()
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'pemodel.h'
      INCLUDE 'pearydat.h'
      INCLUDE 'blkary.h'

      INTEGER JINITSTR(5)
      EXTERNAL INIT_EMSTRESSW
      DATA    JINITSTR/5*0/

      JINITSTR(1) = 4
      JINITSTR(2) = N_STRXX_INIT
      JINITSTR(3) = N_STRYY_INIT
      JINITSTR(4) = N_STRZZ_INIT
      JINITSTR(5) = N_EMSTRESS_INIT

      CALL CALLWORK(INIT_EMSTRESSW,JINITSTR)

      END


C***********************************************************************
      SUBROUTINE INIT_EMSTRESSW(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &           KL1,KL2,KEYOUT,NBLK,STRXX_INIT,STRYY_INIT,STRZZ_INIT,
     &           INITEMSTRESS)
C***********************************************************************

      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'pemodel.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),      KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  STRXX_INIT(IDIM,JDIM,KDIM), STRYY_INIT(IDIM,JDIM,KDIM)
      REAL*8  STRZZ_INIT(IDIM,JDIM,KDIM), INITEMSTRESS(IDIM,JDIM,KDIM)

      INTEGER I,J,K,JL1,JL2
    
      DO K=KL1,KL2
         JL1 = JL1V(K)
         JL2 = JL2V(K)
         DO J=JL1,JL2
            DO I=IL1,IL2
               INITEMSTRESS(I,J,K)=0.D0
               IF(KEYOUT(I,J,K).GT.0) THEN
                  INITEMSTRESS(I,J,K)=1.D0/3.D0*(STRXX_INIT(I,J,K)+
     &                    STRYY_INIT(I,J,K)+STRZZ_INIT(I,J,K))
               ENDIF
            ENDDO
         ENDDO
      ENDDO

      END


C***********************************************************************
      SUBROUTINE PEUPPERM(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                KEYOUT,NBLK,ARRAY1,ARRAY2,XPERM,YPERM,ZPERM,
     &                XPERM_INIT,YPERM_INIT,ZPERM_INIT)
C***********************************************************************

      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'pemodel.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),      KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  ARRAY1(IDIM,JDIM,KDIM), ARRAY2(IDIM,JDIM,KDIM)
      REAL*4  XPERM(IDIM,JDIM,KDIM),  YPERM(IDIM,JDIM,KDIM)
      REAL*4  ZPERM(IDIM,JDIM,KDIM)
      REAL*4  XPERM_INIT(IDIM,JDIM,KDIM), YPERM_INIT(IDIM,JDIM,KDIM)
      REAL*4  ZPERM_INIT(IDIM,JDIM,KDIM)

      INTEGER I,J,K
      REAL*8  COEFFICIENT,INITEFFSTR
      INTEGER*4 TYPEP
      REAL*8  PARA

      TYPEP = TYPESDP 
    
      DO K=KL1,KL2
         DO J=JL1V(K),JL2V(K)
            DO I=IL1,IL2
               IF (KEYOUT(I,J,K).GT.0) THEN
                  COEFFICIENT=1.D0
                  IF (TYPEP.EQ.1) THEN
                     PARA=COEFB
                     COEFFICIENT=EXP(PARA*(ARRAY1(I,J,K)-ARRAY2(I,J,K)))
                  ELSEIF (TYPEP.EQ.2) THEN
                     PARA=COEFM
                     COEFFICIENT=(1.D0+PARA*ARRAY1(I,J,K))/
     &                           (1.D0+PARA*ARRAY2(I,J,K))
                  ELSEIF (TYPEP.EQ.3) THEN
                     PARA=COEFN
                     IF (ARRAY2(I,J,K).GT.0.D0) THEN
                        COEFFICIENT=(ARRAY1(I,J,K)/(ARRAY2(I,J,K)))
     &                           **PARA
                     ENDIF
                  ENDIF
                  IF (COEFFICIENT.LT.0.D0) THEN
                     COEFFICIENT=0.D0
                  ENDIF
                  IF (COEFFICIENT.GT.COEFMAX) COEFMAX=COEFFICIENT
                  IF (COEFFICIENT.LT.COEFMIN) COEFMIN=COEFFICIENT
                  XPERM(I,J,K)=XPERM_INIT(I,J,K)*COEFFICIENT
                  YPERM(I,J,K)=YPERM_INIT(I,J,K)*COEFFICIENT
                  ZPERM(I,J,K)=ZPERM_INIT(I,J,K)*COEFFICIENT
               ENDIF
            ENDDO
         ENDDO
      ENDDO

      END

***********************************************************************
      SUBROUTINE PE_PERM()
C***********************************************************************

      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'pemodel.h'
      INCLUDE 'blkary.h'
      INCLUDE 'pearydat.h'


      
      INTEGER JSTRN(3),JSTRS(12),JUPPERM(13),JCPY(3)
      EXTERNAL AVERAGE_STRAIN,EFFEC_MEAN_STRESS,PEUPPERM,TRANC1,
     &         CPYINITPORE
      INTEGER KERR

      DATA     JSTRN/3*0/,JSTRS/12*0/,JUPPERM/13*0/,JCPY/3*0/

         KERR=0
         JSTRN(1) = 2
         JSTRN(2) = N_EDISP
         JSTRN(3) = N_STRESS
         CALL CALLWORK(AVERAGE_STRAIN,JSTRN)

         JSTRS(1) = 11
         JSTRS(2) = N_MODUL
         JSTRS(3) = N_POISS
         JSTRS(4) = N_BIOTA
         JSTRS(5) = N_STRXX_INIT
         JSTRS(6) = N_STRYY_INIT
         JSTRS(7) = N_STRZZ_INIT
         JSTRS(8) = N_STRESS
         JSTRS(9) = N_EMSTRESS
         JSTRS(10) = N_ETEMPR
         JSTRS(11) = N_ETEMPREF
         JSTRS(12) = N_EROCKTHEXP
         CALL CALLWORK(EFFEC_MEAN_STRESS,JSTRS)

$MANY          CALL TIMON(30)
$MANY          CALL UPDATE(N_EMSTRESS,2)
$MANY          CALL TIMOFF(30)

CBW      UPDATE PERMEABILITY DEPENDING ON EFFECTIVE MEAN STRESS

         JUPPERM(1) = 8
         JUPPERM(2) = N_EMSTRESS
         JUPPERM(3) = N_EMSTRESS_INIT
         IF (TYPESDP.EQ.3) THEN
            JUPPERM(2) = N_EPV_FLOW
            JUPPERM(3) = N_PVREF
         ENDIF
         JUPPERM(4) = N_XPERM
         JUPPERM(5) = N_YPERM
         JUPPERM(6) = N_ZPERM
         JUPPERM(7) = N_XPERM_INIT
         JUPPERM(8) = N_YPERM_INIT
         JUPPERM(9) = N_ZPERM_INIT

         COEFMAX=0.D0
         COEFMIN=1.D15
         CALL CALLWORK(PEUPPERM,JUPPERM)
$MANY          CALL TIMON(30)
$MANY          CALL MAXIT(1,COEFMAX)
$MANY          CALL SPREAD8(1,COEFMAX)
$MANY          COEFMIN=-COEFMIN
$MANY          CALL MAXIT(1,COEFMIN)
$MANY          CALL SPREAD8(1,COEFMIN)
$MANY          COEFMIN=-COEFMIN
$MANY          CALL TIMOFF(30)
         IF (MYPRC.EQ.0) THEN
             WRITE(700,*) "IN PEUPPERM,TIME=,COEFMIN=,COEFMAX=",
     &                    TIM+DELTIM,COEFMIN,COEFMAX
         ENDIF

$MANY         CALL TIMON(3)
$MANY         CALL UPDATE(N_XPERM,2)
$MANY         CALL UPDATE(N_YPERM,2)
$MANY         CALL UPDATE(N_ZPERM,2)
$MANY         CALL TIMOFF(3)

         JCPY(1)=2
         JCPY(2)=N_XPERM
         JCPY(3)=N_XPERM_R8
         CALL CALLWORK(CPYINITPORE,JCPY)
 
         JCPY(1)=2
         JCPY(2)=N_YPERM
         JCPY(3)=N_YPERM_R8
         CALL CALLWORK(CPYINITPORE,JCPY)

         JCPY(1)=2
         JCPY(2)=N_ZPERM
         JCPY(3)=N_ZPERM_R8
         CALL CALLWORK(CPYINITPORE,JCPY)

         JUPPERM(1) = 6
         JUPPERM(2) = N_TCOFX
         JUPPERM(3) = N_TCOFY
         JUPPERM(4) = N_TCOFZ
         JUPPERM(5) = N_XPERM
         JUPPERM(6) = N_YPERM
         JUPPERM(7) = N_ZPERM
         CALL CALLWORK(TRANC1,JUPPERM)

         CALL SDPWELL(KERR)

      END



C***********************************************************************
      SUBROUTINE COPYPERM()
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'pemodel.h'
      INCLUDE 'pearydat.h'
      INCLUDE 'blkary.h'

      INTEGER JCP(3)
      EXTERNAL COPY_PERM
      DATA    JCP/3*0/
      
      JCP(1) = 2
      JCP(2) = N_XPERM_INIT
      JCP(3) = N_XPERM
      CALL CALLWORK(COPY_PERM,JCP)

      JCP(2) = N_YPERM_INIT
      JCP(3) = N_YPERM
      CALL CALLWORK(COPY_PERM,JCP)

      JCP(2) = N_ZPERM_INIT
      JCP(3) = N_ZPERM
      CALL CALLWORK(COPY_PERM,JCP)

      JCP(2) = N_XPERMN
      JCP(3) = N_XPERM
      CALL CALLWORK(COPY_PERM,JCP)

      JCP(2) = N_YPERMN
      JCP(3) = N_YPERM
      CALL CALLWORK(COPY_PERM,JCP)

      JCP(2) = N_ZPERMN
      JCP(3) = N_ZPERM
      CALL CALLWORK(COPY_PERM,JCP)
 

      END


C***********************************************************************
      SUBROUTINE COPY_PERM(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,
     &           JL2V,KL1,KL2,KEYOUT,NBLK,ARRAY1,ARRAY2)
C***********************************************************************

      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'pemodel.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),      KEYOUT(IDIM,JDIM,KDIM)
      REAL*4  ARRAY1(IDIM,JDIM,KDIM), ARRAY2(IDIM,JDIM,KDIM)

      INTEGER I,J,K


      DO K=1,KDIM
         DO J=1,JDIM
            DO I=1,IDIM
               ARRAY1(I,J,K) = ARRAY2(I,J,K)
            ENDDO
         ENDDO
      ENDDO

      END

C***********************************************************************
      SUBROUTINE PE_PERM_INIT()
C***********************************************************************

      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'pemodel.h'
      INCLUDE 'blkary.h'
      INCLUDE 'pearydat.h'
      
      INTEGER JSTRN(3),JSTRS(12),JUPPERM(12),JCPY(3)
      EXTERNAL AVERAGE_STRAIN,EFFEC_MEAN_STRESS,PEUPPERM_INIT,TRANC1,
     &         CPYARYR8,CPYINITPORE
      DATA     JSTRN/3*0/,JSTRS/12*0/,JUPPERM/12*0/,JCPY/3*0/
      INTEGER  KERR

         KERR=0
         JSTRN(1) = 2
         JSTRN(2) = N_EDISP
         JSTRN(3) = N_STRESS
         CALL CALLWORK(AVERAGE_STRAIN,JSTRN)

         JSTRS(1) = 11
         JSTRS(2) = N_MODUL
         JSTRS(3) = N_POISS
         JSTRS(4) = N_BIOTA
         JSTRS(5) = N_STRXX_INIT
         JSTRS(6) = N_STRYY_INIT
         JSTRS(7) = N_STRZZ_INIT
         JSTRS(8) = N_STRESS
         JSTRS(9) = N_EMSTRESS
         JSTRS(10) = N_ETEMPR
         JSTRS(11) = N_ETEMPREF
         JSTRS(12) = N_EROCKTHEXP
         CALL CALLWORK(EFFEC_MEAN_STRESS,JSTRS)
$MANY          CALL TIMON(30)
$MANY          CALL UPDATE(N_EMSTRESS,2)
$MANY          CALL TIMOFF(30)

         JCPY(1)=2
         JCPY(2)=N_EMSTRESS
         JCPY(3)=N_EMSTRESS_INIT
         CALL CALLWORK(CPYARYR8,JCPY)

CBW      UPDATE PERMEABILITY DEPENDING ON EFFECTIVE MEAN STRESS
         JUPPERM(1) = 11
         JUPPERM(2) = N_EMSTRESS
         JUPPERM(3) = N_EMSTRESS_INIT
         JUPPERM(4) = N_XPERM
         JUPPERM(5) = N_YPERM
         JUPPERM(6) = N_ZPERM
         JUPPERM(7) = N_XPERM_INIT
         JUPPERM(8) = N_YPERM_INIT
         JUPPERM(9) = N_ZPERM_INIT
         JUPPERM(10) = N_XPERM_R8
         JUPPERM(11) = N_YPERM_R8
         JUPPERM(12) = N_ZPERM_R8
!BW          CALL CALLWORK(PEUPPERM_INIT,JUPPERM)

!BW $MANY          CALL TIMON(3)
!BW $MANY          CALL UPDATE(N_XPERM,2)
!BW $MANY          CALL UPDATE(N_YPERM,2)
!BW $MANY          CALL UPDATE(N_ZPERM,2)
!BW $MANY          CALL TIMOFF(3)

         JCPY(1)=2
         JCPY(2)=N_XPERM
         JCPY(3)=N_XPERM_R8
         CALL CALLWORK(CPYINITPORE,JCPY)
 
         JCPY(1)=2
         JCPY(2)=N_YPERM
         JCPY(3)=N_YPERM_R8
         CALL CALLWORK(CPYINITPORE,JCPY)

         JCPY(1)=2
         JCPY(2)=N_ZPERM
         JCPY(3)=N_ZPERM_R8
         CALL CALLWORK(CPYINITPORE,JCPY)

!BW          JUPPERM(1) = 6
!BW          JUPPERM(2) = N_TCOFX
!BW          JUPPERM(3) = N_TCOFY
!BW          JUPPERM(4) = N_TCOFZ
!BW          JUPPERM(5) = N_XPERM
!BW          JUPPERM(6) = N_YPERM
!BW          JUPPERM(7) = N_ZPERM
!BW          CALL CALLWORK(TRANC1,JUPPERM)
!BW 
!BW          CALL SDPWELL(KERR)

      END

C***********************************************************************
      SUBROUTINE PEUPPERM_INIT(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &                KL1,KL2,KEYOUT,NBLK,ARRAY1,ARRAY2,XPERM,YPERM,
     &                ZPERM,XPERM_INIT,YPERM_INIT,ZPERM_INIT,XPERM_R8,
     &                YPERM_R8,ZPERM_R8)
C***********************************************************************

      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'pemodel.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),      KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  ARRAY1(IDIM,JDIM,KDIM), ARRAY2(IDIM,JDIM,KDIM)
      REAL*4  XPERM(IDIM,JDIM,KDIM),  YPERM(IDIM,JDIM,KDIM)
      REAL*4  ZPERM(IDIM,JDIM,KDIM)
      REAL*4  XPERM_INIT(IDIM,JDIM,KDIM), YPERM_INIT(IDIM,JDIM,KDIM)
      REAL*4  ZPERM_INIT(IDIM,JDIM,KDIM)
      REAL*8  XPERM_R8(IDIM,JDIM,KDIM),   YPERM_R8(IDIM,JDIM,KDIM)
      REAL*8  ZPERM_R8(IDIM,JDIM,KDIM)

      INTEGER I,J,K
      REAL*8  COEFFICIENT,INITEFFSTR
      INTEGER*4 TYPEP
      REAL*8  PARA

      TYPEP = TYPESDP 
    
      DO K=KL1,KL2
         DO J=JL1V(K),JL2V(K)
            DO I=IL1,IL2
               IF (KEYOUT(I,J,K).GT.0) THEN
                  IF (TYPEP.EQ.1) THEN
                     PARA=COEFB
                     COEFFICIENT=EXP(PARA*(ARRAY1(I,J,K)-ARRAY2(I,J,K)))
                  ELSEIF (TYPEP.EQ.2) THEN
                     PARA=COEFM
                     COEFFICIENT=(1.D0+PARA*ARRAY1(I,J,K))/
     &                           (1.D0+PARA*ARRAY2(I,J,K))
                  ELSEIF (TYPEP.EQ.3) THEN
                     COEFFICIENT=1.D0
                  ENDIF
                  XPERM(I,J,K)=XPERM_INIT(I,J,K)*COEFFICIENT
                  YPERM(I,J,K)=YPERM_INIT(I,J,K)*COEFFICIENT
                  ZPERM(I,J,K)=ZPERM_INIT(I,J,K)*COEFFICIENT
                  XPERM_R8(I,J,K)=XPERM(I,J,K)
                  YPERM_R8(I,J,K)=YPERM(I,J,K)
                  ZPERM_R8(I,J,K)=ZPERM(I,J,K)
               ENDIF
            ENDDO
         ENDDO
      ENDDO

      END

*********************************************************************
      SUBROUTINE EPROCOUTPUT(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &                      KL1,KL2,KEYOUT,NBLK,PROCN,KEYOUT_CR)
C*********************************************************************
      IMPLICIT NONE

      INCLUDE 'control.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  PROCN(IDIM,JDIM,KDIM)
      INTEGER I,J,K,KEYOUT_CR(IDIM,JDIM,KDIM)

      DO K = 1,KDIM
         DO J = 1,JDIM
            DO I = 1,IDIM
               IF (KEYOUT_CR(I,J,K).GT.0) THEN
                  PROCN(I,J,K)=(MYPRC+1)*1.0D0
               ENDIF
            ENDDO
         ENDDO
      ENDDO
      
      END


***********************************************************************
      SUBROUTINE UPDATE_PERM()
C***********************************************************************

      IMPLICIT NONE
      INCLUDE 'pemodel.h'

      IF (SDPM) CALL PE_PERM()
    
      END

         
