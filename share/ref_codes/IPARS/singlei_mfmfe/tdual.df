!  TDUAL.F - SINGLE PHASE IMPLICIT MULTIPOINT FLUX MODEL 
!            DUAL APPROXIMATION MULTIBLOCK ROUTINES
!*********************************************************************
      SUBROUTINE TMDUALS ()
!*********************************************************************
!  Loads buffers for Jocabian and residual contributions for the dual
!  approximation block interface
!*********************************************************************
      IMPLICIT NONE
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'blkary.h'
      INCLUDE 'sblkc.h'
      INCLUDE 'tarydat.h'
      INCLUDE 'mpfaary.h'

      INTEGER IA(6)
      LOGICAL ONCEONLY
      DATA ONCEONLY /.TRUE./,IA/6*0/

      EXTERNAL TMLODBUF

      IF (NFACES.EQ.0) RETURN
      CALL TIMON(12)

      IF (ONCEONLY) THEN
         ONCEONLY=.FALSE.

         IA(1)=5
         IA(2)=N_PRES
         IA(3)=N_FLDEN
         IA(4)=N_DEPTH
         IA(5)=N_BUFDIM
         IA(6)=N_BUFIF
      ENDIF

!  PUT B BLOCK QUANTITIES FOR THE WATER BALANCE IN INTERFACE BUFFERS

      CALL CALLWORK(TMLODBUF,IA)

      CALL TIMOFF(12)

      END SUBROUTINE TMDUALS

!*********************************************************************
      SUBROUTINE TMDUALR ()
!*********************************************************************
!  Computes Jacobian and residual contributions for the dual approximation
!  block interface
!*********************************************************************
      IMPLICIT NONE
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'blkary.h'
      INCLUDE 'sblkc.h'
      INCLUDE 'tarydat.h'
      INCLUDE 'layout.h'
      INCLUDE 'mpfaary.h'

      INTEGER IA(11),JA(20)
      LOGICAL ONCEONLY
      DATA ONCEONLY /.TRUE./,IA/11*0/,JA/20*0/

      EXTERNAL TMJRCAL
      EXTERNAL TMLOCALFLUX_BC
      EXTERNAL TMLOCALFLUX_FILE
      EXTERNAL TMLOCALFLUX_JACOBI

      IF (NFACES.EQ.0) RETURN
      CALL TIMON(12)

      IF (ONCEONLY) THEN
         ONCEONLY=.FALSE.

         IA(1) = 10
         IA(2) = N_PRES
         IA(3) = N_FLDEN
         IA(4) = N_DEPTH
         IA(5) = N_BUFDIM
         IA(6) = N_BUFIF
         IA(7) = N_COF
         IA(8) = N_RESID
         IA(9) = N_VX
         IA(10) = N_VY
         IA(11) = N_VZ

         JA(1) = 19
         JA(2) = N_PRES
         JA(3) = N_FLDEN
         JA(4) = N_DEPTH
         JA(5) = N_BUFDIM
         JA(6) = N_BUFIF
         JA(7) = N_XC
         JA(8) = N_YC
         JA(9) = N_ZC
         JA(10) = N_AINVF
         JA(11) = N_VPROP
         JA(12) = N_FPROP
         JA(13) = N_VDIM
         JA(14) = N_FDIM
         JA(15) = N_PERMINV
         JA(16) = N_RESID
         JA(17) = N_KCR
         JA(18) = N_FAREA
         JA(19) = N_COF
         JA(20) = N_DUNK

      ENDIF
      
!  COMPUTE JACOBIAN AND RESIDUAL CONTRIBUTIONS FOR THE WATER BALANCE

! bag8
!  TMLOCALFLUX_BC - apply B block pressure as Dirichlet BC
!  TMLOCALFLUX_FILE - Jacobi method using COF,RESID from file
!  TMLOCALFLUX_JACOBI - Jacobi method using COF,RESID from mpfa_tran

      IF ((EVFEM_HEX.EQ.1).OR.(EVFEM_HEX.EQ.2)) THEN
        CALL CALLWORK(TMJRCAL,IA)
      ELSEIF (EVFEM_HEX.EQ.3) THEN
        CALL CALLWORK(TMLOCALFLUX_BC,JA)
      ELSEIF (EVFEM_HEX.EQ.4) THEN
        CALL CALLWORK(TMLOCALFLUX_FILE,JA)
      ELSEIF ((EVFEM_HEX.EQ.5).OR.(EVFEM_HEX.EQ.6)) THEN
        CALL CALLWORK(TMLOCALFLUX_JACOBI,JA)
      ENDIF

      CALL TIMOFF(12)
      END SUBROUTINE TMDUALR

!C*********************************************************************
!      SUBROUTINE TDUALV (N_VELD)
!C*********************************************************************
!
!C  Computes Jocabian and residual contributions for the dual approximation
!C  block interface
!
!C*********************************************************************
!      IMPLICIT NONE
!$POWER      INCLUDE 'msjunk.h'
!      INCLUDE 'control.h'
!      INCLUDE 'blkary.h'
!      INCLUDE 'sblkc.h'
!      INCLUDE 'tarydat.h'
!
!      INTEGER IV(7),N_VELD
!      LOGICAL ONCEONLY
!      DATA ONCEONLY /.TRUE./,IV/7*0/
!
!      EXTERNAL T2TRVELD
!
!      IF (NFACES.EQ.0) RETURN
!      CALL TIMON(12)
!
!      IF (ONCEONLY) THEN
!         ONCEONLY=.FALSE.
!
!         IV(1)=6
!         IV(2)=N_PRES
!         IV(3)=N_FLDEN
!         IV(4)=N_DEPTH
!         IV(5)=N_BUFDIM
!         IV(6)=N_BUFIF
!
!      ENDIF
!
!C  COMPUTE VELOCITY ON FAULT BLOCK INTERFACES 
!
!      IV(7)=N_VELD
!      CALL CALLWORK(T2TRVELD,IV)
!
!      CALL TIMOFF(12)
!      END

!*********************************************************************
      SUBROUTINE TMLODBUF (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
     &  KL2,KEYOUT,NBLK,PRES,FLDEN,DEPTH,NBUFDIM,BUFIF8)
!*********************************************************************
!  PUT B BLOCK QUANTITIES FOR THE BALANCE IN INTERFACE BUFFERS
!    PRES(I,J,K) = PRESSURE, PSI (INPUT, REAL*8)
!    FLDEN(I,J,K,1) = DENSITY, LB/CU-FT (INPUT, REAL*8)
!    DEPTH(I,J,K) = ELEMENT DEPTHS , FT (INPUT, REAL*8)
!    NBUFDIM = FIRST DIMENSION OF BUFIF8(,) (INPUT, INTEGER)
!  OUTPUT:
!    BUFIF8(,1) = PRES(,,) = PRESSURE
!    BUFIF8(,2) = FLDEN(,,) = DENSITY
!    BUFIF8(,3) = DEPTH(,,) = ELEMENT DEPTH
!*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'unitsex.h'

      INCLUDE 'sblkc.h'
      INCLUDE 'tfluidsc.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK,NBUFDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),    KEYOUT(IDIM,JDIM,KDIM)
      INTEGER M,II,JJ,II1,II2,IA,JA,KA,K,NBT,NMT
      REAL*8  PRES(IDIM,JDIM,KDIM),     FLDEN(IDIM,JDIM,KDIM),
     &        DEPTH(IDIM,JDIM,KDIM),    BUFIF8(NBUFDIM,*),
     &        DUNK(IDIM,JDIM,KDIM)
      REAL*8 BW,TLW,DENW,DRBW
      INTEGER I2,J2,K2,IB2

      IF (NPAI(NBLK).EQ.0) RETURN

      DO 90 M=1,NPAI(NBLK)
      II1=IESNDI(M,NBLK)
      II2=II1+NESNDI(M,NBLK)-1
      NBT=NBSRI(M,NBLK)
      NMT=FMODBLK(NBT)

      IF ((NMT.EQ.$TMODEL).OR.(NMT.EQ.$TMMODEL)) THEN

!  IMPLICIT SINGLE PHASE MODEL TARGET

         DO 61 II=II1,II2
         K=KFESR(II)
         IA=IJKS(1,K)
         JA=IJKS(2,K)
         KA=IJKS(3,K)
         BUFIF8(II,1)=PRES(IA,JA,KA)
         BUFIF8(II,2)=FLDEN(IA,JA,KA)
         BUFIF8(II,3)=DEPTH(IA,JA,KA)

   61    CONTINUE

      ENDIF

   90 CONTINUE

      END SUBROUTINE TMLODBUF

!*********************************************************************
      SUBROUTINE TMJRCAL (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &       KEYOUT,NBLK,PRES,FLDEN,
     &       DEPTH,NBUFDIM,BUFIF8,COF,RESID,VX,VY,VZ)
!*********************************************************************
!  COMPUTE JACOBIAN AND RESIDUAL CONTRIBUTIONS FOR THE BALANCE AND ALSO 
!  UPDATE GHOST LAYERS OF FAULT BLOCK
!    PRES(I,J,K) = WATER PRESSURE, PSI (INPUT, REAL*8)
!    FLDEN(I,J,K) = WATER DENSITY, LB/CU-FT (INPUT, REAL*8)
!    DEPTH(I,J,K) = ELEMENT DEPTHS, FT (INPUT, REAL*8)
!    NBUFDIM = FIRST DIMENSION OF BUFIF8(,) (INPUT, INTEGER)
!    BUFIF8(,1) = PRES(,,) = PRESSURE, BLOCKB
!    BUFIF8(,2) = FLDEN(,,) = DENSITY, BLOCKB
!    BUFIF8(,3) = DEPTH(,,) = ELEMENT DEPTH, BLOCKB
!    COF(I,J,K,N) = JACOBIAN COEFFICIENTS (INPUT AND OUTPUT, REAL*4)
!    RESID(I,J,K)= RESIDUALS (INPUT AND OUTPUT, REAL*8)
!
!  OUTPUT:
!    VEL(I,J,K,L) = WATER VELOCITY, LB/SFT-DAY (OUTPUT, REAL*8)
!    COFINF(,1,1) = DERIVATIVE OF Q     WRT P
!                                  AiBl      Bl
!
!*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'sblkc.h'
      INCLUDE 'layout.h'

      INCLUDE 'tfluidsc.h'
      INCLUDE 'tbaldat.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK,NBUFDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),    KEYOUT(IDIM,JDIM,KDIM)
      INTEGER NBG,NMS,J,K,L,IA,JA,KA,J1,J2,K1,K2
      REAL*8  PRES(IDIM,JDIM,KDIM),     FLDEN(IDIM,JDIM,KDIM),
     &        VX(IDIM,JDIM,KDIM),VY(IDIM,JDIM,KDIM),
     &        VZ(IDIM,JDIM,KDIM),
     &        DEPTH(IDIM,JDIM,KDIM), 
     &        RESID(IDIM,JDIM,KDIM),    BUFIF8(NBUFDIM,*)
      REAL*8  COF(IDIM,JDIM,KDIM,$NUMCOF)
      REAL*8  TV,PA,PEA,DEA,EADR,DENA,DEPA,SQ,SDQDPA,TC,DENB,
     &        DP,FSW,G2,Q,AFI

      IF (NIEBS(NBLK).EQ.0) RETURN

      NBG=0
      FSW=0.D0
      TV=DELTIM/FLVIS
      G2=.5D0*GRAV

!  LOOP OVER A BLOCK INTERFACE ELEMENTS

      K1=IIEBS(NBLK)
      K2=K1+NIEBS(NBLK)-1
      DO 1 K=K1,K2
      J1=ICGES(K)
      J2=J1+NCGES(K)-1

      IA=IJKS(1,K)
      JA=IJKS(2,K)
      KA=IJKS(3,K)
      PA=PRES(IA,JA,KA)
      DENA=FLDEN(IA,JA,KA)
      DEPA=DEPTH(IA,JA,KA)

!  LOOP OVER THE B BLOCK INTERFACE ELEMENTS

      AFI=0.D0
      SQ=0.D0
      SDQDPA=0.D0
      DO 2 J=J1,J2
      NMS=FMODBLK(JBLOCK(J))

!  COMPUTE COUPLING

      L= LIBUF(J)
      DENB=BUFIF8(L,2)
      DP=PA-BUFIF8(L,1)-G2*(DENA+DENB)*(DEPA-BUFIF8(L,3))
      IF(DP.LT.0.D0) THEN
         TC=TV*DENB*TFINS(J)
      ELSE
         TC=TV*DENA*TFINS(J)
      ENDIF
      AFI=AFI+AREAI(J)
      Q=TC*DP
      SQ=SQ+Q
      SDQDPA=SDQDPA+TC
      COFINF(J,1,1)=-TC

      IF (NMS.NE.MODACT) FLUXOM=FLUXOM+Q

    2 CONTINUE

!  STORE WATER JACOBIAN COEFFICIENTS AND RESIDUALS
!  NOTE THAT ALL INTERFACE OFF-DIAGANOL COEFFICIENTS 
!  ARE CONSOLIDATED IN ONE COEFFICIENT PER EQUATION

      GO TO (11,12,13,14,15,16),KDIRS(J1)

   11 COF(IA,JA,KA,3)=-SDQDPA
      VX(IA+1,JA,KA)=SQ/AFI/DELTIM       ! bag8
      GO TO 17

   12 COF(IA,JA,KA,5)=-SDQDPA
      VY(IA,JA+1,KA)=SQ/AFI/DELTIM       ! bag8
      GO TO 17

   13 COF(IA,JA,KA,7)=-SDQDPA
      VZ(IA,JA,KA+1)=SQ/AFI/DELTIM       ! bag8
      GO TO 17

   14 COF(IA,JA,KA,2)=-SDQDPA
      VX(IA+1,JA,KA)=SQ/AFI/DELTIM       ! bag8
      GO TO 17

   15 COF(IA,JA,KA,4)=-SDQDPA
      VY(IA,JA+1,KA)=SQ/AFI/DELTIM       ! bag8
      GO TO 17

   16 COF(IA,JA,KA,6)=-SDQDPA
      VZ(IA,JA,KA+1)=SQ/AFI/DELTIM       ! bag8

   17 COF(IA,JA,KA,1)=COF(IA,JA,KA,1)+SDQDPA

      IF (BUGKEY(4)) THEN
         FSW=FSW+SQ
         IF (NBG.LT.15) THEN
            WRITE (NFBUG,18) NBLK,IA,JA,KA,SQ
            NBG=NBG+1
         ENDIF
      ENDIF
   18 FORMAT(' FACE: BLOCK,I,J,K =',4I4,' RW =',G14.7)

    1 RESID(IA,JA,KA)=RESID(IA,JA,KA)-SQ

      IF (BUGKEY(4)) WRITE (NFBUG,19) NBLK,FSW
   19 FORMAT(' FACE FLUX SUM: BLOCK =',I4,' QW =',G14.7)

      END SUBROUTINE TMJRCAL

!C*********************************************************************
!      SUBROUTINE T2TRVELD (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
!     &           KL2,KEYOUT,NBLK,PRES,FLDEN,DEPTH,NBUFDIM,BUFIF8,VEL)
!C*********************************************************************
!C  COMPUTE VELOCITY ON FAULT BLOCK INTERFACES
!
!C  PRES(I,J,K) = WATER PRESSURE, PSI (INPUT, REAL*8)
!
!C  FLDEN(I,J,K) = WATER DENSITY, LB/CU-FT (INPUT, REAL*8)
!
!C  DEPTH(I,J,K) = ELEMENT DEPTHS, FT (INPUT, REAL*8)
!
!C  NBUFDIM = FIRST DIMENSION OF BUFIF8(,) (INPUT, INTEGER)
!
!C  BUFIF8(,1) = PRES(,,) = PRESSURE, BLOCKB
!C  BUFIF8(,2) = FLDEN(,,) = DENSITY, BLOCKB
!C  BUFIF8(,3) = DEPTH(,,) = ELEMENT DEPTH, BLOCKB
!
!C  OUTPUT:
!
!C  VEL(I,J,K,L) = VELOCITY COMPONENT L AT LOCATION I,J,K 
!C                 (OUTPUT,REAL*8)
!C*********************************************************************
!      IMPLICIT NONE
!      INCLUDE 'control.h'
!      INCLUDE 'sblkc.h'
!      INCLUDE 'layout.h'
!      INCLUDE 'tfluidsc.h'
!      INCLUDE 'tbaldat.h'
!
!      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK,NBUFDIM
!      INTEGER JL1V(KDIM),JL2V(KDIM),    KEYOUT(IDIM,JDIM,KDIM)
!      INTEGER NBG,J,K,L,IA,JA,KA,J1,J2,K1,K2
!      REAL*8  PRES(IDIM,JDIM,KDIM),     FLDEN(IDIM,JDIM,KDIM),
!     &        DEPTH(IDIM,JDIM,KDIM),    VEL(IDIM,JDIM,KDIM,3),
!     &        BUFIF8(NBUFDIM,*)
!      REAL*8  TV,PA,DENA,DEPA,SQ,TC,DENB,DP,FSW,G2,Q
!
!      IF (NIEBS(NBLK).EQ.0) RETURN
!
!      NBG=0
!      FSW=0.D0
!      TV=1.0D0/FLVIS
!      G2=.5D0*GRAV
!
!C  LOOP OVER A BLOCK INTERFACE ELEMENTS
!
!      K1=IIEBS(NBLK)
!      K2=K1+NIEBS(NBLK)-1
!      DO 1 K=K1,K2
!      J1=ICGES(K)
!      J2=J1+NCGES(K)-1
!
!      IA=IJKS(1,K)
!      JA=IJKS(2,K)
!      KA=IJKS(3,K)
!      PA=PRES(IA,JA,KA)
!      DENA=FLDEN(IA,JA,KA)
!      DEPA=DEPTH(IA,JA,KA)
!
!C  SUM OVER THE B BLOCK INTERFACE ELEMENTS
!
!      SQ=0.D0
!      DO 2 J=J1,J2
!
!C  COMPUTE COUPLING
!
!      L= LIBUF(J)
!      DENB=BUFIF8(L,2)
!      DP=PA-BUFIF8(L,1)-G2*(DENA+DENB)*(DEPA-BUFIF8(L,3))
!      IF(DP.LT.0.D0) THEN
!         TC=TV*TFINS(J)
!      ELSE
!         TC=TV*TFINS(J)
!      ENDIF
!      Q=TC*DP
!      SQ=SQ+Q
!
!    2 CONTINUE
!
!C  STORE FAULT BLOCK INTERFACIAL VELOCITY INTO TRCHEM VEL ARRAY 
!
!      GO TO (11,12,13,14,15,16),KDIRS(J1)
!
!   11 VEL(IA+1,JA,KA,1)=SQ
!      GO TO 17
!
!   12 VEL(IA,JA+1,KA,2)=SQ
!      GO TO 17
!
!   13 VEL(IA,JA,KA+1,3)=SQ
!      GO TO 17
!
!   14 VEL(IA,JA,KA,1)=-SQ
!      GO TO 17
!
!   15 VEL(IA,JA,KA,2)=-SQ
!      GO TO 17
!
!   16 VEL(IA,JA,KA,3)=-SQ
!
!   17 CONTINUE
!
!      IF (BUGKEY(4)) THEN
!         FSW=FSW+SQ
!         IF (NBG.LT.15) THEN
!            WRITE (NFBUG,18) NBLK,IA,JA,KA,SQ
!            NBG=NBG+1
!         ENDIF
!      ENDIF
!   18 FORMAT(' FACE: BLOCK,I,J,K =',4I4,' VW =',G14.7)
!
!    1 CONTINUE
!
!      IF (BUGKEY(4)) WRITE (NFBUG,19) NBLK,FSW
!   19 FORMAT(' FACE FLUX SUM: BLOCK =',I4,' QW =',G14.7)
!
!      RETURN
!      END

!*********************************************************************
      SUBROUTINE TMLOCALFLUX_BC(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &       KL1,KL2,KEYOUT,NBLK,PRES,FLDEN,DEPTH,NBUFDIM,BUFIF8,
     &       XC,YC,ZC,AINVF,VOLPROP,FACEPROP,VOLDIM,FACEDIM,
     &       PERMINV,RESID,KEYOUTCR,FACEAREA,COF,DUNK)
!*********************************************************************
!
! bag8
!  TMLOCALFLUX_BC
!  COMPUTE CONTRIBUTION ACROSS DUAL INTERFACE USING LOCAL FLUX TECHNIQUE
!  APPLYING B BLOCK PRESSURE AS DIRICHLET BOUNDARY CONDITION, AN ORDER H ERROR
!
!*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'sblkc.h'
      INCLUDE 'layout.h'

      INCLUDE 'tfluidsc.h'
      INCLUDE 'tbaldat.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK,NBUFDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  PRES(IDIM,JDIM,KDIM),FLDEN(IDIM,JDIM,KDIM),
     &        DEPTH(IDIM,JDIM,KDIM),BUFIF8(NBUFDIM,*),
     &        XC(IDIM+1,JDIM+1,KDIM+1),YC(IDIM+1,JDIM+1,KDIM+1),
     &        ZC(IDIM+1,JDIM+1,KDIM+1),
     &        AINVF(24,IDIM+1,JDIM+1,KDIM+1)
      INTEGER VOLPROP(IDIM+1,JDIM+1,KDIM+1,8),
     &        FACEPROP(IDIM+1,JDIM+1,KDIM+1,12),
     &        VOLDIM(IDIM+1,JDIM+1,KDIM+1),
     &        FACEDIM(IDIM+1,JDIM+1,KDIM+1)
      REAL*8  PERMINV(3,3,8,IDIM,JDIM,KDIM),RESID(IDIM,JDIM,KDIM),
     &        KEYOUTCR(IDIM+1,JDIM+1,KDIM+1),
     &        FACEAREA(IDIM+1,JDIM+1,KDIM+1,12)
      REAL*8  COF(IDIM,JDIM,KDIM,-13:13),DUNK(IDIM,JDIM,KDIM)

      INTEGER IA,JA,KA,J,J1,J2,K,K1,K2,KD,L,NMS
      INTEGER MPFA_BTYPE,ITMP,JTMP,KTMP
      REAL*8  PA,PB,DENA,DENB,DEPA,DEPB,ARATIO
      REAL*8  XB,YB,ZB,PT(3)
      INTEGER KD2
      REAL*8  PEXACT

      STOP 'TMLOCALFLUX_BC not updated from old MPFA code'

!      IF (NIEBS(NBLK).EQ.0) RETURN
!
!      MPFA_BTYPE=2
!
!!  LOOP OVER A BLOCK INTERFACE ELEMENTS
!
!      K1=IIEBS(NBLK)
!      K2=K1+NIEBS(NBLK)-1
!      DO 1 K=K1,K2
!      J1=ICGES(K)
!      J2=J1+NCGES(K)-1
!
!      IA=IJKS(1,K)
!      JA=IJKS(2,K)
!      KA=IJKS(3,K)
!      PA=PRES(IA,JA,KA)
!      DENA=FLDEN(IA,JA,KA)
!      DEPA=DEPTH(IA,JA,KA)
!
!!  LOOP OVER THE B BLOCK INTERFACE ELEMENTS
!
!      DO 2 J=J1,J2
!      NMS=FMODBLK(JBLOCK(J))
!      L=LIBUF(J)
!      PB=BUFIF8(L,1)
!      KD=KDIRS(J) ! Direction for element j relative to element k
!
!! Interpolate interface for debugging
!!      PB=0.5D0*(PB+PRES(IA,JA,KA))
!
!! Overwrite interface buffer with true solution for debugging
!!      IF (KD.EQ.1) THEN
!!        KD2=1
!!      ELSEIF (KD.EQ.4) THEN
!!        KD2=2
!!      ELSEIF (KD.EQ.2) THEN
!!        KD2=3
!!      ELSEIF (KD.EQ.5) THEN
!!        KD2=4
!!      ELSEIF (KD.EQ.3) THEN
!!        KD2=5
!!      ELSEIF (KD.EQ.6) THEN
!!        KD2=6
!!      ENDIF
!!      CALL FaceCenterCorner(IA,JA,KA,KD2,XB,YB,ZB,XC,YC,ZC,
!!     &                      IDIM,JDIM,KDIM)
!!      PT(1)=XB
!!      PT(2)=YB
!!      PT(3)=ZB
!!      PB=PEXACT(PT)
!
!      IF ((KD.EQ.1).OR.(KD.EQ.4)) THEN       ! X- and X+ faces
!        IF (KD.EQ.1) ITMP = IA+1
!        IF (KD.EQ.4) ITMP = IA
!
!! Weight pressure pb by ratio of area of A block interface to B block interface
!!      ARATIO=MIN(1.D0,ABS(AREAI(J)/FACEAREA(ITMP,JA,KA,11)))
!!      PB=ARATIO*PB
!
!        CALL GETRHSBDABOVE(ITMP,JA,KA,11,KEYOUTCR,
!     &           PB,MPFA_BTYPE,VOLPROP,FACEPROP,VOLDIM,
!     &           FACEDIM,PERMINV,AINVF,PRES,RESID,IDIM,JDIM,KDIM)
!        CALL GETRHSBDABOVE(ITMP,JA+1,KA,9,KEYOUTCR,
!     &           PB,MPFA_BTYPE,VOLPROP,FACEPROP,VOLDIM,
!     &           FACEDIM,PERMINV,AINVF,PRES,RESID,IDIM,JDIM,KDIM)
!        CALL GETRHSBDABOVE(ITMP,JA+1,KA+1,1,KEYOUTCR,
!     &           PB,MPFA_BTYPE,VOLPROP,FACEPROP,VOLDIM,
!     &           FACEDIM,PERMINV,AINVF,PRES,RESID,IDIM,JDIM,KDIM)
!        CALL GETRHSBDABOVE(ITMP,JA,KA+1,3,KEYOUTCR,
!     &           PB,MPFA_BTYPE,VOLPROP,FACEPROP,VOLDIM,
!     &           FACEDIM,PERMINV,AINVF,PRES,RESID,IDIM,JDIM,KDIM)
!
!      ELSEIF ((KD.EQ.2).OR.(KD.EQ.5)) THEN   ! Y- and Y+ faces
!        IF (KD.EQ.2) JTMP = JA+1
!        IF (KD.EQ.5) JTMP = JA
!
!! Weight pressure pb by ratio of area of A block interface to B block interface
!!      ARATIO=MIN(1.D0,ABS(AREAI(J)/FACEAREA(IA,JTMP,KA,10)))
!!      PB=PB*ARATIO
!
!        CALL GETRHSBDABOVE(IA,JTMP,KA,10,KEYOUTCR,
!     &           PB,MPFA_BTYPE,VOLPROP,FACEPROP,VOLDIM,
!     &           FACEDIM,PERMINV,AINVF,PRES,RESID,IDIM,JDIM,KDIM)
!        CALL GETRHSBDABOVE(IA+1,JTMP,KA,12,KEYOUTCR,
!     &           PB,MPFA_BTYPE,VOLPROP,FACEPROP,VOLDIM,
!     &           FACEDIM,PERMINV,AINVF,PRES,RESID,IDIM,JDIM,KDIM)
!        CALL GETRHSBDABOVE(IA+1,JTMP,KA+1,4,KEYOUTCR,
!     &           PB,MPFA_BTYPE,VOLPROP,FACEPROP,VOLDIM,
!     &           FACEDIM,PERMINV,AINVF,PRES,RESID,IDIM,JDIM,KDIM)
!        CALL GETRHSBDABOVE(IA,JTMP,KA+1,2,KEYOUTCR,
!     &           PB,MPFA_BTYPE,VOLPROP,FACEPROP,VOLDIM,
!     &           FACEDIM,PERMINV,AINVF,PRES,RESID,IDIM,JDIM,KDIM)
!
!      ELSEIF ((KD.EQ.3).OR.(KD.EQ.6)) THEN   ! Z- and Z+ faces
!        IF (KD.EQ.3) KTMP = KA+1
!        IF (KD.EQ.6) KTMP = KA
!
!! Weight pressure pb by ratio of area of A block interface to B block interface
!!      ARATIO=MIN(1.D0,ABS(AREAI(J)/FACEAREA(IA,JA,KTMP,7)))
!!      PB=ARATIO*PB
!
!        CALL GETRHSBDABOVE(IA,JA,KTMP,7,KEYOUTCR,
!     &           PB,MPFA_BTYPE,VOLPROP,FACEPROP,VOLDIM,
!     &           FACEDIM,PERMINV,AINVF,PRES,RESID,IDIM,JDIM,KDIM)
!        CALL GETRHSBDABOVE(IA+1,JA,KTMP,8,KEYOUTCR,
!     &           PB,MPFA_BTYPE,VOLPROP,FACEPROP,VOLDIM,
!     &           FACEDIM,PERMINV,AINVF,PRES,RESID,IDIM,JDIM,KDIM)
!        CALL GETRHSBDABOVE(IA+1,JA+1,KTMP,5,KEYOUTCR,
!     &           PB,MPFA_BTYPE,VOLPROP,FACEPROP,VOLDIM,
!     &           FACEDIM,PERMINV,AINVF,PRES,RESID,IDIM,JDIM,KDIM)
!        CALL GETRHSBDABOVE(IA,JA+1,KTMP,6,KEYOUTCR,
!     &           PB,MPFA_BTYPE,VOLPROP,FACEPROP,VOLDIM,
!     &           FACEDIM,PERMINV,AINVF,PRES,RESID,IDIM,JDIM,KDIM)
!
!      ENDIF
!
!    2 CONTINUE
!
!    1 CONTINUE

      END SUBROUTINE TMLOCALFLUX_BC

!*********************************************************************
      SUBROUTINE TMLOCALFLUX_FILE(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &       KL1,KL2,KEYOUT,NBLK,PRES,FLDEN,DEPTH,NBUFDIM,BUFIF8,
     &       XC,YC,ZC,AINVF,VOLPROP,FACEPROP,VOLDIM,FACEDIM,
     &       PERMINV,RESID,KEYOUTCR,FACEAREA,COF,DUNK)
!*********************************************************************
!
! bag8
!  TMLOCALFLUX_FILE
!  COMPUTE CONTRIBUTION ACROSS DUAL INTERFACE USING LOCAL FLUX TECHNIQUE
!  APPLYING GAUSS SEIDEL METHOD USING COF AND RESID READ IN FROM A FILE
!
!*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'sblkc.h'
      INCLUDE 'layout.h'
      INCLUDE 'tfluidsc.h'
      INCLUDE 'tbaldat.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK,NBUFDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  PRES(IDIM,JDIM,KDIM),FLDEN(IDIM,JDIM,KDIM),
     &        DEPTH(IDIM,JDIM,KDIM),BUFIF8(NBUFDIM,*),
     &        XC(IDIM+1,JDIM+1,KDIM+1),YC(IDIM+1,JDIM+1,KDIM+1),
     &        ZC(IDIM+1,JDIM+1,KDIM+1),
     &        AINVF(24,IDIM+1,JDIM+1,KDIM+1)
      INTEGER VOLPROP(IDIM+1,JDIM+1,KDIM+1,8),
     &        FACEPROP(IDIM+1,JDIM+1,KDIM+1,12),
     &        VOLDIM(IDIM+1,JDIM+1,KDIM+1),
     &        FACEDIM(IDIM+1,JDIM+1,KDIM+1)
      REAL*8  PERMINV(3,3,8,IDIM,JDIM,KDIM),RESID(IDIM,JDIM,KDIM),
     &        KEYOUTCR(IDIM+1,JDIM+1,KDIM+1),
     &        FACEAREA(IDIM+1,JDIM+1,KDIM+1,12)
      REAL*8  COF(IDIM,JDIM,KDIM,-13:13),DUNK(IDIM,JDIM,KDIM)

      INTEGER IA,JA,KA,J,J1,J2,K,K1,K2,KD,L,NMS
      INTEGER ITMP,JTMP,KTMP
      REAL*8  PA,PB,DENA,DENB,DEPA,DEPB,ARATIO
      REAL*8  XB,YB,ZB,PT(3)
      INTEGER KD2
      REAL*8  PEXACT
      INTEGER IL,FN,FNBLK,FI,FJ,FK,IOFF,JOFF,KOFF
      REAL*8  MRESID,MCOF(-13:13),MTMP(-13:13),MRTMP,MP(-13:13)
      CHARACTER*80 COFNAME
      INTEGER IMIN,IMAX,JMIN,JMAX,KMIN,KMAX

      IF (NIEBS(NBLK).EQ.0) RETURN

      IMIN = ILAY+1
      JMIN = JLAY+1
      KMIN = KLAY+1
      IMAX = IDIM-ILAY
      JMAX = JDIM-JLAY
      KMAX = KDIM-KLAY

! Store B Block increment

      K1=IIEBS(NBLK)
      K2=K1+NIEBS(NBLK)-1
      DO K=K1,K2
      J1=ICGES(K)
      J2=J1+NCGES(K)-1
      IA=IJKS(1,K)
      JA=IJKS(2,K)
      KA=IJKS(3,K)
      DO J=J1,J2
      NMS=FMODBLK(JBLOCK(J))
      L=LIBUF(J)
      PB=BUFIF8(L,1)
      KD=KDIRS(J)
      IF (KD.EQ.1) THEN
        DUNK(IA+1,JA,KA) = PB - PRES(IA+1,JA,KA)
      ELSEIF (KD.EQ.4) THEN
        DUNK(IA-1,JA,KA) = PB - PRES(IA-1,JA,KA)
      ELSEIF (KD.EQ.2) THEN
        DUNK(IA,JA+1,KA) = PB - PRES(IA,JA+1,KA)
      ELSEIF (KD.EQ.5) THEN
        DUNK(IA,JA-1,KA) = PB - PRES(IA,JA-1,KA)
      ELSEIF (KD.EQ.3) THEN
        DUNK(IA,JA,KA+1) = PB - PRES(IA,JA,KA+1)
      ELSEIF (KD.EQ.6) THEN
        DUNK(IA,JA,KA-1) = PB - PRES(IA,JA,KA-1)
      ENDIF
      ENDDO
      ENDDO

!  LOOP OVER A BLOCK INTERFACE ELEMENTS

      K1=IIEBS(NBLK)
      K2=K1+NIEBS(NBLK)-1
      DO 1 K=K1,K2
      J1=ICGES(K)
      J2=J1+NCGES(K)-1

      IA=IJKS(1,K)
      JA=IJKS(2,K)
      KA=IJKS(3,K)
      PA=PRES(IA,JA,KA)
      DENA=FLDEN(IA,JA,KA)
      DEPA=DEPTH(IA,JA,KA)

! bag8 debug - read in MFMFE COF matrix
      COFNAME='COF08'
!      COFNAME='COF16'
!      COFNAME='COF32'
!      COFNAME='COF64'

      OPEN(unit=10,file=COFNAME,status='old')
      READ(10,*)FN

! Set IOFF,JOFF,KOFF specific to Test-conv-4b
      IF (NBLK.EQ.1) THEN
        IOFF=0
        JOFF=0
        KOFF=0
      ELSEIF (NBLK.EQ.2) THEN
        IOFF=0
        JOFF=FN/2
        KOFF=0
      ELSEIF (NBLK.EQ.3) THEN
        IOFF=FN/2
        JOFF=0
        KOFF=0
      ELSEIF (NBLK.EQ.4) THEN
        IOFF=FN/2
        JOFF=FN/2
        KOFF=0
      ENDIF

      DO IL=1,FN**2
      READ(10,23)FNBLK,FI,FJ,FK
      IF (((IA+IOFF).EQ.FI).AND.((JA+JOFF).EQ.FJ).AND.
     &    ((KA+KOFF).EQ.FK)) THEN
        READ(10,25)MRESID
        READ(10,24)MCOF(-13:-5)
        READ(10,24)MCOF(-4:4)
        READ(10,24)MCOF(5:13)
        GOTO 20
      ELSE
        READ(10,25)MRTMP
        READ(10,24)MTMP(-13:-5)
        READ(10,24)MTMP(-4:4)
        READ(10,24)MTMP(5:13)
      ENDIF
      ENDDO
      WRITE(*,*)'NBLK,IA,JA,KA=',NBLK,IA,JA,KA
      WRITE(*,*)'IOFF,JOFF,KOFF=',IOFF,JOFF,KOFF
      WRITE(*,*)'FI,FJ,FK=',FI,FJ,FK
      STOP 'MCOF not found'
 20   CLOSE(10)
 23   FORMAT(4I4)
 24   FORMAT(1P,9E20.11)
 25   FORMAT(1P,E20.11)

!  LOOP OVER THE B BLOCK INTERFACE ELEMENTS

      DO 2 J=J1,J2
      NMS=FMODBLK(JBLOCK(J))
      L=LIBUF(J)
      PB=BUFIF8(L,1)
      KD=KDIRS(J) ! Direction for element j relative to element k

! Overwrite COF matrix with MCOF from a file
      COF(IA,JA,KA,-13:13) = MCOF(-13:13)

! Overwrite RESID vector with MRESID from a file
      RESID(IA,JA,KA)=MRESID

! Store DUNK vector into MP
      MP(-13)=DUNK(IA,JA,KA)
      MP(-12)=DUNK(IA-1,JA,KA)
      MP(-11)=DUNK(IA+1,JA,KA)
      MP(-10)=DUNK(IA,JA-1,KA)
      MP( -9)=DUNK(IA,JA+1,KA)
      MP( -8)=DUNK(IA,JA,KA-1)
      MP( -7)=DUNK(IA,JA,KA+1)
      MP( -6)=DUNK(IA-1,JA-1,KA)
      MP( -5)=DUNK(IA+1,JA-1,KA)
      MP( -4)=DUNK(IA-1,JA+1,KA)
      MP( -3)=DUNK(IA+1,JA+1,KA)
      MP( -2)=DUNK(IA-1,JA,KA-1)
      MP( -1)=DUNK(IA+1,JA,KA-1)
      MP(  0)=DUNK(IA,JA-1,KA-1)
      MP(  1)=DUNK(IA,JA+1,KA-1)
      MP(  2)=DUNK(IA-1,JA,KA+1)
      MP(  3)=DUNK(IA+1,JA,KA+1)
      MP(  4)=DUNK(IA,JA-1,KA+1)
      MP(  5)=DUNK(IA,JA+1,KA+1)
      MP(  6)=DUNK(IA-1,JA-1,KA-1)
      MP(  7)=DUNK(IA+1,JA-1,KA-1)
      MP(  8)=DUNK(IA-1,JA+1,KA-1)
      MP(  9)=DUNK(IA+1,JA+1,KA-1)
      MP( 10)=DUNK(IA-1,JA-1,KA+1)
      MP( 11)=DUNK(IA+1,JA-1,KA+1)
      MP( 12)=DUNK(IA-1,JA+1,KA+1)
      MP( 13)=DUNK(IA+1,JA+1,KA+1)

      RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-13)*PRES(IA,JA,KA)
      RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-12)*PRES(IA-1,JA,KA)
      RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-11)*PRES(IA+1,JA,KA)
      RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-10)*PRES(IA,JA-1,KA)
      RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-9)*PRES(IA,JA+1,KA)
      RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-8)*PRES(IA,JA,KA-1)
      RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-7)*PRES(IA,JA,KA+1)
      RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-6)*PRES(IA-1,JA-1,KA)
      RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-5)*PRES(IA+1,JA-1,KA)
      RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-4)*PRES(IA-1,JA+1,KA)
      RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-3)*PRES(IA+1,JA+1,KA)
      RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-2)*PRES(IA-1,JA,KA-1)
      RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-1)*PRES(IA+1,JA,KA-1)
      RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(0)*PRES(IA,JA-1,KA-1)
      RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(1)*PRES(IA,JA+1,KA-1)
      RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(2)*PRES(IA-1,JA,KA+1)
      RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(3)*PRES(IA+1,JA,KA+1)
      RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(4)*PRES(IA,JA-1,KA+1)
      RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(5)*PRES(IA,JA+1,KA+1)
      RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(6)*PRES(IA-1,JA-1,KA-1)
      RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(7)*PRES(IA+1,JA-1,KA-1)
      RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(8)*PRES(IA-1,JA+1,KA-1)
      RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(9)*PRES(IA+1,JA+1,KA-1)
      RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(10)*PRES(IA-1,JA-1,KA+1)
      RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(11)*PRES(IA+1,JA-1,KA+1)
      RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(12)*PRES(IA-1,JA+1,KA+1)
      RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(13)*PRES(IA+1,JA+1,KA+1)

      IF ((KD.EQ.1).OR.(KD.EQ.4)) THEN       ! X- and X+ faces
        IF (KD.EQ.1) ITMP = IA+1
        IF (KD.EQ.4) ITMP = IA

         IF (KD.EQ.1) THEN
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-11)*MP(-11)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(13)*MP(-13)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(3)*MP(3)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(11)*MP(11)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-3)*MP(-3)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-5)*MP(-5)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(9)*MP(9)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-1)*MP(-1)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(7)*MP(7)
           COF(IA,JA,KA,-11)=0.D0
           COF(IA,JA,KA,13)=0.D0
           COF(IA,JA,KA,3)=0.D0
           COF(IA,JA,KA,11)=0.D0
           COF(IA,JA,KA,-3)=0.D0
           COF(IA,JA,KA,-5)=0.D0
           COF(IA,JA,KA,9)=0.D0
           COF(IA,JA,KA,-1)=0.D0
           COF(IA,JA,KA,7)=0.D0
         ELSE
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-12)*MP(-12)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(12)*MP(12)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(2)*MP(2)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(10)*MP(10)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-4)*MP(-4)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-6)*MP(-6)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(8)*MP(8)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-2)*MP(-2)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(6)*MP(6)
           COF(IA,JA,KA,-12)=0.D0
           COF(IA,JA,KA,12)=0.D0
           COF(IA,JA,KA,2)=0.D0
           COF(IA,JA,KA,10)=0.D0
           COF(IA,JA,KA,-4)=0.D0
           COF(IA,JA,KA,-6)=0.D0
           COF(IA,JA,KA,8)=0.D0
           COF(IA,JA,KA,-2)=0.D0
           COF(IA,JA,KA,6)=0.D0
         ENDIF

      ELSEIF ((KD.EQ.2).OR.(KD.EQ.5)) THEN   ! Y- and Y+ faces
        IF (KD.EQ.2) JTMP = JA+1
        IF (KD.EQ.5) JTMP = JA

         IF (KD.EQ.2) THEN
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-9)*MP(-9)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(12)*MP(12)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(5)*MP(5)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(13)*MP(13)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-4)*MP(-4)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-3)*MP(-3)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(8)*MP(8)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(1)*MP(1)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(9)*MP(9)
           COF(IA,JA,KA,-9)=0.D0
           COF(IA,JA,KA,12)=0.D0
           COF(IA,JA,KA,5)=0.D0
           COF(IA,JA,KA,13)=0.D0
           COF(IA,JA,KA,-4)=0.D0
           COF(IA,JA,KA,-3)=0.D0
           COF(IA,JA,KA,8)=0.D0
           COF(IA,JA,KA,1)=0.D0
           COF(IA,JA,KA,9)=0.D0
         ELSE
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-10)*MP(-10)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(10)*MP(10)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(4)*MP(4)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(11)*MP(11)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-6)*MP(-6)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-5)*MP(-5)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(6)*MP(6)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(0)*MP(0)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(7)*MP(7)
           COF(IA,JA,KA,-10)=0.D0
           COF(IA,JA,KA,10)=0.D0
           COF(IA,JA,KA,4)=0.D0
           COF(IA,JA,KA,11)=0.D0
           COF(IA,JA,KA,-6)=0.D0
           COF(IA,JA,KA,-5)=0.D0
           COF(IA,JA,KA,6)=0.D0
           COF(IA,JA,KA,0)=0.D0
           COF(IA,JA,KA,7)=0.D0
         ENDIF

      ELSEIF ((KD.EQ.3).OR.(KD.EQ.6)) THEN   ! Z- and Z+ faces
        IF (KD.EQ.3) KTMP = KA+1
        IF (KD.EQ.6) KTMP = KA

         IF (KD.EQ.3) THEN
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-7)*MP(-7)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(12)*MP(12)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(5)*MP(5)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(13)*MP(13)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(2)*MP(2)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(3)*MP(3)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(10)*MP(10)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(4)*MP(4)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(11)*MP(11)
           COF(IA,JA,KA,-7)=0.D0
           COF(IA,JA,KA,12)=0.D0
           COF(IA,JA,KA,5)=0.D0
           COF(IA,JA,KA,13)=0.D0
           COF(IA,JA,KA,2)=0.D0
           COF(IA,JA,KA,3)=0.D0
           COF(IA,JA,KA,10)=0.D0
           COF(IA,JA,KA,4)=0.D0
           COF(IA,JA,KA,11)=0.D0
         ELSE
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-8)*MP(-8)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(8)*MP(8)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(1)*MP(1)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(9)*MP(9)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-2)*MP(-2)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-1)*MP(-1)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(6)*MP(6)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(0)*MP(0)
           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(7)*MP(7)
           COF(IA,JA,KA,-8)=0.D0
           COF(IA,JA,KA,8)=0.D0
           COF(IA,JA,KA,1)=0.D0
           COF(IA,JA,KA,9)=0.D0
           COF(IA,JA,KA,-2)=0.D0
           COF(IA,JA,KA,-1)=0.D0
           COF(IA,JA,KA,6)=0.D0
           COF(IA,JA,KA,0)=0.D0
           COF(IA,JA,KA,7)=0.D0
         ENDIF

      ENDIF

    2 CONTINUE

    1 CONTINUE

! Store B Block pressures

      K1=IIEBS(NBLK)
      K2=K1+NIEBS(NBLK)-1
      DO K=K1,K2
      J1=ICGES(K)
      J2=J1+NCGES(K)-1
      IA=IJKS(1,K)
      JA=IJKS(2,K)
      KA=IJKS(3,K)
      DO J=J1,J2
      NMS=FMODBLK(JBLOCK(J))
      L=LIBUF(J)
      PB=BUFIF8(L,1)
      KD=KDIRS(J)
      IF (KD.EQ.1) THEN
        PRES(IA+1,JA,KA) = PB
      ELSEIF (KD.EQ.4) THEN
        PRES(IA-1,JA,KA) = PB
      ELSEIF (KD.EQ.2) THEN
        PRES(IA,JA+1,KA) = PB
      ELSEIF (KD.EQ.5) THEN
        PRES(IA,JA-1,KA) = PB
      ELSEIF (KD.EQ.3) THEN
        PRES(IA,JA,KA+1) = PB
      ELSEIF (KD.EQ.6) THEN
        PRES(IA,JA,KA-1) = PB
      ENDIF
      ENDDO
      ENDDO

      END SUBROUTINE TMLOCALFLUX_FILE

!*********************************************************************
      SUBROUTINE TMLOCALFLUX_JACOBI(IDIM,JDIM,KDIM,LDIM,IL1,IL2,
     &   JL1V,JL2V,KL1,KL2,KEYOUT,NBLK,PRES,FLDEN,DEPTH,NBUFDIM,
     &   BUFIF8,XC,YC,ZC,AINVF,VOLPROP,FACEPROP,VOLDIM,FACEDIM,
     &   PERMINV,RESID,KEYOUTCR,FACEAREA,COF,DUNK)
!*********************************************************************
!
! bag8
!  TMLOCALFLUX_JACOBI
!  COMPUTE CONTRIBUTION ACROSS DUAL INTERFACE USING LOCAL FLUX TECHNIQUE
!  APPLYING JACOBI METHOD USING COF AND RESID FROM MPFA_TRAN
!
!*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'sblkc.h'
      INCLUDE 'layout.h'

      INCLUDE 'tfluidsc.h'
      INCLUDE 'tbaldat.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK,NBUFDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  PRES(IDIM,JDIM,KDIM),FLDEN(IDIM,JDIM,KDIM),
     &        DEPTH(IDIM,JDIM,KDIM),BUFIF8(NBUFDIM,*),
     &        XC(IDIM+1,JDIM+1,KDIM+1),YC(IDIM+1,JDIM+1,KDIM+1),
     &        ZC(IDIM+1,JDIM+1,KDIM+1),
     &        AINVF(24,IDIM+1,JDIM+1,KDIM+1)
      INTEGER VOLPROP(IDIM+1,JDIM+1,KDIM+1,8),
     &        FACEPROP(IDIM+1,JDIM+1,KDIM+1,12),
     &        VOLDIM(IDIM+1,JDIM+1,KDIM+1),
     &        FACEDIM(IDIM+1,JDIM+1,KDIM+1)
      REAL*8  PERMINV(3,3,8,IDIM,JDIM,KDIM),RESID(IDIM,JDIM,KDIM),
     &        KEYOUTCR(IDIM+1,JDIM+1,KDIM+1),
     &        FACEAREA(IDIM+1,JDIM+1,KDIM+1,12)
      REAL*8  COF(IDIM,JDIM,KDIM,-13:13),DUNK(IDIM,JDIM,KDIM)

      INTEGER IA,JA,KA,J,J1,J2,K,K1,K2,KD,L
!      REAL*8  NMS,PA,PB,DENA,DENB,DEPA,DEPB,ARATIO
!      REAL*8  XB,YB,ZB,PT(3)
!      REAL*8  MCOF(-13:13),MP(-13:13)

      IF (NIEBS(NBLK).EQ.0) RETURN

C  LOOP OVER A BLOCK INTERFACE ELEMENTS

      K1=IIEBS(NBLK)
      K2=K1+NIEBS(NBLK)-1
      DO 1 K=K1,K2
      J1=ICGES(K)
      J2=J1+NCGES(K)-1

      IA=IJKS(1,K)
      JA=IJKS(2,K)
      KA=IJKS(3,K)
!      PA=PRES(IA,JA,KA)
!      DENA=FLDEN(IA,JA,KA)
!      DEPA=DEPTH(IA,JA,KA)

C  SUM OVER THE B BLOCK INTERFACE ELEMENTS

      DO 2 J=J1,J2
!      NMS=FMODBLK(JBLOCK(J))
      L=LIBUF(J)
!      PB=BUFIF8(L,1)
      KD=KDIRS(J) ! Direction for element j relative to element k

! Store COF matrix into MCOF
!      MCOF(-13:13) = COF(IA,JA,KA,:)

! Store DUNK vector into MP
!      MP(-13)=DUNK(IA,JA,KA)
!      MP(-12)=DUNK(IA-1,JA,KA)
!      MP(-11)=DUNK(IA+1,JA,KA)
!      MP(-10)=DUNK(IA,JA-1,KA)
!      MP( -9)=DUNK(IA,JA+1,KA)
!      MP( -8)=DUNK(IA,JA,KA-1)
!      MP( -7)=DUNK(IA,JA,KA+1)
!      MP( -6)=DUNK(IA-1,JA-1,KA)
!      MP( -5)=DUNK(IA+1,JA-1,KA)
!      MP( -4)=DUNK(IA-1,JA+1,KA)
!      MP( -3)=DUNK(IA+1,JA+1,KA)
!      MP( -2)=DUNK(IA-1,JA,KA-1)
!      MP( -1)=DUNK(IA+1,JA,KA-1)
!      MP(  0)=DUNK(IA,JA-1,KA-1)
!      MP(  1)=DUNK(IA,JA+1,KA-1)
!      MP(  2)=DUNK(IA-1,JA,KA+1)
!      MP(  3)=DUNK(IA+1,JA,KA+1)
!      MP(  4)=DUNK(IA,JA-1,KA+1)
!      MP(  5)=DUNK(IA,JA+1,KA+1)
!      MP(  6)=DUNK(IA-1,JA-1,KA-1)
!      MP(  7)=DUNK(IA+1,JA-1,KA-1)
!      MP(  8)=DUNK(IA-1,JA+1,KA-1)
!      MP(  9)=DUNK(IA+1,JA+1,KA-1)
!      MP( 10)=DUNK(IA-1,JA-1,KA+1)
!      MP( 11)=DUNK(IA+1,JA-1,KA+1)
!      MP( 12)=DUNK(IA-1,JA+1,KA+1)
!      MP( 13)=DUNK(IA+1,JA+1,KA+1)

      IF ((KD.EQ.1).OR.(KD.EQ.4)) THEN       ! X- and X+ faces

         IF (KD.EQ.1) THEN
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-11)*MP(-11)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(13)*MP(13)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(3)*MP(3)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(11)*MP(11)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-3)*MP(-3)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-5)*MP(-5)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(9)*MP(9)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-1)*MP(-1)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(7)*MP(7)
           COF(IA,JA,KA,-11)=0.D0
           COF(IA,JA,KA,13)=0.D0
           COF(IA,JA,KA,3)=0.D0
           COF(IA,JA,KA,11)=0.D0
           COF(IA,JA,KA,-3)=0.D0
           COF(IA,JA,KA,-5)=0.D0
           COF(IA,JA,KA,9)=0.D0
           COF(IA,JA,KA,-1)=0.D0
           COF(IA,JA,KA,7)=0.D0
         ELSE
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-12)*MP(-12)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(12)*MP(12)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(2)*MP(2)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(10)*MP(10)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-4)*MP(-4)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-6)*MP(-6)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(8)*MP(8)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-2)*MP(-2)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(6)*MP(6)
           COF(IA,JA,KA,-12)=0.D0
           COF(IA,JA,KA,12)=0.D0
           COF(IA,JA,KA,2)=0.D0
           COF(IA,JA,KA,10)=0.D0
           COF(IA,JA,KA,-4)=0.D0
           COF(IA,JA,KA,-6)=0.D0
           COF(IA,JA,KA,8)=0.D0
           COF(IA,JA,KA,-2)=0.D0
           COF(IA,JA,KA,6)=0.D0
         ENDIF

      ELSEIF ((KD.EQ.2).OR.(KD.EQ.5)) THEN   ! Y- and Y+ faces

         IF (KD.EQ.2) THEN
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-9)*MP(-9)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(12)*MP(12)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(5)*MP(5)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(13)*MP(13)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-4)*MP(-4)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-3)*MP(-3)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(8)*MP(8)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(1)*MP(1)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(9)*MP(9)
           COF(IA,JA,KA,-9)=0.D0
           COF(IA,JA,KA,12)=0.D0
           COF(IA,JA,KA,5)=0.D0
           COF(IA,JA,KA,13)=0.D0
           COF(IA,JA,KA,-4)=0.D0
           COF(IA,JA,KA,-3)=0.D0
           COF(IA,JA,KA,8)=0.D0
           COF(IA,JA,KA,1)=0.D0
           COF(IA,JA,KA,9)=0.D0
         ELSE
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-10)*MP(-10)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(10)*MP(10)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(4)*MP(4)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(11)*MP(11)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-6)*MP(-6)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-5)*MP(-5)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(6)*MP(6)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(0)*MP(0)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(7)*MP(7)
           COF(IA,JA,KA,-10)=0.D0
           COF(IA,JA,KA,10)=0.D0
           COF(IA,JA,KA,4)=0.D0
           COF(IA,JA,KA,11)=0.D0
           COF(IA,JA,KA,-6)=0.D0
           COF(IA,JA,KA,-5)=0.D0
           COF(IA,JA,KA,6)=0.D0
           COF(IA,JA,KA,0)=0.D0
           COF(IA,JA,KA,7)=0.D0
         ENDIF

      ELSEIF ((KD.EQ.3).OR.(KD.EQ.6)) THEN   ! Z- and Z+ faces

         IF (KD.EQ.3) THEN
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-7)*MP(-7)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(12)*MP(12)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(5)*MP(5)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(13)*MP(13)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(2)*MP(2)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(3)*MP(3)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(10)*MP(10)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(4)*MP(4)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(11)*MP(11)
           COF(IA,JA,KA,-7)=0.D0
           COF(IA,JA,KA,12)=0.D0
           COF(IA,JA,KA,5)=0.D0
           COF(IA,JA,KA,13)=0.D0
           COF(IA,JA,KA,2)=0.D0
           COF(IA,JA,KA,3)=0.D0
           COF(IA,JA,KA,10)=0.D0
           COF(IA,JA,KA,4)=0.D0
           COF(IA,JA,KA,11)=0.D0
         ELSE
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-8)*MP(-8)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(8)*MP(8)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(1)*MP(1)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(9)*MP(9)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-2)*MP(-2)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(-1)*MP(-1)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(6)*MP(6)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(0)*MP(0)
!           RESID(IA,JA,KA)=RESID(IA,JA,KA)-MCOF(7)*MP(7)
           COF(IA,JA,KA,-8)=0.D0
           COF(IA,JA,KA,8)=0.D0
           COF(IA,JA,KA,1)=0.D0
           COF(IA,JA,KA,9)=0.D0
           COF(IA,JA,KA,-2)=0.D0
           COF(IA,JA,KA,-1)=0.D0
           COF(IA,JA,KA,6)=0.D0
           COF(IA,JA,KA,0)=0.D0
           COF(IA,JA,KA,7)=0.D0
         ENDIF

      ENDIF

    2 CONTINUE

    1 CONTINUE

      END SUBROUTINE TMLOCALFLUX_JACOBI

!*********************************************************************
      SUBROUTINE TMSET_COORD5()
!*********************************************************************
      IMPLICIT NONE
      INCLUDE 'blkary.h'
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'mpfaary.h'
      INCLUDE 'sblkc.h'
      INCLUDE 'tarydat.h'

      INTEGER IC(6),NBEM($MXMOD),NERR
      LOGICAL ONCEONLY
      DATA ONCEONLY /.TRUE./,IC/6*0/,NBEM/$MXMOD*0/
      EXTERNAL TMCOORDLOAD,TMCOORDFILL5

      IF (EVFEM_HEX.NE.5) RETURN
      IF (NFACES.EQ.0) RETURN

      IF (ONCEONLY) THEN
         ONCEONLY=.FALSE.

         IC(1)=5
         IC(2)=N_XC
         IC(3)=N_YC
         IC(4)=N_ZC
         IC(5)=N_BUFDIM
         IC(6)=N_BUFIF

      ENDIF

! Warning:  this only works for a matching grid

      CALL TIMON(12)

      CALL CALLWORK(TMCOORDLOAD,IC)   ! Load coords into buffer
      NBEM=24
      CALL PIFBUF8(NBEM,NERR)         ! Swap information between blocks
      CALL CALLWORK(TMCOORDFILL5,IC)   ! Fill coords in ghost layer

      CALL TIMOFF(12)

      END SUBROUTINE TMSET_COORD5

!*********************************************************************
      SUBROUTINE TMSET_COORD6()
!*********************************************************************
      IMPLICIT NONE
      include 'blkary.h'
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      include 'mpfaary.h'
      INCLUDE 'sblkc.h'
      include 'tarydat.h'

      INTEGER IC2(3),IC(6),NBEM($MXMOD),NERR
      LOGICAL ONCEONLY
      DATA ONCEONLY /.TRUE./,IC2/3*0/,IC/6*0/,NBEM/$MXMOD*0/
      EXTERNAL TMCOORDLOAD,TMCOORDFILL6

      IF (EVFEM_HEX.NE.6) RETURN
      IF (NFACES.EQ.0) RETURN

      IF (ONCEONLY) THEN
         ONCEONLY=.FALSE.

         IC(1)=5
         IC(2)=N_XC
         IC(3)=N_YC
         IC(4)=N_ZC
         IC(5)=N_BUFDIM
         IC(6)=N_BUFIF

         IC2(1)=2
         IC2(2)=N_BUFDIM
         IC2(3)=N_BUFIF

      ENDIF

      CALL TIMON(12)

      CALL CALLWORK(TMCOORDLOAD,IC)   ! Load coords into buffer
      NBEM=24
      CALL PIFBUF8(NBEM,NERR)         ! Swap information between blocks
      CALL CALLWORK(TMCOORDFILL6,IC2) ! Fill coords in DFAC2HEX

      CALL TIMOFF(12)

      END SUBROUTINE TMSET_COORD6

!*********************************************************************
      SUBROUTINE TMSET_PERMINV5()
!*********************************************************************
      IMPLICIT NONE
      include 'blkary.h'
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      include 'mpfaary.h'
      INCLUDE 'sblkc.h'
      include 'tarydat.h'

      INTEGER IB(2),IP(5),IC(6),NBEM($MXMOD),NERR
      LOGICAL ONCEONLY
      DATA ONCEONLY /.TRUE./,IP/5*0/,NBEM/$MXMOD*0/

      EXTERNAL TMPERMINVLOAD,TMPERMINVFILL5

      IF (EVFEM_HEX.NE.5) RETURN
      IF (NFACES.EQ.0) RETURN

      IF (ONCEONLY) THEN
         ONCEONLY=.FALSE.

         IP(1)=4
         IP(2)=N_PRES
         IP(3)=N_PERMINV
         IP(4)=N_BUFDIM
         IP(5)=N_BUFIF

      ENDIF

! Warning:  this only works for a matching grid

      CALL TIMON(12)

      CALL CALLWORK(TMPERMINVLOAD,IP)   ! Load perminv into buffer
      NBEM=72
      CALL PIFBUF8(NBEM,NERR)           ! Swap information between blocks
      CALL CALLWORK(TMPERMINVFILL5,IP)   ! Fill perminv in ghost layer

      CALL TIMOFF(12)

      END SUBROUTINE TMSET_PERMINV5

!*********************************************************************
      SUBROUTINE TMSET_PERMINV6a()
!*********************************************************************
      IMPLICIT NONE
      include 'blkary.h'
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      include 'mpfaary.h'
      INCLUDE 'sblkc.h'
      include 'tarydat.h'

      INTEGER IB(2),IP(5),IC(6),NBEM($MXMOD),NERR
      LOGICAL ONCEONLY
      DATA ONCEONLY /.TRUE./,IP/5*0/,NBEM/$MXMOD*0/

      EXTERNAL TMPERMINVLOAD,TMPERMINVFILL6a

      IF (EVFEM_HEX.NE.6) RETURN
      IF (NFACES.EQ.0) RETURN

      IF (ONCEONLY) THEN
         ONCEONLY=.FALSE.

         IP(1)=4
         IP(2)=N_PRES
         IP(3)=N_PERMINV
         IP(4)=N_BUFDIM
         IP(5)=N_BUFIF

      ENDIF

      CALL TIMON(12)

      CALL CALLWORK(TMPERMINVLOAD,IP)   ! Load perminv into buffer
      NBEM=72
      CALL PIFBUF8(NBEM,NERR)           ! Swap information between blocks
      CALL CALLWORK(TMPERMINVFILL6a,IP)   ! Fill perminv in ghost layer

      CALL TIMOFF(12)

      END SUBROUTINE TMSET_PERMINV6a

!*********************************************************************
      SUBROUTINE TMSET_PERMINV6b()
!*********************************************************************
      IMPLICIT NONE
      include 'blkary.h'
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      include 'mpfaary.h'
      INCLUDE 'sblkc.h'
      include 'tarydat.h'

      INTEGER IP(4),NBEM($MXMOD),NERR
      LOGICAL ONCEONLY
      DATA ONCEONLY /.TRUE./,IP/4*0/,NBEM/$MXMOD*0/

      EXTERNAL TMPRESLOAD,TMPRESFILL,TMPERMINVFILL6b

      IF (EVFEM_HEX.NE.6) RETURN
      IF (NFACES.EQ.0) RETURN

      IF (ONCEONLY) THEN
         ONCEONLY=.FALSE.

         IP(1)=3
         IP(2)=N_PRES
         IP(3)=N_BUFDIM
         IP(4)=N_BUFIF

      ENDIF

      CALL TIMON(12)

      CALL CALLWORK(TMPRESLOAD,IP)      ! Load pres into buffer
      NBEM=1
      CALL PIFBUF8(NBEM,NERR)           ! Swap information between blocks
      CALL CALLWORK(TMPRESFILL,IP)      ! Fill pres in dpres
      CALL CALLWORK(TMPERMINVFILL6b,IP) ! Fill pres in dpres

      CALL TIMOFF(12)

      END SUBROUTINE TMSET_PERMINV6b

!*********************************************************************
      SUBROUTINE TMSET_PERMCC()
!*********************************************************************
      IMPLICIT NONE
      include 'blkary.h'
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      include 'mpfaary.h'
      INCLUDE 'sblkc.h'

      INTEGER IP(9),JP(3),KP(2),NBEM($MXMOD),NERR
      LOGICAL ONCEONLY
      DATA ONCEONLY /.TRUE./,IP/9*0/,JP/3*0/,KP/2*0/,NBEM/$MXMOD*0/

      EXTERNAL TMPERMCCLOAD,TMPERMCCFILL,TMPERMINVINI

      IF (EVFEM_HEX.NE.6) RETURN
      IF (NFACES.EQ.0) RETURN

      IF (ONCEONLY) THEN
         ONCEONLY=.FALSE.

         IP(1)=8
         IP(2)=N_XPERM
         IP(3)=N_YPERM
         IP(4)=N_ZPERM
         IP(5)=N_XYPERM
         IP(6)=N_XZPERM
         IP(7)=N_YZPERM
         IP(8)=N_BUFDIM
         IP(9)=N_BUFIF

         JP(1)=2
         JP(2)=N_BUFDIM
         JP(3)=N_BUFIF

         KP(1)=1
         KP(2)=N_MPFAQU

      ENDIF

      CALL TIMON(12)

      CALL CALLWORK(TMPERMCCLOAD,IP)   ! Load sym 3x3 perm tensor into buffer
      NBEM=6
      CALL PIFBUF8(NBEM,NERR)          ! Swap information between blocks
      CALL CALLWORK(TMPERMCCFILL,JP)   ! Fill 3x3 perm into DPERMCC
      CALL CALLWORK(TMPERMINVINI,KP)   ! Compute DPERMINVINI

      CALL TIMOFF(12)

      END SUBROUTINE TMSET_PERMCC

!*********************************************************************
      SUBROUTINE TMPERMCCLOAD(IDIM,JDIM,KDIM,LDIM,IL1,IL2,
     &   JL1V,JL2V,KL1,KL2,KEYOUT,NBLK,XPERM,YPERM,ZPERM,
     &   XYPERM,XZPERM,YZPERM,NBUFDIM,BUFIF8)
!*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'unitsex.h'
      INCLUDE 'sblkc.h'
      INCLUDE 'tfluidsc.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK,NBUFDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 BUFIF8(NBUFDIM,*)
      REAL*4 XPERM(IDIM,JDIM,KDIM),YPERM(IDIM,JDIM,KDIM),
     &       ZPERM(IDIM,JDIM,KDIM),XYPERM(IDIM,JDIM,KDIM),
     &       XZPERM(IDIM,JDIM,KDIM),YZPERM(IDIM,JDIM,KDIM)
      INTEGER M,II1,II2,NBT,NMT,II,K,IA,JA,KA

      IF (NPAI(NBLK).EQ.0) RETURN

      DO 90 M=1,NPAI(NBLK)
      II1=IESNDI(M,NBLK)
      II2=II1+NESNDI(M,NBLK)-1
      NBT=NBSRI(M,NBLK)
      NMT=FMODBLK(NBT)

      DO 61 II=II1,II2
      K=KFESR(II)
      IA=IJKS(1,K)
      JA=IJKS(2,K)
      KA=IJKS(3,K)

      BUFIF8(II,1)=XPERM(IA,JA,KA)
      BUFIF8(II,2)=YPERM(IA,JA,KA)
      BUFIF8(II,3)=ZPERM(IA,JA,KA)
      BUFIF8(II,4)=XYPERM(IA,JA,KA)
      BUFIF8(II,5)=XZPERM(IA,JA,KA)
      BUFIF8(II,6)=YZPERM(IA,JA,KA)

   61 CONTINUE
   90 CONTINUE

      END SUBROUTINE TMPERMCCLOAD

!*********************************************************************
      SUBROUTINE TMPERMINVLOAD(IDIM,JDIM,KDIM,LDIM,IL1,IL2,
     &   JL1V,JL2V,KL1,KL2,KEYOUT,NBLK,PRES,PERMINV,NBUFDIM,BUFIF8)
!*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'unitsex.h'
      INCLUDE 'sblkc.h'
      INCLUDE 'tfluidsc.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK,NBUFDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 BUFIF8(NBUFDIM,*)
      REAL*8 PERMINV(3,3,8,IDIM,JDIM,KDIM)
      REAL*8 PRES(IDIM,JDIM,KDIM)
      INTEGER M,II1,II2,NBT,NMT,II,K,IA,JA,KA,IB2,I2,J2,K2

      IF (NPAI(NBLK).EQ.0) RETURN

      DO 90 M=1,NPAI(NBLK)
      II1=IESNDI(M,NBLK)
      II2=II1+NESNDI(M,NBLK)-1
      NBT=NBSRI(M,NBLK)
      NMT=FMODBLK(NBT)

      DO 61 II=II1,II2
      K=KFESR(II)
      IA=IJKS(1,K)
      JA=IJKS(2,K)
      KA=IJKS(3,K)

      IB2=0
      BUFIF8(II,1)=PRES(IA,JA,KA)
      DO K2=1,8
      DO J2=1,3
      DO I2=1,3
        IB2=IB2+1
        BUFIF8(II,1+IB2)=PERMINV(I2,J2,K2,IA,JA,KA)
      ENDDO
      ENDDO
      ENDDO

   61 CONTINUE
   90 CONTINUE

      END SUBROUTINE TMPERMINVLOAD

!*********************************************************************
      SUBROUTINE TMPRESLOAD(IDIM,JDIM,KDIM,LDIM,IL1,IL2,
     &   JL1V,JL2V,KL1,KL2,KEYOUT,NBLK,PRES,NBUFDIM,BUFIF8)
!*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'unitsex.h'
      INCLUDE 'sblkc.h'
      INCLUDE 'tfluidsc.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK,NBUFDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 BUFIF8(NBUFDIM,*)
      REAL*8 PRES(IDIM,JDIM,KDIM)
      INTEGER M,II1,II2,NBT,NMT,II,K,IA,JA,KA

      IF (NPAI(NBLK).EQ.0) RETURN

      DO 90 M=1,NPAI(NBLK)
      II1=IESNDI(M,NBLK)
      II2=II1+NESNDI(M,NBLK)-1
      NBT=NBSRI(M,NBLK)
      NMT=FMODBLK(NBT)

      DO 61 II=II1,II2
      K=KFESR(II)
      IA=IJKS(1,K)
      JA=IJKS(2,K)
      KA=IJKS(3,K)

      BUFIF8(II,1)=PRES(IA,JA,KA)

   61 CONTINUE
   90 CONTINUE

      END SUBROUTINE TMPRESLOAD

!*********************************************************************
      SUBROUTINE TMPERMINVFILL5(IDIM,JDIM,KDIM,LDIM,IL1,IL2,
     &   JL1V,JL2V,KL1,KL2,KEYOUT,NBLK,PRES,PERMINV,NBUFDIM,BUFIF8)
!*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'unitsex.h'
      INCLUDE 'sblkc.h'
      INCLUDE 'tfluidsc.h'
      INCLUDE 'layout.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK,NBUFDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 BUFIF8(NBUFDIM,*)
      REAL*8 PERMINV(3,3,8,IDIM,JDIM,KDIM)
      REAL*8 PRES(IDIM,JDIM,KDIM)
      INTEGER K1,K2,K,J1,J2,IA,JA,KA,J,NMS,L,KD,IB,JB,KB,N2,
     &  IB2,JB2,KB2

      IF (NIEBS(NBLK).EQ.0) RETURN

!  LOOP OVER A BLOCK INTERFACE ELEMENTS

      K1=IIEBS(NBLK)
      K2=K1+NIEBS(NBLK)-1
      DO 1 K=K1,K2
      J1=ICGES(K)
      J2=J1+NCGES(K)-1

      IA=IJKS(1,K)
      JA=IJKS(2,K)
      KA=IJKS(3,K)

!  LOOP OVER THE B BLOCK INTERFACE ELEMENTS

      DO 2 J=J1,J2
      NMS=FMODBLK(JBLOCK(J))
      L=LIBUF(J)
      KD=KDIRS(J)

      IB=IA
      JB=JA
      KB=KA
      IF (KD.EQ.1) THEN
        IB=IA+1
      ELSEIF (KD.EQ.4) THEN
        IB=IA-1
      ELSEIF (KD.EQ.2) THEN
        JB=JA+1
      ELSEIF (KD.EQ.5) THEN
        JB=JA-1
      ELSEIF (KD.EQ.3) THEN
        KB=KA+1
      ELSEIF (KD.EQ.6) THEN
        KB=KA-1
      ENDIF

      PRES(IB,JB,KB)=BUFIF8(L,1)
      N2=0
      DO KB2=1,8
      DO JB2=1,3
      DO IB2=1,3
        N2=N2+1
        PERMINV(IB2,JB2,KB2,IB,JB,KB)=BUFIF8(L,1+N2)
      ENDDO
      ENDDO
      ENDDO

    2 CONTINUE
    1 CONTINUE

      END SUBROUTINE TMPERMINVFILL5

!*********************************************************************
      SUBROUTINE TMPERMINVFILL6a(IDIM,JDIM,KDIM,LDIM,IL1,IL2,
     &   JL1V,JL2V,KL1,KL2,KEYOUT,NBLK,PRES,PERMINV,NBUFDIM,BUFIF8)
!*********************************************************************
      USE dualmod
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'unitsex.h'
      INCLUDE 'sblkc.h'
      INCLUDE 'tfluidsc.h'
      INCLUDE 'layout.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK,NBUFDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 BUFIF8(NBUFDIM,*)
      REAL*8 PERMINV(3,3,8,IDIM,JDIM,KDIM)
      REAL*8 PRES(IDIM,JDIM,KDIM)
      INTEGER I,K1,K2,K,J1,J2,J,L,KD,N,N2,
     &        IB2,JB2,KB2,INB,JNB,KNB
      REAL*8 P,PINV(3,3,8)

      IF (NIEBS(NBLK).EQ.0) RETURN

!  LOOP OVER A BLOCK INTERFACE ELEMENTS

      K1=IIEBS(NBLK)
      K2=K1+NIEBS(NBLK)-1
      DO 1 K=K1,K2
      J1=ICGES(K)
      J2=J1+NCGES(K)-1

!  LOOP OVER THE B BLOCK INTERFACE ELEMENTS

      DO 2 J=J1,J2
      L=LIBUF(J)
      KD=KDIRS(J)

      P=BUFIF8(L,1)
      N2=0
      DO KB2=1,8
      DO JB2=1,3
      DO IB2=1,3
        N2=N2+1
        PINV(IB2,JB2,KB2)=BUFIF8(L,1+N2)
      ENDDO
      ENDDO
      ENDDO

      DO 3 I=1,4
      INB = DFAC2IJK(J,2,I,1)
      JNB = DFAC2IJK(J,2,I,2)
      KNB = DFAC2IJK(J,2,I,3)
      N = DFAC2NOD(J,I)

      IF (KD.EQ.1) THEN       ! B-block is X+
        IF (I.EQ.1) THEN
          DPRES(N,7)=P
        ELSEIF (I.EQ.2) THEN
          DPRES(N,6)=P
        ELSEIF (I.EQ.3) THEN
          DPRES(N,2)=P
        ELSEIF (I.EQ.4) THEN
          DPRES(N,3)=P
        ENDIF
        IF (INB*JNB*KNB.NE.0) THEN
          IF (I.EQ.1) THEN
            DPERMINV(N,:,:,7)=PINV(:,:,1)
          ELSEIF (I.EQ.2) THEN
            DPERMINV(N,:,:,6)=PINV(:,:,2)
          ELSEIF (I.EQ.3) THEN
            DPERMINV(N,:,:,2)=PINV(:,:,3)
          ELSEIF (I.EQ.4) THEN
            DPERMINV(N,:,:,3)=PINV(:,:,4)
          ENDIF
        ENDIF 

      ELSEIF (KD.EQ.4) THEN   ! B-block is X-
        IF (I.EQ.1) THEN
          DPRES(N,8)=P
        ELSEIF (I.EQ.2) THEN
          DPRES(N,5)=P
        ELSEIF (I.EQ.3) THEN
          DPRES(N,1)=P
        ELSEIF (I.EQ.4) THEN
          DPRES(N,4)=P
        ENDIF
        IF (INB*JNB*KNB.NE.0) THEN
          IF (I.EQ.1) THEN
            DPERMINV(N,:,:,8)=PINV(:,:,5)
          ELSEIF (I.EQ.2) THEN
            DPERMINV(N,:,:,5)=PINV(:,:,6)
          ELSEIF (I.EQ.3) THEN
            DPERMINV(N,:,:,1)=PINV(:,:,7)
          ELSEIF (I.EQ.4) THEN
            DPERMINV(N,:,:,4)=PINV(:,:,8)
          ENDIF
        ENDIF 

      ELSEIF (KD.EQ.2) THEN   ! B-block is Y+
        IF (I.EQ.1) THEN
          DPRES(N,7)=P
        ELSEIF (I.EQ.2) THEN
          DPRES(N,8)=P
        ELSEIF (I.EQ.3) THEN
          DPRES(N,4)=P
        ELSEIF (I.EQ.4) THEN
          DPRES(N,3)=P
        ENDIF
        IF (INB*JNB*KNB.NE.0) THEN
          IF (I.EQ.1) THEN
            DPERMINV(N,:,:,7)=PINV(:,:,1)
          ELSEIF (I.EQ.2) THEN
            DPERMINV(N,:,:,8)=PINV(:,:,5)
          ELSEIF (I.EQ.3) THEN
            DPERMINV(N,:,:,4)=PINV(:,:,8)
          ELSEIF (I.EQ.4) THEN
            DPERMINV(N,:,:,3)=PINV(:,:,4)
          ENDIF
        ENDIF 

      ELSEIF (KD.EQ.5) THEN   ! B-block is Y-
        IF (I.EQ.1) THEN
          DPRES(N,6)=P
        ELSEIF (I.EQ.2) THEN
          DPRES(N,5)=P
        ELSEIF (I.EQ.3) THEN
          DPRES(N,1)=P
        ELSEIF (I.EQ.4) THEN
          DPRES(N,2)=P
        ENDIF
        IF (INB*JNB*KNB.NE.0) THEN
          IF (I.EQ.1) THEN
            DPERMINV(N,:,:,6)=PINV(:,:,2)
          ELSEIF (I.EQ.2) THEN
            DPERMINV(N,:,:,5)=PINV(:,:,6)
          ELSEIF (I.EQ.3) THEN
            DPERMINV(N,:,:,1)=PINV(:,:,7)
          ELSEIF (I.EQ.4) THEN
            DPERMINV(N,:,:,2)=PINV(:,:,3)
          ENDIF
        ENDIF 

      ELSEIF (KD.EQ.3) THEN   ! B-block is Z+
        IF (I.EQ.1) THEN
          DPRES(N,7)=P
        ELSEIF (I.EQ.2) THEN
          DPRES(N,8)=P
        ELSEIF (I.EQ.3) THEN
          DPRES(N,5)=P
        ELSEIF (I.EQ.4) THEN
          DPRES(N,6)=P
        ENDIF
        IF (INB*JNB*KNB.NE.0) THEN
          IF (I.EQ.1) THEN
            DPERMINV(N,:,:,7)=PINV(:,:,1)
          ELSEIF (I.EQ.2) THEN
            DPERMINV(N,:,:,8)=PINV(:,:,5)
          ELSEIF (I.EQ.3) THEN
            DPERMINV(N,:,:,5)=PINV(:,:,6)
          ELSEIF (I.EQ.4) THEN
            DPERMINV(N,:,:,6)=PINV(:,:,2)
          ENDIF
        ENDIF 

      ELSEIF (KD.EQ.6) THEN   ! B-block is Z-
        IF (I.EQ.1) THEN
          DPRES(N,3)=P
        ELSEIF (I.EQ.2) THEN
          DPRES(N,4)=P
        ELSEIF (I.EQ.3) THEN
          DPRES(N,1)=P
        ELSEIF (I.EQ.4) THEN
          DPRES(N,2)=P
        ENDIF
        IF (INB*JNB*KNB.NE.0) THEN
          IF (I.EQ.1) THEN
            DPERMINV(N,:,:,3)=PINV(:,:,4)
          ELSEIF (I.EQ.2) THEN
            DPERMINV(N,:,:,4)=PINV(:,:,8)
          ELSEIF (I.EQ.3) THEN
            DPERMINV(N,:,:,1)=PINV(:,:,7)
          ELSEIF (I.EQ.4) THEN
            DPERMINV(N,:,:,2)=PINV(:,:,3)
          ENDIF
        ENDIF 

      ENDIF

    3 CONTINUE
    2 CONTINUE
    1 CONTINUE

      END SUBROUTINE TMPERMINVFILL6a

!*********************************************************************
      SUBROUTINE TMPRESFILL(IDIM,JDIM,KDIM,LDIM,IL1,IL2,
     &   JL1V,JL2V,KL1,KL2,KEYOUT,NBLK,PRES,NBUFDIM,BUFIF8)
!*********************************************************************
      USE dualmod
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'unitsex.h'
      INCLUDE 'sblkc.h'
      INCLUDE 'tfluidsc.h'
      INCLUDE 'layout.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK,NBUFDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 BUFIF8(NBUFDIM,*)
      REAL*8 PRES(IDIM,JDIM,KDIM)
      INTEGER I,K1,K2,K,J1,J2,J,L,KD,N,INB,JNB,KNB
      REAL*8 P

      IF (NIEBS(NBLK).EQ.0) RETURN

!  LOOP OVER A BLOCK INTERFACE ELEMENTS

      K1=IIEBS(NBLK)
      K2=K1+NIEBS(NBLK)-1
      DO 1 K=K1,K2
      J1=ICGES(K)
      J2=J1+NCGES(K)-1

!  LOOP OVER THE B BLOCK INTERFACE ELEMENTS

      DO 2 J=J1,J2
      L=LIBUF(J)
      KD=KDIRS(J)
      P=BUFIF8(L,1)

! LOOP OVER 4 NODES ON INTERFACE ELEMENT

      DO 3 I=1,4
      INB = DFAC2IJK(J,2,I,1)
      JNB = DFAC2IJK(J,2,I,2)
      KNB = DFAC2IJK(J,2,I,3)
      N = DFAC2NOD(J,I)

      IF (KD.EQ.1) THEN       ! B-block is X+
        IF (I.EQ.1) THEN
          DPRES(N,7)=P
        ELSEIF (I.EQ.2) THEN
          DPRES(N,6)=P
        ELSEIF (I.EQ.3) THEN
          DPRES(N,2)=P
        ELSEIF (I.EQ.4) THEN
          DPRES(N,3)=P
        ENDIF

      ELSEIF (KD.EQ.4) THEN   ! B-block is X-
        IF (I.EQ.1) THEN
          DPRES(N,8)=P
        ELSEIF (I.EQ.2) THEN
          DPRES(N,5)=P
        ELSEIF (I.EQ.3) THEN
          DPRES(N,1)=P
        ELSEIF (I.EQ.4) THEN
          DPRES(N,4)=P
        ENDIF

      ELSEIF (KD.EQ.2) THEN   ! B-block is Y+
        IF (I.EQ.1) THEN
          DPRES(N,7)=P
        ELSEIF (I.EQ.2) THEN
          DPRES(N,8)=P
        ELSEIF (I.EQ.3) THEN
          DPRES(N,4)=P
        ELSEIF (I.EQ.4) THEN
          DPRES(N,3)=P
        ENDIF

      ELSEIF (KD.EQ.5) THEN   ! B-block is Y-
        IF (I.EQ.1) THEN
          DPRES(N,6)=P
        ELSEIF (I.EQ.2) THEN
          DPRES(N,5)=P
        ELSEIF (I.EQ.3) THEN
          DPRES(N,1)=P
        ELSEIF (I.EQ.4) THEN
          DPRES(N,2)=P
        ENDIF

      ELSEIF (KD.EQ.3) THEN   ! B-block is Z+
        IF (I.EQ.1) THEN
          DPRES(N,7)=P
        ELSEIF (I.EQ.2) THEN
          DPRES(N,8)=P
        ELSEIF (I.EQ.3) THEN
          DPRES(N,5)=P
        ELSEIF (I.EQ.4) THEN
          DPRES(N,6)=P
        ENDIF

      ELSEIF (KD.EQ.6) THEN   ! B-block is Z-
        IF (I.EQ.1) THEN
          DPRES(N,3)=P
        ELSEIF (I.EQ.2) THEN
          DPRES(N,4)=P
        ELSEIF (I.EQ.3) THEN
          DPRES(N,1)=P
        ELSEIF (I.EQ.4) THEN
          DPRES(N,2)=P
        ENDIF

      ENDIF

    3 CONTINUE
    2 CONTINUE
    1 CONTINUE

      END SUBROUTINE TMPRESFILL

!*********************************************************************
      SUBROUTINE TMPERMINVFILL6b(IDIM,JDIM,KDIM,LDIM,IL1,IL2,
     &   JL1V,JL2V,KL1,KL2,KEYOUT,NBLK,PRES,NBUFDIM,BUFIF8)
!*********************************************************************
      USE dualmod
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'unitsex.h'
      INCLUDE 'sblkc.h'
      INCLUDE 'tfluidsc.h'
      INCLUDE 'layout.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK,NBUFDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  BUFIF8(NBUFDIM,*)
      REAL*8  PRES(IDIM,JDIM,KDIM)
      INTEGER I,K1,K2,K,J1,J2,J,L,KD,N,INB,JNB,KNB,V,JF,NF,NN
      REAL*8  P,RHO,LAMBDA
      INTEGER NORDER(4,6),NKD(6),INTFNOD(8),NODVOL(8),NFARR(4,6),
     &        NNARR(4,6)

! Conversion from local hex node to volume direction
      DATA NODVOL/7,6,2,3,8,5,1,4/

! Tangential hex node number of B-block, given face KD and intf ele nod 1-4
      DATA NORDER/1,2,3,4, 1,5,8,4, 1,5,6,2,
     &            5,6,7,8, 2,6,7,3, 4,8,7,3/

! Normal faces of an intf ele nod in the direction of KD
      DATA NFARR/2,6,7,10, 3,7,8,11, 9,10,11,12,
     &           4,5,8,12, 1,5,6,9,  1,2,3,4/

! Normal node of a normal face corresponding to NFARR array
      DATA NNARR/3,3,2,2, 3,4,3,2, 3,4,4,3,
     &           4,4,1,1, 4,2,1,1, 2,1,1,2/

! High to low face
      DATA NKD/4,5,6,1,2,3/

      IF (NIEBS(NBLK).EQ.0) RETURN

!  LOOP OVER A BLOCK INTERFACE ELEMENTS
      K1=IIEBS(NBLK)
      K2=K1+NIEBS(NBLK)-1
      DO 1 K=K1,K2
      J1=ICGES(K)
      J2=J1+NCGES(K)-1

!  SUM OVER THE B BLOCK INTERFACE ELEMENTS
      DO 2 J=J1,J2
      L=LIBUF(J)
      KD=KDIRS(J)

      P=BUFIF8(L,1)
      RHO=STFLDEN*EXP(FLCMP*P)
      LAMBDA=FLVIS/RHO

! STORE UP TO 8 NODES OF INTF ELEMENT
      INTFNOD(:)=0
      DO I=1,4
        N=DFAC2NOD(J,I)
        INTFNOD(NORDER(I,KD))=N
        INB = DFAC2IJK(J,2,I,1)
        JNB = DFAC2IJK(J,2,I,2)
        KNB = DFAC2IJK(J,2,I,3)
        IF (INB*JNB*KNB.NE.0) THEN
          DO JF=1,4
            NF=DFACENUM(N,NFARR(JF,KD))
            IF (NF.NE.0) GOTO 10
          ENDDO
          STOP 'NF not found'
 10       NN=NNARR(JF,KD)
          INTFNOD(NORDER(I,NKD(KD)))=DNFACE2NOD(NF-NIFACE,NN)
        ENDIF
      ENDDO

! LOOP OVER 8 POSSIBLE NODES OF INTF ELEMENT
      DO 3 I=1,8

      N = INTFNOD(I)
      IF (N.EQ.0) GOTO 3
      V = NODVOL(I)
      DPERMINV(N,:,:,V)=LAMBDA*DPERMINVINI(N,:,:,V)

    3 CONTINUE
    2 CONTINUE
    1 CONTINUE

      END SUBROUTINE TMPERMINVFILL6b

!*********************************************************************
      SUBROUTINE TMPERMCCFILL(IDIM,JDIM,KDIM,LDIM,IL1,IL2,
     &   JL1V,JL2V,KL1,KL2,KEYOUT,NBLK,NBUFDIM,BUFIF8)
!*********************************************************************
      USE dualmod
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'unitsex.h'
      INCLUDE 'sblkc.h'
      INCLUDE 'tfluidsc.h'
      INCLUDE 'layout.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK,NBUFDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  BUFIF8(NBUFDIM,*)
      INTEGER K1,K2,K,J1,J2,J,L

      IF (NIEBS(NBLK).EQ.0) RETURN

!  LOOP OVER A BLOCK INTERFACE ELEMENTS

      K1=IIEBS(NBLK)
      K2=K1+NIEBS(NBLK)-1
      DO 1 K=K1,K2
      J1=ICGES(K)
      J2=J1+NCGES(K)-1

!  SUM OVER THE B BLOCK INTERFACE ELEMENTS

      DO 2 J=J1,J2
      L=LIBUF(J)

      DPERMCC(J,1,1)=BUFIF8(L,1)
      DPERMCC(J,2,2)=BUFIF8(L,2)
      DPERMCC(J,3,3)=BUFIF8(L,3)
      DPERMCC(J,2,1)=BUFIF8(L,4)
      DPERMCC(J,3,1)=BUFIF8(L,5)
      DPERMCC(J,2,3)=BUFIF8(L,6)
      DPERMCC(J,1,2)=DPERMCC(J,2,1)
      DPERMCC(J,1,3)=DPERMCC(J,3,1)
      DPERMCC(J,3,2)=DPERMCC(J,2,3)

    2 CONTINUE
    1 CONTINUE

      END SUBROUTINE TMPERMCCFILL

!*********************************************************************
      SUBROUTINE TMPERMINVINI(IDIM,JDIM,KDIM,LDIM,IL1,IL2,
     &   JL1V,JL2V,KL1,KL2,KEYOUT,NBLK,MPFAQU)
!*********************************************************************
      USE dualmod
      IMPLICIT NONE
      INCLUDE 'layout.h'
      INCLUDE 'control.h'
      INCLUDE 'unitsex.h'
      INCLUDE 'sblkc.h'
      INCLUDE 'tfluidsc.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM),
     &        MPFAQU(IDIM,JDIM,KDIM)
      INTEGER I,II,K1,K2,K,J1,J2,J,L,KD,N,INB,JNB,KNB,V,JF,NF,NN,
     &        IA,JA,KA,MPQU,NUMNOD,IPIV(3),INFO
      REAL*8  PERMI(3,3),X(3,8),X2(3,8),A(3,3,8),CVCINV,detJ,
     &        HATX(3,8),JMAT(3,3,8),JMATC(3,3),TEMP(3,3)

      INTEGER NORDER(4,6),NKD(6),INTFNOD(8),NODVOL(8),NFARR(4,6),
     &        NNARR(4,6)
      REAL*8  HATREF(3,8)

! Conversion from local hex node to volume direction
      DATA NODVOL/7,6,2,3,8,5,1,4/

! Tangential hex node number of B-block, given face KD and intf ele nod 1-4
      DATA NORDER/1,2,3,4, 1,5,8,4, 1,5,6,2,
     &            5,6,7,8, 2,6,7,3, 4,8,7,3/

! Normal faces of an intf ele nod in the direction of KD
      DATA NFARR/2,6,7,10, 3,7,8,11, 9,10,11,12,
     &           4,5,8,12, 1,5,6,9,  1,2,3,4/

! Normal node of a normal face corresponding to NFARR array
      DATA NNARR/3,3,2,2, 3,4,3,2, 3,4,4,3,
     &           4,4,1,1, 4,2,1,1, 2,1,1,2/

! High to low face
      DATA NKD/4,5,6,1,2,3/

! Nodes of reference element
      DATA HATREF/0,0,0, 1,0,0, 1,1,0, 0,1,0,
     &            0,0,1, 1,0,1, 1,1,1, 0,1,1/

      IF (NIEBS(NBLK).EQ.0) RETURN
      CVCINV = 1.D0/CONV_FACTOR

!  LOOP OVER A BLOCK INTERFACE ELEMENTS
      K1=IIEBS(NBLK)
      K2=K1+NIEBS(NBLK)-1
      DO 1 K=K1,K2
      J1=ICGES(K)
      J2=J1+NCGES(K)-1

      IA=IJKS(1,K)
      JA=IJKS(2,K)
      KA=IJKS(3,K)
      MPQU = MPFAQU(IA,JA,KA)

!  SUM OVER THE B BLOCK INTERFACE ELEMENTS
      DO 2 J=J1,J2
      L=LIBUF(J)
      KD=KDIRS(J)

! STORE UP TO 8 NODES OF INTF ELEMENT
      INTFNOD(:)=0
      X(:,:)=0.D0
      DO I=1,4
        N=DFAC2NOD(J,I)
        II=NORDER(I,KD)
        INTFNOD(II)=N
        X(1:3,II)=CIFNOD(INTFNOD(II),1:3)
        INB = DFAC2IJK(J,2,I,1)
        JNB = DFAC2IJK(J,2,I,2)
        KNB = DFAC2IJK(J,2,I,3)
        IF (INB*JNB*KNB.NE.0) THEN
          DO JF=1,4
            NF=DFACENUM(N,NFARR(JF,KD))
            IF (NF.NE.0) GOTO 10
          ENDDO
          STOP 'NF not found'
 10       NN=NNARR(JF,KD)
          II=NORDER(I,NKD(KD))
          INTFNOD(II)=DNFACE2NOD(NF-NIFACE,NN)
          X(1:3,II)=CIFNOD(INTFNOD(II),1:3)
        ENDIF
      ENDDO

! STORE 8 NODES OF B-BLOCK HEX
      DO I=1,8
        X2(1:3,I)=CIFNOD(DFAC2HEX(J,I),1:3)
      ENDDO

      X=X2    ! Matching case

!      PERMI(:,:)=DPERMCC(J,:,:)
!      CALL InvMat(DPERMCC(J,:,:),PERMI)

      CALL GETEYE(PERMI,3,3)
      CALL DGESV(3,3,DPERMCC(J,:,:),3,IPIV,PERMI,3,INFO)
      IF (INFO.NE.0) THEN
         WRITE(*,*)'ERROR BLAS CANNOT INVERT PERM^(-1)'
         STOP
      ENDIF


! "DUAL" VERSION OF MAPTENSORQUAD (buildMPFA.df)
      IF (MPQU.EQ.1) THEN
        NUMNOD=0
        HATX(:,:) = HATREF(:,:)
        DO I=1,8
          IF (INTFNOD(I).GT.0) THEN
            NUMNOD=NUMNOD+1
!            CALL FINDREFCOORD(X,X2(:,I),HATX(:,I))
            CALL JACMAT(X,HATX(:,I),JMAT(:,:,I))
            CALL detMat(JMAT(:,:,I),detJ)
            IF (detJ.eq.0.d0) THEN
              WRITE(*,*)'NBLK,IA,JA,KA=',NBLK,IA,JA,KA
              WRITE(*,*)'I=',I
              WRITE(*,*)'X=',X
              WRITE(*,*)'X2=',X2
              WRITE(*,*)'HATX=',HATX(:,I)
              WRITE(*,*)'JMAT=',JMAT(:,:,I)
              STOP 'detJ is zero'
            ENDIF

!            CALL MatMul(PERMI(:,:),JMAT(:,:,I),TEMP)
            CALL DGEMM('N','N',3,3,3,1.D0,PERMI(:,:),3,JMAT(:,:,I),3,
     &        0.D0,TEMP,3)

!            CALL MatTranMul(JMAT(:,:,I),TEMP,A(:,:,I))
            CALL DGEMM('T','N',3,3,3,1.D0,JMAT(:,:,I),3,TEMP,3,
     &        0.D0,A(:,:,I),3)

            A(:,:,I)=A(:,:,I)/detJ
          ENDIF
        ENDDO

      ELSEIF (MPQU.EQ.2) THEN
        HATX(:,:) = HATREF(:,:)
        DO I=1,8
          CALL JACMAT(X,HATX(:,I),JMAT(:,:,I))
        ENDDO
        JMATC(:,:) = 0.D0
        DO I = 1,8
          JMATC(:,:) = JMATC(:,:) + JMAT(:,:,I)
        ENDDO
        JMATC(:,:) = 0.125D0*JMATC(:,:)   ! Won't work for non-matching
        CALL CenterJac(JMATC,JMAT)
        DO I=1,8
          CALL detMat(JMAT(:,:,I),detJ)

!          CALL MatMul(PERMI(:,:),JMAT(:,:,I),TEMP)
          CALL DGEMM('N','N',3,3,3,1.D0,PERMI(:,:),3,JMAT(:,:,I),3,
     &      0.D0,TEMP,3)

!          CALL MatTranMul(JMATC,TEMP,A(:,:,I))
          CALL DGEMM('T','N',3,3,3,1.D0,JMATC,3,TEMP,3,
     &      0.D0,A(:,:,I),3)

          A(:,:,I)=A(:,:,I)/detJ
        ENDDO
      ENDIF

      DPERMINVINI(J,:,:,:)=A(:,:,:)*CVCINV

    2 CONTINUE
    1 CONTINUE

      END SUBROUTINE TMPERMINVINI

!*********************************************************************
      SUBROUTINE TMCOORDLOAD(IDIM,JDIM,KDIM,LDIM,IL1,IL2,
     &   JL1V,JL2V,KL1,KL2,KEYOUT,NBLK,XC,YC,ZC,NBUFDIM,BUFIF8)
!*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'unitsex.h'
      INCLUDE 'sblkc.h'
      INCLUDE 'tfluidsc.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK,NBUFDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 BUFIF8(NBUFDIM,*)
      REAL*8 XC(IDIM+1,JDIM+1,KDIM+1),YC(IDIM+1,JDIM+1,KDIM+1),
     &       ZC(IDIM+1,JDIM+1,KDIM+1)
      INTEGER M,II1,II2,NBT,NMT,II,K,IA,JA,KA,KD

      IF (NPAI(NBLK).EQ.0) RETURN

      DO 90 M=1,NPAI(NBLK)
      II1=IESNDI(M,NBLK)
      II2=II1+NESNDI(M,NBLK)-1
      NBT=NBSRI(M,NBLK)
      NMT=FMODBLK(NBT)

      DO 61 II=II1,II2
      K=KFESR(II)
      IA=IJKS(1,K)
      JA=IJKS(2,K)
      KA=IJKS(3,K)
      KD=KDIRS(II)

      BUFIF8(II,1)=XC(IA,JA,KA)
      BUFIF8(II,2)=YC(IA,JA,KA)
      BUFIF8(II,3)=ZC(IA,JA,KA)
      BUFIF8(II,4)=XC(IA,JA+1,KA)
      BUFIF8(II,5)=YC(IA,JA+1,KA)
      BUFIF8(II,6)=ZC(IA,JA+1,KA)
      BUFIF8(II,7)=XC(IA,JA+1,KA+1)
      BUFIF8(II,8)=YC(IA,JA+1,KA+1)
      BUFIF8(II,9)=ZC(IA,JA+1,KA+1)
      BUFIF8(II,10)=XC(IA,JA,KA+1)
      BUFIF8(II,11)=YC(IA,JA,KA+1)
      BUFIF8(II,12)=ZC(IA,JA,KA+1)

      BUFIF8(II,13)=XC(IA+1,JA,KA)
      BUFIF8(II,14)=YC(IA+1,JA,KA)
      BUFIF8(II,15)=ZC(IA+1,JA,KA)
      BUFIF8(II,16)=XC(IA+1,JA+1,KA)
      BUFIF8(II,17)=YC(IA+1,JA+1,KA)
      BUFIF8(II,18)=ZC(IA+1,JA+1,KA)
      BUFIF8(II,19)=XC(IA+1,JA+1,KA+1)
      BUFIF8(II,20)=YC(IA+1,JA+1,KA+1)
      BUFIF8(II,21)=ZC(IA+1,JA+1,KA+1)
      BUFIF8(II,22)=XC(IA+1,JA,KA+1)
      BUFIF8(II,23)=YC(IA+1,JA,KA+1)
      BUFIF8(II,24)=ZC(IA+1,JA,KA+1)

   61 CONTINUE
   90 CONTINUE

      END SUBROUTINE TMCOORDLOAD

!*********************************************************************
      SUBROUTINE TMCOORDFILL5(IDIM,JDIM,KDIM,LDIM,IL1,IL2,
     &   JL1V,JL2V,KL1,KL2,KEYOUT,NBLK,XC,YC,ZC,NBUFDIM,BUFIF8)
!*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'unitsex.h'
      INCLUDE 'sblkc.h'
      INCLUDE 'tfluidsc.h'
      INCLUDE 'layout.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK,NBUFDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 BUFIF8(NBUFDIM,*)
      REAL*8 XC(IDIM+1,JDIM+1,KDIM+1),YC(IDIM+1,JDIM+1,KDIM+1),
     &       ZC(IDIM+1,JDIM+1,KDIM+1)
      INTEGER K1,K2,K,J1,J2,IA,JA,KA,J,NMS,L,KD

      IF (NIEBS(NBLK).EQ.0) RETURN

!  LOOP OVER A BLOCK INTERFACE ELEMENTS

      K1=IIEBS(NBLK)
      K2=K1+NIEBS(NBLK)-1
      DO 1 K=K1,K2
      J1=ICGES(K)
      J2=J1+NCGES(K)-1

      IA=IJKS(1,K)
      JA=IJKS(2,K)
      KA=IJKS(3,K)

!  SUM OVER THE B BLOCK INTERFACE ELEMENTS

      DO 2 J=J1,J2
      NMS=FMODBLK(JBLOCK(J))
      L=LIBUF(J)
      KD=KDIRS(J)

      IF (KD.EQ.1) THEN        ! x+ face
        XC(IA+2,JA,KA)=BUFIF8(L,13)
        YC(IA+2,JA,KA)=BUFIF8(L,14)
        ZC(IA+2,JA,KA)=BUFIF8(L,15)
        XC(IA+2,JA+1,KA)=BUFIF8(L,16)
        YC(IA+2,JA+1,KA)=BUFIF8(L,17)
        ZC(IA+2,JA+1,KA)=BUFIF8(L,18)
        XC(IA+2,JA+1,KA+1)=BUFIF8(L,19)
        YC(IA+2,JA+1,KA+1)=BUFIF8(L,20)
        ZC(IA+2,JA+1,KA+1)=BUFIF8(L,21)
        XC(IA+2,JA,KA+1)=BUFIF8(L,22)
        YC(IA+2,JA,KA+1)=BUFIF8(L,23)
        ZC(IA+2,JA,KA+1)=BUFIF8(L,24)
      ELSEIF (KD.EQ.4) THEN    ! x- face
        XC(IA-1,JA,KA)=BUFIF8(L,1)
        YC(IA-1,JA,KA)=BUFIF8(L,2)
        ZC(IA-1,JA,KA)=BUFIF8(L,3)
        XC(IA-1,JA+1,KA)=BUFIF8(L,4)
        YC(IA-1,JA+1,KA)=BUFIF8(L,5)
        ZC(IA-1,JA+1,KA)=BUFIF8(L,6)
        XC(IA-1,JA+1,KA+1)=BUFIF8(L,7)
        YC(IA-1,JA+1,KA+1)=BUFIF8(L,8)
        ZC(IA-1,JA+1,KA+1)=BUFIF8(L,9)
        XC(IA-1,JA,KA+1)=BUFIF8(L,10)
        YC(IA-1,JA,KA+1)=BUFIF8(L,11)
        ZC(IA-1,JA,KA+1)=BUFIF8(L,12)
      ELSEIF (KD.EQ.2) THEN    ! y+ face
        XC(IA,JA+2,KA)=BUFIF8(L,4)
        YC(IA,JA+2,KA)=BUFIF8(L,5)
        ZC(IA,JA+2,KA)=BUFIF8(L,6)
        XC(IA+1,JA+2,KA)=BUFIF8(L,16)
        YC(IA+1,JA+2,KA)=BUFIF8(L,17)
        ZC(IA+1,JA+2,KA)=BUFIF8(L,18)
        XC(IA+1,JA+2,KA+1)=BUFIF8(L,19)
        YC(IA+1,JA+2,KA+1)=BUFIF8(L,20)
        ZC(IA+1,JA+2,KA+1)=BUFIF8(L,21)
        XC(IA,JA+2,KA+1)=BUFIF8(L,7)
        YC(IA,JA+2,KA+1)=BUFIF8(L,8)
        ZC(IA,JA+2,KA+1)=BUFIF8(L,9)
      ELSEIF (KD.EQ.5) THEN    ! y- face
        XC(IA,JA-1,KA)=BUFIF8(L,1)
        YC(IA,JA-1,KA)=BUFIF8(L,2)
        ZC(IA,JA-1,KA)=BUFIF8(L,3)
        XC(IA+1,JA-1,KA)=BUFIF8(L,13)
        YC(IA+1,JA-1,KA)=BUFIF8(L,14)
        ZC(IA+1,JA-1,KA)=BUFIF8(L,15)
        XC(IA+1,JA-1,KA+1)=BUFIF8(L,22)
        YC(IA+1,JA-1,KA+1)=BUFIF8(L,23)
        ZC(IA+1,JA-1,KA+1)=BUFIF8(L,24)
        XC(IA,JA-1,KA+1)=BUFIF8(L,10)
        YC(IA,JA-1,KA+1)=BUFIF8(L,11)
        ZC(IA,JA-1,KA+1)=BUFIF8(L,12)
      ELSEIF (KD.EQ.3) THEN    ! z+ face
        XC(IA,JA,KA+2)=BUFIF8(L,10)
        YC(IA,JA,KA+2)=BUFIF8(L,11)
        ZC(IA,JA,KA+2)=BUFIF8(L,12)
        XC(IA+1,JA,KA+2)=BUFIF8(L,22)
        YC(IA+1,JA,KA+2)=BUFIF8(L,23)
        ZC(IA+1,JA,KA+2)=BUFIF8(L,24)
        XC(IA+1,JA+1,KA+2)=BUFIF8(L,19)
        YC(IA+1,JA+1,KA+2)=BUFIF8(L,20)
        ZC(IA+1,JA+1,KA+2)=BUFIF8(L,21)
        XC(IA,JA+1,KA+2)=BUFIF8(L,7)
        YC(IA,JA+1,KA+2)=BUFIF8(L,8)
        ZC(IA,JA+1,KA+2)=BUFIF8(L,9)
      ELSEIF (KD.EQ.6) THEN    ! z- face
        XC(IA,JA,KA-1)=BUFIF8(L,1)
        YC(IA,JA,KA-1)=BUFIF8(L,2)
        ZC(IA,JA,KA-1)=BUFIF8(L,3)
        XC(IA+1,JA,KA-1)=BUFIF8(L,13)
        YC(IA+1,JA,KA-1)=BUFIF8(L,14)
        ZC(IA+1,JA,KA-1)=BUFIF8(L,15)
        XC(IA+1,JA+1,KA-1)=BUFIF8(L,16)
        YC(IA+1,JA+1,KA-1)=BUFIF8(L,17)
        ZC(IA+1,JA+1,KA-1)=BUFIF8(L,18)
        XC(IA,JA+1,KA-1)=BUFIF8(L,4)
        YC(IA,JA+1,KA-1)=BUFIF8(L,5)
        ZC(IA,JA+1,KA-1)=BUFIF8(L,6)
      ENDIF

    2 CONTINUE
    1 CONTINUE

      END SUBROUTINE TMCOORDFILL5

!*********************************************************************
      SUBROUTINE TMCOORDFILL6(IDIM,JDIM,KDIM,LDIM,IL1,IL2,
     &   JL1V,JL2V,KL1,KL2,KEYOUT,NBLK,NBUFDIM,BUFIF8)
!*********************************************************************
      USE dualmod
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'unitsex.h'
      INCLUDE 'sblkc.h'
      INCLUDE 'tfluidsc.h'
      INCLUDE 'layout.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK,NBUFDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 BUFIF8(NBUFDIM,*)
      INTEGER K1,K2,K,J1,J2,J,L,IBUF,IV,ID,INOD
      REAL*8 X,Y,Z

      IF (NIEBS(NBLK).EQ.0) RETURN

C  LOOP OVER A BLOCK INTERFACE ELEMENTS

      K1=IIEBS(NBLK)
      K2=K1+NIEBS(NBLK)-1
      DO 1 K=K1,K2
      J1=ICGES(K)
      J2=J1+NCGES(K)-1

C  SUM OVER THE B BLOCK INTERFACE ELEMENTS

      DO 2 J=J1,J2
      L=LIBUF(J)

      IBUF=0
      DO IV=1,8
        IBUF=IBUF+1; X=BUFIF8(L,IBUF)
        IBUF=IBUF+1; Y=BUFIF8(L,IBUF)
        IBUF=IBUF+1; Z=BUFIF8(L,IBUF)
        CALL ADD_IFNOD(X,Y,Z,INOD)
        DFAC2HEX(J,IV)=INOD
      ENDDO

    2 CONTINUE
    1 CONTINUE

      END SUBROUTINE TMCOORDFILL6

!*********************************************************************
      SUBROUTINE TMFAKEDIAGONALCOMM_4BLOCK()
!*********************************************************************
      IMPLICIT NONE
      INCLUDE 'tarydat.h'
      INCLUDE 'mpfaary.h'
      INCLUDE 'layout.h'
      INCLUDE 'sblkc.h'
      INTEGER IW(3)
      EXTERNAL TMFAKEDIAG1,TMFAKEDIAG2

      WRITE(*,*)'In TMFAKEDIAGONALCOMM_4BLOCK'
      IF (NUMBLK.NE.4) THEN
        WRITE(*,*)'Error: NUMBLK must be 4'
        STOP 1
      ENDIF

      IW(1)=2
      IW(2)=N_PRES
      IW(3)=N_PERMINV
      CALL CALLWORK(TMFAKEDIAG1,IW)
      CALL CALLWORK(TMFAKEDIAG2,IW)

      END

!*********************************************************************
      SUBROUTINE TMFAKEDIAG1(IDIM,JDIM,KDIM,LDIM,IL1,IL2,
     &   JL1V,JL2V,KL1,KL2,KEYOUT,NBLK,PRES,PERMINV)
!*********************************************************************
      IMPLICIT NONE
      INCLUDE 'layout.h'
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 PERMINV(3,3,8,IDIM,JDIM,KDIM)
      REAL*8 PRES(IDIM,JDIM,KDIM)

      REAL*8 PRESBUF(4),PERMBUF(4,3,3,8)
      COMMON/FAKEDIAG/PRESBUF,PERMBUF

      INTEGER ILO,IHI,JLO,JHI,K

      ILO=ILAY+1
      IHI=IDIM-ILAY
      JLO=JLAY+1
      JHI=JDIM-JLAY
      K=3

      IF (NBLK.EQ.1) THEN
        PRESBUF(1)=PRES(IHI,JHI,K)
        PERMBUF(1,:,:,:)=PERMINV(:,:,:,IHI,JHI,K)
      ELSEIF (NBLK.EQ.2) THEN
        PRESBUF(2)=PRES(IHI,JLO,K)
        PERMBUF(2,:,:,:)=PERMINV(:,:,:,IHI,JLO,K)
      ELSEIF (NBLK.EQ.3) THEN
        PRESBUF(3)=PRES(ILO,JHI,K)
        PERMBUF(3,:,:,:)=PERMINV(:,:,:,ILO,JHI,K)
      ELSEIF (NBLK.EQ.4) THEN
        PRESBUF(4)=PRES(ILO,JLO,K)
        PERMBUF(4,:,:,:)=PERMINV(:,:,:,ILO,JLO,K)
      ENDIF

      END SUBROUTINE TMFAKEDIAG1

!*********************************************************************
      SUBROUTINE TMFAKEDIAG2(IDIM,JDIM,KDIM,LDIM,IL1,IL2,
     &   JL1V,JL2V,KL1,KL2,KEYOUT,NBLK,PRES,PERMINV)
!*********************************************************************
      IMPLICIT NONE
      INCLUDE 'layout.h'
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 PERMINV(3,3,8,IDIM,JDIM,KDIM)
      REAL*8 PRES(IDIM,JDIM,KDIM)

      REAL*8 PRESBUF(4),PERMBUF(4,3,3,8)
      COMMON/FAKEDIAG/PRESBUF,PERMBUF

      INTEGER ILO,IHI,JLO,JHI,K

      ILO=ILAY+1
      IHI=IDIM-ILAY
      JLO=JLAY+1
      JHI=JDIM-JLAY
      K=3

      IF (NBLK.EQ.1) THEN
        PRES(IHI+1,JHI+1,K)=PRESBUF(4)
        PERMINV(:,:,:,IHI+1,JHI+1,K)=PERMBUF(4,:,:,:)
      ELSEIF (NBLK.EQ.2) THEN
        PRES(IHI+1,JLO-1,K)=PRESBUF(3)
        PERMINV(:,:,:,IHI+1,JLO-1,K)=PERMBUF(3,:,:,:)
      ELSEIF (NBLK.EQ.3) THEN
        PRES(ILO-1,JHI+1,K)=PRESBUF(2)
        PERMINV(:,:,:,ILO-1,JHI+1,K)=PERMBUF(2,:,:,:)
      ELSEIF (NBLK.EQ.4) THEN
        PRES(ILO-1,JLO-1,K)=PRESBUF(1)
        PERMINV(:,:,:,ILO-1,JLO-1,K)=PERMBUF(1,:,:,:)
      ENDIF

      END SUBROUTINE TMFAKEDIAG2

!*********************************************************************
      SUBROUTINE TMSENDPROPS(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &   KL1,KL2,KEYOUT,NBLK,VOLPROP,FACEPROP,NBUFDIM,BUFIF8)
!*********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'sblkc.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK,NBUFDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      INTEGER VOLPROP(IDIM+1,JDIM+1,KDIM+1,8),
     &        FACEPROP(IDIM+1,JDIM+1,KDIM+1,12)
      REAL*8  BUFIF8(NBUFDIM,*)
      INTEGER M,II1,II2,NBT,NMT,II,K,INB,JNB,KNB,KD,INOD,IBUF,IP,
     &        IB,JB,KB

! Offset for cell center to 8 hex vertices
      INTEGER OFFSET1(3,8)
      DATA OFFSET1/0,0,0, 1,0,0, 1,1,0, 0,1,0,
     &             0,0,1, 1,0,1, 1,1,1, 0,1,1/

      IF (NPAI(NBLK).EQ.0) RETURN

      DO 90 M=1,NPAI(NBLK)
      II1=IESNDI(M,NBLK)
      II2=II1+NESNDI(M,NBLK)-1
      NBT=NBSRI(M,NBLK)
      NMT=FMODBLK(NBT)

      DO 61 II=II1,II2
      K=KFESR(II)
      KD=KDIRS(II)

! Set up 8 nodes on given B-block face
!   Note 1: The ordering of the 4 nodes is due to POLLYSORT in blksin.f
!   Note 2: KD is the face direction relative to the receiving block
      IB=IJKT(1,II)
      JB=IJKT(2,II)
      KB=IJKT(3,II)

! Fill buffer with VOLPROP and FACEPROP
      IBUF=0
      DO INOD = 1,8
        INB=IB+OFFSET1(1,INOD)
        JNB=JB+OFFSET1(2,INOD)
        KNB=KB+OFFSET1(3,INOD)
        DO IP = 1,8
          IBUF=IBUF+1
          BUFIF8(II,IBUF)=VOLPROP(INB,JNB,KNB,IP)
        ENDDO
        DO IP = 1,12
          IBUF=IBUF+1
          BUFIF8(II,IBUF)=FACEPROP(INB,JNB,KNB,IP)
        ENDDO
      ENDDO

! debug
!      IF ((NBLK.EQ.2).AND.(IB.EQ.2).AND.(JB.EQ.3).AND.(KB.EQ.3)) THEN
!        WRITE(*,*)'In TMSENDPROPS'
!        WRITE(*,'(a,i1,a,3i3,a,i3)')'NBLK=',NBLK,'   IB,JB,KB=',
!     &    IB,JB,KB,'   II=',II
!        IBUF=0
!        DO INOD = 1,4
!          INB=NOD(1,INOD)
!          JNB=NOD(2,INOD)
!          KNB=NOD(3,INOD)
!          WRITE(*,'(a,i1,a,3i3)')'Node ',INOD,
!     &      ':  INB,JNB,KNB=',INB,JNB,KNB
!          DO IP = 1,8
!            IBUF=IBUF+1
!            WRITE(*,'(3(a,i3))')'VOLPROP(',IP,')=BUFIF8(',IBUF,')=',
!     &        INT(BUFIF8(II,IBUF))
!          ENDDO
!          DO IP = 1,12
!            IBUF=IBUF+1
!            WRITE(*,'(3(a,i3))')'FACEPROP(',IP,')=BUFIF8(',IBUF,')=',
!     &        INT(BUFIF8(II,IBUF))
!          ENDDO
!        ENDDO
!      ENDIF

   61 CONTINUE
   90 CONTINUE

      END SUBROUTINE TMSENDPROPS
