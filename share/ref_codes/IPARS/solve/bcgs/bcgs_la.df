C BCGS_LA.F -- BCGS SOLVER LIN.ALGEBRA ROUTINES
C
C ROUTINES IN THIS FILE:
C
C     REAL*8 FUNCTION BCGS_DDOT(X,Y)
C     REAL*8 FUNCTION BCGS_DDOT2(X,Y)
C     SUBROUTINE BCGS_DSCAL(ALFA,X)
C     SUBROUTINE BCGS_DSCAL2(ALFA,X)
C     SUBROUTINE BCGS_DAXPY(ALFA,X,Y)
C     SUBROUTINE BCGS_DAXPY2(ALFA,X,Y)
C     SUBROUTINE BCGS_DCOPY(X,Y)
C     SUBROUTINE BCGS_DSWEEP(X,Y)
C     SUBROUTINE BCGS_DSWEEP2(X,Y)
C     SUBROUTINE BCGS_DZERO(X)
C     SUBROUTINE BCGS_CVG(IFLAG,X)
C     SUBROUTINE BCGS_CVG2(IFLAG,X)
C     SUBROUTINE BCGS_MATVEC(X,Y,AB,AD)
C     SUBROUTINE BCGS_MATVEC2(X,Y,AB,AD)
C     SUBROUTINE BCGS_PREVEC()
C     SUBROUTINE BCGS_PREVEC2()
C
C CODE HISTORY:

C  YURI VASSILEVSKI 01/17/2002
C  SUNIL G. THOMAS 3-6/1-31/2008 MODS TO ACCOMODATE FLOW COUPLED TO 
C                                REACTIVE TRANSPORT AS WELL AS ISOLATED 
C                                SCALAR PDE SOLVES
C                  9-10/--/2009  SWITCHED TO CALLS TO NEW MGWORK ROUTINES 
C                                IN PREVEC TO AVOID PROCESSOR DEADLOCK IN 
C                                PARALLEL MULTI-BLOCK RUNS
C***********************************************************************
      REAL*8 FUNCTION BCGS_DDOT(N_X,N_Y)
C***********************************************************************
C Call a work routine to calculate dinrm=x.y
C
C N_X = ARRAY NUMBER OF ONE GRID ELEMENT ARRAY       (INPUT,INTEGER)
C N_Y = ARRAY NUMBER OF THE OTHER GRID ELEMENT ARRAY (INPUT,INTEGER)
C***********************************************************************   
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'bcgs_la.h'

      INTEGER N_X(*),N_Y(*),MCNT

      INTEGER IGDDOT(3)
      EXTERNAL IG_DDOT
 
      MCNT=0
      DINRM(1)=0.D0
      DINRM(2)=0.D0
      DINRM(3)=0.D0
      DO 1 I=1,$MXMOD
       IF(I.EQ.$TRMODEL) CYCLE
       IF (I.EQ.$PEMODEL) CYCLE
       IF (MODELON(I)) THEN
        MCNT=MCNT+1
        IGDDOT(1)=2
        IGDDOT(2)=N_X(I)
        IGDDOT(3)=N_Y(I)
        MODACT=I
        CALL CALLWORK(IG_DDOT,IGDDOT)
       ENDIF
    1 CONTINUE
      MODACT=0
      IF(MCNT.EQ.0) THEN
         WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_DDOT!'
      ENDIF

$MANY      CALL SUMIT(3,DINRM)
$MANY      CALL SPREAD8(3,DINRM)
      BCGS_DDOT=DINRM(1)

      RETURN
      END

C***********************************************************************
      REAL*8 FUNCTION BCGS_DDOT2(N_X,N_Y)
C***********************************************************************
C Call a work routine to calculate dinrm=x.y for non-model dependent 
C single unknowns (such as temperature)
C
C N_X = ARRAY NUMBER OF ONE GRID ELEMENT ARRAY       (INPUT,INTEGER)
C N_Y = ARRAY NUMBER OF THE OTHER GRID ELEMENT ARRAY (INPUT,INTEGER)
C***********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'bcgs_la.h'

      INTEGER N_X,N_Y

      INTEGER IGDDOT(3)
      EXTERNAL IG_DDOT2

      DINRM(1)=0.D0
      DINRM(2)=0.D0
      DINRM(3)=0.D0
      IGDDOT(1)=2
      IGDDOT(2)=N_X
      IGDDOT(3)=N_Y
      CALL CALLWORK(IG_DDOT2,IGDDOT)

$MANY      CALL SUMIT(3,DINRM)
$MANY      CALL SPREAD8(3,DINRM)
      BCGS_DDOT2=DINRM(1)

      RETURN
      END

C***********************************************************************
      SUBROUTINE BCGS_DSCAL(ALFA,N_X)
C***********************************************************************
C Call work a routine to perform x=x*alfa
C 
C N_X = ARRAY NUMBER OF ONE GRID ELEMENT ARRAY    (INPUT/OUTPUT,INTEGER)
C ALFA = SCALAR                                    (INPUT,REAL*8)
C***********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'bcgs_la.h'

      INTEGER N_X(*)
      REAL*8 ALFA

      INTEGER IGDSCAL(2),MCNT
      EXTERNAL IG_DSCAL

      MCNT=0
      ALPHA=ALFA
      DO 1 I=1,$MXMOD
       IF(I.EQ.$TRMODEL) CYCLE
       IF (I.EQ.$PEMODEL) CYCLE
       IF (MODELON(I)) THEN
        MCNT=MCNT+1
        IGDSCAL(1)=1
        IGDSCAL(2)=N_X(I)
        MODACT=I
        CALL CALLWORK(IG_DSCAL,IGDSCAL)
       ENDIF
    1 CONTINUE
      MODACT=0
      IF(MCNT.EQ.0) THEN
         WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_DSCAL!'
      ENDIF

      END

C***********************************************************************
      SUBROUTINE BCGS_DSCAL2(ALFA,N_X)
C***********************************************************************
C Call work a routine to perform x=x*alfa
C     
C N_X = ARRAY NUMBER OF ONE GRID ELEMENT ARRAY    (INPUT/OUTPUT,INTEGER)
C ALFA = SCALAR                                    (INPUT,REAL*8)
C***********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'bcgs_la.h'

      INTEGER N_X
      REAL*8 ALFA

      INTEGER IGDSCAL(2)
      EXTERNAL IG_DSCAL2

      ALPHA=ALFA
      IGDSCAL(1)=1
      IGDSCAL(2)=N_X
      CALL CALLWORK(IG_DSCAL2,IGDSCAL)

      RETURN
      END

C***********************************************************************
      SUBROUTINE BCGS_DSHOW(N_X,N_Y)
C***********************************************************************
C Call work a routine to show x,y 
C N_X = ARRAY NUMBER OF ONE GRID ELEMENT ARRAY    (INPUT,INTEGER)
C***********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'

      INTEGER N_X(*),N_Y(*),MCNT

      INTEGER IGDSHOW(3)
      EXTERNAL IG_DSHOW

      MCNT=0
      ALPHA=ALFA
      DO 1 I=1,$MXMOD
       IF(I.EQ.$TRMODEL) CYCLE
       IF (I.EQ.$PEMODEL) CYCLE
       IF (MODELON(I)) THEN
        MCNT=MCNT+1
        IGDSHOW(1)=2
        IGDSHOW(2)=N_X(I)
        IGDSHOW(3)=N_Y(I)
        MODACT=I
        CALL CALLWORK(IG_DSHOW,IGDSHOW)
       ENDIF
    1 CONTINUE
      MODACT=0
      IF(MCNT.EQ.0) THEN
         WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_DSHOW!'
      ENDIF

      END


C***********************************************************************
      SUBROUTINE BCGS_DAXPY (ALFA,N_X,N_Y)
C***********************************************************************
C Call work a routine to performs y=y+alfa*x

C N_X = ARRAY NUMBER OF ONE GRID ELEMENT ARRAY        (INPUT,INTEGER)
C N_Y = ARRAY NUMBER OF THE OTHER GRID ELEMENT ARRRAY (OUTPUT,INTEGER)
C ALFA = SCALAR                                     (INPUT,REAL*8)
C***********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'bcgs_la.h'
   
      INTEGER N_X(*),N_Y(*)
      REAL*8 ALFA

      INTEGER IGDAXPY(3),MCNT
      EXTERNAL IG_DAXPY

      MCNT=0
      ALPHA=ALFA
      DO 1 I=1,$MXMOD
       IF(I.EQ.$TRMODEL) CYCLE
       IF (I.EQ.$PEMODEL) CYCLE
       IF (MODELON(I)) THEN
        MCNT=MCNT+1
        IGDAXPY(1)=2
        IGDAXPY(2)=N_X(I)
        IGDAXPY(3)=N_Y(I)
        MODACT=I
        CALL CALLWORK(IG_DAXPY,IGDAXPY)
       ENDIF
    1 CONTINUE
      MODACT=0
      IF(MCNT.EQ.0) THEN
         WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_DAXPY!'
      ENDIF

      END

C***********************************************************************
      SUBROUTINE BCGS_DAXPY2 (ALFA,N_X,N_Y)
C***********************************************************************
C Call work a routine to performs y=y+alfa*x

C N_X = ARRAY NUMBER OF ONE GRID ELEMENT ARRAY        (INPUT,INTEGER)
C N_Y = ARRAY NUMBER OF THE OTHER GRID ELEMENT ARRRAY (OUTPUT,INTEGER)
C ALFA = SCALAR                                     (INPUT,REAL*8)
C***********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'bcgs_la.h'

      INTEGER N_X,N_Y
      REAL*8 ALFA

      INTEGER IGDAXPY(3)
      EXTERNAL IG_DAXPY2

      ALPHA=ALFA
      IGDAXPY(1)=2
      IGDAXPY(2)=N_X
      IGDAXPY(3)=N_Y
      CALL CALLWORK(IG_DAXPY2,IGDAXPY)
      END 
  
C***********************************************************************
      SUBROUTINE BCGS_DCOPY(N_X,N_Y)
C***********************************************************************
C Call a work routine to copy x to y
C
C N_X = ARRAY NUMBER FOR x (INPUT, INTEGER)
C N_Y = ARRAY NUMBER FOR y (OUTPUT, INTEGER)
C***********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'

      INTEGER N_X(*),N_Y(*),MCNT
      
      INTEGER IGDCOPY(3)
      EXTERNAL IG_DCOPY

      MCNT=0
      DO 1 I=1,$MXMOD
       IF(I.EQ.$TRMODEL) CYCLE
       IF (I.EQ.$PEMODEL) CYCLE
       IF (MODELON(I)) THEN
        MCNT=MCNT+1
        IGDCOPY(1)=2
        IGDCOPY(2)=N_X(I)
        IGDCOPY(3)=N_Y(I)
        MODACT=I
        CALL CALLWORK(IG_DCOPY,IGDCOPY)
       ENDIF
    1 CONTINUE
      MODACT=0
      IF(MCNT.EQ.0) THEN
         WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_DCOPY!'
      ENDIF

      END
C***********************************************************************
      SUBROUTINE BCGS_DZERO(N_X)
C***********************************************************************
C Call a work routine to zero x
C
C N_X = ARRAY NUMBER FOR x (INPUT/OUTPUT, INTEGER)
C***********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'

      INTEGER N_X(*),MCNT
      
      INTEGER IGDZERO(2)
      EXTERNAL DUNK0

      MCNT=0
      DO 1 I=1,$MXMOD
      IF(I.EQ.$TRMODEL) CYCLE
      IF (I.EQ.$PEMODEL) CYCLE
       IF (MODELON(I)) THEN
        MCNT=MCNT+1
        IGDZERO(1)=1
        IGDZERO(2)=N_X(I)
        MODACT=I
        CALL CALLWORK(DUNK0,IGDZERO)
       ENDIF
    1 CONTINUE
      MODACT=0
      IF(MCNT.EQ.0) THEN
         WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_DZERO!'
      ENDIF

      END
C***********************************************************************
      SUBROUTINE BCGS_DSWEEP(N_X,N_Y)
C***********************************************************************
C Call a work routine to sweep x <-> y
C
C N_X = ARRAY NUMBER FOR x (INPUT/OUTPUT, INTEGER)
C N_Y = ARRAY NUMBER FOR y (INPUT/OUTPUT, INTEGER)
C***********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'

      INTEGER N_X(*),N_Y(*),MCNT
      
      INTEGER IGDSWEEP(3)

      EXTERNAL IG_DSWEEP

      MCNT=0
      DO 1 I=1,$MXMOD
       IF(I.EQ.$TRMODEL) CYCLE
       IF (I.EQ.$PEMODEL) CYCLE
       IF (MODELON(I)) THEN
        MCNT=MCNT+1
        IGDSWEEP(1)=2
        IGDSWEEP(2)=N_X(I)
        IGDSWEEP(3)=N_Y(I)
        MODACT=I
        CALL CALLWORK(IG_DSWEEP,IGDSWEEP)
       ENDIF
    1 CONTINUE
      MODACT=0
      IF(MCNT.EQ.0) THEN
         WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_DSWEEP!'
      ENDIF

      END

C***********************************************************************
      SUBROUTINE BCGS_DSWEEP2(N_X,N_Y)
C***********************************************************************
C Call a work routine to sweep x <-> y
C     
C N_X = ARRAY NUMBER FOR x (INPUT/OUTPUT, INTEGER)
C N_Y = ARRAY NUMBER FOR y (INPUT/OUTPUT, INTEGER)
C***********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'

      INTEGER N_X,N_Y

      INTEGER IGDSWEEP(3)
      EXTERNAL IG_DSWEEP2

      IGDSWEEP(1)=2
      IGDSWEEP(2)=N_X
      IGDSWEEP(3)=N_Y
      CALL CALLWORK(IG_DSWEEP2,IGDSWEEP)

      END


C***********************************************************************
      SUBROUTINE  BCGS_CVG(IFLAG,N_X)
C***********************************************************************
C Call a work routine to check mulgrd-convergence test of x
C
C N_X = ARRAY NUMBER OF ONE GRID ELEMENT ARRAY       (INPUT,INTEGER)
C IFLAG = 0   CONVERGENCE IS NOT ACHIEVED            (OUTPUT,INTEGER)
C IFLAG = 1   CONVERGENCE IS ACHIEVED            
C***********************************************************************   
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'mulgrdc.h'

      INTEGER IFLAG,N_X(*)

      INTEGER IGMEAS(2),MCNT
      EXTERNAL IG_MEAS

      REAL*8 REDM,REDT,DUB
 
      MCNT=0
      DO 1 I=1,$MXMOD
       IF(I.EQ.$TRMODEL) CYCLE
       IF (I.EQ.$PEMODEL) CYCLE
       IF (MODELON(I)) THEN
        MCNT=MCNT+1
        DO 2 L=1,MXNUMEQS
        RMAX(I,L)=0.D0
    2   RTOT(I,L)=0.D0
        IGMEAS(1)=1
        IGMEAS(2)=N_X(I)
        MODACT=I
        CALL CALLWORK(IG_MEAS,IGMEAS)
       ENDIF
    1 CONTINUE
      MODACT=0
      IF(MCNT.EQ.0) THEN
         WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_CVG!'
      ENDIF

$MANY      CALL TIMON(4)
$MANY      CALL MAXIT($MXMOD*$MXNUMEQ,RMAX)
$MANY      CALL SUMIT($MXMOD*$MXNUMEQ,RTOT)
$MANY      CALL TIMOFF(4)

      IF (MYPRC.EQ.0.AND.ITMG.GT.0) THEN

         MCNT=0
         REDM=0.D0
         REDT=0.D0
         DO 6 I=1,$MXMOD
         IF(I.EQ.$TRMODEL) CYCLE
         IF (I.EQ.$PEMODEL) CYCLE
         IF (MODELON(I)) THEN
            MCNT=MCNT+1
            DO 7 J=1,MODEQS(I)
            IF (RMAX0(I,J).NE.0.D0) THEN
               DUB=ABS(RMAX(I,J)/RMAX0(I,J))
               IF (REDM.EQ.0.D0.OR.DUB.LT.REDM) REDM=DUB
            ENDIF
            IF (RTOT0(I,J).NE.0.D0) THEN
               DUB=ABS(RTOT(I,J)/RTOT0(I,J))
               IF (REDT.EQ.0.D0.OR.DUB.LT.REDT) REDT=DUB
            ENDIF
    7       CONTINUE
         ENDIF
    6    CONTINUE
         IF(MCNT.EQ.0) THEN
            WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_CVG!'
         ENDIF

         IF (REDM.LT.TOLMG .AND. REDT.LT.2d0*TOLMG) THEN
            IFLAG=1
         ELSE
            IFLAG=0
         END IF 
cdbg        write(*,*)'MG measures: max=',REDM,' tot=',REDT,' tol=',TOLMG
      ENDIF

$MANY      IF (NUMPRC.GT.1) CALL SPREAD(1,IFLAG)

      RETURN
      END

C***********************************************************************
      SUBROUTINE  BCGS_CVG2(IFLAG,N_X)
C***********************************************************************
C Call a work routine to check mulgrd-convergence test of x for single 
C unknowns (non-model dependent) such as temperature. Assumes just one 
C unknown per element. 
C     
C N_X = ARRAY NUMBER OF ONE GRID ELEMENT ARRAY       (INPUT,INTEGER)
C IFLAG = 0   CONVERGENCE IS NOT ACHIEVED            (OUTPUT,INTEGER)
C IFLAG = 1   CONVERGENCE IS ACHIEVED  
C***********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'mulgrdc.h'

      INTEGER IFLAG,N_X

      INTEGER IGMEAS(2)
      EXTERNAL IG_MEAS2

      REAL*8 REDM,REDT,DUB

      RMAX12=0.D0
      RTOT12=0.D0
      IGMEAS(1)=1
      IGMEAS(2)=N_X
      CALL CALLWORK(IG_MEAS2,IGMEAS)

$MANY      CALL TIMON(4)
$MANY      CALL MAXIT(1,RMAX12)
$MANY      CALL SUMIT(1,RTOT12)
$MANY      CALL TIMOFF(4)

      IF (MYPRC.EQ.0.AND.ITMG.GT.0) THEN

         REDM=0.D0
         REDT=0.D0
         IF (RMAX02.NE.0.D0) THEN
            DUB=ABS(RMAX12/RMAX02)
            IF (REDM.EQ.0.D0.OR.DUB.LT.REDM) REDM=DUB
         ENDIF
         IF (RTOT02.NE.0.D0) THEN
            DUB=ABS(RTOT12/RTOT02)
            IF (REDT.EQ.0.D0.OR.DUB.LT.REDT) REDT=DUB
         ENDIF

         IF (REDM.LT.TOLMG .AND. REDT.LT.2d0*TOLMG) THEN
            IFLAG=1
         ELSE
            IFLAG=0
         END IF
      ENDIF

$MANY      IF (NUMPRC.GT.1) CALL SPREAD(1,IFLAG)

      RETURN
      END

C***********************************************************************
      SUBROUTINE BCGS_MATVEC(ALFA,N_A,N_X,N_Y)
C***********************************************************************
C Call a work routine to compute y=alfa*Ax 
C
C N_A  = ARRAY NUMBER FOR matrix ARRAY                (INPUT, INTEGER)
C N_X  = ARRAY NUMBER FOR x ARRAY                     (INPUT, INTEGER)
C N_Y  = ARRAY NUMBER FOR y ARRAY                     (OUTPUT, INTEGER)
C***********************************************************************
$POWER      INCLUDE 'msjunk.h' 
      INCLUDE 'control.h'
      INCLUDE 'bcgs_la.h'
   
      INTEGER N_X(*),N_Y(*),N_A(*),MCNT
      REAL*8 ALFA
 
      INTEGER IGMATVEC(4)
      EXTERNAL IG_MATVEC, WELLSCHUR

      MCNT=0
      ALPHA=ALFA

C  UPDATE 3D UNKNOWNS IN THE COMMUNICATION LAYER

$DUAL      CALL MDUAL(NERR)

$MANY      CALL TIMON(4)
$MANY      DO 15 I=1,$MXMOD
$MANY      IF(I.EQ.$TRMODEL) CYCLE
$MANY      IF (I.EQ.$PEMODEL) CYCLE
$MANY      IF (MODELON(I)) THEN
$MANY         MCNT=MCNT+1
$MANY         MODACT=I
$MANY         CALL UPDATE(N_X(I),1)
$MANY      ENDIF
$MANY   15 CONTINUE
$MANY      MODACT=0
$MANY      IF(MCNT.EQ.0) THEN
$MANY         WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_MATVEC!'
$MANY      ENDIF
$MANY      CALL TIMOFF(4)

      MCNT=0
      IGMATVEC(1)=3
      DO 1 I=1,$MXMOD
       IF(I.EQ.$TRMODEL) CYCLE
       IF (I.EQ.$PEMODEL) CYCLE
       IF (MODELON(I)) THEN
        MCNT=MCNT+1
        IGMATVEC(2)=N_A(I)
        IGMATVEC(3)=N_X(I)
        IGMATVEC(4)=N_Y(I)
        MODACT=I
        CALL CALLWORK(IG_MATVEC,IGMATVEC)
       ENDIF
    1 CONTINUE
      MODACT=0
      IF(MCNT.EQ.0) THEN
         WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_MATVEC!'
      ENDIF

$MANY      MCNT=0
$MANY      CALL TIMON(4)
$MANY      DO 16 I=1,$MXMOD
$MANY      IF(I.EQ.$TRMODEL) CYCLE
$MANY      IF (I.EQ.$PEMODEL) CYCLE
$MANY      IF (MODELON(I)) THEN
$MANY         MCNT=MCNT+1
$MANY         MODACT=I
$MANY         CALL UPDATE(N_Y(I),1)
$MANY      ENDIF
$MANY   16 CONTINUE
$MANY      MODACT=0
$MANY      IF(MCNT.EQ.0) THEN
$MANY         WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_MATVEC!'
$MANY      ENDIF
$MANY      CALL TIMOFF(4)

      MCNT=0
      IGMATVEC(1)=2
      DO 2 I=1,$MXMOD
      IF(I.EQ.$TRMODEL) CYCLE
      IF (I.EQ.$PEMODEL) CYCLE
      IF (MODELON(I)) THEN
         MCNT=MCNT+1
         IGMATVEC(2)=N_X(I)
         IGMATVEC(3)=N_Y(I)
         MODACT=I
         CALL CALLWORK(WELLSCHUR,IGMATVEC)
      ENDIF
   2  CONTINUE
      MODACT=0
      IF(MCNT.EQ.0) THEN
         WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_MATVEC!'
      ENDIF

      END 

C***********************************************************************
      SUBROUTINE BCGS_MATVEC2(ALFA,N_A,N_X,N_Y)
C***********************************************************************
C Call a work routine to compute y=alfa*Ax
C
C N_A  = ARRAY NUMBER FOR matrix ARRAY                (INPUT, INTEGER)
C N_X  = ARRAY NUMBER FOR x ARRAY                     (INPUT, INTEGER)
C N_Y  = ARRAY NUMBER FOR y ARRAY                     (OUTPUT, INTEGER)
C***********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'bcgs_la.h'

      INTEGER N_X,N_Y,N_A
      REAL*8 ALFA

      INTEGER IGMATVEC(4)
      EXTERNAL IG_MATVEC2

      ALPHA=ALFA

C  UPDATE 3D UNKNOWNS IN THE COMMUNICATION LAYER

$DUAL      CALL MDUAL2(N_X,NERR)

$MANY      CALL TIMON(4)
$MANY      CALL UPDATE(N_X,1)
$MANY      CALL TIMOFF(4)

      IGMATVEC(1)=3
      IGMATVEC(2)=N_A
      IGMATVEC(3)=N_X
      IGMATVEC(4)=N_Y
      CALL CALLWORK(IG_MATVEC2,IGMATVEC)

$MANY      CALL TIMON(4)
$MANY      CALL UPDATE(N_Y,1)
$MANY      CALL TIMOFF(4)

      RETURN
      END
      
C***********************************************************************
      SUBROUTINE BCGS_PREVEC()
C***********************************************************************
C Call a work routine to compute DUNK=B^{-1}RESID
C
C  IPRECOND = TYPE OF MG PRECONDITIONER IN BCGSTAB:
C     1 ==> LSOR SWEEP
C     2 ==> LSOR SWEEP + WHEELER AGGRAGATION MG
C     3 ==> LSOR SWEEP + NLSORC LSOR SWEEPS ON THE 3D AGGREGATED MATRIX
C     4 ==> LSOR SWEEP + WHEELER AGGRAGATION MG +
C           NLSORC LSOR SWEEPS ON THE 3D AGGREGATED MATRIX
C***********************************************************************
$POWER      INCLUDE 'msjunk.h' 
      INCLUDE 'control.h'
      INCLUDE 'blkary.h'

      INCLUDE 'mulgrdc.h'


      INTEGER IARG(4),MCNT

      EXTERNAL DUNK0,COURSEN1,MGBUG3,COURSEN2,MGDIRECT,REFINE2,REFINE1
      EXTERNAL MGBUG1,MGBUGC,MGBUGR,PSOR0
      EXTERNAL COURSEN1Y,COURSEN2Y,REFINE2Y,REFINE1Y
$MANY      EXTERNAL R8SMCOF2,R8SMRES2,R8MATCH2,R8MATCH3,R8UPDMG2
$MANY      EXTERNAL R8SMCOFY,R8SMRESY,R8MATCHY,R8UPDMGY

      ROBUST=.FALSE.

C  CLEAR 3D UNKNOWNS
      MCNT=0
      IARG(1)=1
      DO 1 I=1,$MXMOD
      IF(I.EQ.$TRMODEL) CYCLE
      IF (I.EQ.$PEMODEL) CYCLE
      IF (MODELON(I)) THEN
         MCNT=MCNT+1
         IARG(2)=N_DUNKV(I)
         MODACT=I
         CALL CALLWORK(DUNK0,IARG)
      ENDIF
    1 CONTINUE
      MODACT=0
      IF(MCNT.EQ.0) THEN
         WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_PREVEC!'
      ENDIF

C  APPLY LSOR TO 3D GRID
      CALL LSORMG()

C  RETURN IF ONLY LSOR HAS TO BE DONE
      IF (IPRECOND.EQ.1) RETURN

C  JUMP TO 3D AGGREGATION IF  WHEELER MG IS NOT APPLIED
      IF (IPRECOND.EQ.3) GOTO 10

C WHEELER MG (2D AGGREGATION)
C  COURSEN FROM 3D TO 1ST 2D GRID
      MCNT=0
      DO 3 I=1,$MXMOD
      IF(I.EQ.$TRMODEL) CYCLE
      IF (I.EQ.$PEMODEL) CYCLE
      IF (MODELON(I)) THEN
         MCNT=MCNT+1
         MODACT=I
         CALL MGWORK1(COURSEN1,N_COFV(I),N_DUNKV(I),N_RESIDV(I))
      ENDIF
    3 CONTINUE
      MODACT=0
      IF(MCNT.EQ.0) THEN
         WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_PREVEC!'
      ENDIF

C  DOWN LOOP OVER MULTIGRID LEVELS
      DO 5 LEVEL=1,MGLEV
C  SUM 2D COEFFICIENTS and RESIDS IN THE COMMUNICATION LAYER
$MANY      MCNT=0
$MANY      CALL TIMON(4)
$MANY      DO 15 I=1,$MXMOD
$MANY      IF(I.EQ.$TRMODEL) CYCLE
$MANY      IF (I.EQ.$PEMODEL) CYCLE
$MANY      IF (MODELON(I)) THEN
$MANY         MCNT=MCNT+1
$MANY         MODACT=I
C$MANY         IF (NEW_COF) CALL MGWORK3(R8SMCOF2,LEVEL)
C$MANY         CALL MGWORK3(R8SMRES2,LEVEL)
$MANY         IF (NEW_COF) CALL MGWORK3T(R8SMCOF2,LEVEL)
$MANY         CALL MGWORK3T(R8SMRES2,LEVEL)
$MANY      ENDIF
$MANY   15 CONTINUE
$MANY      MODACT=0
$MANY      IF(MCNT.EQ.0) THEN
$MANY         WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_PREVEC!'
$MANY      ENDIF
$MANY      CALL TIMOFF(4)
C   CLEAR UNKNOWNS GOING DOWN
       MCNT=0
       DO 4 I=1,$MXMOD
       IF(I.EQ.$TRMODEL) CYCLE
       IF (I.EQ.$PEMODEL) CYCLE
       IF (MODELON(I)) THEN
         MCNT=MCNT+1
         MODACT=I
         CALL MGWORK3(PSOR0,LEVEL)
       ENDIF
    4  CONTINUE
       MODACT=0
       IF(MCNT.EQ.0) THEN
          WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_PREVEC!'
       ENDIF
C   APPLY PSOR GOING DOWN
       CALL PSORMG (1)
C   COURSEN FROM ONE 2D GRID TO THE NEXT
       CALL MGWORK2(COURSEN2,LEVEL)
    5 CONTINUE

C  SUM 2D COEFFICIENTS and RESIDS IN THE COMMUNICATION LAYER
$MANY      CALL TIMON(4)
$MANY      MCNT=0
$MANY      DO 25 I=1,$MXMOD
$MANY      IF(I.EQ.$TRMODEL) CYCLE
$MANY      IF (I.EQ.$PEMODEL) CYCLE
$MANY      IF (MODELON(I)) THEN
$MANY         MCNT=MCNT+1
$MANY         MODACT=I
C$MANY         IF (NEW_COF) CALL MGWORK3(R8SMCOF2,MGLEV+1)
C$MANY         CALL MGWORK3(R8SMRES2,MGLEV+1)
$MANY         IF (NEW_COF) CALL MGWORK3T(R8SMCOF2,MGLEV+1)
$MANY         CALL MGWORK3T(R8SMRES2,MGLEV+1)
$MANY      ENDIF
$MANY   25 CONTINUE
$MANY      MODACT=0
$MANY      IF(MCNT.EQ.0) THEN
$MANY         WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_PREVEC!'
$MANY      ENDIF
$MANY      CALL TIMOFF(4)

C  APPLY PSORMG (1) INSTEAD OF DIRECT SOLUTION TO COURSEST GRID
      MCNT=0
      LEVEL=MGLEV+1
      DO I=1,$MXMOD
      IF(I.EQ.$TRMODEL) CYCLE
      IF (I.EQ.$PEMODEL) CYCLE
      IF (MODELON(I)) THEN
         MCNT=MCNT+1
         MODACT=I
         CALL MGWORK3(PSOR0,LEVEL)
      ENDIF
      END DO
      MODACT=0
      IF(MCNT.EQ.0) THEN
         WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_PREVEC!'
      ENDIF
      CALL PSORMG (1)

C  UP LOOP OVER MULTIGRID LEVELS
      DO 6 LEVEL=MGLEV,1,-1
C   REFINE FROM ONE 2D GRID TO THE NEXT
       CALL MGWORK2(REFINE2,LEVEL)
C  MATCH 2D VALUES IN THE COMMUNICATION LAYER:
C  IF KEYMGC=-1 and KEYMGF=1 THEN UPDATE THE VALUE
C  AT KEYMGF from THE NEIGHBORING PROCESSOR
$MANY      CALL TIMON(4)
$MANY      MCNT=0
$MANY      DO 35 I=1,$MXMOD
$MANY      IF(I.EQ.$TRMODEL) CYCLE
$MANY      IF (I.EQ.$PEMODEL) CYCLE
$MANY      IF (MODELON(I)) THEN
$MANY         MCNT=MCNT+1
$MANY         MODACT=I
C$MANY         CALL MGWORK2(R8MATCH2,LEVEL)
C$MANY         CALL MGWORK3(R8UPDMG2,LEVEL)
$MANY         CALL MGWORK2T(R8MATCH2,LEVEL)
$MANY         CALL MGWORK3T(R8UPDMG2,LEVEL)
$MANY      ENDIF
$MANY   35 CONTINUE
$MANY      MODACT=0
$MANY      IF(MCNT.EQ.0) THEN
$MANY         WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_PREVEC!'
$MANY      ENDIF
$MANY      CALL TIMOFF(4)
C   APPLY PSOR GOING UP
       CALL PSORMG (2)
    6 CONTINUE

C  REFINE FROM COURSEST 2D GRID TO 3D GRID
      MCNT=0
      DO 7 I=1,$MXMOD
      IF(I.EQ.$TRMODEL) CYCLE
      IF (I.EQ.$PEMODEL) CYCLE
      IF (MODELON(I)) THEN
         MCNT=MCNT+1
         MODACT=I
         CALL MGWORK1(REFINE1,N_COFV(I),N_DUNKV(I),N_RESIDV(I))
      ENDIF
    7 CONTINUE
      MODACT=0
      IF(MCNT.EQ.0) THEN
         WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_PREVEC!'
      ENDIF

C  MATCH 3D VALUES IN THE COMMUNICATION LAYER:
C  IF KEYMG=-1 and KEYOUT=1 THEN UPDATE THE VALUE N_DUNKV
C  AT KEYOUT from THE NEIGHBORING PROCESSOR
$MANY      CALL TIMON(4)
$MANY      MCNT=0
$MANY      DO 45 I=1,$MXMOD
$MANY      IF(I.EQ.$TRMODEL) CYCLE
$MANY      IF (I.EQ.$PEMODEL) CYCLE
$MANY      IF (MODELON(I)) THEN
$MANY         MCNT=MCNT+1
$MANY         MODACT=I
C$MANY         CALL MGWORK1(R8MATCH3,N_COFV(I),N_DUNKV(I),N_RESIDV(I))
$MANY         CALL MGWORK1T(R8MATCH3,N_COFV(I),N_DUNKV(I),N_RESIDV(I))
$MANY         CALL UPDATE(N_DUNKV(I),2)
$MANY      ENDIF
$MANY   45 CONTINUE
$MANY      MODACT=0
$MANY      IF(MCNT.EQ.0) THEN
$MANY         WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_PREVEC!'
$MANY      ENDIF
$MANY      CALL TIMOFF(4)

C END WHEELER MG (2D AGGREGATION)

C  RETURN IF ONLY LSOR + WHEELER MG HAVE TO BE DONE
      IF (IPRECOND.EQ.2) RETURN

C LSOR FOR 3D AGGREGATION - STARTING POINT
 10   CONTINUE    

C  COURSEN FROM FINE TO 1ST COARSER GRID
      MCNT=0
      DO 11 I=1,$MXMOD
      IF(I.EQ.$TRMODEL) CYCLE
      IF (I.EQ.$PEMODEL) CYCLE
      IF (MODELON(I)) THEN
         MCNT=MCNT+1
         MODACT=I
         CALL MGWORK1Y(COURSEN1Y,N_COFV(I),N_DUNKV(I),N_RESIDV(I))
      ENDIF
   11 CONTINUE
      MODACT=0
      IF(MCNT.EQ.0) THEN
         WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_PREVEC!'
      ENDIF

C  DOWN LOOP OVER REMAINING 3D AGGREGATION LEVELS
      DO 12 LEVEL=1,NLV3DA-1 
C  SUM 3D COEFFICIENTS and RESIDS IN THE COMMUNICATION LAYER
$MANY      CALL TIMON(4)
$MANY      MCNT=0
$MANY      DO 26 I=1,$MXMOD
$MANY      IF(I.EQ.$TRMODEL) CYCLE
$MANY      IF (I.EQ.$PEMODEL) CYCLE
$MANY      IF (MODELON(I)) THEN
$MANY         MCNT=MCNT+1
$MANY         MODACT=I
C$MANY         IF (NEW_COF) CALL MGWORK3Y(R8SMCOFY,LEVEL)
C$MANY         CALL MGWORK3Y(R8SMRESY,LEVEL)
$MANY         IF (NEW_COF) CALL MGWORK3YT(R8SMCOFY,LEVEL)
$MANY         CALL MGWORK3YT(R8SMRESY,LEVEL)
$MANY      ENDIF
$MANY   26 CONTINUE
$MANY      MODACT=0
$MANY      IF(MCNT.EQ.0) THEN
$MANY         WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_PREVEC!'
$MANY      ENDIF
$MANY      CALL TIMOFF(4)
C   COARSEN FROM ONE COARSER GRID TO THE NEXT
       CALL MGWORK2Y(COURSEN2Y,LEVEL)
   12 CONTINUE

C  SUM 3D COEFFICIENTS and RESIDS IN THE COMMUNICATION LAYER
$MANY      CALL TIMON(4)
$MANY      MCNT=0
$MANY      DO 27 I=1,$MXMOD
$MANY      IF(I.EQ.$TRMODEL) CYCLE
$MANY      IF (I.EQ.$PEMODEL) CYCLE
$MANY      IF (MODELON(I)) THEN
$MANY         MCNT=MCNT+1
$MANY         MODACT=I
C$MANY         IF (NEW_COF) CALL MGWORK3Y(R8SMCOFY,NLV3DA)
C$MANY         CALL MGWORK3Y(R8SMRESY,NLV3DA)
$MANY         IF (NEW_COF) CALL MGWORK3YT(R8SMCOFY,NLV3DA)
$MANY         CALL MGWORK3YT(R8SMRESY,NLV3DA)
$MANY      ENDIF
$MANY   27 CONTINUE
$MANY      MODACT=0
$MANY      IF(MCNT.EQ.0) THEN
$MANY         WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_PREVEC!'
$MANY      ENDIF
$MANY      CALL TIMOFF(4)

C  APPLY NLSORC LSOR-SWEEPS  TO COARSEST GRID FOR 3D AGGREGATION
      CALL LSOR3DA(NLV3DA)

C  UP LOOP OVER 3D AGGREGATION  LEVELS - DISAGGREGATE
      DO 13 LEVEL=NLV3DA-1,1,-1
C   REFINE FROM ONE FINE GRID TO THE COARSER
       CALL MGWORK2Y(REFINE2Y,LEVEL)
C  MATCH 3D VALUES IN THE COMMUNICATION LAYER:
C  IF KEYMGC=-1 and KEYMGF=1 THEN UPDATE THE VALUE
C  AT KEYMGF from THE NEIGHBORING PROCESSOR
$MANY      CALL TIMON(4)
$MANY      MCNT=0
$MANY      DO 36 I=1,$MXMOD
$MANY      IF(I.EQ.$TRMODEL) CYCLE
$MANY      IF (I.EQ.$PEMODEL) CYCLE
$MANY      IF (MODELON(I)) THEN
$MANY         MCNT=MCNT+1
$MANY         MODACT=I
C$MANY         CALL MGWORK2Y(R8MATCHY,LEVEL)
C$MANY         CALL MGWORK3Y(R8UPDMGY,LEVEL)
$MANY         CALL MGWORK2YT(R8MATCHY,LEVEL)
$MANY         CALL MGWORK3YT(R8UPDMGY,LEVEL)
$MANY      ENDIF
$MANY   36 CONTINUE
$MANY      MODACT=0
$MANY      IF(MCNT.EQ.0) THEN
$MANY         WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_PREVEC!'
$MANY      ENDIF
$MANY      CALL TIMOFF(4)
   13 CONTINUE

C  REFINE FROM THE 1ST 3D AGGREGATION  LEVEL TO 3D GRID
      MCNT=0
      DO 14 I=1,$MXMOD
       IF(I.EQ.$TRMODEL) CYCLE
       IF (I.EQ.$PEMODEL) CYCLE
       IF (MODELON(I)) THEN
         MCNT=MCNT+1
         MODACT=I
         CALL MGWORK1Y(REFINE1Y,N_COFV(I),N_DUNKV(I),N_RESIDV(I))
       ENDIF
   14 CONTINUE
      MODACT=0
      IF(MCNT.EQ.0) THEN
         WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_PREVEC!'
      ENDIF
C  MATCH 3D VALUES IN THE COMMUNICATION LAYER:
C  IF KEYMG=-1 and KEYOUT=1 THEN UPDATE THE VALUE N_DUNKV
C  AT KEYOUT from THE NEIGHBORING PROCESSOR
$MANY      CALL TIMON(4)
$MANY      MCNT=0
$MANY      DO 37 I=1,$MXMOD
$MANY      IF(I.EQ.$TRMODEL) CYCLE
$MANY      IF (I.EQ.$PEMODEL) CYCLE
$MANY      IF (MODELON(I)) THEN
$MANY         MCNT=MCNT+1
$MANY         MODACT=I
C$MANY         CALL MGWORK1(R8MATCH3,N_COFV(I),N_DUNKV(I),N_RESIDV(I))
$MANY         CALL MGWORK1T(R8MATCH3,N_COFV(I),N_DUNKV(I),N_RESIDV(I))
$MANY         CALL UPDATE(N_DUNKV(I),2)
$MANY      ENDIF
$MANY   37 CONTINUE
$MANY      MODACT=0
$MANY      IF(MCNT.EQ.0) THEN
$MANY         WRITE(0,*) 'WARNING: NO MODELS ACTIVE IN BCGS_PREVEC!'
$MANY      ENDIF
$MANY      CALL TIMOFF(4)

C END FOR 3D AGGREGATION     

      RETURN
      END


C***********************************************************************
      SUBROUTINE BCGS_PREVEC2(NMAT,NRHS,NSOL)
C***********************************************************************
C Call a work routine to compute DUNK=B^{-1}RESID for single unknowns
C that are model independent such as temperature (CAUTION: Some of the 
C MGWORK and other callwork type of routines called use NUMEQS(NBLK) 
C which needs to be adjusted by making copies of those functions. But 
C currently since T is hooked up to compositional model, it is ok. 
C
C  IPRECOND = TYPE OF MG PRECONDITIONER IN BCGSTAB:
C     1 ==> LSOR SWEEP
C     2 ==> LSOR SWEEP + WHEELER AGGRAGATION MG
C     3 ==> LSOR SWEEP + NLSORC LSOR SWEEPS ON THE 3D AGGREGATED MATRIX
C     4 ==> LSOR SWEEP + WHEELER AGGRAGATION MG +
C           NLSORC LSOR SWEEPS ON THE 3D AGGREGATED MATRIX
C***********************************************************************
$POWER      INCLUDE 'msjunk.h' 
      INCLUDE 'control.h'
      INCLUDE 'blkary.h'
      INCLUDE 'mulgrdc.h'

      INTEGER NMAT,NSOL,NRHS,IARG(4)

      EXTERNAL DUNK0,COURSEN1,MGBUG3,COURSEN2,MGDIRECT,REFINE2,REFINE1
      EXTERNAL MGBUG1,MGBUGC,MGBUGR,PSOR0
      EXTERNAL COURSEN1Y,COURSEN2Y,REFINE2Y,REFINE1Y
$MANY      EXTERNAL R8SMCOF2,R8SMRES2,R8MATCH2,R8MATCH3,R8UPDMG2
$MANY      EXTERNAL R8SMCOFY,R8SMRESY,R8MATCHY,R8UPDMGY

      MODACT=MODEL
$POROE      IF (MODELON($PEMODEL)) MODACT=FLOWMODEL
      ROBUST=.FALSE.

C  CLEAR 3D UNKNOWNS
      IARG(1)=1
      IARG(2)=NSOL
      CALL CALLWORK(DUNK0,IARG)

C  APPLY LSOR TO 3D GRID
      CALL LSORMG2(NMAT,NRHS,NSOL)

C  RETURN IF ONLY LSOR HAS TO BE DONE
      IF (IPRECOND.EQ.1) RETURN

C  JUMP TO 3D AGGREGATION IF  WHEELER MG IS NOT APPLIED
      IF (IPRECOND.EQ.3) GOTO 10

C WHEELER MG (2D AGGREGATION)
C  COURSEN FROM 3D TO 1ST 2D GRID
      CALL MGWORK1(COURSEN1,NMAT,NSOL,NRHS)

C  DOWN LOOP OVER MULTIGRID LEVELS
      DO 5 LEVEL=1,MGLEV
C  SUM 2D COEFFICIENTS and RESIDS IN THE COMMUNICATION LAYER
$MANY      CALL TIMON(4)
C$MANY      IF (NEW_COF) CALL MGWORK3(R8SMCOF2,LEVEL)
C$MANY      CALL MGWORK3(R8SMRES2,LEVEL)
$MANY      IF (NEW_COF) CALL MGWORK3T(R8SMCOF2,LEVEL)
$MANY      CALL MGWORK3T(R8SMRES2,LEVEL)
$MANY      CALL TIMOFF(4)
C   CLEAR UNKNOWNS GOING DOWN
       CALL MGWORK3(PSOR0,LEVEL)
C   APPLY PSOR GOING DOWN
       CALL PSORMG2 (1)
C   COURSEN FROM ONE 2D GRID TO THE NEXT
       CALL MGWORK2(COURSEN2,LEVEL)
    5 CONTINUE

C  SUM 2D COEFFICIENTS and RESIDS IN THE COMMUNICATION LAYER
$MANY      CALL TIMON(4)
C$MANY      IF (NEW_COF) CALL MGWORK3(R8SMCOF2,MGLEV+1)
C$MANY      CALL MGWORK3(R8SMRES2,MGLEV+1)
$MANY      IF (NEW_COF) CALL MGWORK3T(R8SMCOF2,MGLEV+1)
$MANY      CALL MGWORK3T(R8SMRES2,MGLEV+1)
$MANY      CALL TIMOFF(4)

C  APPLY PSORMG (1) INSTEAD OF DIRECT SOLUTION TO COURSEST GRID
      LEVEL=MGLEV+1
      CALL MGWORK3(PSOR0,LEVEL)
      CALL PSORMG2 (1)

C  UP LOOP OVER MULTIGRID LEVELS
      DO 6 LEVEL=MGLEV,1,-1
C   REFINE FROM ONE 2D GRID TO THE NEXT
       CALL MGWORK2(REFINE2,LEVEL)
C  MATCH 2D VALUES IN THE COMMUNICATION LAYER:
C  IF KEYMGC=-1 and KEYMGF=1 THEN UPDATE THE VALUE
C  AT KEYMGF from THE NEIGHBORING PROCESSOR
$MANY      CALL TIMON(4)
C$MANY      CALL MGWORK2(R8MATCH2,LEVEL)
C$MANY      CALL MGWORK3(R8UPDMG2,LEVEL)
$MANY      CALL MGWORK2T(R8MATCH2,LEVEL)
$MANY      CALL MGWORK3T(R8UPDMG2,LEVEL)
$MANY      CALL TIMOFF(4)
C   APPLY PSOR GOING UP
       CALL PSORMG2 (2)
    6 CONTINUE

C  REFINE FROM COURSEST 2D GRID TO 3D GRID
      CALL MGWORK1(REFINE1,NMAT,NSOL,NRHS)

C  MATCH 3D VALUES IN THE COMMUNICATION LAYER:
C  IF KEYMG=-1 and KEYOUT=1 THEN UPDATE THE VALUE NSOL
C  AT KEYOUT from THE NEIGHBORING PROCESSOR
$MANY      CALL TIMON(4)
C$MANY      CALL MGWORK1(R8MATCH3,NMAT,NSOL,NRHS)
$MANY      CALL MGWORK1T(R8MATCH3,NMAT,NSOL,NRHS)
$MANY      CALL UPDATE(NSOL,2)
$MANY      CALL TIMOFF(4)

C END WHEELER MG (2D AGGREGATION)

C  RETURN IF ONLY LSOR + WHEELER MG HAVE TO BE DONE
      IF (IPRECOND.EQ.2) RETURN

C LSOR FOR 3D AGGREGATION - STARTING POINT
 10   CONTINUE

C  COURSEN FROM FINE TO 1ST COARSER GRID
      CALL MGWORK1Y(COURSEN1Y,NMAT,NSOL,NRHS)

C  DOWN LOOP OVER REMAINING 3D AGGREGATION LEVELS
      DO 12 LEVEL=1,NLV3DA-1
C  SUM 3D COEFFICIENTS and RESIDS IN THE COMMUNICATION LAYER
$MANY      CALL TIMON(4)
C$MANY      IF (NEW_COF) CALL MGWORK3Y(R8SMCOFY,LEVEL)
C$MANY      CALL MGWORK3Y(R8SMRESY,LEVEL)
$MANY      IF (NEW_COF) CALL MGWORK3YT(R8SMCOFY,LEVEL)
$MANY      CALL MGWORK3YT(R8SMRESY,LEVEL)
$MANY      CALL TIMOFF(4)
C   COARSEN FROM ONE COARSER GRID TO THE NEXT
       CALL MGWORK2Y(COURSEN2Y,LEVEL)
   12 CONTINUE

C  SUM 3D COEFFICIENTS and RESIDS IN THE COMMUNICATION LAYER
$MANY      CALL TIMON(4)
C$MANY      IF (NEW_COF) CALL MGWORK3Y(R8SMCOFY,NLV3DA)
C$MANY      CALL MGWORK3Y(R8SMRESY,NLV3DA)
$MANY      IF (NEW_COF) CALL MGWORK3YT(R8SMCOFY,NLV3DA)
$MANY      CALL MGWORK3YT(R8SMRESY,NLV3DA)
$MANY      CALL TIMOFF(4)

C  APPLY NLSORC LSOR-SWEEPS  TO COARSEST GRID FOR 3D AGGREGATION
      CALL LSOR3DA2(NSOL,NLV3DA)

C  UP LOOP OVER 3D AGGREGATION  LEVELS - DISAGGREGATE
      DO 13 LEVEL=NLV3DA-1,1,-1
C   REFINE FROM ONE FINE GRID TO THE COARSER
       CALL MGWORK2Y(REFINE2Y,LEVEL)
C  MATCH 3D VALUES IN THE COMMUNICATION LAYER:
C  IF KEYMGC=-1 and KEYMGF=1 THEN UPDATE THE VALUE
C  AT KEYMGF from THE NEIGHBORING PROCESSOR
$MANY      CALL TIMON(4)
C$MANY      CALL MGWORK2Y(R8MATCHY,LEVEL)
C$MANY      CALL MGWORK3Y(R8UPDMGY,LEVEL)
$MANY      CALL MGWORK2YT(R8MATCHY,LEVEL)
$MANY      CALL MGWORK3YT(R8UPDMGY,LEVEL)
$MANY      CALL TIMOFF(4)
   13 CONTINUE

C  REFINE FROM THE 1ST 3D AGGREGATION  LEVEL TO 3D GRID
       CALL MGWORK1Y(REFINE1Y,NMAT,NSOL,NRHS)

C  MATCH 3D VALUES IN THE COMMUNICATION LAYER:
C  IF KEYMG=-1 and KEYOUT=1 THEN UPDATE THE VALUE NSOL
C  AT KEYOUT from THE NEIGHBORING PROCESSOR
$MANY      CALL TIMON(4)
C$MANY      CALL MGWORK1(R8MATCH3,NMAT,NSOL,NRHS)
$MANY      CALL MGWORK1T(R8MATCH3,NMAT,NSOL,NRHS)
$MANY      CALL UPDATE(NSOL,2)
$MANY      CALL TIMOFF(4)

C END FOR 3D AGGREGATION
      MODACT=0

      RETURN
      END
