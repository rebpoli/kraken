// mulgrdm.c - Memory Management Routines in C for multigrid

// HISTORY:

// JOHN WHEELER       4/21/00   ORIGINAL BETA CODE
// YURI VASSSILEVSKI  3/10/02   INCLUDE EXTERNAL LAYERS
// SUNIL G THOMAS    10/23/09   CHANGED LONG TO INT FOR 64-BIT 
//                              COMPATIBILITY, PROVIDED EXTRA 
//                              C-INTERFACE FUNCTIONS TO RESOLVE 
//                              DEADLOCK IN PARALLEL MULTI-BLOCK 
//                              RUNS (EVMFEM)

// NOTES:

//   1)  ERROR NUMBERS 461-500 ARE RESERVED FOR MEMORY MANAGEMENT

// DATA

#include "memory.h"

#define MAXLEV   $MXMGLV    // Maximum number of multigrid levels
#define MAXLEVP  $MXMGLV+1  // Maximum number of multigrid levels + 1

int    jdimg[MAXLEVP][MAXBLK];   // Array dimensions (min 1) (local)
int    kdimg[MAXLEVP][MAXBLK];
int    jlmg1[MAXLEVP][MAXBLK];   // J index limits (local, base 1)
int    jlmg2[MAXLEVP][MAXBLK];
int    klmg1[MAXLEVP][MAXBLK];   // K index limits (local, base 1)
int    klmg2[MAXLEVP][MAXBLK];
PREAL8 cofmg[MAXLEVP][MAXBLK];   // Pointers to COF arrays (local)
PREAL8 resmg[MAXLEVP][MAXBLK];   // Pointers to RESID arrays (local)
PREAL8 unkmg[MAXLEVP][MAXBLK];   // Pointers to DUNK arrays (local)
PINT4  mapmg[MAXLEVP][MAXBLK];   // Pointers to multigrid map arrays (local)
PINT4  keymg[MAXLEVP][MAXBLK];   // Pointers to keyout arrays (local)
PREAL4 cofmgy[MAXLEVP][MAXBLK];   // Pointers to COFy arrays (local)
PREAL4 wrkmgy[MAXLEVP][MAXBLK];   // Pointers to WORKy arrays (local)
PREAL4 wrkmgbuf[MAXBLK]; // Pointers to WORK buffer arrays (local)
// On multiprocessor machines a grid element in a multigrid level will
// belong to the processor that owns the grid base location of the next
// finer level

// These relations are base 1 as in fortran
//    jfl   = jfg - jofff
//    jcl   = jcg - joffc
//    jcg   = (jfg + 1) / 2
//    joffc = (jofff + 2) / 2 - jlay1
// ==>
//    jcl   = (jfl + jofff + 1) / 2 - joffc
//    jflb  = 2 * (jcl + joffc) - jofff - 1    (base location)

// *mapmg(jc,kc) = Map from course to fine grid (local indexes)
//      Patterns:
//                   ---             ---                         
//        *         | * |         * |   |     *           *       
//                   ---             ---         ---     ---     
//                                              |   |   |   |    
//                                               ---     ---     
//      0000=0      0001=1       0010=2      0100=4     1000=8

//       --- ---     ---         ---             ---     --- --- 
//      | * |   |   | * |       | * |         * |   |   | * |   |
//       --- ---     --- ---     ---             ---     --- --- 
//                      |   |   |   |           |   |       |   |
//                       ---     ---             ---         --- 
//      0011=3      0101=5      1001=9       0110=6     0111=7

//           ---     --- ---                 ---             --- 
//        * |   |   | * |   |     *         | * |         * |   |
//       --- ---     --- ---     --- ---     --- ---     --- --- 
//      |   |       |   |       |   |   |   |   |   |   |   |   |
//       ---         ---         --- ---     --- ---     --- --- 
//      1010=10     1011=11     1100=12     1101=13     1110=14

//       --- --- 
//      | * |   |
//       --- --- 
//      |   |   |
//       --- --- 
//      1111=15

// ROUTINE DECLARATIONS

FORTSUB $UPPERalcmga$USAN (PINT4 nmga, PINT4 neqs,PINT4 myprc, PINT4 joffmg,
                           PINT4 koffmg, PINT4 nymg, PINT4 nzmg, PINT4 n0mapmg, 
                           PINT4 prcmapmg, PINT4 mxcl, PINT4 err) ;
FORTSUB $UPPERmgwork1$USAN (FORTSUB (*subadd) (), PINT4 ancof, PINT4 anunk,
   PINT4 anres);
FORTSUB $UPPERmgwork1t$USAN (FORTSUB (*subadd) (), PINT4 ancof, PINT4 anunk,
   PINT4 anres);
FORTSUB $UPPERmgwork2$USAN (FORTSUB (*subadd) (), PINT4 mglfa);
FORTSUB $UPPERmgwork2t$USAN (FORTSUB (*subadd) (), PINT4 mglfa);
FORTSUB $UPPERmgwork3$USAN (FORTSUB (*subadd) (), PINT4 mgla);
FORTSUB $UPPERmgwork3t$USAN (FORTSUB (*subadd) (), PINT4 mgla);
FORTSUB $UPPERmgwork4$USAN (FORTSUB (*subadd) (), PINT4 mgla, PINT4 anbufdim,
                            PINT4 anbuf);
FORTSUB $UPPERmgwork4t$USAN (FORTSUB (*subadd) (), PINT4 mgla, PINT4 anbufdim,
                            PINT4 anbuf);
FORTSUB $UPPERmgwork1y$USAN (FORTSUB (*subadd) (), PINT4 ancof, PINT4 anunk,
   PINT4 anres);
FORTSUB $UPPERmgwork1yt$USAN (FORTSUB (*subadd) (), PINT4 ancof, PINT4 anunk,
   PINT4 anres);
FORTSUB $UPPERmgwork2y$USAN (FORTSUB (*subadd) (), PINT4 mglfa);
FORTSUB $UPPERmgwork2yt$USAN (FORTSUB (*subadd) (), PINT4 mglfa);
FORTSUB $UPPERmgwork3y$USAN (FORTSUB (*subadd) (), PINT4 mgla);
FORTSUB $UPPERmgwork3yt$USAN (FORTSUB (*subadd) (), PINT4 mgla);
FORTSUB $UPPERmgwork4y$USAN (FORTSUB (*subadd) (), PINT4 mgla);
FORTSUB $UPPERmgwork4yt$USAN (FORTSUB (*subadd) (), PINT4 mgla);

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
FORTSUB $UPPERalcmga$USAN (PINT4 nmga, PINT4 neqs,PINT4 myprc, PINT4 joffmg,
                           PINT4 koffmg, PINT4 nymg, PINT4 nzmg, PINT4 n0mapmg, 
                           PINT4 prcmapmg, PINT4 mxcl, PINT4 err)
{
// *******************************************************************

// 2d grid-element array creation for a multigrid linear solver
// Build map and keyout arrays

// nmga = number of multigrid levels (psor levels) (input)
//        nmga+1 arrays will be created to allow 1 for direct solution

// neqs[b] = number of equations in block b (input)

// joffmg[n][b] = grid local to global j offset for level n, block b (output)

// koffmg[n][b] = grid local to global k offset for level n, block b (output)

// err = Error number (output)
//     = 0 ==> no error
//     = 462 ==> insufficient memory

// *******************************************************************
int mgl,nb,nmgl;
int kd,jd,eq,jdc,kdc,nm,jk,i,k,jc,kc,idf,jdf,kdf,nl,jf,kf,if2,jf2,kf2;
int kf1,jf1,if1;
int ilay1,ilay2,jlay1,jlay2,klay1,klay2,maps,ko,jo,jfb,kfb;
int jofff,kofff,joffc,koffc;

nmgl=*nmga;

// Initialize data

for (nb = 0; nb < numblks; nb++)
   {
   wrkmgbuf[nb] = NULL;
   for (nl = 0; nl < MAXLEVP; nl++)
      {
      jdimg[nl][nb] = 0L;
      kdimg[nl][nb] = 0L;
      jlmg1[nl][nb] = 2000000000L;
      jlmg2[nl][nb] = 0L;
      klmg1[nl][nb] = 2000000000L;
      klmg2[nl][nb] = 0L;
      *(joffmg + nl + nb * (MAXLEVP)) = 0L;
      *(koffmg + nl + nb * (MAXLEVP)) = 0L;
      cofmg[nl][nb] = NULL;  cofmgy[nl][nb] = NULL;
      resmg[nl][nb] = NULL;  wrkmgy[nl][nb] = NULL;
      unkmg[nl][nb] = NULL;  
      mapmg[nl][nb] = NULL;
      }
   }


// Create multigrid arrays and fill them

ilay1 = layer[0];
ilay2 = max(1L,ilay1);
jlay1 = layer[1];
jlay2 = max(1L,jlay1);
klay1 = layer[2];
klay2 = max(1L,klay1);


for (nb = 0; nb < numblks; nb++)
   {
   if (myelem[nb] > 0)
      {
      jd = jdim[nb] - jlay1 - jlay2;
      kd = kdim[nb] - klay1 - klay2;
      eq = *(neqs + nb);
      for (nl = 0; nl <= nmgl; nl++)
         {
         jd = (jd+1)/2;
         if (jd < 1L) jd = 1L;
         jdimg[nl][nb] = jdc = jd + jlay1 + jlay2;
         kd = (kd+1)/2;
         if (kd < 1L) kd = 1L;
         kdimg[nl][nb] = kdc = kd + klay1 + klay2;

// Allocate space and clear it

         jk = jdc*kdc;
         *err = 462;

         nm = $NCOFMG * eq * eq * jk;
         if ((cofmg[nl][nb] = (PREAL8) malloc(nm * sizeof(double))) == NULL)
            return;
         for (k = 0L; k < nm; k++) *(cofmg[nl][nb] + k) = 0.;

         nm = eq * jk;
         if ((resmg[nl][nb] = (PREAL8) malloc(nm * sizeof(double))) == NULL)
            return;
         for (k = 0L; k < nm; k++) *(resmg[nl][nb] + k) = 0.;

         if ((unkmg[nl][nb] = (PREAL8) malloc(nm * sizeof(double))) == NULL)
            return;
         for (k = 0L; k < nm; k++) *(unkmg[nl][nb] + k) = 0.;

         if ((mapmg[nl][nb] = (PINT4) malloc(jk * sizeof(int))) == NULL)
            return;
         for (k = 0L; k < jk; k++) *(mapmg[nl][nb] + k) = 0L;

         if ((keymg[nl][nb] = (PINT4) malloc(jk * sizeof(int))) == NULL)
            return;
         for (k = 0L; k < jk; k++) *(keymg[nl][nb] + k) = 0L;

         nm = $NUMCOF * eq * eq * jk * idim[nb] ;
         if ((cofmgy[nl][nb] = (PREAL4) malloc(nm * sizeof(double))) == NULL)
            return;
         for (k = 0L; k < nm; k++) *(cofmgy[nl][nb] + k) = 0.;

         nm = eq * jk * idim[nb] ;
         if ((wrkmgy[nl][nb] = (PREAL4) malloc(nm * sizeof(double))) == NULL)
            return;
         for (k = 0L; k < nm; k++) *(wrkmgy[nl][nb] + k) = 0.;

         if (nl == 0)
         {
          if ((wrkmgbuf[nb] = (PREAL4) malloc(nm * sizeof(double))) == NULL)
            return;
          for (k = 0L; k < nm; k++) *(wrkmgbuf[nb] + k) = 0.;
         }

// Set dimensions and mapping for the multigrid levels

         if (nl == 0)
            {

//  3d grid source for first multigrid level

            jdf = jdim[nb];
//          jf2 = jdf - jlay2;
            jf2 = min(jdf - jlay2 + 1, jdf);
            jf1 = max( 0, jlay1-1 );
            jofff = jofflg[nb];
            joffc = (jofff + 2L) / 2L - jlay1;

            kdf = kdim[nb];
//          kf2 = kdf - klay2;
            kf2 = min(kdf - klay2 + 1, kdf);
            kf1 = max( 0, klay1-1 );

            kofff = kofflg[nb];
            koffc = (kofff + 2L) / 2L - klay1;

            idf = idim[nb];
//          if2 = idf - ilay2;
            if2 = min( idf - ilay2 + 1, idf);
            if1 = max( 0, ilay1-1 );


//          for (kf = klay1; kf < kf2; kf++)
            for (kf = kf1  ; kf < kf2; kf++)
               {
               kc = (kf + kofff + 2L) / 2L - koffc - 1L;
               kfb = 2L * (kc + koffc + 1L) - kofff - 2L;
//             for (jf = jlay1; jf < jf2; jf++)
               for (jf = jf1  ; jf < jf2; jf++)
                  {
                  jc = (jf + jofff + 2L) / 2L - joffc - 1L;
                  jfb = 2L * (jc + joffc + 1L) - jofff - 2L;
                  nm = idf * (jf + jdf * kf);
                  jo = 0L;
//                for (i = ilay1; i < if2; i++)
                  for (i = if1  ; i < if2; i++)

                     {
                     ko = *(keyout[nb] + nm + i);
                     if (ko != 0L) jo = ko;
                     }
                  if (jf == jfb && kf == kfb)
{
                     *(keymg[nl][nb] + jc + jdc * kc) = jo;
 if (jo > 0L)
 {
  int mm;
  mm = *(n0mapmg+nl+nb*(MAXLEVP)) + (kc+koffc)* *(nymg+nl+nb*(MAXLEVP))
                                   +(jc+joffc);
  *(prcmapmg+mm+nl*(*mxcl)) = *myprc ;
  //  printf("%d %d | %d %d: %d \n",*myprc,nl,jc+joffc,kc+koffc,jo);
 }
}
                  if (jo > 0L)
                     {
                     if ((jc + 1L) < jlmg1[nl][nb]) jlmg1[nl][nb] = jc + 1L;
                     if ((jc + 1L) > jlmg2[nl][nb]) jlmg2[nl][nb] = jc + 1L;
                     if ((kc + 1L) < klmg1[nl][nb]) klmg1[nl][nb] = kc + 1L;
                     if ((kc + 1L) > klmg2[nl][nb]) klmg2[nl][nb] = kc + 1L;
                     }
                  if (jo != 0L)
                     {
                     if (jf > jfb)
                        {
                        if (kf > kfb)
                           maps = 4L;
                        else
                           maps = 2L;
                        }
                     else
                        {
                        if (kf > kfb)
                           maps = 8L;
                        else
                           maps = 1L;
                        }
                     nm = jc + jdc * kc;
                     *(mapmg[nl][nb] + nm) = *(mapmg[nl][nb] + nm) + maps;
                     }  
                  }  
               }  
            }
         else
            {

//  2d grid source for other multigrid levels
//  Put small elements (if any) on alternating sides

            jdf = jdimg[nl - 1][nb];
//          jf2 = jdf - jlay2;
            jf2 = min(jdf - jlay2 + 1, jdf);
            jf1 = max( 0, jlay1-1 );

            jofff = *(joffmg + nl - 1L + nb * (MAXLEVP));
            joffc = (jofff + 2L) / 2L - jlay1;


            kdf = kdimg[nl - 1][nb];
//          kf2 = kdf - klay2;
            kf2 = min(kdf - klay2 + 1, kdf);
            kf1 = max( 0, klay1-1 );
            kofff = *(koffmg + nl - 1L + nb * (MAXLEVP));
            koffc = (kofff + 2L) / 2L - klay1;


//          for (kf = klay1; kf < kf2; kf++)
            for (kf = kf1  ; kf < kf2; kf++)
               {
               kc = (kf + kofff + 2L) / 2L - koffc - 1L;
               kfb = 2L * (kc + koffc + 1L) - kofff - 2L;
//             for (jf = jlay1; jf < jf2; jf++)
               for (jf = jf1  ; jf < jf2; jf++)
                  {
                  jc = (jf + jofff + 2L) / 2L - joffc - 1L;
                  jfb = 2L * (jc + joffc + 1L) - jofff - 2L;

                  jo = *(keymg[nl - 1L][nb] + jf + jdf * kf);
                  if (jf == jfb && kf == kfb)
{
                     *(keymg[nl][nb] + jc + jdc * kc) = jo;
 if (jo > 0L)
 {
  int mm;
  mm = *(n0mapmg+nl+nb*(MAXLEVP)) + (kc+koffc)* *(nymg+nl+nb*(MAXLEVP))
                                   +(jc+joffc);
  *(prcmapmg+mm+nl*(*mxcl)) = *myprc ;
  //  printf("%d %d | %d %d: %d \n",*myprc,nl,jc+joffc,kc+koffc,jo);
 }
}

                  if (jo > 0L)
                     {
                     if ((jc + 1L) < jlmg1[nl][nb]) jlmg1[nl][nb] = jc + 1L;
                     if ((jc + 1L) > jlmg2[nl][nb]) jlmg2[nl][nb] = jc + 1L;
                     if ((kc + 1L) < klmg1[nl][nb]) klmg1[nl][nb] = kc + 1L;
                     if ((kc + 1L) > klmg2[nl][nb]) klmg2[nl][nb] = kc + 1L;
                     }

                  if (*(mapmg[nl - 1][nb] + jf + kf * jdf) > 0L)
                     {
                     if (jf > jfb)
                        {
                        if (kf > kfb)
                           maps = 4;
                        else
                           maps = 2;
                        }
                     else
                        {
                        if (kf > kfb)
                           maps = 8;
                        else
                           maps = 1;
                        }
                     nm = jc + jdc * kc;
                     *(mapmg[nl][nb] + nm) = *(mapmg[nl][nb] + nm) + maps;
                     }
                  }  
               }  
            }
         *(joffmg + nl + nb * (MAXLEVP)) = joffc;
         *(koffmg + nl + nb * (MAXLEVP)) = koffc;
         }
      }
   }


*err = 0L;
return;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
FORTSUB $UPPERmgwork1t$USAN (FORTSUB (*subadd) (), PINT4 ancof, 
                             PINT4 anunk, PINT4 anres)
{
// *******************************************************************

// Calls a multigrid work routine that involves elements of the 3-d grid and
// the first multigrid level

// subadd = Name of the work routine (input).  The FORTRAN statement
// EXTERNAL WORK
// must appear in the subroutine that calls MGWORK1.

// ancof = Array number of 3d coefficient array (input)

// anunk = Array number of 3d unknown array (input)

// anres = Array number of 3d residual array (input)

// The arguments of the work routines are:

// IDIM, JDIM, KDIM = The first three local dimensions of 3d grid-element arrays
// (input).  Space for communication layers are included in these dimensions.

// LDIM = The first dimension of grid-refinement arrays (input).

// IL1, IL2 = the smallest and largest local 3d I indexes for which the work
// routine is responsible (input).

// JL1V(K), JL2V(K) = the smallest and largest local 3d J indexes for which
// the work routine is responsible in row K. (input).

// KL1, KL2 = the smallest and largest local 3d K indexes for which the work
// routine is responsible (input).

// KEYOUT(I,J,K) = a 3d array defining element type.  Local indexes are
// used as subscripts for KEYOUT. (input)
// 0  ==> The grid element does not exist.  It may be outside the boundary
//        of the reservoir or may represent a shale.
// 1  ==> The grid element exists and belongs to the current processor.
//        The element is not refined.
// -1 ==> The grid element exists but belongs to a neighboring processor.
//        The element is not refined.

// NBLK = Grid-block number (input) (mod 1).

// COF(I,J,K,...) = 3d linear system coefficients (input)

// DUNK(I,J,K,V) = 3d linear system coefficients (input and output)

// RESID(I,J,K,E) = 3d linear system residuals (input)

// JDMG, KDMG = The first two local dimensions of 2d grid-element arrays
// (input).  Space for communication layers are included in these dimensions.

// JMG1, JMG2 = The smallest and largest local 2d indexes for which the work
// KMG1, KMG2   routine is responsible (input).

// MAPMG(J,K) = Map from 2d indexes to 3d column indexes (input)
//              See alcmga() for difinitions

// KEYMG(J,K) = a 2d array defining element type.  Local indexes are
// used as subscripts for KEYMG. (input)
// 0  ==> The grid element does not exist.  It may be outside the boundary
//        of the reservoir or may represent a shale.
// 1  ==> The grid element exists and belongs to the current processor.
//        The element is not refined.
// -1 ==> The grid element exists but belongs to a neighboring processor.
//        The element is not refined.

// COFMG(J,K,...) = 2d linear system coefficients (input and output)

// DUMG(J,K,V) = 2d linear system coefficients (input and output)

// RESMG(J,K,E) = 2d linear system residuals (input and output)

// *******************************************************************
int nbp;
int  nb;
void **a;

for (nb = 0; nb < numblks; nb++)
   {
   if (((*modact) == 0) || ((*modact) == modblk[nb]) 
      || ((*modact) == fmodblk[nb]))
      {
      nbp = nb + 1;
      a = &(aryadd[nb][0]);
      (*subadd) (&(idim[nb]),&(jdim[nb]),&(kdim[nb]),&dimr,
              &(iloc1[nb]),&(iloc2[nb]),jloc1[nb],jloc2[nb],
              &(kloc1[nb]),&(kloc2[nb]),keyout[nb],&nbp,
              *(a + *ancof),*(a + *anunk),*(a + *anres),
              &(jdimg[0][nb]),&(kdimg[0][nb]),&(jlmg1[0][nb]),
              &(jlmg2[0][nb]),&(klmg1[0][nb]),&(klmg2[0][nb]),
              mapmg[0][nb],keymg[0][nb],cofmg[0][nb],
              unkmg[0][nb],resmg[0][nb]);
      }
   }
return;
}
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
FORTSUB $UPPERmgwork1$USAN (FORTSUB (*subadd) (), PINT4 ancof, 
                            PINT4 anunk, PINT4 anres)
{
// *******************************************************************

// Calls a multigrid work routine that involves elements of the 3-d grid and
// the first multigrid level

// subadd = Name of the work routine (input).  The FORTRAN statement
// EXTERNAL WORK
// must appear in the subroutine that calls MGWORK1.

// ancof = Array number of 3d coefficient array (input)

// anunk = Array number of 3d unknown array (input)

// anres = Array number of 3d residual array (input)

// The arguments of the work routines are:

// IDIM, JDIM, KDIM = The first three local dimensions of 3d grid-element arrays
// (input).  Space for communication layers are included in these dimensions.

// LDIM = The first dimension of grid-refinement arrays (input).

// IL1, IL2 = the smallest and largest local 3d I indexes for which the work
// routine is responsible (input).

// JL1V(K), JL2V(K) = the smallest and largest local 3d J indexes for which
// the work routine is responsible in row K. (input).

// KL1, KL2 = the smallest and largest local 3d K indexes for which the work
// routine is responsible (input).

// KEYOUT(I,J,K) = a 3d array defining element type.  Local indexes are
// used as subscripts for KEYOUT. (input)
// 0  ==> The grid element does not exist.  It may be outside the boundary
//        of the reservoir or may represent a shale.
// 1  ==> The grid element exists and belongs to the current processor.
//        The element is not refined.
// -1 ==> The grid element exists but belongs to a neighboring processor.
//        The element is not refined.

// NBLK = Grid-block number (input) (mod 1).

// COF(I,J,K,...) = 3d linear system coefficients (input)

// DUNK(I,J,K,V) = 3d linear system coefficients (input and output)

// RESID(I,J,K,E) = 3d linear system residuals (input)

// JDMG, KDMG = The first two local dimensions of 2d grid-element arrays
// (input).  Space for communication layers are included in these dimensions.

// JMG1, JMG2 = The smallest and largest local 2d indexes for which the work
// KMG1, KMG2   routine is responsible (input).

// MAPMG(J,K) = Map from 2d indexes to 3d column indexes (input)
//              See alcmga() for difinitions

// KEYMG(J,K) = a 2d array defining element type.  Local indexes are
// used as subscripts for KEYMG. (input)
// 0  ==> The grid element does not exist.  It may be outside the boundary
//        of the reservoir or may represent a shale.
// 1  ==> The grid element exists and belongs to the current processor.
//        The element is not refined.
// -1 ==> The grid element exists but belongs to a neighboring processor.
//        The element is not refined.

// COFMG(J,K,...) = 2d linear system coefficients (input and output)

// DUMG(J,K,V) = 2d linear system coefficients (input and output)

// RESMG(J,K,E) = 2d linear system residuals (input and output)

// *******************************************************************
int nbp;
int  nb;
void **a;

for (nb = 0; nb < numblks; nb++)
   {
   if ((((*modact) == 0) || ((*modact) == modblk[nb]) 
      || (*modact == fmodblk[nb])) && ((myelem[nb] > 0)))
      {
      nbp = nb + 1;
      a = &(aryadd[nb][0]);
      (*subadd) (&(idim[nb]),&(jdim[nb]),&(kdim[nb]),&dimr,
              &(iloc1[nb]),&(iloc2[nb]),jloc1[nb],jloc2[nb],
              &(kloc1[nb]),&(kloc2[nb]),keyout[nb],&nbp,
              *(a + *ancof),*(a + *anunk),*(a + *anres),
              &(jdimg[0][nb]),&(kdimg[0][nb]),&(jlmg1[0][nb]),
              &(jlmg2[0][nb]),&(klmg1[0][nb]),&(klmg2[0][nb]),
              mapmg[0][nb],keymg[0][nb],cofmg[0][nb],
              unkmg[0][nb],resmg[0][nb]);
      }
   }
return;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
FORTSUB $UPPERmgwork2t$USAN (FORTSUB (*subadd) (), PINT4 mglfa)
{
// *******************************************************************

// Calls a multigrid work routine that involves elements of 2 multigrid levels

// subadd = Name of the work routine (input).  The FORTRAN statement
// EXTERNAL WORK
// must appear in the subroutine that calls MGWORK1.

// mglfa = Multigrid level of the fine grid (input)

// The arguments of the work routines are:

// MGLF = Multigrid fine level

// NBLK = Grid-block number (input) (mod 1).

// JDMGF, KDMGF = The first two local dimensions of fine grid arrays
// (input).  Space for communication layers are included in these dimensions.

// JDMGC, KDMGC = The first two local dimensions of course grid arrays
// (input).  Space for communication layers are included in these dimensions.

// JMG1F, JMG2F = The smallest and largest local 2d indexes for which the work
// KMG1F, KMG2F   routine is responsible in the fine grid (input).

// JMG1C, JMG2C = The smallest and largest local 2d indexes for which the work
// KMG1C, KMG2C   routine is responsible in the course grid (input).

// MAPMG(J,K) = Map from course grid to the fine grid (input)
//              See alcmga() for difinitions.  Course grid indexes are used.

// KEYMGF(J,K) = Keyout arrays (input)
// KEYMGC(J,K) 

// COFMGF(J,K,...) = 2d linear system coefficients (input and output)
// COFMGC(J,K,...)

// DUMGF(J,K,V) = 2d linear system coefficients (input and output)
// DUMGC(J,K,V)

// RESMGF(J,K,E) = 2d linear system residuals (input and output)
// RESMGC(J,K,E)

// *******************************************************************
int nbp, mglf, mglc;
int  nb;

mglf = (*mglfa) - 1L;
mglc = mglf + 1L;

for (nb = 0; nb < numblks; nb++)
   {
      nbp = nb + 1;
      (*subadd) (mglfa,&nbp,&(jdimg[mglf][nb]),&(kdimg[mglf][nb]),
                 &(jdimg[mglc][nb]),&(kdimg[mglc][nb]),
                 &(jlmg1[mglf][nb]),&(jlmg2[mglf][nb]),
                 &(klmg1[mglf][nb]),&(klmg2[mglf][nb]),
                 &(jlmg1[mglc][nb]),&(jlmg2[mglc][nb]),
                 &(klmg1[mglc][nb]),&(klmg2[mglc][nb]),
                 mapmg[mglc][nb],
                 keymg[mglf][nb],keymg[mglc][nb],
                 cofmg[mglf][nb],cofmg[mglc][nb],
                 unkmg[mglf][nb],unkmg[mglc][nb],
                 resmg[mglf][nb],resmg[mglc][nb]);
   }
return;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
FORTSUB $UPPERmgwork2$USAN (FORTSUB (*subadd) (), PINT4 mglfa)
{
// *******************************************************************

// Calls a multigrid work routine that involves elements of 2 multigrid levels

// subadd = Name of the work routine (input).  The FORTRAN statement
// EXTERNAL WORK
// must appear in the subroutine that calls MGWORK1.

// mglfa = Multigrid level of the fine grid (input)

// The arguments of the work routines are:

// MGLF = Multigrid fine level

// NBLK = Grid-block number (input) (mod 1).

// JDMGF, KDMGF = The first two local dimensions of fine grid arrays
// (input).  Space for communication layers are included in these dimensions.

// JDMGC, KDMGC = The first two local dimensions of course grid arrays
// (input).  Space for communication layers are included in these dimensions.

// JMG1F, JMG2F = The smallest and largest local 2d indexes for which the work
// KMG1F, KMG2F   routine is responsible in the fine grid (input).

// JMG1C, JMG2C = The smallest and largest local 2d indexes for which the work
// KMG1C, KMG2C   routine is responsible in the course grid (input).

// MAPMG(J,K) = Map from course grid to the fine grid (input)
//              See alcmga() for difinitions.  Course grid indexes are used.

// KEYMGF(J,K) = Keyout arrays (input)
// KEYMGC(J,K) 

// COFMGF(J,K,...) = 2d linear system coefficients (input and output)
// COFMGC(J,K,...)

// DUMGF(J,K,V) = 2d linear system coefficients (input and output)
// DUMGC(J,K,V)

// RESMGF(J,K,E) = 2d linear system residuals (input and output)
// RESMGC(J,K,E)

// *******************************************************************
int nbp, mglf, mglc;
int  nb;

mglf = (*mglfa) - 1L;
mglc = mglf + 1L;

for (nb = 0; nb < numblks; nb++)
   {
   if (myelem[nb] > 0)
      {
      nbp = nb + 1;
      (*subadd) (mglfa,&nbp,&(jdimg[mglf][nb]),&(kdimg[mglf][nb]),
                 &(jdimg[mglc][nb]),&(kdimg[mglc][nb]),
                 &(jlmg1[mglf][nb]),&(jlmg2[mglf][nb]),
                 &(klmg1[mglf][nb]),&(klmg2[mglf][nb]),
                 &(jlmg1[mglc][nb]),&(jlmg2[mglc][nb]),
                 &(klmg1[mglc][nb]),&(klmg2[mglc][nb]),
                 mapmg[mglc][nb],
                 keymg[mglf][nb],keymg[mglc][nb],
                 cofmg[mglf][nb],cofmg[mglc][nb],
                 unkmg[mglf][nb],unkmg[mglc][nb],
                 resmg[mglf][nb],resmg[mglc][nb]);
      }
   }
return;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
FORTSUB $UPPERmgwork3t$USAN (FORTSUB (*subadd) (), PINT4 mgla)
{
// *******************************************************************

// Calls a multigrid work routine that involves elements of a single
// multigrid level

// subadd = Name of the work routine (input).  The FORTRAN statement
// EXTERNAL WORK
// must appear in the subroutine that calls MGWORK1.

// mglfa = Multigrid level of the fine grid (input)

// The arguments of the work routines are:

// MGLF = Multigrid fine level

// NBLK = Grid-block number (input) (mod 1).

// JDMG, KDMG = The first two local dimensions of grid arrays
// (input).  Space for communication layers are included in these dimensions.

// JMG1, JMG2 = The smallest and largest local 2d indexes for which the work
// KMG1, KMG2   routine is responsible in the grid (input).

// MAPMG(J,K) = Map from course grid to the fine grid (input)
//              See alcmga() for difinitions.  Course grid indexes are used.

// KEYMG(J,K) = Keyout array (input)

// COFMG(J,K,...) = 2d linear system coefficients (input and output)

// DUMG(J,K,V) = 2d linear system coefficients (input and output)

// RESMG(J,K,E) = 2d linear system residuals (input and output)

// *******************************************************************
int nbp, mgl;
int  nb;

mgl = (*mgla) - 1L;

for (nb = 0; nb < numblks; nb++)
   {
      nbp = nb + 1;
      (*subadd) (mgla,&nbp,&(jdimg[mgl][nb]),&(kdimg[mgl][nb]),
                 &(jlmg1[mgl][nb]),&(jlmg2[mgl][nb]),
                 &(klmg1[mgl][nb]),&(klmg2[mgl][nb]),
                 mapmg[mgl][nb],keymg[mgl][nb],cofmg[mgl][nb],
                 unkmg[mgl][nb],resmg[mgl][nb]);
   }
return;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
FORTSUB $UPPERmgwork3$USAN (FORTSUB (*subadd) (), PINT4 mgla)
{
// *******************************************************************

// Calls a multigrid work routine that involves elements of a single
// multigrid level

// subadd = Name of the work routine (input).  The FORTRAN statement
// EXTERNAL WORK
// must appear in the subroutine that calls MGWORK1.

// mglfa = Multigrid level of the fine grid (input)

// The arguments of the work routines are:

// MGLF = Multigrid fine level

// NBLK = Grid-block number (input) (mod 1).

// JDMG, KDMG = The first two local dimensions of grid arrays
// (input).  Space for communication layers are included in these dimensions.

// JMG1, JMG2 = The smallest and largest local 2d indexes for which the work
// KMG1, KMG2   routine is responsible in the grid (input).

// MAPMG(J,K) = Map from course grid to the fine grid (input)
//              See alcmga() for difinitions.  Course grid indexes are used.

// KEYMG(J,K) = Keyout array (input)

// COFMG(J,K,...) = 2d linear system coefficients (input and output)

// DUMG(J,K,V) = 2d linear system coefficients (input and output)

// RESMG(J,K,E) = 2d linear system residuals (input and output)

// *******************************************************************
int nbp, mgl;
int  nb;

mgl = (*mgla) - 1L;

for (nb = 0; nb < numblks; nb++)
   {
   if (myelem[nb] > 0)
      {
      nbp = nb + 1;
      (*subadd) (mgla,&nbp,&(jdimg[mgl][nb]),&(kdimg[mgl][nb]),
                 &(jlmg1[mgl][nb]),&(jlmg2[mgl][nb]),
                 &(klmg1[mgl][nb]),&(klmg2[mgl][nb]),
                 mapmg[mgl][nb],keymg[mgl][nb],cofmg[mgl][nb],
                 unkmg[mgl][nb],resmg[mgl][nb]);
      }
   }
return;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
FORTSUB $UPPERmgwork4t$USAN (FORTSUB (*subadd) (), PINT4 mgla, 
                             PINT4 anbufdim, PINT4 anbuf)
{
// *******************************************************************

// Calls a multigrid work routine that fills or uses the dual-approximation
// buffers

// subadd = Name of the work routine (input).  The FORTRAN statement
// EXTERNAL WORK
// must appear in the subroutine that calls MGWORK1.

// mgla = Multigrid level (input)

// anbufdim = array number of 1st buffer dimension (input)

// anbuf = array number of buffer (input)

// The arguments of the work routines are:

// MGLV = Multigrid level

// NBLK = CURRENT FAULT-BLOCK NUMBER

// JDMG = FIRST 2 DIMENSIONS OF DUKMG
// KDMG 

// DUKMG(J,K,v) = CHANGE IN VARIABLE v

// NBUFDIM = FIRST DIMENSION OF BUFIF8(,)

// BUFIF8(,) = INTERFACE BUFFER

// *******************************************************************
int nbp, mgl;
int  nb;
void **a;

mgl = (*mgla) - 1L;

for (nb = 0; nb < numblks; nb++)
   {
      nbp = nb + 1;
      a = &(aryadd[nb][0]);
      (*subadd) (mgla,&nbp,&(jdimg[mgl][nb]),&(kdimg[mgl][nb]),
                 unkmg[mgl][nb],*(a + *anbufdim),*(a + *anbuf));
   }
return;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
FORTSUB $UPPERmgwork4$USAN (FORTSUB (*subadd) (), PINT4 mgla, 
                            PINT4 anbufdim, PINT4 anbuf)
{
// *******************************************************************

// Calls a multigrid work routine that fills or uses the dual-approximation
// buffers

// subadd = Name of the work routine (input).  The FORTRAN statement
// EXTERNAL WORK
// must appear in the subroutine that calls MGWORK1.

// mgla = Multigrid level (input)

// anbufdim = array number of 1st buffer dimension (input)

// anbuf = array number of buffer (input)

// The arguments of the work routines are:

// MGLV = Multigrid level

// NBLK = CURRENT FAULT-BLOCK NUMBER

// JDMG = FIRST 2 DIMENSIONS OF DUKMG
// KDMG 

// DUKMG(J,K,v) = CHANGE IN VARIABLE v

// NBUFDIM = FIRST DIMENSION OF BUFIF8(,)

// BUFIF8(,) = INTERFACE BUFFER

// *******************************************************************
int nbp, mgl;
int  nb;
void **a;

mgl = (*mgla) - 1L;

for (nb = 0; nb < numblks; nb++)
   {
   if (myelem[nb] > 0)
      {
      nbp = nb + 1;
      a = &(aryadd[nb][0]);
      (*subadd) (mgla,&nbp,&(jdimg[mgl][nb]),&(kdimg[mgl][nb]),
                 unkmg[mgl][nb],*(a + *anbufdim),*(a + *anbuf));
      }
   }
return;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
FORTSUB $UPPERmgwork1yt$USAN (FORTSUB (*subadd) (), PINT4 ancof, 
                              PINT4 anunk, PINT4 anres)
{
// *******************************************************************

// Calls a multigrid work routine that involves elements of the 3-d grid and
// the first multigrid level

// subadd = Name of the work routine (input).  The FORTRAN statement
// EXTERNAL WORK
// must appear in the subroutine that calls MGWORK1.

// ancof = Array number of 3d coefficient array (input)

// anunk = Array number of 3d unknown array (input)

// anres = Array number of 3d residual array (input)

// The arguments of the work routines are:

// IDIM, JDIM, KDIM = The first three local dimensions of 3d grid-element arrays
// (input).  Space for communication layers are included in these dimensions.

// LDIM = The first dimension of grid-refinement arrays (input).

// IL1, IL2 = the smallest and largest local 3d I indexes for which the work
// routine is responsible (input).

// JL1V(K), JL2V(K) = the smallest and largest local 3d J indexes for which
// the work routine is responsible in row K. (input).

// KL1, KL2 = the smallest and largest local 3d K indexes for which the work
// routine is responsible (input).

// KEYOUT(I,J,K) = a 3d array defining element type.  Local indexes are
// used as subscripts for KEYOUT. (input)
// 0  ==> The grid element does not exist.  It may be outside the boundary
//        of the reservoir or may represent a shale.
// 1  ==> The grid element exists and belongs to the current processor.
//        The element is not refined.
// -1 ==> The grid element exists but belongs to a neighboring processor.
//        The element is not refined.

// NBLK = Grid-block number (input) (mod 1).

// COF(I,J,K,...) = 3d linear system coefficients (input)

// DUNK(I,J,K,V) = 3d linear system coefficients (input and output)

// RESID(I,J,K,E) = 3d linear system residuals (input)

// JDMG, KDMG = The first two local dimensions of 2d grid-element arrays
// (input).  Space for communication layers are included in these dimensions.

// JMG1, JMG2 = The smallest and largest local 2d indexes for which the work
// KMG1, KMG2   routine is responsible (input).

// MAPMG(J,K) = Map from 2d indexes to 3d column indexes (input)
//              See alcmga() for difinitions

// KEYMG(J,K) = a 2d array defining element type.  Local indexes are
// used as subscripts for KEYMG. (input)
// 0  ==> The grid element does not exist.  It may be outside the boundary
//        of the reservoir or may represent a shale.
// 1  ==> The grid element exists and belongs to the current processor.
//        The element is not refined.
// -1 ==> The grid element exists but belongs to a neighboring processor.
//        The element is not refined.

// COFMG(I,J,K,...) = 3d linear system coefficients (input and output)

// DUMG(I,J,K,V) = 3d linear system coefficients (input and output)

// RESMG(I,J,K,E) = 3d linear system residuals (input and output)

// *******************************************************************
int nbp;
int  nb;
void **a;

for (nb = 0; nb < numblks; nb++)
   {
   if (((*modact) == 0) || ((*modact) == modblk[nb])
      || ((*modact) == fmodblk[nb]))
      {
      nbp = nb + 1;
      a = &(aryadd[nb][0]);
      (*subadd) (&(idim[nb]),&(jdim[nb]),&(kdim[nb]),&dimr,
              &(iloc1[nb]),&(iloc2[nb]),jloc1[nb],jloc2[nb],
              &(kloc1[nb]),&(kloc2[nb]),keyout[nb],&nbp,
              *(a + *ancof),*(a + *anunk),*(a + *anres),
              &(jdimg[0][nb]),&(kdimg[0][nb]),&(jlmg1[0][nb]),
              &(jlmg2[0][nb]),&(klmg1[0][nb]),&(klmg2[0][nb]),
              mapmg[0][nb],keymg[0][nb],cofmgy[0][nb],wrkmgy[0][nb]);
      }
   }
return;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
FORTSUB $UPPERmgwork1y$USAN (FORTSUB (*subadd) (), PINT4 ancof, 
                             PINT4 anunk, PINT4 anres)
{
// *******************************************************************

// Calls a multigrid work routine that involves elements of the 3-d grid and
// the first multigrid level

// subadd = Name of the work routine (input).  The FORTRAN statement
// EXTERNAL WORK
// must appear in the subroutine that calls MGWORK1.

// ancof = Array number of 3d coefficient array (input)

// anunk = Array number of 3d unknown array (input)

// anres = Array number of 3d residual array (input)

// The arguments of the work routines are:

// IDIM, JDIM, KDIM = The first three local dimensions of 3d grid-element arrays
// (input).  Space for communication layers are included in these dimensions.

// LDIM = The first dimension of grid-refinement arrays (input).

// IL1, IL2 = the smallest and largest local 3d I indexes for which the work
// routine is responsible (input).

// JL1V(K), JL2V(K) = the smallest and largest local 3d J indexes for which
// the work routine is responsible in row K. (input).

// KL1, KL2 = the smallest and largest local 3d K indexes for which the work
// routine is responsible (input).

// KEYOUT(I,J,K) = a 3d array defining element type.  Local indexes are
// used as subscripts for KEYOUT. (input)
// 0  ==> The grid element does not exist.  It may be outside the boundary
//        of the reservoir or may represent a shale.
// 1  ==> The grid element exists and belongs to the current processor.
//        The element is not refined.
// -1 ==> The grid element exists but belongs to a neighboring processor.
//        The element is not refined.

// NBLK = Grid-block number (input) (mod 1).

// COF(I,J,K,...) = 3d linear system coefficients (input)

// DUNK(I,J,K,V) = 3d linear system coefficients (input and output)

// RESID(I,J,K,E) = 3d linear system residuals (input)

// JDMG, KDMG = The first two local dimensions of 2d grid-element arrays
// (input).  Space for communication layers are included in these dimensions.

// JMG1, JMG2 = The smallest and largest local 2d indexes for which the work
// KMG1, KMG2   routine is responsible (input).

// MAPMG(J,K) = Map from 2d indexes to 3d column indexes (input)
//              See alcmga() for difinitions

// KEYMG(J,K) = a 2d array defining element type.  Local indexes are
// used as subscripts for KEYMG. (input)
// 0  ==> The grid element does not exist.  It may be outside the boundary
//        of the reservoir or may represent a shale.
// 1  ==> The grid element exists and belongs to the current processor.
//        The element is not refined.
// -1 ==> The grid element exists but belongs to a neighboring processor.
//        The element is not refined.

// COFMG(I,J,K,...) = 3d linear system coefficients (input and output)

// DUMG(I,J,K,V) = 3d linear system coefficients (input and output)

// RESMG(I,J,K,E) = 3d linear system residuals (input and output)

// *******************************************************************
int nbp;
int  nb;
void **a;

for (nb = 0; nb < numblks; nb++)
   {
   if ((((*modact) == 0) || ((*modact) == modblk[nb])
      || ((*modact) == fmodblk[nb])) && ((myelem[nb] > 0)))
      {
      nbp = nb + 1;
      a = &(aryadd[nb][0]);
      (*subadd) (&(idim[nb]),&(jdim[nb]),&(kdim[nb]),&dimr,
              &(iloc1[nb]),&(iloc2[nb]),jloc1[nb],jloc2[nb],
              &(kloc1[nb]),&(kloc2[nb]),keyout[nb],&nbp,
              *(a + *ancof),*(a + *anunk),*(a + *anres),
              &(jdimg[0][nb]),&(kdimg[0][nb]),&(jlmg1[0][nb]),
              &(jlmg2[0][nb]),&(klmg1[0][nb]),&(klmg2[0][nb]),
              mapmg[0][nb],keymg[0][nb],cofmgy[0][nb],wrkmgy[0][nb]);
      }
   }
return;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
FORTSUB $UPPERmgwork2yt$USAN (FORTSUB (*subadd) (), PINT4 mglfa)
{
// *******************************************************************

// Calls a multigrid work routine that involves elements of 2 multigrid levels

// subadd = Name of the work routine (input).  The FORTRAN statement
// EXTERNAL WORK
// must appear in the subroutine that calls MGWORK1.

// mglfa = Multigrid level of the fine grid (input)

// The arguments of the work routines are:

// MGLF = Multigrid fine level

// NBLK = Grid-block number (input) (mod 1).

// IDIM = The X local dimension
// JDMGF, KDMGF = The first two local dimensions of fine grid arrays
// (input).  Space for communication layers are included in these dimensions.

// JDMGC, KDMGC = The first two local dimensions of course grid arrays
// (input).  Space for communication layers are included in these dimensions.

// IL1,IL2 = The smallest and largest local X indexes 
// JMG1F, JMG2F = The smallest and largest local 2d indexes for which the work
// KMG1F, KMG2F   routine is responsible in the fine grid (input).

// JMG1C, JMG2C = The smallest and largest local 2d indexes for which the work
// KMG1C, KMG2C   routine is responsible in the course grid (input).

// MAPMG(J,K) = Map from course grid to the fine grid (input)
//              See alcmga() for difinitions.  Course grid indexes are used.

// KEYMGF(J,K) = Keyout arrays (input)
// KEYMGC(J,K) 

// COFMGF(I,J,K,...) = 3d linear system coefficients (input and output)
// COFMGC(I,J,K,...)

// DUMGF(I,J,K,V) = 3d linear system coefficients (input and output)
// DUMGC(I,J,K,V)

// RESMGF(I,J,K,E) = 3d linear system residuals (input and output)
// RESMGC(I,J,K,E)

// *******************************************************************
int nbp, mglf, mglc;
int  nb;

mglf = (*mglfa) - 1L;
mglc = mglf + 1L;

for (nb = 0; nb < numblks; nb++)
   {
      nbp = nb + 1;
      (*subadd) (mglfa,&nbp,&(idim[nb]),&(jdimg[mglf][nb]),&(kdimg[mglf][nb]),
                 &(jdimg[mglc][nb]),&(kdimg[mglc][nb]),
                 &(iloc1[nb]),&(iloc2[nb]),
                 &(jlmg1[mglf][nb]),&(jlmg2[mglf][nb]),
                 &(klmg1[mglf][nb]),&(klmg2[mglf][nb]),
                 &(jlmg1[mglc][nb]),&(jlmg2[mglc][nb]),
                 &(klmg1[mglc][nb]),&(klmg2[mglc][nb]),
                 mapmg[mglc][nb],
                 keymg[mglf][nb],keymg[mglc][nb],
                 cofmgy[mglf][nb],cofmgy[mglc][nb],
                 wrkmgy[mglf][nb],wrkmgy[mglc][nb]);
   }
return;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
FORTSUB $UPPERmgwork2y$USAN (FORTSUB (*subadd) (), PINT4 mglfa)
{
// *******************************************************************

// Calls a multigrid work routine that involves elements of 2 multigrid levels

// subadd = Name of the work routine (input).  The FORTRAN statement
// EXTERNAL WORK
// must appear in the subroutine that calls MGWORK1.

// mglfa = Multigrid level of the fine grid (input)

// The arguments of the work routines are:

// MGLF = Multigrid fine level

// NBLK = Grid-block number (input) (mod 1).

// IDIM = The X local dimension
// JDMGF, KDMGF = The first two local dimensions of fine grid arrays
// (input).  Space for communication layers are included in these dimensions.

// JDMGC, KDMGC = The first two local dimensions of course grid arrays
// (input).  Space for communication layers are included in these dimensions.

// IL1,IL2 = The smallest and largest local X indexes 
// JMG1F, JMG2F = The smallest and largest local 2d indexes for which the work
// KMG1F, KMG2F   routine is responsible in the fine grid (input).

// JMG1C, JMG2C = The smallest and largest local 2d indexes for which the work
// KMG1C, KMG2C   routine is responsible in the course grid (input).

// MAPMG(J,K) = Map from course grid to the fine grid (input)
//              See alcmga() for difinitions.  Course grid indexes are used.

// KEYMGF(J,K) = Keyout arrays (input)
// KEYMGC(J,K) 

// COFMGF(I,J,K,...) = 3d linear system coefficients (input and output)
// COFMGC(I,J,K,...)

// DUMGF(I,J,K,V) = 3d linear system coefficients (input and output)
// DUMGC(I,J,K,V)

// RESMGF(I,J,K,E) = 3d linear system residuals (input and output)
// RESMGC(I,J,K,E)

// *******************************************************************
int nbp, mglf, mglc;
int  nb;

mglf = (*mglfa) - 1L;
mglc = mglf + 1L;

for (nb = 0; nb < numblks; nb++)
   {
   if (myelem[nb] > 0)
      {
      nbp = nb + 1;
      (*subadd) (mglfa,&nbp,&(idim[nb]),&(jdimg[mglf][nb]),&(kdimg[mglf][nb]),
                 &(jdimg[mglc][nb]),&(kdimg[mglc][nb]),
                 &(iloc1[nb]),&(iloc2[nb]),
                 &(jlmg1[mglf][nb]),&(jlmg2[mglf][nb]),
                 &(klmg1[mglf][nb]),&(klmg2[mglf][nb]),
                 &(jlmg1[mglc][nb]),&(jlmg2[mglc][nb]),
                 &(klmg1[mglc][nb]),&(klmg2[mglc][nb]),
                 mapmg[mglc][nb],
                 keymg[mglf][nb],keymg[mglc][nb],
                 cofmgy[mglf][nb],cofmgy[mglc][nb],
                 wrkmgy[mglf][nb],wrkmgy[mglc][nb]);
      }
   }
return;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
FORTSUB $UPPERmgwork3yt$USAN (FORTSUB (*subadd) (), PINT4 mgla)
{
// *******************************************************************

// Calls a multigrid work routine that involves elements of a single
// multigrid level

// subadd = Name of the work routine (input).  The FORTRAN statement
// EXTERNAL WORK
// must appear in the subroutine that calls MGWORK1.

// mglfa = Multigrid level of the fine grid (input)

// The arguments of the work routines are:

// MGLF = Multigrid fine level

// NBLK = Grid-block number (input) (mod 1).

// IDIM = The X local dimension
// JDMG, KDMG = The first two local dimensions of grid arrays
// (input).  Space for communication layers are included in these dimensions.

// IL1,IL2 = The smallest and largest local X indexes 
// JMG1, JMG2 = The smallest and largest local 2d indexes for which the work
// KMG1, KMG2   routine is responsible in the grid (input).

// MAPMG(J,K) = Map from course grid to the fine grid (input)
//              See alcmga() for difinitions.  Course grid indexes are used.

// KEYMG(J,K) = Keyout array (input)

// COFMG(I,J,K,...) = 3d linear system coefficients (input and output)

// DUMG(I,J,K,V) = 3d linear system coefficients (input and output)

// RESMG(I,J,K,E) = 3d linear system residuals (input and output)

// *******************************************************************
int nbp, mgl;
int  nb;

mgl = (*mgla) - 1L;

for (nb = 0; nb < numblks; nb++)
   {
      nbp = nb + 1;
      (*subadd) (mgla,&nbp,&(idim[nb]),&(jdimg[mgl][nb]),&(kdimg[mgl][nb]),
                 &(iloc1[nb]),&(iloc2[nb]),
                 &(jlmg1[mgl][nb]),&(jlmg2[mgl][nb]),
                 &(klmg1[mgl][nb]),&(klmg2[mgl][nb]),
                 mapmg[mgl][nb],keymg[mgl][nb],cofmgy[mgl][nb],
                 wrkmgy[mgl][nb]);
   }
return;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
FORTSUB $UPPERmgwork3y$USAN (FORTSUB (*subadd) (), PINT4 mgla)
{
// *******************************************************************

// Calls a multigrid work routine that involves elements of a single
// multigrid level

// subadd = Name of the work routine (input).  The FORTRAN statement
// EXTERNAL WORK
// must appear in the subroutine that calls MGWORK1.

// mglfa = Multigrid level of the fine grid (input)

// The arguments of the work routines are:

// MGLF = Multigrid fine level

// NBLK = Grid-block number (input) (mod 1).

// IDIM = The X local dimension
// JDMG, KDMG = The first two local dimensions of grid arrays
// (input).  Space for communication layers are included in these dimensions.

// IL1,IL2 = The smallest and largest local X indexes 
// JMG1, JMG2 = The smallest and largest local 2d indexes for which the work
// KMG1, KMG2   routine is responsible in the grid (input).

// MAPMG(J,K) = Map from course grid to the fine grid (input)
//              See alcmga() for difinitions.  Course grid indexes are used.

// KEYMG(J,K) = Keyout array (input)

// COFMG(I,J,K,...) = 3d linear system coefficients (input and output)

// DUMG(I,J,K,V) = 3d linear system coefficients (input and output)

// RESMG(I,J,K,E) = 3d linear system residuals (input and output)

// *******************************************************************
int nbp, mgl;
int  nb;

mgl = (*mgla) - 1L;

for (nb = 0; nb < numblks; nb++)
   {
   if (myelem[nb] > 0)
      {
      nbp = nb + 1;
      (*subadd) (mgla,&nbp,&(idim[nb]),&(jdimg[mgl][nb]),&(kdimg[mgl][nb]),
                 &(iloc1[nb]),&(iloc2[nb]),
                 &(jlmg1[mgl][nb]),&(jlmg2[mgl][nb]),
                 &(klmg1[mgl][nb]),&(klmg2[mgl][nb]),
                 mapmg[mgl][nb],keymg[mgl][nb],cofmgy[mgl][nb],
                 wrkmgy[mgl][nb]);
      }
   }
return;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
FORTSUB $UPPERmgwork4yt$USAN (FORTSUB (*subadd) (), PINT4 mgla)
{
// *******************************************************************

// Calls a multigrid work routine that involves elements of a single
// multigrid level

// subadd = Name of the work routine (input).  The FORTRAN statement
// EXTERNAL WORK
// must appear in the subroutine that calls MGWORK1.

// mglfa = Multigrid level of the fine grid (input)

// The arguments of the work routines are:

// MGLF = Multigrid fine level

// NBLK = Grid-block number (input) (mod 1).

// IDIM = The X local dimension
// JDMG, KDMG = The first two local dimensions of grid arrays
// (input).  Space for communication layers are included in these dimensions.

// IL1,IL2 = The smallest and largest local X indexes 
// JMG1, JMG2 = The smallest and largest local 2d indexes for which the work
// KMG1, KMG2   routine is responsible in the grid (input).

// MAPMG(J,K) = Map from course grid to the fine grid (input)
//              See alcmga() for difinitions.  Course grid indexes are used.

// KEYMG(J,K) = Keyout array (input)

// COFMG(I,J,K,...) = 3d linear system coefficients (input and output)

// DUMG(I,J,K,V) = 3d linear system coefficients (input and output)

// RESMG(I,J,K,E) = 3d linear system residuals (input and output)

// *******************************************************************
int nbp, mgl;
int  nb;

mgl = (*mgla) - 1L;

for (nb = 0; nb < numblks; nb++)
   {
      nbp = nb + 1;
      (*subadd) (mgla,&nbp,&(idim[nb]),&(jdimg[mgl][nb]),&(kdimg[mgl][nb]),
                 &(iloc1[nb]),&(iloc2[nb]),
                 &(jlmg1[mgl][nb]),&(jlmg2[mgl][nb]),
                 &(klmg1[mgl][nb]),&(klmg2[mgl][nb]),
                 mapmg[mgl][nb],keymg[mgl][nb],cofmgy[mgl][nb],
                 wrkmgy[mgl][nb],wrkmgbuf[nb]);
   }
return;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
FORTSUB $UPPERmgwork4y$USAN (FORTSUB (*subadd) (), PINT4 mgla)
{
// *******************************************************************

// Calls a multigrid work routine that involves elements of a single
// multigrid level

// subadd = Name of the work routine (input).  The FORTRAN statement
// EXTERNAL WORK
// must appear in the subroutine that calls MGWORK1.

// mglfa = Multigrid level of the fine grid (input)

// The arguments of the work routines are:

// MGLF = Multigrid fine level

// NBLK = Grid-block number (input) (mod 1).

// IDIM = The X local dimension
// JDMG, KDMG = The first two local dimensions of grid arrays
// (input).  Space for communication layers are included in these dimensions.

// IL1,IL2 = The smallest and largest local X indexes 
// JMG1, JMG2 = The smallest and largest local 2d indexes for which the work
// KMG1, KMG2   routine is responsible in the grid (input).

// MAPMG(J,K) = Map from course grid to the fine grid (input)
//              See alcmga() for difinitions.  Course grid indexes are used.

// KEYMG(J,K) = Keyout array (input)

// COFMG(I,J,K,...) = 3d linear system coefficients (input and output)

// DUMG(I,J,K,V) = 3d linear system coefficients (input and output)

// RESMG(I,J,K,E) = 3d linear system residuals (input and output)

// *******************************************************************
int nbp, mgl;
int  nb;

mgl = (*mgla) - 1L;

for (nb = 0; nb < numblks; nb++)
   {
   if (myelem[nb] > 0)
      {
      nbp = nb + 1;
      (*subadd) (mgla,&nbp,&(idim[nb]),&(jdimg[mgl][nb]),&(kdimg[mgl][nb]),
                 &(iloc1[nb]),&(iloc2[nb]),
                 &(jlmg1[mgl][nb]),&(jlmg2[mgl][nb]),
                 &(klmg1[mgl][nb]),&(klmg2[mgl][nb]),
                 mapmg[mgl][nb],keymg[mgl][nb],cofmgy[mgl][nb],
                 wrkmgy[mgl][nb],wrkmgbuf[nb]);
      }
   }
return;
}


