C*********************************************************************
C     YURI VASSILEVSKI    2/23/00  vasilevs@ticam.utexas.edu
C     We use MPI Library, since the finnish package pdc3d is based on MPI.
C     As a matter of fact, this is the interface between IPARS and (p)dc3d.
C     SUBROUTINE PRECPREP1(work routine) 
C                         is used for initialization of (p)dc3d:
C                         defining one dimensional matrices,
C                         memory allocation, and intialization itself
C     SUBROUTINE PRECSOL (work routine) 
C                         performs the action of the preconditioner
C     SUBROUTINE extrpl2hole produces extrapolation of  tridiagonal matrices
C                            to the holes (outside the domain) where they
C                            are not defined by TRAN3?
C     SUBROUTINE avrgnb averages the entries of tridiagonal matrices.
C                       May be useful for high geterogenuity.
C     SUBROUTINE PRECPREP2(work routine) 
C                         is used for initialization of (p)dc3d:
C                         defining two dimensional matrices,
C                         memory allocation, and intialization itself
C     SUBROUTINE extrpl2holeplane produces extrapolation 
C                         of  five-diagonal matrices
C                         to the holes (outside the domain) where they
C                         are not defined by TRAN3?
C*********************************************************************
      SUBROUTINE PRECPREP1(IDIM,JDIM,KDIM,LDIM,IL1,IL2,
     &                 JL1V,JL2V,KL1,KL2,
     &                 KEYOUT,NBLK, COF,RESID,
     &                 Value,Index,SEPARABLE,RHS_SEP)
C*********************************************************************
C  Preparation routine for the separable preconditioner, 
C  called from PRECPREPINI
C  COF(I,J,K,N,L,M)  = JACOBIAN COEFFICIENTS (OUTPUT, REAL*4)
C  RESID(I,J,K)      = RESIDUALS (OUTPUT, REAL*8)
C  Value(*)          = DATA FOR (p)dc3d (OUTPUT, REAL*8)
C  Index(*)          = DATA FOR (p)dc3d (OUTPUT, INTEGER*4)
C  SEPARABLE(*)      = TRACES OF JACOBIAN (INPUT, REAL*8),
C  RHS_SEP(*)        = WORK ARRAY (OUTPUT, REAL*8)
C***********************************************************************
$MANY      INCLUDE 'mpif.h'
      INCLUDE 'control.h'
      INCLUDE 'layout.h'

      INTEGER  JL1V(KDIM),JL2V(KDIM),    KEYOUT(IDIM,JDIM,KDIM)

      REAL*4 COF(IDIM,JDIM,KDIM,7,2,2)
      REAL*8 RESID(IDIM,JDIM,KDIM,2)

      real*8  Value(*),SEPARABLE(*),RHS_SEP(*)
      integer Index(*)

      INCLUDE 'sprb.h'

c  local variables
      logical init(3)
      integer ASendV($MXPROC+1),ASend($MXPROC+1),ADispl($MXPROC+1)
      integer hole1(2,$MXRECZP),hole2(2,$MXRECYP),hole3(2,$MXRECXP)
      integer KHOSTBLK,NBLK,Key($MXPROC)
      LOGICAL ONCEONLY1
      common/MyONCEONLY1/ONCEONLY1
      save/MyONCEONLY1/
      DATA ONCEONLY1 /.TRUE./


      call BLKOFF(NBLK,NXO,NYO,NZO,ierr)
      I0trace = ILINEINDX(NBLK) - NXO
      J0trace = JLINEINDX(NBLK) - NYO
      K0trace = KLINEINDX(NBLK) - NZO

C Get the distribution of processors for blocks and form the block communicators
C MPI_COMM_FBLOCK ( in case of many processors)
      IF (ONCEONLY1) THEN
         ONCEONLY1=.FALSE.
$MANY      DO 200 N = 1, NUMPRC
$MANY 200  Key(N)    = N
$MANY      MyFBLOCK = NUMBLK
$MANY      DO 500 N = 1, NUMBLK-1
$MANY      IF (MYPRC.GE.NPCBLK(N).and.MYPRC.LT.NPCBLK(N+1)) MyFBLOCK = N
$MANY  500 CONTINUE
$MANY      CALL MPI_COMM_SPLIT( MPI_COMM_WORLD, MyFBLOCK, Key,
$MANY     &                     MPI_COMM_FBLOCK, ierr)
      END IF

      MyID = 0
c  In case of many processors take valid trace lines
$MANY      CALL MPI_COMM_SIZE (MPI_COMM_FBLOCK,NUMPRCBLK,ierr)
$MANY      CALL MPI_COMM_RANK( MPI_COMM_FBLOCK, MyID, ierr )
      IF (.not.(K0trace.GE.KL1.and.K0trace.LE.KL2)) THEN
         MyID = -MyID
      END IF
      KHOSTBLK = MyID
$MANY      CALL MPI_ALLREDUCE(MyID,KHOSTBLK,1,MPI_INTEGER,MPI_MAX,
$MANY     &                   MPI_COMM_FBLOCK,ierr)
      IF (MyID.lt.0) MyID = -MyID

c   prepare data for (p)dc3d initialization
      init(1) = .false.
      init(2) = .true.
      init(3) = .true.
      ldf2(NBLK) = n2(NBLK)
      ldf3(NBLK) = n3(NBLK)

      ch(NBLK) = 0d0
c   x-component
      do 33 i = 1, n3(NBLK)
         a3(i,NBLK) = 0d0
         b3(i,NBLK) = 0d0
         d3(i,NBLK) = 1d0
33    continue
      do 3 i = IL1,IL2
         ii = i + NXO
         a3(ii,NBLK)=SEPARABLE(i)
         b3(ii,NBLK)=SEPARABLE(IDIM+i) 
3     continue
c    fill in tridiagonal matrices in the holes
      IF(MyID.eq.KHOSTBLK)call extrpl2hole(n3(NBLK),a3(1,NBLK),
     &                    b3(1,NBLK),hole3,1,ierr)
c     IF (MyID.eq.KHOSTBLK) THEN
c        write(*,*)'a3: ',(a3(i,NBLK),i=1,n3(NBLK))
c        write(*,*)'b3: ',(b3(i,NBLK),i=1,n3(NBLK))
c     END IF
      if (ierr.ne.0) goto 999
c    average tridiagonal matrices (to smear out heterogenuity)
c     do i = 1, 2
c     IF(MyID.eq.KHOSTBLK)call avrgnb(n3(NBLK),a3(1,NBLK),b3(1,NBLK))
c     end do

c    perturb tridiagonal matrix to avoid degeneracy
      b3(I0trace,NBLK) = 1.001*b3(I0trace,NBLK)
c Send a3,b3,d3 to all processors from MPI_COMM_FBLOCK
$MANY      CALL MPI_BCAST(a3(1,NBLK),n3(NBLK),MPI_DOUBLE_PRECISION,
$MANY     &               KHOSTBLK, MPI_COMM_FBLOCK, ierr )
$MANY      CALL MPI_BCAST(b3(1,NBLK),n3(NBLK),MPI_DOUBLE_PRECISION,
$MANY     &               KHOSTBLK, MPI_COMM_FBLOCK, ierr )
$MANY      CALL MPI_BCAST(d3(1,NBLK),n3(NBLK),MPI_DOUBLE_PRECISION,
$MANY     &               KHOSTBLK, MPI_COMM_FBLOCK, ierr )
c   y-component
      do 44 i = 1, n2(NBLK)
         a2(i,NBLK) = 0d0
         b2(i,NBLK) = 0d0
         d2(i,NBLK) = 1d0
44    continue
      JL1 = JL1V(KL1)
      do 1 k = KL1,KL2
         JL1 = min(JL1,JL1V(K))
1     continue
      JL2 = JL2V(KL1)
      do 2 k = KL1,KL2
         JL2 = max(JL2,JL2V(K))
2     continue
      do 4 j = JL1,JL2
         jj = j + NYO
         a2(jj,NBLK)=SEPARABLE(3*IDIM+j)
         b2(jj,NBLK)=SEPARABLE(3*IDIM+JDIM+j) 
4     continue
c    fill in tridiagonal matrices in the holes
      IF(MyID.eq.KHOSTBLK)call extrpl2hole(n2(NBLK),a2(1,NBLK),
     &                         b2(1,NBLK),hole2,2,ierr)
c     IF (MyID.eq.KHOSTBLK) THEN
c        write(*,*)'a2: ',(a2(i,NBLK),i=1,n2(NBLK))
c        write(*,*)'b2: ',(b2(i,NBLK),i=1,n2(NBLK))
c     END IF
      if (ierr.ne.0) goto 999
c    average tridiagonal matrices (to smear out heterogenuity)
c     do i = 1, 2
c     IF(MyID.eq.KHOSTBLK)call avrgnb(n2(NBLK),a2(1,NBLK),b2(1,NBLK))
c     end do
c Send a2,b2,d2 to all processors from MPI_COMM_FBLOCK
$MANY      CALL MPI_BCAST(a2(1,NBLK),n2(NBLK),MPI_DOUBLE_PRECISION,
$MANY     &               KHOSTBLK, MPI_COMM_FBLOCK, ierr )
$MANY      CALL MPI_BCAST(b2(1,NBLK),n2(NBLK),MPI_DOUBLE_PRECISION,
$MANY     &               KHOSTBLK, MPI_COMM_FBLOCK, ierr )
$MANY      CALL MPI_BCAST(d2(1,NBLK),n2(NBLK),MPI_DOUBLE_PRECISION,
$MANY     &               KHOSTBLK, MPI_COMM_FBLOCK, ierr )
c   z-component
      kk = 0
      do 5 k = KL1,KL2
         kk = kk + 1
         a1(kk,NBLK)=SEPARABLE(3*IDIM+3*JDIM+k)
         b1(kk,NBLK)=SEPARABLE(3*IDIM+3*JDIM+KDIM+k)  
         d1(kk,NBLK)= 1d0
 5    continue
      n1(NBLK) = KL2-KL1+1
c    in case of many processors merge arrays
$MANY      do 6 i = 1, NUMPRCBLK
$MANY         ASend(i) = 1
$MANY         ADispl(i) = i-1
$MANY6     continue
$MANY      call MPI_ALLGATHERV( n1(NBLK), 1, MPI_INTEGER,
$MANY     &     ASendV,ASend,ADispl, MPI_INTEGER, MPI_COMM_FBLOCK,ierr)
$MANY      ADispl(1) = 0
$MANY      do 7 i = 2, NUMPRCBLK
$MANY         ADispl(i) = ADispl(i-1)+ASendV(i-1)   
$MANY7     continue
c Merge a1,b1,d1 and send them to all processors from MPI_COMM_FBLOCK
$MANY      call MPI_ALLGATHERV( a1(1,NBLK), n1(NBLK), MPI_DOUBLE_PRECISION,
$MANY     &     a1(1,NBLK),ASendV,ADispl,MPI_DOUBLE_PRECISION,
$MANY     &     MPI_COMM_FBLOCK,ierr )
$MANY      call MPI_ALLGATHERV( b1(1,NBLK), n1(NBLK), MPI_DOUBLE_PRECISION,
$MANY     &     b1(1,NBLK),ASendV,ADispl,MPI_DOUBLE_PRECISION,
$MANY     &     MPI_COMM_FBLOCK,ierr )
$MANY      call MPI_ALLGATHERV( d1(1,NBLK), n1(NBLK), MPI_DOUBLE_PRECISION,
$MANY     &     d1(1,NBLK),ASendV,ADispl,MPI_DOUBLE_PRECISION,
$MANY     &     MPI_COMM_FBLOCK,ierr )
$MANY      call MPI_ALLREDUCE(KL2-KL1+1,n1(NBLK),1,MPI_INTEGER,MPI_SUM,
$MANY     &                   MPI_COMM_FBLOCK,ierr)
c    fill in tridiagonal matrices in the holes
      call extrpl2hole(n1(NBLK),a1(1,NBLK),b1(1,NBLK),hole1,3,ierr)
c     IF (MyID.eq.KHOSTBLK) THEN
c        write(*,*)'a1: ',(a1(i,NBLK),i=1,n1(NBLK))
c        write(*,*)'b1: ',(b1(i,NBLK),i=1,n1(NBLK))
c     END IF
      if (ierr.ne.0) goto 999
c    average tridiagonal matrices (to smear out heterogenuity)
c     do i = 1, 2
c     call avrgnb(n1(NBLK),a1(1,NBLK),b1(1,NBLK))
c     end do

c  initialization of (p)dc3d. Here we are sure that there is enough room
c  in Value,Index
$MANY      call pdc3d(n1(NBLK),n2(NBLK),n3(NBLK),RHS_SEP,ldf2(NBLK),
$MANY     &           ldf3(NBLK),ilf(NBLK),iuf(NBLK),
$MANY     &           a1(1,NBLK),b1(1,NBLK),d1(1,NBLK),
$MANY     &           a2(1,NBLK),b2(1,NBLK),d2(1,NBLK),
$MANY     &           a3(1,NBLK),b3(1,NBLK),d3(1,NBLK),ch(NBLK),
$MANY     &           Value,Lvalue(NBLK),Index,Lindex(NBLK),
$MANY     &           MPI_COMM_FBLOCK,init,.false.,ierr)
$MANY      GOTO 999
      call dc3d(n1(NBLK),n2(NBLK),n3(NBLK),
     &          RHS_SEP,ldf2(NBLK),ldf3(NBLK),
     &          a1(1,NBLK),b1(1,NBLK),d1(1,NBLK),
     &          a2(1,NBLK),b2(1,NBLK),d2(1,NBLK),
     &          a3(1,NBLK),b3(1,NBLK),d3(1,NBLK),ch(NBLK),
     &          Value,Lvalue(NBLK),Index,Lindex(NBLK),
     &          .true.,.false.,ierr)
999   CONTINUE
      if (ierr.ne.0) then
         WRITE(NFOUT,*) 'Error no ', ierr, ' in initialization'
         IF (LEVERR.lt.3) LEVERR = 3
         if(levelc) write(NFOUT,*)  'FATAL ERROR in PRECPREP'
         if(levelc) write(NFOUT,*)
     &     '***************************************************'
         call SLDIE("Not possible to continue")
      end if
      RETURN
      END

C***********************************************************************
      SUBROUTINE PRECSOL(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                 KEYOUT,NBLK, COF,RESID,
     &                 Value,Index,SEPARABLE,RHS_SEP)
C*********************************************************************
C  {SEPARABLE}^{-1} RESID(I,J,K,1) => RESID(I,J,K,1)
C  COF(I,J,K,N,L,M)  = JACOBIAN COEFFICIENTS (OUTPUT, REAL*4)
C  RESID(I,J,K)      = RESIDUALS (OUTPUT, REAL*8)
C  Value(*)          = DATA FOR (p)dc3d (OUTPUT, REAL*8)
C  Index(*)          = DATA FOR (p)dc3d (OUTPUT, INTEGER*4)
C  SEPARABLE(*)      = WORK ARRAY (OUTPUT, REAL*8)
C  RHS_SEP(*)        = WORK ARRAY (OUTPUT, REAL*8)
C***********************************************************************
$MANY      INCLUDE 'mpif.h'
      INCLUDE 'control.h'

      INTEGER  JL1V(KDIM),JL2V(KDIM),    KEYOUT(IDIM,JDIM,KDIM)

      REAL*4 COF(IDIM,JDIM,KDIM,7,2,2)
      REAL*8 RESID(IDIM,JDIM,KDIM,2)

      real*8  Value(*),SEPARABLE(*),RHS_SEP(*)
      integer Index(*)

      INCLUDE 'sprb.h'

      logical init(3)



      call BLKOFF(NBLK,NXO,NYO,NZO,ierr)

      DO 1 K=1,KL2-KL1+1
      DO 1 J=1,n2(NBLK)
      DO 1 I=1,n3(NBLK)
       call SEPeqVAL(RHS_SEP,ldf3(NBLK),ldf2(NBLK),I,J,K,0d0)
  1   CONTINUE

      DO 2 K=KL1,KL2
      JL1=JL1V(K)
      JL2=JL2V(K)
      DO 2 J=JL1,JL2
      DO 2 I=IL1,IL2
       IF (KEYOUT(I,J,K).NE.1) GO TO 2
       call SEPeqVAL(RHS_SEP,ldf3(NBLK),ldf2(NBLK),
     &               I+NXO,J+NYO,K-KL1+1,RESID(I,J,K,1))
  2   CONTINUE

      init(1) = .false.
      init(2) = .false.
      init(3) = .false.

$MANY      call pdc3d(n1(NBLK),n2(NBLK),n3(NBLK),RHS_SEP,ldf2(NBLK),
$MANY     &           ldf3(NBLK),ilf(NBLK),iuf(NBLK),
$MANY     &           a1(1,NBLK),b1(1,NBLK),d1(1,NBLK),
$MANY     &           a2(1,NBLK),b2(1,NBLK),d2(1,NBLK),
$MANY     &           a3(1,NBLK),b3(1,NBLK),d3(1,NBLK),ch(NBLK),
$MANY     &           Value,Lvalue(NBLK),Index,Lindex(NBLK),
$MANY     &           MPI_COMM_FBLOCK,init,heter,ierr)
$MANY      GOTO 999
      call dc3d(n1(NBLK),n2(NBLK),n3(NBLK),
     &          RHS_SEP,ldf2(NBLK),ldf3(NBLK),
     &          a1(1,NBLK),b1(1,NBLK),d1(1,NBLK),
     &          a2(1,NBLK),b2(1,NBLK),d2(1,NBLK),
     &          a3(1,NBLK),b3(1,NBLK),d3(1,NBLK),ch(NBLK),
     &          Value,Lvalue(NBLK),Index,Lindex(NBLK),
     &          .false.,heter,ierr)
999   CONTINUE
      if (ierr.ne.0) then
         WRITE(NFOUT,*) 'Error no ', ierr, ' in solution'
         IF (LEVERR.lt.3) LEVERR = 3
         if(levelc) write(NFOUT,*)  'FATAL ERROR in PRECSOL'
         if(levelc) write(NFOUT,*)
     &     '***************************************************'
         return
      end if

      DO 3 K=KL1,KL2
      JL1=JL1V(K)
      JL2=JL2V(K)
      DO 3 J=JL1,JL2
      DO 3 I=IL1,IL2
       IF (KEYOUT(I,J,K).NE.1) GO TO 3
       call VALeqSEP(RHS_SEP,ldf3(NBLK),ldf2(NBLK),
     &               I+NXO,J+NYO,K-KL1+1,RESID(I,J,K,1))
  3   CONTINUE

      RETURN
      END


      subroutine SEPeqVAL(SEP,LD1,LD2,I,J,K,VAL)
      integer LD1,LD2,I,J,K
      real*8  SEP(LD1,LD2,*),VAL
         SEP(I,J,K) = VAL
      return
      end
      subroutine VALeqSEP(SEP,LD1,LD2,I,J,K,VAL)
      integer LD1,LD2,I,J,K
      real*8  SEP(LD1,LD2,*),VAL
         VAL = SEP(I,J,K)
      return
      end

C   Extrapolate the tridiagonal matrix into the hole where it is 0
      subroutine extrpl2hole(iel,a,b,hole,axis,ierr)
      double precision a(*),b(*)
      integer iel,hole(2,*),axis,ierr

      integer ih,i, j

      INCLUDE 'control.h'

      ierr = 0

c     write(NFOUT,'(i2,a,100f9.3)')axis,'b:',(b(i),i=1,iel)
c     write(NFOUT,'(i2,a,100f9.3)')axis,'a:',(a(i),i=1,iel)

c Count holes, find their bounds
      ih = 0
      do i = 1, iel
         if (b(i).eq.0d0) then
           if (ih.eq.0) then
            ih = ih + 1
            hole(1,ih) = i
            hole(2,ih) = i
           else
            if (hole(2,ih).eq.i-1) then
               hole(2,ih) = i
            else
               ih = ih + 1
               hole(1,ih) = i
               hole(2,ih) = i
            end if
           end if
         end if
      end do
 
c Extrapolate a,b to the holes
      do i = 1,ih
        if (hole(1,i).eq.1.and.hole(2,i).eq.iel) then
         write(NFOUT,*)axis,'index: line is out of the domain'
     &,  hole(1,i),hole(2,i),iel
         IF (LEVERR.lt.3) LEVERR = 3
         if(levelc) write(NFOUT,*)  'FATAL ERROR in extrpl2hole'
         if(levelc) write(NFOUT,*)
     &     '***************************************************'
         ierr = 1
         return
        else if (hole(1,i).eq.1) then
            do j = hole(2,i)+1,hole(1,i),-1
               if (j.gt.1) then
                  a(j) = a(j+1)
                  b(j-1) = abs(a(j))
               else
                  a(j) = 0d0
               end if
               b(j) = b(j)+abs(a(j))
            end do
        else if (hole(2,i).eq.iel) then
            do j = hole(1,i)-1,hole(2,i)
               if (j.lt.iel) then
                  a(j+1) = a(j)
                  b(j) = b(j)+abs(a(j+1))
                  b(j+1) = abs(a(j+1))
               end if
            end do
        else
            do j = hole(1,i)-1,hole(2,i)
               a(j+1) = a(hole(2,i)+2)
               b(j) = b(j)+abs(a(j+1))
               if (j+1.lt.hole(2,i)+1) then
                  b(j+1) = abs(a(j+1))
               else
                  b(j+1) = b(j+1) + abs(a(j+1))
               end if
            end do
        end if
       end do

c     write(*,'(i2,a,100f9.3)')axis,'b:',(b(i),i=1,iel)
c     write(*,'(i2,a,100f9.3)')axis,'a:',(a(i),i=1,iel)
      return
      end

c  Average the tridiagonal matrix to smear out heterogenuity
      subroutine avrgnb(iel,a,b)
      implicit none
      double precision a(*),b(*)
      integer iel
 
      integer i, j, mxdim
      parameter (mxdim=$MXRECYP+$MXRECZP+$MXRECXP)
      double precision ac(mxdim),bc(mxdim)

      do i = 1, iel
         ac(i) = a(i)
         bc(i) = b(i)
      end do
      ac(1) = 0
      ac(iel+1) = 0

      do i = 3, iel-2
         a(i) = (ac(i-1)+ac(i)+ac(i+1))/3.
         b(i) = (bc(i-1)+bc(i)+bc(i+1))/3.
      end do
      a(2) = (ac(2)+ac(3))/2.
      b(2) = -(a(2)+a(3))
      b(1) = -a(2)
      a(iel-1) = -b(iel-2)-a(iel-2)
      b(iel-1) = (bc(iel-1)+bc(iel-2))/2.
      a(iel) = -b(iel-1)-a(iel-1)
      b(iel) = -a(iel)

c     write(*,'(a,100f9.3)')'-b:',(b(i),i=1,iel)
c     write(*,'(a,100f9.3)')'-a:',(a(i),i=1,iel)
      return
      end

      

C*********************************************************************
      SUBROUTINE PRECPREP2(IDIM,JDIM,KDIM,LDIM,IL1,IL2,
     &                 JL1V,JL2V,KL1,KL2,
     &                 KEYOUT,NBLK, COF,RESID,
     &                 Value,Index,SEPARABLE,RHS_SEP)
C*********************************************************************
C  Preparation routine for the separable preconditioner, 
C  called from PRECPREPINI
C  COF(I,J,K,N,L,M)  = JACOBIAN COEFFICIENTS (OUTPUT, REAL*4)
C  RESID(I,J,K)      = RESIDUALS (OUTPUT, REAL*8)
C  Value(*)          = DATA FOR (p)dc3d (OUTPUT, REAL*8)
C  Index(*)          = DATA FOR (p)dc3d (OUTPUT, INTEGER*4)
C  SEPARABLE(*)      = TRACES OF JACOBIAN (INPUT, REAL*8),
C  RHS_SEP(*)        = WORK ARRAY (OUTPUT, REAL*8)
C***********************************************************************
$MANY      INCLUDE 'mpif.h'
      INCLUDE 'control.h'
      INCLUDE 'layout.h'

      INTEGER  JL1V(KDIM),JL2V(KDIM),    KEYOUT(IDIM,JDIM,KDIM)

      REAL*4 COF(IDIM,JDIM,KDIM,7,2,2)
      REAL*8 RESID(IDIM,JDIM,KDIM,2)

      real*8  Value(*),SEPARABLE(*),RHS_SEP(*)
      integer Index(*)

      INCLUDE 'sprb.h'

c  local variables
      logical init(3)
      integer ASendV($MXPROC+1),ASend($MXPROC+1),ADispl($MXPROC+1)
      integer hole1(2,$MXRECZP),hole2(2,$MXRECYP),hole3(2,$MXRECXP)
      integer hole23(2,$MXRECXP+$MXRECYP)
      integer KHOSTBLK,NBLK,Key($MXPROC)
      LOGICAL ONCEONLY2
      common/MyONCEONLY2/ONCEONLY2
      save/MyONCEONLY2/
      DATA ONCEONLY2 /.TRUE./


      call BLKOFF(NBLK,NXO,NYO,NZO,ierr)
      I0trace = ILINEINDX(NBLK) - NXO
      J0trace = JLINEINDX(NBLK) - NYO
      K0trace = KLINEINDX(NBLK) - NZO

C Get the distribution of processors for blocks and form the block communicators
C MPI_COMM_FBLOCK ( in case of many processors)
      IF (ONCEONLY2) THEN
         ONCEONLY2=.FALSE.
$MANY      DO 200 N = 1, NUMPRC
$MANY 200  Key(N)    = N
$MANY      MyFBLOCK = NUMBLK
$MANY      DO 500 N = 1, NUMBLK-1
$MANY      IF (MYPRC.GE.NPCBLK(N).and.MYPRC.LT.NPCBLK(N+1)) MyFBLOCK = N
$MANY  500 CONTINUE
$MANY      CALL MPI_COMM_SPLIT( MPI_COMM_WORLD, MyFBLOCK, Key,
$MANY     &                     MPI_COMM_FBLOCK, ierr)
      END IF

      MyID = 0
c  In case of many processors take valid trace lines
$MANY      CALL MPI_COMM_SIZE (MPI_COMM_FBLOCK,NUMPRCBLK,ierr)
$MANY      CALL MPI_COMM_RANK( MPI_COMM_FBLOCK, MyID, ierr )
      IF (.not.(K0trace.GE.KL1.and.K0trace.LE.KL2)) THEN
         MyID = -MyID
      END IF
      KHOSTBLK = MyID
$MANY      CALL MPI_ALLREDUCE(MyID,KHOSTBLK,1,MPI_INTEGER,MPI_MAX,
$MANY     &                   MPI_COMM_FBLOCK,ierr)
      IF (MyID.lt.0) MyID = -MyID

c   prepare data for (p)dc3d initialization
      init(1) = .false.
      init(2) = .true.
      init(3) = .true.
      ldf2(NBLK) = n2(NBLK)
      ldf3(NBLK) = n3(NBLK)

      ch(NBLK) = 0d0
c  x+y-component
      do 44 k = 1, n3(NBLK)*n2(NBLK)
         a3(k,NBLK) = 0d0
         b3(k,NBLK) = 0d0
         d3(k,NBLK) = 1d0
         a2(k,NBLK) = 0d0
         b2(k,NBLK) = 0d0
         d2(k,NBLK) = 1d0
44    continue
      JL1 = JL1V(KL1)
      do 1 k = KL1,KL2
         JL1 = min(JL1,JL1V(K))
1     continue
      JL2 = JL2V(KL1)
      do 2 k = KL1,KL2
         JL2 = max(JL2,JL2V(K))
2     continue
      do 4 i = IL1,IL2
      do 4 j = JL1,JL2
         jj = j + NYO
         ii = i + NXO
         k = ii+(jj-1)*n3(NBLK)
         a3(k,NBLK)=SEPARABLE(IDIM*(j-1)+i)
         b3(k,NBLK)=SEPARABLE(IDIM*(j-1)+i+IDIM*JDIM)
         a2(k,NBLK)=SEPARABLE(IDIM*(j-1)+i+IDIM*JDIM*3)
         b2(k,NBLK)=SEPARABLE(IDIM*(j-1)+i+IDIM*JDIM*4)
4     continue
c    fill in tridiagonal matrices in the holes
      IF(MyID.eq.KHOSTBLK)call extrpl2holeplane(n2(NBLK),n3(NBLK),
     &   a2(1,NBLK),b2(1,NBLK),d2(1,NBLK),
     &   a3(1,NBLK),b3(1,NBLK),d3(1,NBLK),
     &   hole23)
      if (ierr.ne.0) goto 999
c Send a2,b2,a3,b3 to all processors from MPI_COMM_FBLOCK
$MANY      CALL MPI_BCAST(a2(1,NBLK),n2(NBLK)*n3(NBLK),MPI_DOUBLE_PRECISION,
$MANY     &               KHOSTBLK, MPI_COMM_FBLOCK, ierr )
$MANY      CALL MPI_BCAST(b2(1,NBLK),n2(NBLK)*n3(NBLK),MPI_DOUBLE_PRECISION,
$MANY     &               KHOSTBLK, MPI_COMM_FBLOCK, ierr )
$MANY      CALL MPI_BCAST(d2(1,NBLK),n2(NBLK)*n3(NBLK),MPI_DOUBLE_PRECISION,
$MANY     &               KHOSTBLK, MPI_COMM_FBLOCK, ierr )
$MANY      CALL MPI_BCAST(a3(1,NBLK),n2(NBLK)*n3(NBLK),MPI_DOUBLE_PRECISION,
$MANY     &               KHOSTBLK, MPI_COMM_FBLOCK, ierr )
$MANY      CALL MPI_BCAST(b3(1,NBLK),n2(NBLK)*n3(NBLK),MPI_DOUBLE_PRECISION,
$MANY     &               KHOSTBLK, MPI_COMM_FBLOCK, ierr )
$MANY      CALL MPI_BCAST(d3(1,NBLK),n2(NBLK)*n3(NBLK),MPI_DOUBLE_PRECISION,
$MANY     &               KHOSTBLK, MPI_COMM_FBLOCK, ierr )
c    perturb five diagonal matrix to avoid degeneracy
      jj = J0trace + NYO
      ii = I0trace + NXO
      k =  ii+(jj-1)*n3(NBLK)
      b3(k,NBLK) = 1.001*b3(k,NBLK)
      b2(k,NBLK) = 1.001*b2(k,NBLK)
c   z-component
      kk = 0
      do 5 k = KL1,KL2
         kk = kk + 1
         a1(kk,NBLK)=SEPARABLE(6*IDIM*JDIM+k)
         b1(kk,NBLK)=SEPARABLE(6*IDIM*JDIM+KDIM+k)  
         d1(kk,NBLK)= 1d0
 5    continue
      n1(NBLK) = KL2-KL1+1
c    in case of many processors merge arrays
$MANY      do 6 i = 1, NUMPRCBLK
$MANY         ASend(i) = 1
$MANY         ADispl(i) = i-1
$MANY6     continue
$MANY      call MPI_ALLGATHERV( n1(NBLK), 1, MPI_INTEGER,
$MANY     &     ASendV,ASend,ADispl, MPI_INTEGER, MPI_COMM_FBLOCK,ierr)
$MANY      ADispl(1) = 0
$MANY      do 7 i = 2, NUMPRCBLK
$MANY         ADispl(i) = ADispl(i-1)+ASendV(i-1)   
$MANY7     continue
c Merge a1,b1,d1 and send them to all processors from MPI_COMM_FBLOCK
$MANY      call MPI_ALLGATHERV( a1(1,NBLK), n1(NBLK), MPI_DOUBLE_PRECISION,
$MANY     &     a1(1,NBLK),ASendV,ADispl,MPI_DOUBLE_PRECISION,
$MANY     &     MPI_COMM_FBLOCK,ierr )
$MANY      call MPI_ALLGATHERV( b1(1,NBLK), n1(NBLK), MPI_DOUBLE_PRECISION,
$MANY     &     b1(1,NBLK),ASendV,ADispl,MPI_DOUBLE_PRECISION,
$MANY     &     MPI_COMM_FBLOCK,ierr )
$MANY      call MPI_ALLGATHERV( d1(1,NBLK), n1(NBLK), MPI_DOUBLE_PRECISION,
$MANY     &     d1(1,NBLK),ASendV,ADispl,MPI_DOUBLE_PRECISION,
$MANY     &     MPI_COMM_FBLOCK,ierr )
$MANY      call MPI_ALLREDUCE(KL2-KL1+1,n1(NBLK),1,MPI_INTEGER,MPI_SUM,
$MANY     &                   MPI_COMM_FBLOCK,ierr)
c    fill in tridiagonal matrices in the holes
      call extrpl2hole(n1(NBLK),a1(1,NBLK),b1(1,NBLK),hole1,3,ierr)
      if (ierr.ne.0) goto 999
c    average tridiagonal matrices (to smear out heterogenuity)
c     do i = 1, 2
c     call avrgnb(n1(NBLK),a1(1,NBLK),b1(1,NBLK))
c     end do

c  initialization of (p)dc3d. Here we are sure that there is enough room
c  in Value,Index
$MANY      call pdc3d(n1(NBLK),n2(NBLK),n3(NBLK),RHS_SEP,ldf2(NBLK),
$MANY     &           ldf3(NBLK),ilf(NBLK),iuf(NBLK),
$MANY     &           a1(1,NBLK),b1(1,NBLK),d1(1,NBLK),
$MANY     &           a2(1,NBLK),b2(1,NBLK),d2(1,NBLK),
$MANY     &           a3(1,NBLK),b3(1,NBLK),d3(1,NBLK),ch(NBLK),
$MANY     &           Value,Lvalue(NBLK),Index,Lindex(NBLK),
$MANY     &           MPI_COMM_FBLOCK,init,.true.,ierr)
$MANY      GOTO 999
      call dc3d(n1(NBLK),n2(NBLK),n3(NBLK),
     &          RHS_SEP,ldf2(NBLK),ldf3(NBLK),
     &          a1(1,NBLK),b1(1,NBLK),d1(1,NBLK),
     &          a2(1,NBLK),b2(1,NBLK),d2(1,NBLK),
     &          a3(1,NBLK),b3(1,NBLK),d3(1,NBLK),ch(NBLK),
     &          Value,Lvalue(NBLK),Index,Lindex(NBLK),
     &          .true.,.true.,ierr)
999   CONTINUE
      if (ierr.ne.0) then
         WRITE(NFOUT,*) 'Error no ', ierr, ' in initialization'
         IF (LEVERR.lt.3) LEVERR = 3
         if(levelc) write(NFOUT,*)  'FATAL ERROR in PRECPREP'
         if(levelc) write(NFOUT,*)
     &     '***************************************************'
         call SLDIE("Not possible to continue")
      end if
      RETURN
      END


C   Extrapolate the five diagonal matrix into the hole where it is 0
      subroutine extrpl2holeplane(iel2,iel3,a2,b2,d2,a3,b3,d3,hole)
      implicit none
      double precision a2(*),b2(*),d2(*),a3(*),b3(*),d3(*)
      integer iel3,iel2,hole(2,*),empty($MXRECXP+$MXRECYP)

      integer ih,i,m, j,k,j1,j2,i1,i2,nem


      nem = 0
      do j = 1,iel2
c Count holes, find their bounds
      ih = 0
      do i = 1, iel3
         if (b3(i+(j-1)*iel3).eq.0d0) then
           if (ih.eq.0) then
            ih = ih + 1
            hole(1,ih) = i
            hole(2,ih) = i
           else
            if (hole(2,ih).eq.i-1) then
               hole(2,ih) = i
            else
               ih = ih + 1
               hole(1,ih) = i
               hole(2,ih) = i
            end if
           end if
         end if
      end do

c Extrapolate a,b to the holes
      do m = 1,ih
        if (hole(1,m).eq.1.and.hole(2,m).eq.iel3) then
           nem = nem + 1
           empty(nem) = j
        else if (hole(1,m).eq.1) then
            do i = hole(2,m)+1,hole(1,m),-1
               if (i.gt.1) then
                  a3(i+(j-1)*iel3) = a3(i+1+(j-1)*iel3)
                  b3(i-1+(j-1)*iel3) = abs(a3(i+(j-1)*iel3))
               else
                  a3(i+(j-1)*iel3) = 0d0
               end if
               b3(i+(j-1)*iel3) = b3(i+(j-1)*iel3)+abs(a3(i+(j-1)*iel3))
            end do
        else if (hole(2,m).eq.iel3) then
            do i = hole(1,m)-1,hole(2,m)
               if (i.lt.iel3) then
                  a3(i+1+(j-1)*iel3) = a3(i+(j-1)*iel3)
                  b3(i+(j-1)*iel3) = b3(i+(j-1)*iel3)
     &                              +abs(a3(i+1+(j-1)*iel3))
                  b3(i+1+(j-1)*iel3) = abs(a3(i+1+(j-1)*iel3))
               end if
            end do
        else
            do i = hole(1,m)-1,hole(2,m)
               a3(i+1+(j-1)*iel3) = a3(hole(2,m)+2+(j-1)*iel3)
               b3(i+(j-1)*iel3) = b3(i+(j-1)*iel3)
     &                           +abs(a3(i+1+(j-1)*iel3))
               if (i+1.lt.hole(2,m)+1) then
                  b3(i+1+(j-1)*iel3) = abs(a3(i+1+(j-1)*iel3))
               else
                  b3(i+1+(j-1)*iel3) = b3(i+1+(j-1)*iel3)
     &                               + abs(a3(i+1+(j-1)*iel3))
               end if
            end do
        end if
       end do
      end do
      j1 = 0
      j2 = iel2+1
      if (nem.eq.0) goto 1
      if (empty(1).eq.1.and.empty(nem).eq.iel2) then
        do k = 1, nem
         if (empty(k).ne.empty(k+1)-1) then
            j1 = empty(k)
            j2 = empty(k+1)
            goto 1
         end if
        end do
      else if (empty(1).eq.1.and.empty(nem).ne.iel2) then
        j1 = empty(nem)
      else if (empty(1).ne.1.and.empty(nem).eq.iel2) then
        j2 = empty(1)
      else if (empty(1).ne.1.and.empty(nem).ne.iel2) then
        write(*,*)"Bad domain, cannot process..."
        stop
      end if
 1    continue
      do j = j1,1,-1
         do i = 1, iel3
            b3(i+(j-1)*iel3) = b3(i+(j-0)*iel3)
            a3(i+(j-1)*iel3) = a3(i+(j-0)*iel3)
         end do
      end do
      do j = j2,iel2
         do i = 1, iel3
            b3(i+(j-1)*iel3) = b3(i+(j-2)*iel3)
            a3(i+(j-1)*iel3) = a3(i+(j-2)*iel3)
         end do
      end do

      nem = 0
      do i = 1,iel3
c Count holes, find their bounds
      ih = 0
      do j = 1, iel2
         if (b2(i+(j-1)*iel3).eq.0d0) then
           if (ih.eq.0) then
            ih = ih + 1
            hole(1,ih) = j
            hole(2,ih) = j
           else
            if (hole(2,ih).eq.j-1) then
               hole(2,ih) = j
            else
               ih = ih + 1
               hole(1,ih) = j
               hole(2,ih) = j
            end if
           end if
         end if
      end do

c Extrapolate a,b to the holes
      do m = 1,ih
        if (hole(1,m).eq.1.and.hole(2,m).eq.iel2) then
           nem = nem + 1
           empty(nem) = j
        else if (hole(1,m).eq.1) then
            do j = hole(2,m)+1,hole(1,m),-1
               if (j.gt.1) then
                  a2(i+(j-1)*iel3) = a2(i+(j-0)*iel3)
                  b2(i+(j-2)*iel3) = abs(a2(i+(j-1)*iel3))
               else
                  a2(i+(j-1)*iel3) = 0d0
               end if
               b2(i+(j-1)*iel3) = b2(i+(j-1)*iel3)+abs(a2(i+(j-1)*iel3))
            end do
        else if (hole(2,m).eq.iel2) then
            do j = hole(1,m)-1,hole(2,m)
               if (j.lt.iel2) then
                  a2(i+(j-0)*iel3) = a2(i+(j-1)*iel3)
                  b2(i+(j-1)*iel3) = b2(i+(j-1)*iel3)
     &                              +abs(a2(i+(j-0)*iel3))
                  b2(i+(j-0)*iel3) = abs(a2(i+(j-0)*iel3))
               end if
            end do
        else
            do j = hole(1,m)-1,hole(2,m)
               a2(i+(j-0)*iel3) = a2(i+(hole(2,m)+2-1)*iel3)
               b2(i+(j-1)*iel3) = b2(i+(j-1)*iel3)
     &                           +abs(a2(i+(j-0)*iel3))
               if (j+1.lt.hole(2,m)+1) then
                  b2(i+(j-0)*iel3) = abs(a2(i+(j-0)*iel3))
               else
                  b2(i+(j-0)*iel3) = b2(i+(j-0)*iel3)
     &                               + abs(a2(i+(j-0)*iel3))
               end if
            end do
        end if
       end do
      end do
      i1 = 0
      i2 = iel3+1
      if (nem.eq.0) goto 2
      if (empty(1).eq.1.and.empty(nem).eq.iel3) then
        do k = 1, nem
         if (empty(k).ne.empty(k+1)-1) then
            i1 = empty(k)
            i2 = empty(k+1)
            goto 2
         end if
        end do
      else if (empty(1).eq.1.and.empty(nem).ne.iel3) then
        i1 = empty(nem)
      else if (empty(1).ne.1.and.empty(nem).eq.iel3) then
        i2 = empty(1)
      else if (empty(1).ne.1.and.empty(nem).ne.iel3) then
        write(*,*)"Bad domain, cannot process..."
        stop
      end if
 2    continue
      do i = i1,1,-1
         do j = 1, iel2
            b2(i+(j-1)*iel3) = b2(i+1+(j-1)*iel3)
            a2(i+(j-1)*iel3) = a2(i+1+(j-1)*iel3)
         end do
      end do
      do i = i2,iel3
         do j = 1, iel2
            b2(i+(j-1)*iel3) = b2(i-1+(j-1)*iel3)
            a2(i+(j-1)*iel3) = a2(i-1+(j-1)*iel3)
         end do
      end do


      return
      end

      

C*********************************************************************
      SUBROUTINE MRKDNK(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                 KEYOUT,NBLK,DUNK)
C*********************************************************************
C  THIS IS A WORK ROUTINE.
C  ROUTINE MARKS DUNK ACCORDING THE RULE: 
C  0.0 - CLOSE-TO-INTERFACE CELLS
C  0.5 - THEIR NEIGHBORS
C  1.0 - THE REST
C***********************************************************************
      INCLUDE 'control.h'
      INCLUDE 'layout.h'

      INTEGER JL1V(KDIM),JL2V(KDIM),    KEYOUT(IDIM,JDIM,KDIM)
      REAL*8  DUNK(IDIM,JDIM,KDIM)

      LOGICAL  OK

      DO 10 K=1,KDIM
      DO 10 J=1,JDIM
      DO 10 I=1,IDIM
         DUNK(I,J,K) = 1D0
 10   CONTINUE


      DO 30 K=KL1,KL2
      JL1=JL1V(K)
      JL2=JL2V(K)
      DO 30 J=JL1,JL2
      OK = .FALSE.
       DO 20 I=IL1,IL2
        IF (KEYOUT(I,J,K).EQ.1) THEN
        IF(K.GT.1   .AND.KEYOUT(I,J,K-1).EQ.-1) OK=.TRUE.
        IF(K.LT.KDIM.AND.KEYOUT(I,J,K+1).EQ.-1) OK=.TRUE.
        IF(J.GT.1   .AND.KEYOUT(I,J-1,K).EQ.-1) OK=.TRUE.
        IF(J.LT.JDIM.AND.KEYOUT(I,J+1,K).EQ.-1) OK=.TRUE.
        IF(K.GT.1   .AND.J.GT.1   .AND.KEYOUT(I,J-1,K-1).EQ.-1)OK=.TRUE.
        IF(K.LT.KDIM.AND.J.GT.1   .AND.KEYOUT(I,J-1,K+1).EQ.-1)OK=.TRUE.
        IF(K.GT.1   .AND.J.LT.JDIM.AND.KEYOUT(I,J+1,K-1).EQ.-1)OK=.TRUE.
        IF(K.LT.KDIM.AND.J.LT.JDIM.AND.KEYOUT(I,J+1,K+1).EQ.-1)OK=.TRUE.
        END IF
 20    CONTINUE
       IF (OK) THEN 
        DO 25 I=IL1,IL2
           IF (KEYOUT(I,J,K).EQ.1) DUNK(I,J,K) = 0D0
 25     CONTINUE
       END IF
 30   CONTINUE


      DO 50 K=KL1,KL2
      JL1=JL1V(K)
      JL2=JL2V(K)
      DO 50 J=JL1,JL2
      OK = .FALSE.
       DO 40 I=IL1,IL2
        IF (KEYOUT(I,J,K).EQ.1) THEN
           IF (K.GT.1   .AND.DUNK(I,J,K-1).EQ.0D0) OK=.TRUE.
           IF (K.LT.KDIM.AND.DUNK(I,J,K+1).EQ.0D0) OK=.TRUE.
           IF (J.GT.1   .AND.DUNK(I,J-1,K).EQ.0D0) OK=.TRUE.
           IF (J.LT.JDIM.AND.DUNK(I,J+1,K).EQ.0D0) OK=.TRUE.
        END IF
 40    CONTINUE
       IF (OK) THEN
        DO 45 I=IL1,IL2
           IF (KEYOUT(I,J,K).EQ.1.AND.DUNK(I,J,K).EQ.1D0) 
     &        DUNK(I,J,K) = 0.5D0
 45     CONTINUE
       END IF
 50   CONTINUE


      RETURN
      END


      SUBROUTINE SINGLEPROC( SINGLE )
      INTEGER SINGLE

      SINGLE = 1
$MANY      SINGLE = 0

      RETURN
      END
c----------------------------------------------------------------------c
       subroutine amub (nrow,ncol,job,a,ja,ia,b,jb,ib,
     *                  c,jc,ic,nzmax,iw,ierr) 
      real*8 a(*), b(*), c(*) 
      integer ja(*),jb(*),jc(*),ia(nrow+1),ib(*),ic(*),iw(ncol)
c-----------------------------------------------------------------------
c performs the matrix by matrix product C = A B 
c-----------------------------------------------------------------------
c on entry:
c ---------
c nrow  = integer. The row dimension of A = row dimension of C
c ncol  = integer. The column dimension of B = column dimension of C
c job   = integer. Job indicator. When job = 0, only the structure
c                  (i.e. the arrays jc, ic) is computed and the
c                  real values are ignored.
c
c a,
c ja,
c ia   = Matrix A in compressed sparse row format.
c 
c b, 
c jb, 
c ib    =  Matrix B in compressed sparse row format.
c
c nzmax = integer. The  length of the arrays c and jc.
c         amub will stop if the result matrix C  has a number 
c         of elements that exceeds exceeds nzmax. See ierr.
c 
c on return:
c----------
c c, 
c jc, 
c ic    = resulting matrix C in compressed sparse row sparse format.
c           
c ierr  = integer. serving as error message. 
c         ierr = 0 means normal return,
c         ierr .gt. 0 means that amub stopped while computing the
c         i-th row  of C with i=ierr, because the number 
c         of elements in C exceeds nzmax.
c
c work arrays:
c------------
c iw    = integer work array of length equal to the number of
c         columns in A.
c Note: 
c-------
c   The row dimension of B is not needed. However there is no checking 
c   on the condition that ncol(A) = nrow(B). 
c
c----------------------------------------------------------------------- 
      real*8 scal 
      logical values
      values = (job .ne. 0) 
      len = 0
      ic(1) = 1 
      ierr = 0
c     initialize array iw.
      do 1 j=1, ncol
         iw(j) = 0
 1    continue
c
      do 500 ii=1, nrow 
c     row i 
         do 200 ka=ia(ii), ia(ii+1)-1 
	    if (values) scal = a(ka)
	    jj   = ja(ka)
	    do 100 kb=ib(jj),ib(jj+1)-1
               jcol = jb(kb)
               jpos = iw(jcol)
               if (jpos .eq. 0) then
                  len = len+1
                  if (len .gt. nzmax) then
                     ierr = ii
                     return
                  endif
                  jc(len) = jcol
                  iw(jcol)= len
                  if (values) c(len)  = scal*b(kb)
               else
                  if (values) c(jpos) = c(jpos) + scal*b(kb)
               endif
 100	    continue
 200     continue
         do 201 k=ic(ii), len
	    iw(jc(k)) = 0
 201     continue
         ic(ii+1) = len+1
 500  continue
      return
c-------------end-of-amub-----------------------------------------------
      end
c-----------------------------------------------------------------------
      subroutine csrcsc2 (n,n2,job,ipos,a,ja,ia,ao,jao,iao)
      integer ia(n+1),iao(n2+1),ja(*),jao(*)
      real*8  a(*),ao(*)
c-----------------------------------------------------------------------
c Compressed Sparse Row     to      Compressed Sparse Column
c
c (transposition operation)   Not in place. 
c----------------------------------------------------------------------- 
c Rectangular version.  n is number of rows of CSR matrix,
c                       n2 (input) is number of columns of CSC matrix.
c----------------------------------------------------------------------- 
c -- not in place --
c this subroutine transposes a matrix stored in a, ja, ia format.
c ---------------
c on entry:
c----------
c n	= number of rows of CSR matrix.
c n2    = number of columns of CSC matrix.
c job	= integer to indicate whether to fill the values (job.eq.1) of the
c         matrix ao or only the pattern., i.e.,ia, and ja (job .ne.1)
c
c ipos  = starting position in ao, jao of the transposed matrix.
c         the iao array takes this into account (thus iao(1) is set to ipos.)
c         Note: this may be useful if one needs to append the data structure
c         of the transpose to that of A. In this case use for example
c                call csrcsc2 (n,n,1,ia(n+1),a,ja,ia,a,ja,ia(n+2)) 
c	  for any other normal usage, enter ipos=1.
c a	= real array of length nnz (nnz=number of nonzero elements in input 
c         matrix) containing the nonzero elements.
c ja	= integer array of length nnz containing the column positions
c 	  of the corresponding elements in a.
c ia	= integer of size n+1. ia(k) contains the position in a, ja of
c	  the beginning of the k-th row.
c
c on return:
c ---------- 
c output arguments:
c ao	= real array of size nzz containing the "a" part of the transpose
c jao	= integer array of size nnz containing the column indices.
c iao	= integer array of size n+1 containing the "ia" index array of
c	  the transpose. 
c
c----------------------------------------------------------------------- 
c----------------- compute lengths of rows of transp(A) ----------------
      do 1 i=1,n2+1
         iao(i) = 0
 1    continue
      do 3 i=1, n
         do 2 k=ia(i), ia(i+1)-1 
            j = ja(k)+1
            iao(j) = iao(j)+1
 2       continue 
 3    continue
c---------- compute pointers from lengths ------------------------------
      iao(1) = ipos 
      do 4 i=1,n2
         iao(i+1) = iao(i) + iao(i+1)
 4    continue
c--------------- now do the actual copying ----------------------------- 
      do 6 i=1,n
         do 62 k=ia(i),ia(i+1)-1 
            j = ja(k) 
            next = iao(j)
            if (job .eq. 1)  ao(next) = a(k)
            jao(next) = i
            iao(j) = next+1
 62      continue
 6    continue
c-------------------------- reshift iao and leave ---------------------- 
      do 7 i=n2,1,-1
         iao(i+1) = iao(i)
 7    continue
      iao(1) = ipos
c--------------- end of csrcsc2 ---------------------------------------- 
c-----------------------------------------------------------------------
      end
c----------------------------------------------------------------------c
      subroutine amux (n, x, y, a,ja,ia)
      real*8  x(*), y(*), a(*)
      integer n, ja(*), ia(*)
c-----------------------------------------------------------------------
c         A times a vector
c-----------------------------------------------------------------------
c multiplies a matrix by a vector using the dot product form
c Matrix A is stored in compressed sparse row storage.
c
c on entry:
c----------
c n     = row dimension of A
c x     = real array of length equal to the column dimension of
c         the A matrix.
c a, ja,
c    ia = input matrix in compressed sparse row format.
c
c on return:
c-----------
c y     = real array of length n, containing the product y=Ax
c
c-----------------------------------------------------------------------
c local variables
c
      real*8 t
      integer i, k
c-----------------------------------------------------------------------
      do 100 i = 1,n
c
c     compute the inner product of row i with vector x
c
         t = 0.0d0
         do 99 k=ia(i), ia(i+1)-1
            t = t + a(k)*x(ja(k))
 99      continue
c
c     store result in y(i)
c
         y(i) = t
 100  continue
c
      return
c---------end-of-amux---------------------------------------------------
c-----------------------------------------------------------------------
      end
c-----------------------------------------------------------------------
c-----------------------------------------------------------------------
      subroutine atmuxr (m, n, x, y, a, ja, ia)
      real*8 x(*), y(*), a(*)
      integer m, n, ia(*), ja(*)
c-----------------------------------------------------------------------
c         transp( A ) times a vector, A can be rectangular
c-----------------------------------------------------------------------
c See also atmux.  The essential difference is how the solution vector
c is initially zeroed.  If using this to multiply rectangular CSC
c matrices by a vector, m number of rows, n is number of columns.
c-----------------------------------------------------------------------
c
c on entry:
c----------
c m     = column dimension of A
c n     = row dimension of A
c x     = real array of length equal to the column dimension of
c         the A matrix.
c a, ja,
c    ia = input matrix in compressed sparse row format.
c
c on return:
c-----------
c y     = real array of length n, containing the product y=transp(A)*x
c
c-----------------------------------------------------------------------
c     local variables
c
      integer i, k
c-----------------------------------------------------------------------
c
c     zero out output vector
c
      do 1 i=1,m
         y(i) = 0.0
 1    continue
c
c loop over the rows
c
      do 100 i = 1,n
         do 99 k=ia(i), ia(i+1)-1
            y(ja(k)) = y(ja(k)) + x(i)*a(k)
 99      continue
 100  continue
c
      return
c-------------end-of-atmuxr---------------------------------------------
c-----------------------------------------------------------------------
      end

