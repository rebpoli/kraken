/*----------------------------------------------------------------------*/
/*   Iterative solver for IPARS' multicomponent Jacobian                */
/*----------------------------------------------------------------------
Vassilevski: The fastest method is GMRES_PREC = 16 in a general case.
*/

/*---------------------------------------------------------------------- 
History:  H. Carter Edwards   1997   Initial version

          Qin Lu   6/7/99   MultiModel extension: The original code only 
works for single physical model. Now the data structure for solve data is 
extended from a scalar to an array so that each model has its own solve 
data structure and own work space for the solver. Hence the solver can be 
used by more than one model simultaneously without conflicts.   

          Philippe Quandalle 2/28/99  LSOR inner iterations for the pressure
GMRES_PREC = 4               ->       block

          Yuri Vassilevski 4/10/00  Variety of preconditioners for
the pressure block: 
GMRES_PREC = 5               -> Truncated Neumann series preconditioner
                              accelerated by the PCG. Needed for comparison.
GMRES_PREC = 6               -> Truncated Neumann series preconditioner
                              accelerated by the PBCGstab. 
                              Needed for comparison. 
GMRES_PREC = 7               -> Truncated Neumann series preconditioner
                              accelerated by the GMRES. 
                              Needed for comparison. 
GMRES_PREC = 8               -> Unaccelerated truncated Neumann series prec.
                              Needed for comparison.
GMRES_PREC = 10(+METHOD = 4) -> SEPARABLE preconditioner. Good for hydrology
                              Needed for comparison. 
GMRES_PREC = 11(+METHOD = 4) -> SEPARABLE preconditioner combined with LSOR
                              Good for hydrology  model.
GMRES_PREC = 12(+METHOD = 4) -> SEPARABLE-based-ums preconditioner 
                              combined with Gauss-Seidel smoother. 
                              Needed for comparison. 
GMRES_PREC = 13              -> MULTILEVEL ILU for the pressure block
                              Needed for comparison.       
GMRES_PREC = 14              -> Two-stage MULTILEVEL ILU combined with 
                              LSOR smoother for the pressure block
                              Needed for comparison.       
GMRES_PREC = 15              -> ALGEBRAIC MULTIGRID for the pressure block
                              Very robust. Initialization makes is slower.
GMRES_PREC = 16              -> Two stage ALGEBRAIC MULTIGRID combined with 
                              LSOR smoother for the pressure block.
                              The fastest method! The convergence may be slower
                              in case of severe hetrogenuity.
GMRES_PREC = 17              -> SPARSE FACTORIZATION of the pressure block
                              Good for debugging and research

Macros for the preprocessor:

In the case of very fine meshes EDWARDS_STOP_TEST is preferably to be
activated. It will allow to use quite relaxed tolerance for the GMRES solver.

In the case of large time steps (depending on the model and parameters) 
the decoupling (combinative or multi-stage) techniques may produce
a very bad preconditioner. In this case it is recommended to use
GMRES(5) or GMRES(10)  (set in ticama.df) and activate SWITCH_TO_LSOR
------------------------------------------------------------------------*/



/*
#define DEBUGGING
#define DEBUGGING_SOL
#define DEBUGGING_JAC
//#define DEBUGGING_PQ_JAC
#define DEBUGGING_PQ_LSOR
#define TIME_OF_ITERATIONS
#define CHECK_RESIDUALS
*/

/* Code switches:
   EDWARDS_MULTISTAGE -> multistage instead of conminative technique
   EDWARDS_STOP_TEST  -> Edwards stop test for GMRES instead of relative
                         reduction of L2 residual
   SWITCH_TO_LSOR     -> After first GMRES restart switch to one sweep of LSOR
                         as a coupled preconditioner, instead of decoupling for
                         the coupled system
#define EDWARDS_MULTISTAGE
#define EDWARDS_STOP_TEST
#define SWITCH_TO_LSOR
*/




#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include "cfsimple.h"
#include "r8blas.h"
#include "r8lapack.h"
#include "struct.h"


#ifdef TIME_OF_ITERATIONS
#include <time.h>//Temporary, just for time measuring
 double t1,t2; static  double t3=0.; //Temporary, just for time measuring
#endif


/* -------Yuri Vassilevski: global variables for symbolic pressure
factorization and memory requirements for pressure factorization.
Active only if GMRES_PREC = 13,14,17 --------------------------------------*/
int flag_first_fctrz = 1; // flag for the first factorization
int factor_for_real = 600;//real space for the factorizer=factor_for_real*nloc
int factor_for_int  = 200; // int  space for the factorizer=factor_for_int *nloc

/* -------  MultiModel extension ---------------------------------------*/
int current_model;

#define solve_data solve_data_mod [current_model-1]
/*----------------------------------------------------------------------*/

#define SL_SOLVE_GMRES		1
#define SL_SOLVE_FGMRES		2

#define SL_PREC_DIAG 		1
#define SL_PREC_LINEJAC		2
#define SL_PREC_LINEGS		3
#define SL_PREC_LINESOR		4
#define SL_PREC_NEUPCG          5
#define SL_PREC_NEUPBCGS        6
#define SL_PREC_NEUGMRES        7
#define SL_PREC_NEUSER          8 
#define SL_PREC_SEPARABLE       10
#define SL_PREC_SEPAR_GS        11
#define SL_PREC_SEPAR_UMS       12
#define SL_PREC_MLILU           13
#define SL_PREC_MLILU2          14
#define SL_PREC_AMG             15
#define SL_PREC_AMG2            16
#define SL_PREC_FCTRZ           17

/*----------------------------------------------------------------------*/
/*  Routines with FORTRAN interface (FORTRAN or 'C' called by FORTRAN)  */
#define myblkoff   _F_NAME_(MYBLKOFF,myblkoff)
#define myblkdim   _F_NAME_(MYBLKDIM,myblkdim)
#define mycallwork _F_NAME_(MYCALLWORK,mycallwork)

/* mpesz:       the macros below are replaced by the macros above
                for compatibility woth DOS (WSLee)

#define _blkdim    _F_NAME_(BLKDIM,blkdim)
#define _blkoff    _F_NAME_(BLKOFF,blkoff)
#define _callwork  _F_NAME_(CALLWORK,callwork)
*/
#define _slupdate  _F_NAME_(SLUPDATE,slupdate)
#define _gr8sum    _F_NAME_(GR8SUM,gr8sum)
#define _slblk     _F_NAME_(SLBLK,slblk)
#define _sliblk    _F_NAME_(SLIBLK,sliblk)
#define _slgmres   _F_NAME_(SLGMRES,slgmres)
#define _slfgmres  _F_NAME_(SLFGMRES,slfgmres)
#define _slgmres1  _F_NAME_(SLGMRES1,slgmres1)
#define _slpcg     _F_NAME_(SLPCG,slpcg)
#define _slpbcgs   _F_NAME_(SLPBCGS,slpbcgs)
#define _slmsg     _F_NAME_(SLMSG,slmsg)
#define _slmsgunit _F_NAME_(SLMSGUNIT,slmsgunit)
#define _sldie     _F_NAME_(SLDIE,sldie)

#define _sljacdebug   _F_NAME_(SLJACDEBUG,sljacdebug)
#define _sljacnorm    _F_NAME_(SLJACNORM,sljacnorm)

#define _set_gs_step    _F_NAME_(SET_GS_STEP,set_gs_step)
#define _set_n_gs_step  _F_NAME_(SET_N_GS_STEP,set_n_gs_step)
#define _get_currentmodel _F_NAME_(GET_CURRENTMODEL,get_currentmodel)

/* ++++SEPARABLE PRECONDITIONER and factorizer and amg+++++ */
#define _precsol   _F_NAME_(PRECSOL,precsol)
#define _precprep1 _F_NAME_(PRECPREP1,precprep1)
#define _precprep2 _F_NAME_(PRECPREP2,precprep2)
#define _ums2so   _F_NAME_(UMS2SO,ums2so)
#define _ums2fa   _F_NAME_(UMS2FA,ums2fa)
#define _ums2rf   _F_NAME_(UMS2RF,ums2rf)
#define _ums2in   _F_NAME_(UMS2IN,ums2in)
#define _amg1r5   _F_NAME_(AMG1R5,amg1r5)
#define _sllsori    _F_NAME_(SLLSORI,sllsori)
#define _sllsor     _F_NAME_(SLLSOR,sllsor)
#define _mrkdnk  _F_NAME_(MRKDNK,mrkdnk)
#define _singleproc  _F_NAME_(SINGLEPROC,singleproc)
#define _amub     _F_NAME_(AMUB,amub)
#define _amux     _F_NAME_(AMUX,amux)
#define _csrcsc2  _F_NAME_(CSRCSC2,csrcsc2)
/* +++++++++ */
/* Routines written in FORTRAN */
_F_EXTERN_(void) myblkoff();
_F_EXTERN_(void) myblkdim();
_F_EXTERN_(void) mycallwork();
/*
_F_EXTERN_(void) _blkdim();
_F_EXTERN_(void) _blkoff();
_F_EXTERN_(void) _callwork();
*/
_F_EXTERN_(void) _gr8sum();
_F_EXTERN_(void) _slgmres();
_F_EXTERN_(void) _slfgmres();
_F_EXTERN_(void) _slgmres1();
_F_EXTERN_(void) _slpcg();
_F_EXTERN_(void) _slpbcgs();
_F_EXTERN_(void) _sljacdebug();
_F_EXTERN_(void) _slmsg();
_F_EXTERN_(void) _slmsgunit();
_F_EXTERN_(void) _sldie();
_F_EXTERN_(void) _set_gs_step();
_F_EXTERN_(void) _set_n_gs_step();
_F_EXTERN_(_F_INTEGER) _get_currentmodel();

/* ++++SEPARABLE PRECONDITIONER and factorizer and amg+++++ */
_F_EXTERN_(void) _precsol();
_F_EXTERN_(void) _precprep1();
_F_EXTERN_(void) _precprep2();
_F_EXTERN_(void) _ums2so();
_F_EXTERN_(void) _ums2fa();
_F_EXTERN_(void) _ums2rf();
_F_EXTERN_(void) _ums2in();
_F_EXTERN_(void) _amg1r5();
_F_EXTERN_(void) _sllsori();
_F_EXTERN_(void) _sllsor();
_F_EXTERN_(void) _mrkdnk();
_F_EXTERN_(void) _singleproc();
_F_EXTERN_(void) _amub();
_F_EXTERN_(void) _amux();
_F_EXTERN_(void) _csrcsc2();
/* +++++++++ */
/* Routines written to be called by FORTRAN */

_F_EXTERN_(void) _sliblk(
  _F_INTEGER * NEV,   /* input  Number of equations/variables */
  _F_INTEGER * NS,    /* input  Stencil size: 7,19, or 27     */
  _F_INTEGER * JSMAP, /* input  Stencil mapping               */
  _F_INTEGER * KTMP,  /* input  IPARS Type of stencil         */
  _F_INTEGER * NBLK,  /* input  Number of blocks              */
  _F_INTEGER * SPEC ); /* Input: solver & preconditioner spec's */

_F_EXTERN_(void) _slblk(
  _F_INTEGER * IP_GJAC,  /* input:  IPARS id of Jacobian      */
  _F_INTEGER * IP_GRES,  /* input:  IPARS id of Residual      */
  _F_INTEGER * IP_GSOL,  /* in/out: IPARS id of 'GXDELTA'     */
  _F_REAL_4  * RES,      /* in/out: Convergence/actual residual ratio */
  _F_REAL_4  * ARES,     /* in/out: Absolute Convergence tolerance */
  _F_INTEGER * ITER,     /* in/out: Max/Actual iterations             */
  _F_INTEGER * INFO,     /* output: Status of overall solve           */
  _F_INTEGER * IPRECPREP);/* input: IPARS id of preconditioned pressure block */


/*--------------------------------------------------------------------*/

#if _F_STRING_OPTION_ == _F_STRING_HIDE_TRAILING_INT_ || \
    _F_STRING_OPTION_ == _F_STRING_HIDE_ADJACENT_INT_

#define SLMSG(MSG) _slmsg( MSG , strlen(MSG) )
#define SLDIE(MSG) _sldie( MSG , strlen(MSG) )

#else

#error "UNKNOWN FORTRAN STRING OPTION"

#endif

const static char strline[] =
"------------------------------------------------------------------------" ;

#define SLMSGLINE  SLMSG(strline)

/*----------------------------------------------------------------------*/
/* IPARS' grid block specifications are compressed and mapped           */

typedef struct solve_blk_type {

  _F_INTEGER   ldgrid ; /* Leading dimension of grid-element array */
  _F_INTEGER   nloc ;   /* Number of local cells in the grid-element array */
  _F_INTEGER   disp ;   /* Displacement of local cells */
  _F_INTEGER   nblk ;   /* Number of block in line preconditioners */
  _F_INTEGER * jblk ;   /* Blocking for line preconditioners */
  char       * jcolor ; /* Color of line */
  _F_INTEGER * jmap ;   /* Grid and Jacobian mapping */
  _F_INTEGER * mapj ;   /* Map grid -> vector */

  _F_REAL_4  * gjac ;  /* IPARS' Jacobian grid-element array */
  _F_REAL_8  * gres ;  /* IPARS' Residual grid-element array */
  _F_REAL_8  * gsol ;  /* IPARS' Solution grid-element array */

} solve_blk_type ;

/*
  jmap[0]     = Grid element of this vector entry (vector -> grid)
  jmap[1]     = Number of coefficients in the Jacobian's row
  jmap[i*2+0] = Jacobian's offset for the coefficient
  jmap[i*2+1] = Grid element associated with coefficient
*/

/*--------------------------------------------------------------------*/
/* Overall IPARS interface */

#define MAX_SPEC_DATA	2

typedef struct solve_all_type {

  _F_INTEGER ns   ;  /* Maximum stencil size */
  _F_INTEGER nev  ;  /* Number of equations/variabls */
  _F_INTEGER nblk ;  /* Number of blocks */
  _F_INTEGER nloc ;  /* Number of locally owned grid cells, all blocks */
  _F_INTEGER nwork ; /* Size of work space pool */
  _F_INTEGER sspec[ MAX_SPEC_DATA ]; /* Solver spec's */
  _F_INTEGER pspec[ MAX_SPEC_DATA ]; /* Preconditioner spec's */

  solve_blk_type * blk ;    /* Grid block data */
  _F_INTEGER   * jsmap ;  /* Stencil mapping */
  _F_REAL_4      * rnorm ;  /* Residual norms per equation */

  _F_INTEGER   idgjac ; /* IPARS' identifier for Jacobian */
  _F_INTEGER   idgres ; /* IPARS' identifier for Residual */
  _F_INTEGER   idgsol ; /* IPARS' identifier for Solution */
  _F_INTEGER   idktmp ; /* IPARS' identifier for stencil type */

  void      * pwork ;  /* Pressure equation's workspace */
  void      * pworki;  /* Pressure equation's int workspace for factorizer,amg*/
  void      * pworkr;  /* Pressure equation's real workspace for factorizer */
  void      * pworks;  /* Pressure-saturation preconditioner real workspace */
  void      * pworksr;  /* Pressure-saturation preconditioner real workspace */
  void      * pworksi;  /* Pressure-saturation preconditioner real workspace */


  _F_REAL_8 * sol ;      /* Solution vector */
  _F_REAL_8 * res ;      /* Residual vector */
  _F_REAL_8 * work ;     /* Solver space pool */

} solve_all_type ;

/*--------------------------------------------------------------------*/

/* -------  MultiModel extension -------------------*/
// static solve_all_type * solve_data_mod[ $MXMOD ]; mpesz: this will crash:
        // models numbered from 0..MXMOD -1
static solve_all_type * solve_data_mod[ $MXMOD ];
/*--------------------------------------------------*/


#ifdef DEBUGGING

static solve_all_type * solve_data_backup = NULL ;

#endif

/*----------------------------------------------------------------------*/

static _F_REAL_4 * fr4_alloc( size_t N )
{
  _F_REAL_4 * ptr = (_F_REAL_4 *) malloc( sizeof(_F_REAL_4) * N );

  if ( ptr == (_F_REAL_4 *) NULL ) {
    char buf[512] ;
    sprintf(buf,"solver : malloc( %d ) failed",sizeof(_F_REAL_4) * N);
    SLDIE(buf);
  }

  return ptr ;
}

static _F_REAL_8 * fr8_alloc( size_t N )
{
  _F_REAL_8 * ptr = (_F_REAL_8 *) malloc( sizeof(_F_REAL_8) * N );

  if ( ptr == (_F_REAL_8 *) NULL ) {
    char buf[512] ;
    sprintf(buf,"solver : malloc( %d ) failed",sizeof(_F_REAL_8) * N);
    SLDIE(buf);
  }

  return ptr ;
}

static _F_INTEGER * fi_alloc( size_t N )
{
  _F_INTEGER * ptr = (_F_INTEGER *) malloc( sizeof(_F_INTEGER) * N );

  if ( ptr == (_F_INTEGER *) NULL ) {
    char buf[512] ;
    sprintf(buf,"solver : malloc( %d ) failed",sizeof(_F_INTEGER) * N);
    SLDIE(buf);
  }

  return ptr ;
}

/*----------------------------------------------------------------------*/

static int comp_int_array( const void * const I1 , const void * const I2 )
{
  const int N = 3 ;
  register int i ;

  for ( i = 0 ; i < N &&
     ((const unsigned *)I1)[i] == ((const unsigned *)I2)[i] ; ++i );

  return ( i == N ) ? 0 : (
         ( ((const unsigned *)I1)[i] < ((const unsigned *)I2)[i] ) ? -1 : 1 );
}

/*----------------------------------------------------------------------*/
/* IPARS work routine to fill in the block information
   - Leading dimension of block
   - Number of local/active cells of block
   - Grid and jacobian mapping for the block
 */

static void slblkwork(
  const _F_INTEGER * const IDIM,
  const _F_INTEGER * const JDIM,
  const _F_INTEGER * const KDIM,
  const _F_INTEGER * const LDIM,
  const _F_INTEGER * const IL1,
  const _F_INTEGER * const IL2,
  const _F_INTEGER * const JLV1,
  const _F_INTEGER * const JLV2,
  const _F_INTEGER * const KL1,
  const _F_INTEGER * const KL2,
  const _F_INTEGER * const KEYOUT,
  const _F_INTEGER * const NBLK )
{
  const int idim   = *IDIM ;
  const int jdim   = *JDIM ;
  const int kdim   = *KDIM ;
  const int ldgrid = idim * jdim * kdim ;
  const int kinc   = idim * jdim ;
  const int jinc   = idim ;
  const int kbeg   = (*KL1) - 1 ;
  const int kend   = (*KL2) ;
  const int iblk   = *NBLK - 1 ;
  const int ns     = solve_data->ns ;
  const int nev    = solve_data->nev ;
  const int ldjmap = 2 * ( ns + 1 );

  char       * jcolor = NULL ;
  _F_INTEGER * jblk = NULL ;
  _F_INTEGER * jmap = NULL ;
  _F_INTEGER * mapj = NULL ;

  int k , koff , n , na , ic , ica ;

  _F_INTEGER IGOFF , JGOFF , KGOFF , NERR ;

  /*------------------------------------------------------------------*/
  /* Obtain global offsets for the grid block */

  myblkoff( NBLK , &IGOFF , &JGOFF , &KGOFF , &NERR );

  /*------------------------------------------------------------------*/
  /* Loop over 'KEYOUT' to determine number of locally active cells   */

  n = 0 ;
  na = 0 ;
  for ( n = 0, k = kbeg, koff = kbeg * kinc ; k < kend ; ++k, koff += kinc ) {
    const int jbeg = koff + jinc * ( JLV1[k] - 1 );
    const int jend = koff + jinc * ( JLV2[k] );
    int joff ;
    for ( joff = jbeg ; joff < jend ; joff += jinc ) {
      const int ioffbeg = joff + *IL1 - 1 ;
      const int ioffend = joff + *IL2 ;
      const int nold = n ;
      int ioff ;
      for ( ioff = ioffbeg ; ioff < ioffend ; ++ioff ) {
        if ( KEYOUT[ioff] == 1 ) ++n ;
      }
      if ( nold < n ) ++na ;
    }
  }

  /*------------------------------------------------------------------*/
  /* Update block information */

  solve_data->blk[iblk].ldgrid = ldgrid ;
  solve_data->blk[iblk].nloc   = n ;
  solve_data->blk[iblk].nblk   = na ;
  solve_data->blk[iblk].jblk   = jblk   = fi_alloc( na );
  solve_data->blk[iblk].jcolor = jcolor = malloc( na );
  solve_data->blk[iblk].jmap   = jmap   = fi_alloc( ldjmap * n );
  solve_data->blk[iblk].mapj   = mapj   = fi_alloc( ldgrid );

  {
    int iend = ldjmap * n ;
    int i ;
    for ( i = 0 ; i < na ; ++i ) jcolor[i] = 0 ;
    for ( i = 0 ; i < na ; ++i ) jblk[i] = 0 ;
    for ( i = 0 ; i < iend ; ++i ) jmap[i] = 0 ;
    for ( i = 0 ; i < ldgrid ; ++i ) mapj[i] = -1 ;
  }

  /*------------------------------------------------------------------*/
  /* Determine SFC mapping */

  ic = 0 ;
  for ( k = kbeg, koff = kbeg * kinc ; k < kend ; ++k, koff += kinc ) {
    const int jbeg = JLV1[k] - 1 ;
    const int jend = JLV2[k] ;
    int j , joff ;
    for (j = jbeg, joff = koff + jbeg * jinc ; j < jend ; ++j, joff += jinc){
      const int ibeg = *IL1 - 1 ;
      const int iend = *IL2 ;
      int i , ioff ;
      const unsigned ITWO = 2 ;
      double sfc[2] ;
      unsigned isfc[2] ;

      /* SFC horizontal coordinate for the cell */

      sfc[0] = ((double)(k+1)) / ((double)(kdim+2));
      sfc[1] = ((double)(j+1)) / ((double)(jdim+2));
      fhsfc2d( sfc, &ITWO, isfc );

      for ( i = ibeg , ioff = joff + ibeg ; i < iend ; ++i, ++ioff ) {
        if ( KEYOUT[ioff] == 1 ) {
          _F_INTEGER * const map = jmap + ldjmap * ic++ ;

          /* Ordering (sorting) data */

          map[0] = ((_F_INTEGER *) isfc)[0] ;
          map[1] = ((_F_INTEGER *) isfc)[1] ;
          map[2] = i ;    /* Local Grid 'i' (vertical) */

          /* Other important grid data */

          map[3] = j ;    /* Local Grid 'j' */
          map[4] = k ;    /* Local Grid 'k' */
          map[5] = ioff ; /* Local Grid offset */
        }
      }
    }
  }

  qsort( jmap , n , sizeof(int) * ldjmap , comp_int_array );

  /*------------------------------------------------------------------*/
  /* Loop over active cells to determine:
     1) the grid and jacobian mapping,
     2) vertical line blocking,
     3) binary (red/black) coloring.
  */

#ifdef DEBUGGING
  SLMSGLINE ;
  SLMSG("Ordering of grid colums, begin");
#endif

  ica = 0 ;
  for ( ic = 0 ; ic < n ; ++ic ) {
    _F_INTEGER * const map = jmap + ldjmap * ic ;

    /* Extract grid information for the current cell */

    const int ig    = map[2] ; /* Local Grid 'i' */
    const int jg    = map[3] ; /* Local Grid 'j' */
    const int kg    = map[4] ; /* Local Grid 'k' */
    const int igoff = map[5] ; /* Local Grid offset */

    int is ;

    /* Blocking specifications */

    if ( jblk[ica] == 0 ) { /* New block */
      jcolor[ica] = ( jg + JGOFF + kg + KGOFF ) % 2 ;

#ifdef DEBUGGING
      {
        char buf[128] ;
        sprintf(buf,"  loc[%7d](%3d,%3d,%3d) <=> glo(%3d,%3d,%3d)",
          igoff+1,ig+1,jg+1,kg+1,ig+IGOFF+1,jg+JGOFF+1,kg+KGOFF+1);
        SLMSG(buf);
      }
#endif

    }

    ++jblk[ica] ; /* Block count */

    if ( ic + 1 < n && ( jg != map[3+ldjmap] || kg != map[4+ldjmap] ) ) {
      ++ica ;
    }

    /* Form the Grid & Jacobian mapping */

    for ( is = 0 ; is < ldjmap ; ++is ) map[is] = 0 ;

    /* Grid offset for the active cell */

    mapj[igoff] = ic ; /* Grid mapping */

    map[0] = igoff ; /* Grid offset of this cell */
    map[1] = 1 ;     /* Number of coefficients   */

    /* Coefficient for the local cell */

    map[2] = 0 ;     /* Coefficient offset         */
    map[3] = igoff ; /* Grid offset of coefficient */

    /* Determine remainder of Jacobian's entries */

    for ( is = 1 ; is < ns ; ++is ) {

      const _F_INTEGER * const jsmap = solve_data->jsmap + 3 * is ;

      const int ign = ig + jsmap[0] ;
      const int jgn = jg + jsmap[1] ;
      const int kgn = kg + jsmap[2] ;

      if ( 0 <= ign && ign < *IDIM &&
           0 <= jgn && jgn < *JDIM &&
           0 <= kgn && kgn < *KDIM ) {
        const int ignoff = ign + jgn * jinc + kgn * kinc ;

        if ( abs( KEYOUT[ignoff] ) == 1 ) {
          ++map[1] ;
          map[  2*map[1]] = is ;
          map[1+2*map[1]] = ignoff ;
        }
      }
    } /* End loop: is */
  }

#ifdef DEBUGGING
  SLMSG("Ordering of grid colums, end");
  SLMSGLINE ;
#endif

}

/*----------------------------------------------------------------------*/
static void initinterpolation( )
{
      const _F_INTEGER NLOC = solve_data->nloc ;
      const _F_INTEGER NS   = solve_data->ns   ;
            _F_INTEGER NLOC2 ;
            _F_INTEGER * PNLOC2 = solve_data->pworki ;
            _F_INTEGER * IP2 = PNLOC2 + 1 ;
            _F_INTEGER * JP2 = IP2 + NLOC + 1 ;
            _F_INTEGER * IP3 ;
            _F_INTEGER * JP3 ;
            _F_REAL_8  * AP2 = solve_data->pworkr ;
            _F_REAL_8  * AP3 ;


      const int nblk   = solve_data->nblk ;
      const int ns     = solve_data->ns ;
      const int ldjmap = 2 * ( solve_data->ns + 1 );
      const _F_INTEGER * jmap ;
      const _F_INTEGER * jblk = NULL ;

      _F_INTEGER IONE = 1 ;
      int i,j,k,is;

      for ( j = 0 ; j < NLOC + 1 ; ++j ) IP2[j] = j+1  ;
      for ( j = 1 ; j < IP2[ NLOC ] ; ++j ) JP2[j-1] = 0 ; 

      NLOC2 = 0 ;
      for ( i = 0 ; i < nblk ; ++i ) {
          const solve_blk_type * const blk  = solve_data->blk + i ;
          const int                    ldg  = blk->ldgrid ;
          const int                    nloc = blk->nloc ;
          const int                    disp = blk->disp ;
          const _F_INTEGER     * const jbeg = blk->jmap ;
          const _F_INTEGER     * const mapj = blk->mapj ;
          jblk = blk->jblk ;
          jmap = blk->jmap ;
          for ( j = 0 ; j < nloc ; ) {
              const _F_INTEGER NBJ = *jblk++ ;
              int jj ;
              for ( k = 0 ; k < NBJ ; ++k , jmap += ldjmap ) {
                 int ir = (jmap-jbeg)/ldjmap+1+disp;
                 if ( k==0 || k == NBJ-1 || k%3 == 1 ) NLOC2 += 1 ; 
                 for ( jj = IP2[ir-1] ; jj < IP2[ir] ; ++jj ) {
                  JP2[jj-1] = NLOC2 ;
                  AP2[jj-1] = 1.0  ;
                 }
             }
             j  += NBJ ;
          }
      }
      IP3 = JP2 + IP2[NLOC]  ;
      JP3 = JP2 + IP2[NLOC] + NLOC2 + 1 ;
      AP3 = AP2 + IP2[NLOC]  ;
      _csrcsc2(&NLOC,&NLOC2,&IONE,&IONE,AP2,JP2,IP2,AP3,JP3,IP3);
      PNLOC2[0] = NLOC2 ;
}
/*----------------------------------------------------------------------*/
/*  Allocations for solver and mappings for grid interface */

void _sliblk(
  /* Arguments regarding the grid and jacobian */

  _F_INTEGER * NEV,   /* input  Number of equations/variables */
  _F_INTEGER * NS,    /* input  Stencil size: 7,19, or 27     */
  _F_INTEGER * JSMAP, /* input  Stencil mapping               */
  _F_INTEGER * KTMP,  /* input  IPARS Type of stencil         */
  _F_INTEGER * NBLK,  /* input  Number of blocks              */
  _F_INTEGER * SPEC ) /* Input: solver & preconditioner spec's */
{
  const size_t nblk = *NBLK ;
  const size_t nev  = *NEV ;
  const size_t ns   = *NS ;

  size_t nloc = 0 ; /* Number of local unknowns for all grids */
  size_t nall = 0 ; /* nloc * nev */
  int i ;

  /* Qin Lu, get the current model number */ 
  current_model = _get_currentmodel();

  /*------------------------------------------------------------------*/
  /* Verify 'JSMAP' */

  if ( *NS < 1 || JSMAP[0] != 0 || JSMAP[1] != 0 || JSMAP[2] != 0 ) {
    SLDIE("Jacobian stencil mapping (JSMAP) leading entry is non-zero");
  }

  /*------------------------------------------------------------------*/
  /* Allocate base data */

  if ( solve_data ) {
    /* Free maps, solvers, and preconditioners */

    for ( i = 0 ; i < solve_data->nblk ; ++i ) {
      if ( solve_data->blk[i].jcolor) free( solve_data->blk[i].jcolor );
      if ( solve_data->blk[i].jblk )  free( solve_data->blk[i].jblk );
      if ( solve_data->blk[i].jmap )  free( solve_data->blk[i].jmap );
      if ( solve_data->blk[i].mapj )  free( solve_data->blk[i].mapj );
    }

    if ( solve_data->pwork )  free( solve_data->pwork );
    if ( solve_data->pworki)  free( solve_data->pworki);
    if ( solve_data->pworkr)  free( solve_data->pworkr);
    if ( solve_data->pworks)  free( solve_data->pworks);
    if ( solve_data->pworksr) free( solve_data->pworksr);
    if ( solve_data->pworksi) free( solve_data->pworksi);
    if ( solve_data->sol )    free( solve_data->sol );
    if ( solve_data->res )    free( solve_data->res );
    if ( solve_data->work )   free( solve_data->work );

    free( solve_data );
    solve_data = NULL ;
#ifdef DEBUGGING
    free( solve_data_backup );
    solve_data_backup = NULL ;
#endif
  }

  /* Allocation / zero fill: 'solve_data', 'jsmap', 'eqn', and 'blk' */

  {
    size_t sizealloc =
      sizeof(solve_all_type) +         /* solve_data         */
      sizeof(solve_blk_type) * nblk +  /* solve_data->blk    */
      sizeof(_F_INTEGER *) * 3 * ns +  /* solve_data->jsmap  */
      sizeof(_F_REAL_4) * nev ;        /* solve_data->rnorm  */

    char * alloc = (char *) calloc( sizealloc , (size_t) 1 );

#ifdef DEBUGGING
     solve_data_size = sizealloc ;
#endif

    if ( alloc == NULL ) { SLDIE("calloc failed"); }

    solve_data = (solve_all_type *) alloc ;
      alloc += sizeof(solve_all_type);

    solve_data->blk = (solve_blk_type *) alloc ;
      alloc += sizeof(solve_blk_type) * nblk ;

    solve_data->jsmap = (_F_INTEGER *) alloc ;
      alloc += sizeof(_F_INTEGER) * 3 * ns ;

    solve_data->rnorm = (_F_REAL_4 *) alloc ;
      alloc += sizeof(_F_REAL_4 *) * nev ;
  }

  solve_data->nblk   = nblk ;
  solve_data->nev    = nev ;
  solve_data->ns     = ns ;
  solve_data->nloc   = 0 ;
  solve_data->idktmp = *KTMP ;
  solve_data->idgjac = -1 ;
  solve_data->idgres = -1 ;
  solve_data->idgsol = -1 ;

  for ( i = 0 ; i < 3 * ns ; ++i ) solve_data->jsmap[i] = JSMAP[i] ;

  /*------------------------------------------------------------------*/
  /* Sizes and maps of local grid blocks */

  {
    _F_INTEGER callworkdata = 0 ;
    mycallwork( slblkwork, &callworkdata );
  }

  solve_data->blk[0].disp = 0 ;
  for ( i = 0 ; i < nblk - 1 ; ++i ) {
    solve_data->blk[i+1].disp =
      solve_data->blk[i].disp + solve_data->blk[i].nloc ;
  }

  nloc = solve_data->nloc =
    solve_data->blk[i].disp + solve_data->blk[i].nloc ;

  nall = nloc * nev ;

  /*------------------------------------------------------------------*/
  /* Local variables dependent upon 'nloc' */

  solve_data->sol = fr8_alloc( nall );
  solve_data->res = fr8_alloc( nall );

  /*------------------------------------------------------------------*/
  /* Solver */

  {
    size_t max_w = 2 * nall ; /* Vector workspace */

    switch( solve_data->sspec[0] = SPEC[0] ) {
    case SL_SOLVE_GMRES:
      {
        const size_t restart = solve_data->sspec[1] = SPEC[1] ;
        const size_t nwork   = restart + 3 ; /* Number of vectors */
        const size_t mh      = restart + 1 ; /* 'H' Rows    */
        const size_t nh      = restart + 6 ; /* 'H' Columns */
        const size_t num_w   = nall * nwork + mh * nh ;

        if ( max_w < num_w ) max_w = num_w ;
      }
      break ;
    case SL_SOLVE_FGMRES:
      {
        const size_t restart = solve_data->sspec[1] = SPEC[1] ;
        const size_t nwork   = 2*(restart+1)  + 2 ; /* Number of vectors */
        const size_t mh      = restart + 1 ; /* 'H' Rows    */
        const size_t nh      = restart + 6 ; /* 'H' Columns */
        const size_t num_w   = nall * nwork + mh * nh ;

        if ( max_w < num_w ) max_w = num_w ;
      }
      break ;

    default:
      {
        char buf[512] ;
        sprintf(buf,"Unknown solver specification (1) = %d",SPEC[0]);
        SLDIE(buf);
      }
    }

    solve_data->nwork = max_w ;
    solve_data->work  = fr8_alloc( max_w );
  }

  /* Preconditioner for pressure equation */

  switch( solve_data->pspec[0] = SPEC[2] ) {
  case SL_PREC_DIAG:
    solve_data->pwork = NULL ;
    break ;

/*
  case SL_PREC_BAND:
    {
      const size_t hbw  = solve_data->pspec[1] = SPEC[3] ;
      const size_t ld   = 3 * hbw + 1 ;
      const size_t nloci =
        ( sizeof(_F_INTEGER) * nloc + sizeof(_F_REAL_8) - 1 )
        / sizeof(_F_REAL_8) ;

      solve_data->pwork = (void *) fr8_alloc( ld * nloc + nloci );
    }
    break ;
*/

  case SL_PREC_LINEJAC: /* Line Jacobi */
  case SL_PREC_LINEGS:  /* Line Gauss-Seidel */
  case SL_PREC_LINESOR: /* Line Successive Over Relaxation */
    {
      const size_t hbw  = 1 ;
      const size_t ld   = 3 * hbw + 1 ;
      const size_t nloci =
        ( sizeof(_F_INTEGER) * nloc + sizeof(_F_REAL_8) - 1 )
        / sizeof(_F_REAL_8) ;

      solve_data->pwork = (void *) fr8_alloc( ld * nloc + nloci );
    }
    break ;
  case SL_PREC_SEPAR_GS:/* Parallel separable preconditioner with GS smoother*/
  case SL_PREC_SEPAR_UMS:/*Parallel separable-based-ums preconditioner with 
                           GS smoother*/
    {
      const size_t hbw  = 1 ;
      const size_t ld   = 3 * hbw + 1 ;
      const size_t nloci =
        ( sizeof(_F_INTEGER) * nloc + sizeof(_F_REAL_8) - 1 )
        / sizeof(_F_REAL_8) ;

      solve_data->pwork = (void *) fr8_alloc( ld * nloc + nloci );
      solve_data->pworkr= (void *) fr8_alloc( nloc );
    }
  case SL_PREC_SEPARABLE:  /* Parallel separable preconditioner */
    break ;
  case SL_PREC_FCTRZ:  /* Sparse factorizer */
    {
      const size_t hbw  = 1 ;
      const size_t ld   = 3 * hbw + 1 ;
      const size_t nloci =
        ( sizeof(_F_INTEGER) * nloc + sizeof(_F_REAL_8) - 1 )
        / sizeof(_F_REAL_8) ;
      solve_data->pwork = (void *) fr8_alloc( ld * nloc + nloci );
      solve_data->pworki= (void *) fi_alloc(  nloc*factor_for_int +80 );
      solve_data->pworkr= (void *) 
                            fr4_alloc( nloc*factor_for_real+nloc*6+30+8*nblk );
                       //   fr4_alloc( nloc*factor_for_real+nloc*4+30 );
    }
    break ;
  case SL_PREC_NEUPCG:  /* Truncated Neumann series preconditioner + PCG */
    {
      const size_t hbw  = 1 ;
      const size_t ld   = 3 * hbw + 1 ;
      const size_t nloci =
        ( sizeof(_F_INTEGER) * nloc + sizeof(_F_REAL_8) - 1 )
        / sizeof(_F_REAL_8) ;

      solve_data->pwork = (void *) fr8_alloc( ld * nloc + 5 * nloc + nloci );
    }
    break ;
  case SL_PREC_NEUPBCGS: /* Truncated Neumann series preconditioner + PBCGS */
    {
      const size_t hbw  = 1 ;
      const size_t ld   = 3 * hbw + 1 ;
      const size_t nloci =
        ( sizeof(_F_INTEGER) * nloc + sizeof(_F_REAL_8) - 1 )
        / sizeof(_F_REAL_8) ;

      solve_data->pwork = (void *) fr8_alloc( ld * nloc + nloci
                 + nloc + 8 * nloc );
    }
    break ;
  case SL_PREC_NEUGMRES: /* Truncated Neumann series preconditioner 
                            + GMRES(RESTART/4) */
    {
      const size_t hbw  = 1 ;
      const size_t ld   = 3 * hbw + 1 ;
      const size_t nloci =
        ( sizeof(_F_INTEGER) * nloc + sizeof(_F_REAL_8) - 1 )
        / sizeof(_F_REAL_8) ;
      const size_t nworkvec  = solve_data->sspec[1]/4 + 3 ;

      solve_data->pwork = (void *) fr8_alloc( ld * nloc + nloci
                 + nloc + nworkvec * nloc + (nworkvec+1)*(nworkvec+6) );
    }
    break ;
  case SL_PREC_NEUSER:  /* Truncated Neumann series preconditioner */
    {
      const size_t hbw  = 1 ;
      const size_t ld   = 3 * hbw + 1 ;
      const size_t nloci =
        ( sizeof(_F_INTEGER) * nloc + sizeof(_F_REAL_8) - 1 )
        / sizeof(_F_REAL_8) ;

      solve_data->pwork = (void *) fr8_alloc( ld * nloc + nloc + nloci );
    }
    break ;
  case SL_PREC_AMG:  /* Algebraic multigrid */
     {
      int memd = 7*(ns*nloc) + 5*nloc + (int)(2.2*nloc) +(int)(2.2*nloc)+4*nblk;
      int AdMemIG = 100 ;
      int memi = 7*(ns*nloc) + 5*nloc + (int)(2.2*nloc) +(int)(5.4*nloc)+  nblk
                +AdMemIG ;
      const size_t hbw  = 1 ;
      const size_t ld   = 3 * hbw + 1 ;
      const size_t nloci =
        ( sizeof(_F_INTEGER) * nloc + sizeof(_F_REAL_8) - 1 )
        / sizeof(_F_REAL_8) ;
      solve_data->pwork = (void *) fr8_alloc( ld * nloc + nloci );

      solve_data->pworki= (void *) fi_alloc( memi );
      solve_data->pworkr= (void *) fr8_alloc( memd );
    }
    break ;
  case SL_PREC_AMG2:  /* Algebraic multigrid  with LSOR smoother*/
     {
      int memd = 7*(ns*nloc) + 5*nloc + (int)(2.2*nloc) +(int)(2.2*nloc)+4*nblk
                 + 2*nloc ;
      int AdMemIG = 100 ;
      int memi = 7*(ns*nloc) + 5*nloc + (int)(2.2*nloc) +(int)(5.4*nloc)+  nblk
                 + 4*nloc + 4 + AdMemIG ;
      const size_t hbw  = 1 ;
      const size_t ld   = 3 * hbw + 1 ;
      const size_t nloci =
        ( sizeof(_F_INTEGER) * nloc + sizeof(_F_REAL_8) - 1 )
        / sizeof(_F_REAL_8) ;
      solve_data->pwork = (void *) fr8_alloc( ld * nloc + nloci );

      solve_data->pworki= (void *) fi_alloc( memi );
      solve_data->pworkr= (void *) fr8_alloc( memd );
      initinterpolation();
     }
    break ;
  case SL_PREC_MLILU:  /* MLILU */
     {
      extern typ ***LU;
      extern int ***indexLU;
      extern typ ***matKi;
      extern typ **mat_init ;
      extern int ***indKi;
      extern int **index_init;
      extern typ **matt; //= (typ**) malloc(sizeof(typ*));
      extern int **indext; //= (int**) malloc(sizeof(int*));
      extern int *temporaire;
      extern int *temporaire2;
      extern int* worki;
      extern int *sauvtaille;
      extern int *size_tab ;
      extern int **tab;
      extern int *size;

      extern spec_noeud **spec_tab;
      extern ensemble **lens;
      extern  refr *Wi;
      extern couple *Pi;
      extern couple *Qi ;
      extern int smaxwi;
      extern int smaxqi;
      extern int smaxpi;

      extern int **indices;
      extern int *levels;
      extern double* workr;
      extern int taillei;
      extern int size_min;
      extern double *vdi, *vd;
      extern int *init;
      extern int *level ;

      const size_t hbw  = 1 ;
      const size_t ld   = 3 * hbw + 1 ;
      const size_t nloci =
        ( sizeof(_F_INTEGER) * nloc + sizeof(_F_REAL_8) - 1 )
        / sizeof(_F_REAL_8) ;
      solve_data->pwork = (void *) fr8_alloc( ld * nloc + nloci );
      solve_data->pworkr= (void *) fr8_alloc( 3*nloc + 4*nblk );
      solve_data->pworki= (void *) fi_alloc( nblk );
      // From here all the data are passed to  MLILU by predefined objects
      // hidden in MLILU structure


      if ( nloc < 2000 ) taillei = 2000;
      else taillei = nloc;
      taillei = nloc;

      spec_tab = (spec_noeud**) malloc(sizeof(spec_noeud*));
      lens = (ensemble**) malloc(sizeof(ensemble*)*3);

      Wi = (refr*) malloc(sizeof(refr)*smaxwi);
      Pi = (couple*) malloc(sizeof(couple)*smaxpi);
      Qi = (couple*) malloc(sizeof(couple)*smaxqi);

      LU = (typ***) malloc(sizeof(typ**));
      indexLU = (int***) malloc(sizeof(int**));
      *indexLU = (int**) malloc(nloc*sizeof(int*));
      *LU = (typ**) malloc(nloc*sizeof(typ*));

   worki = (int*) malloc(sizeof(int)*(size_min*factor_for_int+80));
   workr = (double*)malloc(sizeof(double)*(size_min*(factor_for_real+4)+30));

      vdi = (double*) malloc(sizeof(double)*nloc);
      vd  = (double*) malloc(sizeof(double)*nloc);

      level = (int*) malloc(sizeof(int));
      init = (int*) malloc(sizeof(int));

      indices = (int**) malloc(sizeof(int)*25);
      levels = (int*) malloc(sizeof(int)*25);
      size = (int*) malloc(sizeof(int));
      tab = (int**) malloc(3*sizeof(int*));
      size_tab = (int*) malloc(12*sizeof(int));
      sauvtaille = (int*) malloc(sizeof(int)*30);
      temporaire = (int*) malloc(sizeof(int)*taillei);
      temporaire2 = (int*) malloc(sizeof(int)*taillei);

      matKi = (typ***) malloc(25*sizeof(typ**));
      matKi[0]= NULL;
      indKi =  (int***) malloc(25*sizeof(int**));


      index_init = (int**) malloc(sizeof(int*)*nloc);
      mat_init = (typ**) malloc(sizeof(typ*)*nloc);
      mat_init[0] = NULL;
      indKi =  (int***) malloc(25*sizeof(int**));

      matt = (typ**) malloc(sizeof(typ*)*nloc);
      indext = (int**) malloc(sizeof(int*)*nloc);
      (*LU)[0] = NULL;
     }
    break ;
  case SL_PREC_MLILU2:  /* MLILU  with LSOR smoother*/
     {
      extern typ ***LU;
      extern int ***indexLU;
      extern typ ***matKi;
      extern typ **mat_init ;
      extern int ***indKi;
      extern int **index_init;
      extern typ **matt; //= (typ**) malloc(sizeof(typ*));
      extern int **indext; //= (int**) malloc(sizeof(int*));
      extern int *temporaire;
      extern int *temporaire2;
      extern int* worki;
      extern int *sauvtaille;
      extern int *size_tab ;
      extern int **tab;
      extern int *size;

      extern spec_noeud **spec_tab;
      extern ensemble **lens;
      extern  refr *Wi;
      extern couple *Pi;
      extern couple *Qi ;
      extern int smaxwi;
      extern int smaxqi;
      extern int smaxpi;

      extern int **indices;
      extern int *levels;
      extern double* workr;
      extern int taillei;
      extern int size_min;
      extern double *vdi, *vd;
      extern int *init;
      extern int *level ;
      const size_t hbw  = 1 ;
      const size_t ld   = 3 * hbw + 1 ;
      const size_t nloci =
        ( sizeof(_F_INTEGER) * nloc + sizeof(_F_REAL_8) - 1 )
        / sizeof(_F_REAL_8) ;
      // solve_data->pwork = (void *) fr8_alloc( ld * nloc + nloci );
      // pwork is used not only for tridiagonal factorizations,
      // but for the coarse matrix in initialisemlilu2.
      // Since we need ns*nloc real8  rather than ld*nloc, we allocate
      solve_data->pwork = (void *) fr8_alloc( ns * nloc + nloci );
      solve_data->pworkr= (void *) fr8_alloc( ns*nloc+2*nloc +3*nloc + 4*nblk);
      solve_data->pworki= (void *) fi_alloc( nblk + 2*((ns+1)*nloc+1)+4*nloc+4);


  // From here all the data are passed to  MLILU by predefined objects
      // hidden in MLILU structure


      if ( nloc < 2000 ) taillei = 2000;
      else taillei = nloc;
      taillei = nloc;

      spec_tab = (spec_noeud**) malloc(sizeof(spec_noeud*));
      lens = (ensemble**) malloc(sizeof(ensemble*)*3);

      Wi = (refr*) malloc(sizeof(refr)*smaxwi);
      Pi = (couple*) malloc(sizeof(couple)*smaxpi);
      Qi = (couple*) malloc(sizeof(couple)*smaxqi);

      LU = (typ***) malloc(sizeof(typ**));
      indexLU = (int***) malloc(sizeof(int**));
      *indexLU = (int**) malloc(nloc*sizeof(int*));
      *LU = (typ**) malloc(nloc*sizeof(typ*));

   worki = (int*) malloc(sizeof(int)*(size_min*factor_for_int+80));
   workr = (double*)malloc(sizeof(double)*(size_min*(factor_for_real+4)+30));
      vdi = (double*) malloc(sizeof(double)*nloc);
      vd  = (double*) malloc(sizeof(double)*nloc);

      level = (int*) malloc(sizeof(int));
      init = (int*) malloc(sizeof(int));

      indices = (int**) malloc(sizeof(int)*25);
      levels = (int*) malloc(sizeof(int)*25);
      size = (int*) malloc(sizeof(int));
      tab = (int**) malloc(3*sizeof(int*));
      size_tab = (int*) malloc(12*sizeof(int));
      sauvtaille = (int*) malloc(sizeof(int)*30);
      temporaire = (int*) malloc(sizeof(int)*taillei);
      temporaire2 = (int*) malloc(sizeof(int)*taillei);

      matKi = (typ***) malloc(25*sizeof(typ**));
      matKi[0]= NULL;
      indKi =  (int***) malloc(25*sizeof(int**));

      index_init = (int**) malloc(sizeof(int*)*nloc);
      mat_init = (typ**) malloc(sizeof(typ*)*nloc);
      mat_init[0] = NULL;
      indKi =  (int***) malloc(25*sizeof(int**));

      matt = (typ**) malloc(sizeof(typ*)*nloc);
      indext = (int**) malloc(sizeof(int*)*nloc);

      (*LU)[0] = NULL;
      initinterpolation();
     }
    break ;
  default:
    {
      char buf[512] ;
      sprintf(buf,"Unknown pressure preconditioner specification = %d",
        SPEC[2]);
      SLDIE(buf);
    }
  }

  /* workspace for pressure-saturation preconditioner */
  //lsor solver for total system or block Jacobi prec for the total system
  solve_data->pworks = (void *) fr8_alloc( nloc );
  //block Gauss-Seidel -- nothing
  //two Richardson iterations for total system
  // solve_data->pworks = (void *) fr8_alloc( nloc * (nev+1) );
  //DILU for the total system. Don't forget decoment dilu() !!!
  //solve_data->pworks = (void *) fr8_alloc( nloc );
  //solve_data->pworksr= (void *) fr4_alloc( nall*nev*ns + nall );
  //solve_data->pworksi= (void *) fi_alloc( nall*nev*ns + nall+1 + nall );
  //ILU0 for the total system. Don't forget decoment ilu0() !!!
  //solve_data->pworks = (void *) fr8_alloc( nloc );
  //solve_data->pworksr= (void *) fr4_alloc( nall*nev*ns );
  //solve_data->pworksi= (void *) fi_alloc( nall*nev*ns + nall+1 + 2*nall );

#ifdef DEBUGGING
  solve_data_backup = malloc( solve_data_size );
  memcpy( solve_data_backup , solve_data , solve_data_size );
#endif
}

/*----------------------------------------------------------------------*/
/*----------------------------------------------------------------------*/
/* Copy grid to vector with scaling */

static void slgrid2vec(
  const int         USE_RESIDUAL ,
        _F_REAL_8 * V ,
  const _F_REAL_8  ALPHA ,
  const int igbeg ,
  const int igend )
{
  const int nblk   = solve_data->nblk ;
  const int ldvec  = solve_data->nloc ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );

  int i, ig ;
  _F_INTEGER * jmap ;

  if ( USE_RESIDUAL ) {
    if ( ALPHA == 1.0 ) {
      for ( ig = igbeg ; ig < igend ; ++ig ) {
        for ( i = 0 ; i < nblk ; ++i ) {
          const solve_blk_type * const blk  = solve_data->blk + i ;
          const _F_REAL_8      * const G    = blk->gres + blk->ldgrid * ig ;
          const _F_INTEGER     * const jend = ( jmap = blk->jmap ) +
                                              blk->nloc * ldjmap ;
          for ( ; jmap < jend ; jmap += ldjmap ) *V++ = G[*jmap];
        }
      }
    }
    else {
      for ( ig = igbeg ; ig < igend ; ++ig ) {
        for ( i = 0 ; i < nblk ; ++i ) {
          const solve_blk_type * const blk  = solve_data->blk + i ;
          const _F_REAL_8      * const G    = blk->gres + blk->ldgrid * ig ;
          const _F_INTEGER     * const jend = ( jmap = blk->jmap ) +
                                              blk->nloc * ldjmap ;
          for ( ; jmap < jend ; jmap += ldjmap ) *V++ = ALPHA * G[*jmap];
        }
      }
    }
  }
  else {
    if ( ALPHA == 1.0 ) {
      for ( ig = igbeg ; ig < igend ; ++ig ) {
        for ( i = 0 ; i < nblk ; ++i ) {
          const solve_blk_type * const blk  = solve_data->blk + i ;
          const _F_REAL_8      * const G    = blk->gsol + blk->ldgrid * ig ;
          const _F_INTEGER     * const jend = ( jmap = blk->jmap ) +
                                              blk->nloc * ldjmap ;
          for ( ; jmap < jend ; jmap += ldjmap ) *V++ = G[*jmap];
        }
      }
    }
    else {
      for ( ig = igbeg ; ig < igend ; ++ig ) {
        for ( i = 0 ; i < nblk ; ++i ) {
          const solve_blk_type * const blk  = solve_data->blk + i ;
          const _F_REAL_8      * const G    = blk->gsol + blk->ldgrid * ig ;
          const _F_INTEGER     * const jend = ( jmap = blk->jmap ) +
                                              blk->nloc * ldjmap ;
          for ( ; jmap < jend ; jmap += ldjmap ) *V++ = ALPHA * G[*jmap];
        }
      }
    }
  }
}
/*----------------------------------------------------------------------*/
/*----------------------------------------------------------------------*/
/* Copy vector to grid with scaling */

static void slvec2grid(
  const int USE_RESIDUAL ,
  const _F_REAL_8 * V ,
  const _F_REAL_8  ALPHA ,
  const int igbeg ,
  const int igend )
{
  const _F_INTEGER IONE = 1 ;
  const _F_INTEGER IZERO = 0 ;
  const _F_REAL_8  ZERO  = 0.0 ;
  const int nblk   = solve_data->nblk ;
  const int ldvec  = solve_data->nloc ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );

  int i, ig ;
  _F_INTEGER * jmap ;

  if ( USE_RESIDUAL ) {
    if ( ALPHA == 1.0 ) {
      for ( ig = igbeg ; ig < igend ; ++ig ) {
        for ( i = 0 ; i < nblk ; ++i ) {
          const solve_blk_type * const blk  = solve_data->blk + i ;
          const _F_INTEGER             LDG  = blk->ldgrid ;
                _F_REAL_8      * const G    = blk->gres + LDG * ig ;
          const _F_INTEGER     * const jend = ( jmap = blk->jmap ) +
                                              blk->nloc * ldjmap ;
          r8copy( &LDG, &ZERO, &IZERO, G, &IONE );
          for ( ; jmap < jend ; jmap += ldjmap ) G[*jmap] = *V++ ;
        }
      }
    }
    else {
      for ( ig = igbeg ; ig < igend ; ++ig ) {
        for ( i = 0 ; i < nblk ; ++i ) {
          const solve_blk_type * const blk  = solve_data->blk + i ;
          const _F_INTEGER             LDG  = blk->ldgrid ;
                _F_REAL_8      * const G    = blk->gres + LDG * ig ;
          const _F_INTEGER     * const jend = ( jmap = blk->jmap ) +
                                              blk->nloc * ldjmap ;
          r8copy( &LDG, &ZERO, &IZERO, G, &IONE );
          for ( ; jmap < jend ; jmap += ldjmap ) G[*jmap] = ALPHA * *V++ ;
        }
      }
    }
  }
  else {
    if ( ALPHA == 1.0 ) {
      for ( ig = igbeg ; ig < igend ; ++ig ) {
        for ( i = 0 ; i < nblk ; ++i ) {
          const solve_blk_type * const blk  = solve_data->blk + i ;
          const _F_INTEGER             LDG  = blk->ldgrid ;
                _F_REAL_8      * const G    = blk->gsol + LDG * ig ;
          const _F_INTEGER     * const jend = ( jmap = blk->jmap ) +
                                              blk->nloc * ldjmap ;
          r8copy( &LDG, &ZERO, &IZERO, G, &IONE );
          for ( ; jmap < jend ; jmap += ldjmap ) G[*jmap] = *V++ ;
        }
      }
    }
    else {
      for ( ig = igbeg ; ig < igend ; ++ig ) {
        for ( i = 0 ; i < nblk ; ++i ) {
          const solve_blk_type * const blk  = solve_data->blk + i ;
          const _F_INTEGER             LDG  = blk->ldgrid ;
                _F_REAL_8      * const G    = blk->gsol + LDG * ig ;
          const _F_INTEGER     * const jend = ( jmap = blk->jmap ) +
                                              blk->nloc * ldjmap ;
          r8copy( &LDG, &ZERO, &IZERO, G, &IONE );
          for ( ; jmap < jend ; jmap += ldjmap ) G[*jmap] = ALPHA * *V++ ;
        }
      }
    }
  }
}

/*----------------------------------------------------------------------*/
/*----------------------------------------------------------------------*/
/* Copy vector to grid with scaling */

static void slgridminusvec(
  const int USE_RESIDUAL ,
  const _F_REAL_8 * V ,
  const _F_REAL_8  ALPHA ,
  const int igbeg ,
  const int igend )
{
  const _F_INTEGER IONE = 1 ;
  const _F_INTEGER IZERO = 0 ;
  const _F_REAL_8  ZERO  = 0.0 ;
  const int nblk   = solve_data->nblk ;
  const int ldvec  = solve_data->nloc ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );

  int i, ig ;
  _F_INTEGER * jmap ;

  if ( USE_RESIDUAL ) {
      for ( ig = igbeg ; ig < igend ; ++ig ) {
        for ( i = 0 ; i < nblk ; ++i ) {
          const solve_blk_type * const blk  = solve_data->blk + i ;
          const _F_INTEGER             LDG  = blk->ldgrid ;
                _F_REAL_8      * const G    = blk->gres + LDG * ig ;
          const _F_INTEGER     * const jend = ( jmap = blk->jmap ) +
                                              blk->nloc * ldjmap ;
          r8copy( &LDG, &ZERO, &IZERO, G, &IONE );
          for ( ; jmap < jend ; jmap += ldjmap ) 
              G[*jmap] = ALPHA * (G[*jmap] - *V++) ;
        }
      }
  }
  else {
      for ( ig = igbeg ; ig < igend ; ++ig ) {
        for ( i = 0 ; i < nblk ; ++i ) {
          const solve_blk_type * const blk  = solve_data->blk + i ;
          const _F_INTEGER             LDG  = blk->ldgrid ;
                _F_REAL_8      * const G    = blk->gsol + LDG * ig ;
          const _F_INTEGER     * const jend = ( jmap = blk->jmap ) +
                                              blk->nloc * ldjmap ;
          r8copy( &LDG, &ZERO, &IZERO, G, &IONE );
          for ( ; jmap < jend ; jmap += ldjmap ) 
              G[*jmap] = ALPHA * (G[*jmap] - *V++) ;
        }
      }
  }
}

/*----------------------------------------------------------------------*/
/*----------------------------------------------------------------------*/
/* Copy grid to vector with scaling */

static void slvecminusgrid(
  const int         USE_RESIDUAL ,
        _F_REAL_8 * V ,
  const _F_REAL_8  ALPHA ,
  const int igbeg ,
  const int igend )
{
  const int nblk   = solve_data->nblk ;
  const int ldvec  = solve_data->nloc ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );

  int i, ig ;
  _F_INTEGER * jmap ;

  if ( USE_RESIDUAL ) {
      for ( ig = igbeg ; ig < igend ; ++ig ) {
        for ( i = 0 ; i < nblk ; ++i ) {
          const solve_blk_type * const blk  = solve_data->blk + i ;
          const _F_REAL_8      * const G    = blk->gres + blk->ldgrid * ig ;
          const _F_INTEGER     * const jend = ( jmap = blk->jmap ) +
                                              blk->nloc * ldjmap ;
          for ( ; jmap < jend ; jmap += ldjmap ) *V++ -= G[*jmap];
        }
      }
  }
  else {
      for ( ig = igbeg ; ig < igend ; ++ig ) {
        for ( i = 0 ; i < nblk ; ++i ) {
          const solve_blk_type * const blk  = solve_data->blk + i ;
          const _F_REAL_8      * const G    = blk->gsol + blk->ldgrid * ig ;
          const _F_INTEGER     * const jend = ( jmap = blk->jmap ) +
                                              blk->nloc * ldjmap ;
          for ( ; jmap < jend ; jmap += ldjmap ) *V++ -=  G[*jmap];
        }
      }
  }
}
/*----------------------------------------------------------------------*/
/*----------------------------------------------------------------------*/

static void sljxg(
  _F_REAL_8 *  const VBASE , 
  const int iebeg ,
  const int ieend ,
  const int ivbeg ,
  const int ivend )
{
  const int nblk   = solve_data->nblk ;
  const int ldvec  = solve_data->nloc ;
  const int ns     = solve_data->ns ;
  const int nev    = solve_data->nev ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );

  int i, iv, ie, is ;
  const _F_INTEGER * jmap ;
        _F_REAL_8  * V ;
    char buf[512] ;
#ifdef DEBUGGING_PQ_JAC
    SLMSG("Jacobian multiply");
#endif

  for ( iv = ivbeg ; iv < ivend ; ++iv ) {
    const int ivoff = iv * nev ;

    V = VBASE ;

    for ( ie = iebeg ; ie < ieend ; ++ie ) {
      const int ieoff = ns * ( ie + ivoff );

      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    ldg  = blk->ldgrid ;
        const int                    nloc = blk->nloc ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;
        const _F_REAL_8      * const GI   = blk->gsol + ldg * iv ;
        const _F_REAL_4      * const AJGI = blk->gjac + ldg * ieoff ;

        for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap , ++V ) {
          const _F_REAL_4 * const A = AJGI + jmap[0] ;
          const int isend = 2 * jmap[1] ;

          for ( is = 2 ; is <= isend ; is += 2 ) {
#ifdef DEBUGGING_PQ_JAC
	      sprintf(buf,"i = %d, j = %d, A = %.15g",(jmap-jbeg)/ldjmap, 
jmap[1+is], A[ jmap[is] * ldg ]);
	      SLMSG(buf);
#endif
            *V += A[ jmap[is] * ldg ] * GI[ jmap[1+is] ];
          }
        }
      }
    }
  }
#ifdef DEBUGGING_PQ_JAC
    sprintf(buf,"fin de l'ecriture du jacobien");
    SLDIE(buf);
#endif
}

/*----------------------------------------------------------------------*/
/*----------------------------------------------------------------------*/
/* Matrix-vector multiply:  y = alpha * A * x + beta * y */

static void slmatvec(
  const _F_INTEGER * const DATA ,  /* Input [0:3] = IE1, IE2, IV1, IV2 */
  const _F_REAL_8  * const ALPHA , /* Input  scaling  */
  const _F_REAL_8  * const XVEC ,  /* Input  vector   */
  const _F_REAL_8  * const BETA ,  /* Input  scaling  */
        _F_REAL_8  * const YVEC )  /* In/out vector   */
{
  const _F_INTEGER IONE = 1 ;
  const _F_INTEGER IE1  = DATA[0] ;
  const _F_INTEGER IE2  = DATA[1] ;
  const _F_INTEGER IV1  = DATA[2] ;
  const _F_INTEGER IV2  = DATA[3] ;
  const _F_INTEGER IE   = IE1 - 1 ;
  const _F_INTEGER IV   = IV1 - 1 ;
  const _F_INTEGER NE   = IE2 - IE ;
  const _F_INTEGER NV   = IV2 - IV ;

  /* Scale the output vector */

  {
    const _F_INTEGER N = solve_data->nloc * NE ;
    if ( 0.0 == *BETA ) {
      int i ; for ( i = 0 ; i < N ; ++i ) YVEC[i] = 0.0 ;
    }
    else if ( 1.0 != *BETA ) {
      r8scal( &N, BETA, YVEC , &IONE );
    }
  }

  /* Copy input vector to work (solution) grid, with scaling */

  slvec2grid( 0, XVEC, *ALPHA , IV , IV2 );

  /* Update the work grid via IPARS' update-range routine */

  {
    const _F_INTEGER I4DG = solve_data->idgsol ;
    const _F_INTEGER K4TG = solve_data->idktmp ;
    const _F_INTEGER I4V1 = IV1 ;
    const _F_INTEGER I4V2 = IV2 ;
    _slupdate( &I4DG , &I4V1, &I4V2, &K4TG );
  }

  /* Apply Jacobian */

  sljxg( YVEC, IE, IE2, IV, IV2 );
}

/*----------------------------------------------------------------------*/
/* Apply diagonal preconditioner to vector */

static void slpressdiagsol(
  const _F_INTEGER * const IOPT,  /* Input: which preconditioner option */
  const _F_REAL_8  * const X ,    /* Input  */
        _F_REAL_8  * const Y )    /* Output */
{
  const int nblk   = solve_data->nblk ;
  const int ns     = solve_data->ns ;
  const int nev    = solve_data->nev ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );

  const _F_REAL_8 * V = X ;
        _F_REAL_8 * W = Y ;

  int i, j, iv, ie, ib, is, ic ;

  const _F_INTEGER * jmap ;

  for ( i = 0 ; i < nblk ; ++i ) {
    const solve_blk_type * const blk  = solve_data->blk + i ;
    const int                    ldg  = blk->ldgrid ;
    const int                    nloc = blk->nloc ;
    const _F_INTEGER     * const jbeg = blk->jmap ;
    const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;
    const _F_REAL_4      * const AJGI = blk->gjac ;

    for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap , ++V , ++W ) {
      *W = *V / *(AJGI + jmap[0]); /* Leading block is diagonal */
    }
  }
}

/*----------------------------------------------------------------------*/
/*----------------------------------------------------------------------*/
/* John Wheeler's magic formula for Line-SOR Omega
   for uniform grid blocks in a reservior simulator.
 */

static double linesoromega( int iblk )
{
  _F_INTEGER NBLK = iblk + 1 ;
  _F_INTEGER NXG , NYG , NZG , NERROR ;
  double omega ;

  myblkdim(&NBLK,&NXG,&NYG,&NZG,&NERROR);

  omega = ( NYG < NZG ) ? NZG : NYG ;
  if (omega==1.0) return omega ;
  omega = 1.0 - 4.9348 / ( omega * omega );
  omega = 2.0 / ( 1.0 + sqrt( 1.0 - omega * omega ) );
  omega = omega + ( 2.0 - omega ) * 0.13 ;

  return omega ;
}

/*----------------------------------------------------------------------
The next 820 lines is the implementation of the truncated Neumann series
(reduced system) preconditioners
----------------------------------------------------------------------*/

/* GIr = Arb GIb */
static void slneumArbGIb() {
  const int nblk   = solve_data->nblk ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );
  _F_INTEGER * jmap ;
  _F_INTEGER * jblk ;

  int i , j , k , is ;

    char   * jcolor ;
    const int color = 0 ;

    /* Update grid */
    {
      const _F_INTEGER I4DG = solve_data->idgsol ;
      const _F_INTEGER K4TG = solve_data->idktmp ;
      const _F_INTEGER I4V1 = 1 ;
      const _F_INTEGER I4V2 = 1 ;
      _slupdate( &I4DG , &I4V1, &I4V2, &K4TG );
    }

    for ( i = 0 ; i < nblk ; ++i ) {
      const solve_blk_type * const blk   = solve_data->blk + i ;
      const int                    ldg   = blk->ldgrid ;
      const int                    nloc  = blk->nloc ;
      const _F_REAL_4      * const AJGI  = blk->gjac ;
            _F_REAL_8      * const GI    = blk->gsol ;


      jmap   = blk->jmap ;
      jblk   = blk->jblk ;
      jcolor = blk->jcolor ;

      for ( j = 0 ; j < nloc ; ) {
        const _F_INTEGER NBJ = *jblk++ ;
        if ( color == *jcolor++ ) {
        /* Compute  Arb GIb for 'Red' lines */
          const int igfirst = *jmap ;
          const int iglast  = *(jmap + ldjmap * ( NBJ - 1));

          for ( k = 0 ; k < NBJ ; ++k , jmap += ldjmap ) {
            const _F_REAL_4 * const A = AJGI + jmap[0] ;
            const int isend = 2 * jmap[1] ;
            GI[igfirst+k] = 0. ;
            for ( is = 2 ; is <= isend ; is += 2 ) {
              // stuff for symmetrization v
               const _F_INTEGER * jmapT = 
                      blk->jmap + blk->mapj[jmap[1+is]]*ldjmap ;
               const _F_REAL_4 * const AT = AJGI + jmapT[0];
               const int isendT = 2 * jmapT[1] ;
               int isT, iss ;
               _F_REAL_4 Asym ;
              // stuff for symmetrization ^
              const int ig = jmap[1+is] ;
              if ( ig < igfirst || iglast < ig ) {
               if ( solve_data->pspec[0] == SL_PREC_NEUPCG ) {
                 for ( iss = 2 ; iss <= isendT ; iss += 2 ) {
                     if ( blk->mapj[jmapT[1+iss]] == (jmap-blk->jmap)/ldjmap )
                        isT = iss; 
                 }
                 Asym = A[ jmap[is] * ldg ];
                 if ( fabs(AT[ jmapT[isT] * ldg ]) < fabs(Asym) )
                      Asym=AT[ jmapT[isT] * ldg ];
                 GI[igfirst+k] += Asym * GI[ig] ;
               }
               else {
                 GI[igfirst+k] += A[ jmap[is] * ldg ] * GI[ig] ;
               }
              }
            }
          }
        }
        else {
        /* Jump over 'Black' lines */
          jmap += ldjmap * NBJ ;
        }
        j  += NBJ ;
      }
    }
}

/*   GIb = Abr GIr  */ 
static void slneumAbrGIr() {
  const int nblk   = solve_data->nblk ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );
  _F_INTEGER * jmap ;
  _F_INTEGER * jblk ;

  int i , j , k , is ;

    char   * jcolor ;
    const int color = 0 ;

    /* Update grid */
    {
      const _F_INTEGER I4DG = solve_data->idgsol ;
      const _F_INTEGER K4TG = solve_data->idktmp ;
      const _F_INTEGER I4V1 = 1 ;
      const _F_INTEGER I4V2 = 1 ;
      _slupdate( &I4DG , &I4V1, &I4V2, &K4TG );
    }

    for ( i = 0 ; i < nblk ; ++i ) {
      const solve_blk_type * const blk   = solve_data->blk + i ;
      const int                    ldg   = blk->ldgrid ;
      const int                    nloc  = blk->nloc ;
      const _F_REAL_4      * const AJGI  = blk->gjac ;
            _F_REAL_8      * const GI    = blk->gsol ;

      jmap   = blk->jmap ;
      jblk   = blk->jblk ;
      jcolor = blk->jcolor ;
      for ( j = 0 ; j < nloc ; ) {
        const _F_INTEGER NBJ = *jblk++ ;
        if ( color == *jcolor++ ) {
        /* Jump over 'Red' lines */
          jmap += ldjmap * NBJ ;
        }
        else {
        /* Compute  Abr GI for 'Black' lines */
          const int igfirst = *jmap ;
          const int iglast  = *(jmap + ldjmap * ( NBJ - 1));

          for ( k = 0 ; k < NBJ ; ++k , jmap += ldjmap ) {
            const _F_REAL_4 * const A = AJGI + jmap[0] ;
            const int isend = 2 * jmap[1] ;
            GI[igfirst+k] = 0. ;
            for ( is = 2 ; is <= isend ; is += 2 ) {
              // stuff for symmetrization v
               const _F_INTEGER * jmapT = 
                      blk->jmap + blk->mapj[jmap[1+is]]*ldjmap ;
               const _F_REAL_4 * const AT = AJGI + jmapT[0];
               const int isendT = 2 * jmapT[1] ;
               int isT, iss ;
               _F_REAL_4 Asym ;
              // stuff for symmetrization ^
              const int ig = jmap[1+is] ;
              if ( ig < igfirst || iglast < ig ) {
               if ( solve_data->pspec[0] == SL_PREC_NEUPCG ) {
                 for ( iss = 2 ; iss <= isendT ; iss += 2 ) {
                     if ( blk->mapj[jmapT[1+iss]] == (jmap-blk->jmap)/ldjmap )
                        isT = iss;
                 }
                 Asym = A[ jmap[is] * ldg ];
                 if ( fabs(AT[ jmapT[isT] * ldg ]) < fabs(Asym) )
                      Asym=AT[ jmapT[isT] * ldg ];
                 GI[igfirst+k] += Asym * GI[ig] ;
               }
               else{
                 GI[igfirst+k] += A[ jmap[is] * ldg ] * GI[ig] ;
               }
              }
            }
          }
        }
        j  += NBJ ;
      }
    }
}

/*  GIr = Arr^{-1} GIr   */ 
static void slneumArrGIr(
        _F_REAL_8  *       Y )    /* Work   */
{
  const int nblk   = solve_data->nblk ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );

  const _F_INTEGER   IONE = 1 ;
  const _F_INTEGER   HBW  = 1 ;
  const _F_INTEGER   LDP  = 3 * HBW + 1 ;
  const _F_INTEGER   N    = solve_data->nloc ;
        _F_INTEGER   INFO = 0 ;
  _F_INTEGER * jmap ;
  _F_INTEGER * jblk ;
  int i , j , k , is ;

    char   * jcolor ;
    const int color = 0 ;
    const _F_REAL_8  * P  = solve_data->pwork ;
    const _F_INTEGER * IP =(_F_INTEGER *)( P + LDP * N ) ;
          _F_REAL_8  * VI = Y ;

    for ( i = 0 ; i < nblk ; ++i ) {
      const solve_blk_type * const blk   = solve_data->blk + i ;
      const int                    ldg   = blk->ldgrid ;
      const int                    nloc  = blk->nloc ;
      const _F_REAL_4      * const AJGI  = blk->gjac ;
            _F_REAL_8      * const GI    = blk->gsol ;
            _F_REAL_8      *       VB    = VI ;

      jmap   = blk->jmap ;
      jblk   = blk->jblk ;
      jcolor = blk->jcolor ;

      for ( j = 0 ; j < nloc ; ) {
        const _F_INTEGER NBJ = *jblk++ ;
        if ( color == *jcolor++ ) {
          const int igfirst = *jmap ;
          for ( k = 0 ; k < NBJ ; ++k ) VB[k] = GI[igfirst+k] ;

          r8gbtrs("N",&NBJ,&HBW,&HBW,&IONE,P,&LDP,IP,VB,&NBJ,&INFO);
          if ( 0 != INFO ) {
            SLDIE("lapack block solve failed");
          }
          for ( k = 0 ; k < NBJ ; ++k )  GI[igfirst+k] = VB[k] ;
        }
        jmap += ldjmap * NBJ ;

        P  += LDP * NBJ ;
        IP += NBJ ;
        VB += NBJ ;
        j  += NBJ ;
      }
      VI += nloc ;
    }
}

/*  GIb = Abb^{-1} GIb   */
static void slneumAbbGIb(
        _F_REAL_8  *       Y )    /* Work   */
{
  const int nblk   = solve_data->nblk ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );

  const _F_INTEGER   IONE = 1 ;
  const _F_INTEGER   HBW  = 1 ;
  const _F_INTEGER   LDP  = 3 * HBW + 1 ;
  const _F_INTEGER   N    = solve_data->nloc ;
        _F_INTEGER   INFO = 0 ;
  _F_INTEGER * jmap ;
  _F_INTEGER * jblk ;
  int i , j , k , is ;

    char   * jcolor ;
    const int color = 0 ;
    const _F_REAL_8  * P  = solve_data->pwork ;
    const _F_INTEGER * IP =(_F_INTEGER *)( P + LDP * N ) ;
          _F_REAL_8  * VI = Y ;



    for ( i = 0 ; i < nblk ; ++i ) {
      const solve_blk_type * const blk   = solve_data->blk + i ;
      const int                    ldg   = blk->ldgrid ;
      const int                    nloc  = blk->nloc ;
      const _F_REAL_4      * const AJGI  = blk->gjac ;
            _F_REAL_8      * const GI    = blk->gsol ;
            _F_REAL_8      *       VB    = VI ;

      jmap   = blk->jmap ;
      jblk   = blk->jblk ;
      jcolor = blk->jcolor ;
      for ( j = 0 ; j < nloc ; ) {
        const _F_INTEGER NBJ = *jblk++ ;
        if ( color == *jcolor++ ) {
          jmap += ldjmap * NBJ ;
        }
        else {
          const int igfirst = *jmap ;
          for ( k = 0 ; k < NBJ ; ++k ) VB[k] = GI[igfirst+k] ;

          r8gbtrs("N",&NBJ,&HBW,&HBW,&IONE,P,&LDP,IP,VB,&NBJ,&INFO);
          if ( 0 != INFO ) {
            SLDIE("lapack block solve failed");
          }
          for ( k = 0 ; k < NBJ ; ++k )  GI[igfirst+k] = VB[k] ;
          jmap += ldjmap * NBJ ;
        }

        P  += LDP * NBJ ;
        IP += NBJ ;
        VB += NBJ ;
        j  += NBJ ;
      }
      VI += nloc ;
    }
}

static void slprecneumser(
  _F_INTEGER * iprecdata , /* Input:  */
  _F_INTEGER * ichange   , /* Input:  */
  _F_REAL_8  * X ,    /* Input:  */
  _F_REAL_8  * Y )    /* Output: */
{
  const int nblk   = solve_data->nblk ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );

  _F_INTEGER * jmap ;
  _F_INTEGER * jblk ;
  int i , j , k , is ;

    char   * jcolor ;
    const int color = 0 ;
    _F_REAL_8  * VI ;
    _F_REAL_8  * UI ;

    VI = X ;
    /* The first term in the Neumann series */
    for ( i = 0 ; i < nblk ; ++i ) {
      const solve_blk_type * const blk   = solve_data->blk + i ;
      const int                    ldg   = blk->ldgrid ;
      const int                    nloc  = blk->nloc ;
            _F_REAL_8      * const GI    = blk->gsol ;
            _F_REAL_8      *       VB    = VI ;

      jmap   = blk->jmap ;
      jblk   = blk->jblk ;
      for ( j = 0 ; j < nloc ; ) {
        const _F_INTEGER NBJ = *jblk++ ;
        const int igfirst = *jmap ;
        for ( k = 0 ; k < NBJ ; ++k ) GI[igfirst+k] = VB[k] ;
        jmap += ldjmap * NBJ ;
        VB += NBJ ;
        j  += NBJ ;
      }
      VI += nloc ;
    }

/* The second term in the Neumann series */
    /*  GIb = Abb^{-1} GIb   */ 
    slneumAbbGIb( Y ) ;

    /* GIr = Arb GIb */
    slneumArbGIb() ;

    /*  GIr = Arr^{-1} GIr   */ 
    slneumArrGIr( Y ) ;

    /*   GIb = Abr GIr  */ 
    slneumAbrGIr() ;



    /* Yr = Xr, GIb = ( GIb + Xb ) Add the last term of truncated series*/
    VI = X ;
    UI = Y ;
    for ( i = 0 ; i < nblk ; ++i ) {
      const solve_blk_type * const blk   = solve_data->blk + i ;
      const int                    ldg   = blk->ldgrid ;
      const int                    nloc  = blk->nloc ;
            _F_REAL_8      * const GI    = blk->gsol ;
            _F_REAL_8      *       VB    = VI ;
            _F_REAL_8      *       UB    = UI ;

      jmap   = blk->jmap ;
      jblk   = blk->jblk ;
      jcolor = blk->jcolor ;
      for ( j = 0 ; j < nloc ; ) {
        const _F_INTEGER NBJ = *jblk++ ;
        if ( color == *jcolor++ ) {
          for ( k = 0 ; k < NBJ ; ++k ) UB[k] = VB[k] ;
        }
        else {
          const int igfirst = *jmap ;
          for ( k = 0 ; k < NBJ ; ++k ) GI[igfirst+k] += VB[k] ;
        }
        jmap += ldjmap * NBJ ;

        VB += NBJ ;
        UB += NBJ ;
        j  += NBJ ;
      }
      VI += nloc ;
      UI += nloc ;
    }

    /* Yb= GIb = Abb^{-1}  GIb  */
    slneumAbbGIb( Y ) ;

}

/* Matrix-vector multiply:  y = alpha * A * x + beta * y */
/* 
   A  =  |  I  0    |
         |  0 Schur |
   Schur = Abb - AbrArr^{-1}Arb  */
static void slmulschur(
  const _F_INTEGER * const DATA ,  /* Input [0:3] = IE1, IE2, IV1, IV2 */
  const _F_REAL_8  * const ALPHA , /* Input  scaling  */
  const _F_REAL_8  * const X ,  /* Input  vector   */
  const _F_REAL_8  * const BETA ,  /* Input  scaling  */
        _F_REAL_8  * const Y )  /* In/out vector   */
{
  const int nblk   = solve_data->nblk ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );

  _F_INTEGER * jmap ;
  _F_INTEGER * jblk ;
  int i , j , k , is ;
  const _F_INTEGER   IONE = 1 ;
  const _F_INTEGER   HBW  = 1 ;
  const _F_INTEGER   LDP  = 3 * HBW + 1 ;
  const _F_INTEGER   N    = solve_data->nloc ;
        _F_INTEGER   INFO = 0 ;

    const _F_REAL_8  * P  = solve_data->pwork ;
    const _F_INTEGER * IP =(_F_INTEGER *)( P + LDP * N ) ;

    char   * jcolor ;
    const int color = 0 ;
    const _F_REAL_8  * VI ;
    _F_REAL_8  * UI ;

    if (*BETA != 0.) SLDIE("slmulschur can not be applied for nonzero BETA" ) ;

    /* GI = X */
    VI = X ;
    for ( i = 0 ; i < nblk ; ++i ) {
      const solve_blk_type * const blk   = solve_data->blk + i ;
      const int                    ldg   = blk->ldgrid ;
      const int                    nloc  = blk->nloc ;
            _F_REAL_8      * const GI    = blk->gsol ;
      const _F_REAL_8      *       VB    = VI ;

      jmap   = blk->jmap ;
      jblk   = blk->jblk ;
      for ( j = 0 ; j < nloc ; ) {
        const _F_INTEGER NBJ = *jblk++ ;
        const int igfirst = *jmap ;
        for ( k = 0 ; k < NBJ ; ++k ) GI[igfirst+k] = VB[k] ;
        jmap += ldjmap * NBJ ;
        VB += NBJ ;
        j  += NBJ ;
      }
      VI += nloc ;
    }

    // GIr = Arb GIb 
    slneumArbGIb() ;

    //  GIr = Arr^{-1} GIr     !!! Yr is used as a work vector!!!  
    UI = Y ;
    for ( i = 0 ; i < nblk ; ++i ) {
      const solve_blk_type * const blk   = solve_data->blk + i ;
      const int                    nloc  = blk->nloc ;
            _F_REAL_8      * const GI    = blk->gsol ;
            _F_REAL_8      *       UB    = UI ;

      jmap   = blk->jmap ;
      jblk   = blk->jblk ;
      jcolor = blk->jcolor ;

      for ( j = 0 ; j < nloc ; ) {
        const _F_INTEGER NBJ = *jblk++ ;
        if ( color == *jcolor++ ) {
          const int igfirst = *jmap ;
          for ( k = 0 ; k < NBJ ; ++k ) UB[k] = GI[igfirst+k] ;

          r8gbtrs("N",&NBJ,&HBW,&HBW,&IONE,P,&LDP,IP,UB,&NBJ,&INFO);
          if ( 0 != INFO ) {
            SLDIE("lapack block solve failed");
          }
          for ( k = 0 ; k < NBJ ; ++k )  GI[igfirst+k] = UB[k] ;
        }
        jmap += ldjmap * NBJ ;

        P  += LDP * NBJ ;
        IP += NBJ ;
        UB += NBJ ;
        j  += NBJ ;
      }
      UI += nloc ;
    }

    // GIb = Abr GIr 
    slneumAbrGIr() ;

/*  Yr = ALPHA * Xr , Yb = ALPHA * ( - GIb ) , GIb = Xb  */
    UI = Y ;
    VI = X ;
    for ( i = 0 ; i < nblk ; ++i ) {
      const solve_blk_type * const blk   = solve_data->blk + i ;
      const int                    nloc  = blk->nloc ;
            _F_REAL_8      * const GI    = blk->gsol ;
            _F_REAL_8      *       UB    = UI ;
      const _F_REAL_8      *       VB    = VI ;

      jmap   = blk->jmap ;
      jblk   = blk->jblk ;
      jcolor = blk->jcolor ;
      for ( j = 0 ; j < nloc ; ) {
        const _F_INTEGER NBJ = *jblk++ ;
        if ( color == *jcolor++ ) {
        // For 'Red' lines just a scalar matrix
          for ( k = 0 ; k < NBJ ; ++k )  UB[k] = *ALPHA*VB[k] ;
        }
        else {
        // For 'Black' lines just a scalar matrix
          const int igfirst = *jmap ;
          for ( k = 0 ; k < NBJ ; ++k )  {
             UB[k] = - *ALPHA*GI[igfirst+k] ;
             GI[igfirst+k] = VB[k] ;
          }
        }
        jmap += ldjmap * NBJ ;
        j  += NBJ ;
        UB += NBJ ;
        VB += NBJ ;
      }
      VI += nloc ;
      UI += nloc ;
    }
    /* Update grid */
    {
      const _F_INTEGER I4DG = solve_data->idgsol ;
      const _F_INTEGER K4TG = solve_data->idktmp ;
      const _F_INTEGER I4V1 = 1 ;
      const _F_INTEGER I4V2 = 1 ;
      _slupdate( &I4DG , &I4V1, &I4V2, &K4TG );
    }
/*   Yb += ALPHA * ( Abb * GIb )  */
    UI = Y ;
    for ( i = 0 ; i < nblk ; ++i ) {
      const solve_blk_type * const blk   = solve_data->blk + i ;
      const int                    ldg   = blk->ldgrid ;
      const int                    nloc  = blk->nloc ;
      const _F_REAL_4      * const AJGI  = blk->gjac ;
            _F_REAL_8      * const GI    = blk->gsol ;
            _F_REAL_8      *       UB    = UI ;

      jmap   = blk->jmap ;
      jblk   = blk->jblk ;
      jcolor = blk->jcolor ;
      for ( j = 0 ; j < nloc ; ) {
        const _F_INTEGER NBJ = *jblk++ ;
        if ( color == *jcolor++ ) {
          jmap += ldjmap * NBJ ;
        }
        else {
          const int igfirst = *jmap ;
          const int iglast  = *(jmap + ldjmap * ( NBJ - 1));
          for ( k = 0 ; k < NBJ ; ++k , jmap += ldjmap ) {
            const _F_REAL_4 * const A = AJGI + jmap[0] ;
            const int isend = 2 * jmap[1] ;
            double tmp = 0.0 ;
            for ( is = 2 ; is <= isend ; is += 2 ) {
              // stuff for symmetrization v
               const _F_INTEGER * jmapT =
                      blk->jmap + blk->mapj[jmap[1+is]]*ldjmap ;
               const _F_REAL_4 * const AT = AJGI + jmapT[0];
               const int isendT = 2 * jmapT[1] ;
               int isT, iss ;
               _F_REAL_4 Asym ;
              // stuff for symmetrization ^
              const int ig = jmap[1+is] ;
              if ( ig >= igfirst && ig <= iglast ) {
               if ( solve_data->pspec[0] == SL_PREC_NEUPCG ) {
                 for ( iss = 2 ; iss <= isendT ; iss += 2 ) {
                     if ( blk->mapj[jmapT[1+iss]] == (jmap-blk->jmap)/ldjmap )
                        isT = iss;
                 }
                 Asym = A[ jmap[is] * ldg ];
                 if ( fabs(AT[ jmapT[isT] * ldg ]) < fabs(Asym) )
                      Asym=AT[ jmapT[isT] * ldg ];
                 tmp += Asym * GI[ig] ;
               }
               else{
                 tmp += A[ jmap[is] * ldg ] * GI[ig] ;
               }
              }
            }
            UB[k] +=  *ALPHA * tmp  ;
          }
        }
        j  += NBJ ;
        UB += NBJ ;
      }
      UI += nloc ;
    }

}

static void slneumseries(
  const _F_REAL_8  * const X ,    /* Input  */
        _F_REAL_8  *       Y ,    /* Output */
        _F_REAL_8  *       WRK )  /* Work   */
{
  const int nblk   = solve_data->nblk ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );

  const _F_INTEGER   N    = solve_data->nloc ;
  _F_INTEGER * jmap ;
  _F_INTEGER * jblk ;
  int i , j , k , is ;

    char   * jcolor ;
    const int color = 0 ;
    const _F_INTEGER IONE = 1 ;
          _F_REAL_8  * Z = WRK ;
          _F_REAL_8  * VI ;
          _F_REAL_8  * VIZ ;



    /* Copy input vector to work (residual) grid, with scaling */
    if ( X != Y ) r8copy( &N, X, &IONE, Y, &IONE );


  /*------------------------------------------------------------------*/

  /* forward substitution ( Yr GIb )^t = L^{-1}  (Yr Yb )^t */

    /* Zr = GIr = Yr , Zb = GIb = Yb  */
    VI = Y ;
    VIZ= Z ;
    for ( i = 0 ; i < nblk ; ++i ) {
      const solve_blk_type * const blk   = solve_data->blk + i ;
      const int                    nloc  = blk->nloc ;
            _F_REAL_8      * const GI    = blk->gsol ;
            _F_REAL_8      *       VB    = VI ;
            _F_REAL_8      *       VBZ   = VIZ ;

      jmap   = blk->jmap ;
      jblk   = blk->jblk ;
      for ( j = 0 ; j < nloc ; ) {
        const _F_INTEGER NBJ = *jblk++ ;
        const int igfirst = *jmap ;
	for ( k = 0 ; k < NBJ ; ++k ) VBZ[k] = GI[igfirst+k] = VB[k] ;
        jmap += ldjmap * NBJ ;
        VB += NBJ ;
        VBZ+= NBJ ;
        j  += NBJ ;
      }
      VI += nloc ;
      VIZ+= nloc ;
    }

    /*  GIr = Arr^{-1} GIr   */
    slneumArrGIr( Y ) ;

    /*  GIb = Abr GIr   */
    slneumAbrGIr() ;

    /*  GIb = Yb - Abr Arr^{-1} Yr , Z = GI */
    VIZ= Z ;
    for ( i = 0 ; i < nblk ; ++i ) {
      const solve_blk_type * const blk   = solve_data->blk + i ;
      const int                    nloc  = blk->nloc ;
            _F_REAL_8      * const GI    = blk->gsol ;
            _F_REAL_8      *       VBZ   = VIZ ;

      jmap   = blk->jmap ;
      jblk   = blk->jblk ;
      jcolor = blk->jcolor ;
      for ( j = 0 ; j < nloc ; ) {
        const _F_INTEGER NBJ = *jblk++ ;
        const int igfirst = *jmap ;
        if ( color == *jcolor++ ) {
          for ( k = 0 ; k < NBJ ; ++k ) VBZ[k] = GI[igfirst+k] ;
        }
        else {
          for ( k = 0 ; k < NBJ ; ++k ) 
              VBZ[k] = GI[igfirst+k] = VBZ[k] - GI[igfirst+k] ;
        }
        jmap += ldjmap * NBJ ;
        j  += NBJ ;
        VBZ+= NBJ ;
      }
      VIZ+= nloc ;
    }


/* At this point,
   Correct values for Red lines are in Zr = GIr = Arr^{-1} Xr, 
           for Black lines are in Zb = GIb = Xb - Abr Arr^{-1} Xr  */

/* Apply Neumann series for preconditioning Shur complement 
   Schur = Abb - AbrArr^{-1}Arb 
   Y = Prec(Schur) Z */

   {
      _F_INTEGER  ITER = 100;
      
      const _F_INTEGER IZERO = 0 ;
      const _F_REAL_8  ZERO  = 0.0 ;

      _F_INTEGER   INFO = 0 ;
      _F_INTEGER fnunit = 6 ;
      _F_INTEGER imatvec = 0 ;
      _F_INTEGER igdsum = 0 ;
      _F_INTEGER iprevec = 0 ;

      _F_REAL_8  TMP, TMP2 ;
      _F_REAL_8  R8 ;

      _F_REAL_8  * WORK = WRK + N ;
      _F_INTEGER  NWORK ;


      /* REDUCE RESIDUAL NORM BT FACTOR 0.3 */
      TMP = r8dot(&N,Z,&IONE,Z,&IONE) ;
      _gr8sum( &igdsum, &IONE, &TMP , &TMP2 ) ;
      R8   = 0.6 * sqrt( TMP2 ) ;

      r8copy( &N, &ZERO, &IZERO, Y, &IONE );

      if ( solve_data->pspec[0] == SL_PREC_NEUPCG ) 
      {
        NWORK = 4 ;
       _slpcg(
        _gr8sum,       &igdsum,
        slprecneumser, &iprevec,
        slmulschur,    &imatvec,
        WORK , &N, &NWORK,                  // WORK(NALL,NWORK) 
        &N, Z, Y, &ITER, &R8, &INFO, &fnunit );
      }
      
      if ( solve_data->pspec[0] == SL_PREC_NEUPBCGS ) 
      {
        NWORK = 8 ;
       _slpbcgs(
        _gr8sum,       &igdsum,
        slprecneumser, &iprevec,
        slmulschur,    &imatvec,
        WORK , &N, &NWORK,                  // WORK(NALL,NWORK)
        &N, Z, Y, &ITER, &R8, &INFO, &fnunit );
      }

      if ( solve_data->pspec[0] == SL_PREC_NEUGMRES ) 
      {
       //  GMRES(RESTART/4)
      _F_INTEGER  MH, NH ;
       NWORK =  solve_data->sspec[1]/4 + 3 ;
       MH = NWORK + 1 ;
       NH = NWORK + 6 ;
      _slgmres(
        _gr8sum,       &igdsum,
        slprecneumser, &iprevec,
        slmulschur,    &imatvec,
        WORK , &N, &NWORK,                  // WORK(NALL,NWORK)
        WORK + N * NWORK, &MH, &NH,         /* H(MH,NH) */
        &N, Z, Y, &ITER, &R8, &INFO, &fnunit );
      }
      
      if ( solve_data->pspec[0] == SL_PREC_NEUSER ) 
        slprecneumser( &iprevec, &iprevec, Z, Y ) ;
   }

   

/* At this point,
   Correct values for Red lines are in Z: Zr = Arr^{-1} Xr, 
   for Black lines are in  Yb = Prec(Schur) (Xb - Abr Arr^{-1} Xr)  */

    /* GIb = Yb  */
    VI = Y ;
    for ( i = 0 ; i < nblk ; ++i ) {
      const solve_blk_type * const blk   = solve_data->blk + i ;
      const int                    nloc  = blk->nloc ;
            _F_REAL_8      * const GI    = blk->gsol ;
            _F_REAL_8      *       VB    = VI ;

      jmap   = blk->jmap ;
      jblk   = blk->jblk ;
      jcolor = blk->jcolor ;
      for ( j = 0 ; j < nloc ; ) {
        const _F_INTEGER NBJ = *jblk++ ;
        if ( color == *jcolor++ ) {
        }
        else {
        /*  GIb = Yb  */
          const int igfirst = *jmap ;
          for ( k = 0 ; k < NBJ ; ++k ) GI[igfirst+k] = VB[k] ;
        }
        jmap += ldjmap * NBJ ;
        VB += NBJ ;
        j  += NBJ ;
      }
      VI += nloc ;
    }


/* backward substitution ( Yr Yb )^t = U^{-1} ( GIr GIb )^t */

    /* GIr = Arb GIb */
    slneumArbGIb() ;

    /*  GIr = Arr^{-1} GIr   */ 
    slneumArrGIr( Y ) ;

    /* Yr = Zr - GIr,  Yb = GIb  */
    VI = Y ;
    VIZ= Z ;
    for ( i = 0 ; i < nblk ; ++i ) {
      const solve_blk_type * const blk   = solve_data->blk + i ;
      const int                    nloc  = blk->nloc ;
            _F_REAL_8      * const GI    = blk->gsol ;
            _F_REAL_8      *       VB    = VI ;
            _F_REAL_8      *       VBZ   = VIZ ;

      jmap   = blk->jmap ;
      jblk   = blk->jblk ;
      jcolor = blk->jcolor ;
      for ( j = 0 ; j < nloc ; ) {
        const _F_INTEGER NBJ = *jblk++ ;
        if ( color == *jcolor++ ) {
          /* Yr = Zr - GIr */
          const int igfirst = *jmap ;
          for ( k = 0 ; k < NBJ ; ++k ) 
              GI[igfirst+k] = VB[k] = VBZ[k] - GI[igfirst+k] ;
        }
        else {
        /*  Yb = GIb  */
          const int igfirst = *jmap ;
          for ( k = 0 ; k < NBJ ; ++k ) VB[k] = GI[igfirst+k] ;
        }
        jmap += ldjmap * NBJ ;
        VB += NBJ ;
        VBZ+= NBJ ;
        j  += NBJ ;
      }
      VI += nloc ;
      VIZ+= nloc ;
    }

}

/* Apply line (block) SOR preconditioner to vector
     ( *IOPT % 4 ) == 0  =>  Forward SFC sweep ordering
     ( *IOPT % 4 ) == 1  =>  Backward SFC sweep ordering
     ( *IOPT % 4 ) == 2  =>  Black ordering
     ( *IOPT % 4 ) == 3  =>  Red ordering
 */

static void slpresslinesorsol(
  const _F_INTEGER * const IOPT,  /* Input: which preconditioner option */ 
  const _F_REAL_8  * const OMEGA, /* Input: Omega input (0 == compute) */
  const _F_REAL_8  * const X ,    /* Input  */
        _F_REAL_8  *       Y )    /* Output */
{
  const int iomega = ( *OMEGA != 0.0 );
  const int nblk   = solve_data->nblk ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );

  const _F_INTEGER IZERO = 0 ;
  const _F_REAL_8  ZERO  = 0.0 ;
  const _F_INTEGER   IONE = 1 ;
  const _F_INTEGER   HBW  = 1 ;
  const _F_INTEGER   LDP  = 3 * HBW + 1 ;
  const _F_INTEGER   N    = solve_data->nloc ;
        _F_INTEGER   INFO = 0 ;
  _F_REAL_8 * VI = Y ;
  _F_INTEGER * jmap ;
  _F_INTEGER * jblk ;
  int i , j , k , is, istep ;
  int nstep;
  char buf[512] ;

  // get the current value of nstep from input file
  _set_gs_step(&nstep);
  
    /* Copy input vector to work (residual) grid, with scaling */
    //  if ( X != Y ) r8copy( &N, X, &IONE, Y, &IONE );

  /*------------------------------------------------------------------*/
  switch( *IOPT % 4 ) {
  case 1:
  case 3: {

    const int color = ( ( *IOPT % 4 ) == 1 ) ? 1 : 0 ;
    char   * jcolor ;

   /* Do nstep RB-linesor sweeps */
    for (istep = 0; istep < nstep; ++istep ) {
	/* 'Red' lines */

    const _F_REAL_8  * P  = solve_data->pwork ;
    const _F_INTEGER * IP = (_F_INTEGER *)( P + LDP * N );
          _F_REAL_8  * VI = Y ;

    /* Copy input vector to work (residual) grid, with scaling */
	if (istep > 0 ) r8copy( &N, X, &IONE, Y, &IONE );

#ifdef DEBUGGING_PQ_LSOR
		  SLMSG("'Red' lines");
#endif
    for ( i = 0 ; i < nblk ; ++i ) {
      const solve_blk_type * const blk   = solve_data->blk + i ;
      const double                 omega = iomega ? *OMEGA : 
        /* linesoromega(i) ;    */
            1.0 + istep*(linesoromega(i) - 1.0)/(nstep+1); 
       
      const int                    ldg   = blk->ldgrid ;
      const int                    nloc  = blk->nloc ;
      const _F_REAL_4      * const AJGI  = blk->gjac ;
            _F_REAL_8      * const GI    = blk->gres ;
            _F_REAL_8      *       VB    = VI ;

      jmap   = blk->jmap ;
      jblk   = blk->jblk ;
      jcolor = blk->jcolor ;

      for ( j = 0 ; j < nloc ; ) {

        const _F_INTEGER NBJ = *jblk++ ;

        if ( color == *jcolor++ ) {

          const int igfirst = *jmap ;
          const int iglast  = *(jmap + ldjmap * ( NBJ - 1));

          /* Update current vector block */

          if ( istep > 0 ) {
	      for ( k = 0 ; k < NBJ ; ++k , jmap += ldjmap ) {
		  const _F_REAL_4 * const A = AJGI + jmap[0] ;
		  const int isend = 2 * jmap[1] ;
		  double tmp = 0.0 ;
		  for ( is = 2 ; is <= isend ; is += 2 ) {
		      const int ig = jmap[1+is] ;
		      if ( ig < igfirst || iglast < ig ) {
#ifdef DEBUGGING_PQ_LSOR
			  sprintf(buf,"k+j = %d, ig = %d", k+j, ig);
			  SLMSG(buf);
#endif
			  tmp += A[ jmap[is] * ldg ] * GI[ig] ;
		      }
		  }
		  VB[k] -= tmp ;
	      }
	  }
	  else jmap += ldjmap * NBJ ;

          /* Solve for current vector block */

          r8gbtrs("N",(_F_INTEGER *)&NBJ,&HBW,&HBW,&IONE,P,&LDP,IP,VB,
(_F_INTEGER *)&NBJ,&INFO);

          if ( 0 != INFO ) {
            SLDIE("lapack band solve failed");
          }

          if ( omega != 1.0 ){
	      if (istep > 0 ) for ( k = 0 ; k < NBJ ; ++k ) 
                 VB[k] = GI[igfirst+k] += omega*(VB[k] - GI[igfirst+k]);
	      else for ( k = 0 ; k < NBJ ; ++k ) GI[igfirst+k] = VB[k] *= omega ;
	  }
	  else for ( k = 0 ; k < NBJ ; ++k ) GI[igfirst+k] = VB[k] ;
	}
        else {
          jmap += ldjmap * NBJ ;
        }

        P  += LDP * NBJ ;
        IP += NBJ ;
        VB += NBJ ;
        j  += NBJ ;
      }
      VI += nloc ;
    }

    /* Update grid */
    {
      const _F_INTEGER I4DG = solve_data->idgres ;
      const _F_INTEGER K4TG = solve_data->idktmp ;
      const _F_INTEGER I4V1 = 1 ;
      const _F_INTEGER I4V2 = 1 ;
      _slupdate( &I4DG , &I4V1, &I4V2, &K4TG );
    }

    /* 'Black' lines */
#ifdef DEBUGGING_PQ_LSOR
    SLMSG("'Black' lines");
#endif

    P  = solve_data->pwork ;
    IP = (_F_INTEGER *)( P + LDP * N );
    VI = Y ;

    for ( i = 0 ; i < nblk ; ++i ) {
      const solve_blk_type * const blk   = solve_data->blk + i ;
      const double                 omega = iomega ? *OMEGA :
          /* linesoromega(i) ;    */
               1.0 + istep*(linesoromega(i) - 1.0)/(nstep+1); 
      const int                    ldg   = blk->ldgrid ;
      const int                    nloc  = blk->nloc ;
      const _F_REAL_4      * const AJGI  = blk->gjac ;
            _F_REAL_8      * const GI    = blk->gres ;
            _F_REAL_8      *       VB    = VI ;

      jmap   = blk->jmap ;
      jblk   = blk->jblk ;
      jcolor = blk->jcolor ;

      for ( j = 0 ; j < nloc ; ) {

        const _F_INTEGER NBJ = *jblk++ ;

        if ( color == *jcolor++ ) {
          jmap += ldjmap * NBJ ;
        }
        else {
          const int igfirst = *jmap ;
          const int iglast  = *(jmap + ldjmap * ( NBJ - 1));

          /* Update current vector block */

          for ( k = 0 ; k < NBJ ; ++k , jmap += ldjmap ) {
            const _F_REAL_4 * const A = AJGI + jmap[0] ;
            const int isend = 2 * jmap[1] ;
            double tmp = 0.0 ;
	    // debug PQ
            for ( is = 2 ; is <= isend ; is += 2 ) {
              const int ig = jmap[1+is] ;
              if ( ig < igfirst || iglast < ig ) {
#ifdef DEBUGGING_PQ_LSOR
		  sprintf(buf,"k+j = %d, ig = %d", k+j, ig);
		  SLMSG(buf);
#endif
		tmp += A[ jmap[is] * ldg ] * GI[ig] ;
              }
            }
            VB[k] -= tmp ;
          }

          /* Solve for current vector block */

          r8gbtrs("N",&NBJ,&HBW,&HBW,&IONE,P,&LDP,IP,VB,&NBJ,&INFO);

          if ( 0 != INFO ) {
            SLDIE("lapack block solve failed");
          }

          if ( omega != 1.0 ){
	      if (istep > 0 ) for ( k = 0 ; k < NBJ ; ++k ) 
                  VB[k] = GI[igfirst+k] += omega*(VB[k] - GI[igfirst+k]);
	      else for ( k = 0 ; k < NBJ ; ++k ) GI[igfirst+k] = VB[k] *= omega ;
	  }
	  else for ( k = 0 ; k < NBJ ; ++k ) GI[igfirst+k] = VB[k] ;
        }

        P  += LDP * NBJ ;
        IP += NBJ ;
        VB += NBJ ;
        j  += NBJ ;
      }
      VI += nloc ;
    }

    /* Update grid */
    if (istep < nstep - 1 ) {
      const _F_INTEGER I4DG = solve_data->idgres ;
      const _F_INTEGER K4TG = solve_data->idktmp ;
      const _F_INTEGER I4V1 = 1 ;
      const _F_INTEGER I4V2 = 1 ;
      _slupdate( &I4DG , &I4V1, &I4V2, &K4TG );
    }
    }
    } break ;
    /*----------------------------------------------------------------*/
  case 2: { /* Forward SFC sweep ordering */
    const _F_REAL_8  * P    = solve_data->pwork ;
    const _F_INTEGER * IP   = (_F_INTEGER *)( P + LDP * N );

    /* Copy input vector to work (residual) grid, with scaling */
    if ( X != Y ) r8copy( &N, X, &IONE, Y, &IONE );

    for ( i = 0 ; i < nblk ; ++i ) {
      const solve_blk_type * const blk   = solve_data->blk + i ;
      const double                 omega = iomega ? *OMEGA : linesoromega(i) ;
      const int                    ldg   = blk->ldgrid ;
      const int                    nloc  = blk->nloc ;
      const _F_INTEGER     * const mapj  = blk->mapj ;
      const _F_REAL_4      * const AJGI  = blk->gjac ;
            _F_REAL_8      *       VB    = VI ;

      jblk = blk->jblk ;
      jmap = blk->jmap ;

      for ( j = 0 ; j < nloc ; ) {

        const _F_INTEGER NBJ = *jblk++ ;

        /* Update current vector block */

        for ( k = 0 ; k < NBJ ; ++k , jmap += ldjmap ) {
          const _F_REAL_4 * const A = AJGI + jmap[0] ;
          const int isend = 2 * jmap[1] ;
          double tmp = 0.0 ;
          for ( is = 2 ; is < isend ; is += 2 ) {
            const int iv = mapj[ jmap[1+is] ] ;
            if ( 0 <= iv && iv < j ) tmp += A[ jmap[is] * ldg ] * VI[iv] ;
          }
          VB[k] -= tmp ;
        }

        /* Solve for current vector block */

        r8gbtrs("N",&NBJ,&HBW,&HBW,&IONE,P,&LDP,IP,VB,&NBJ,&INFO);

        if ( 0 != INFO ) {
          SLDIE("lapack band solve failed");
        }

        if ( omega != 1.0 ) 
	  for ( k = 0 ; k < NBJ ; ++k )  VB[k] *= omega ;

        P  += LDP * NBJ ;
        IP += NBJ ;
        VB += NBJ ;
        j  += NBJ ;
      }
      VI += nloc ;
    }
    
    } break ;
    /*----------------------------------------------------------------*/
  case 0: { /* Backward SFC sweep ordering */

    const _F_REAL_8  * PI  = solve_data->pwork ;
    const _F_INTEGER * IPI = (_F_INTEGER *)( PI + LDP * N );

    /* Copy input vector to work (residual) grid, with scaling */
    if ( X != Y ) r8copy( &N, X, &IONE, Y, &IONE );

    for ( i = 0 ; i < nblk ; ++i ) {
      const solve_blk_type * const blk   = solve_data->blk + i ;
      const double                 omega = iomega ? *OMEGA : linesoromega(i) ;
      const int                    ldg   = blk->ldgrid ;
      const int                    nloc  = blk->nloc ;
      const _F_INTEGER     * const mapj  = blk->mapj ;
      const _F_REAL_4      * const AJGI  = blk->gjac ;
            _F_REAL_8      *       VB    = VI + nloc ;
      const _F_REAL_8      *       PB    = PI + LDP * nloc ;
      const _F_INTEGER     *       IPB   = IPI + nloc ;

      jblk = blk->jblk + blk->nblk ;
      jmap = blk->jmap + nloc * ldjmap ;

      for ( j = nloc ; 0 < j ; ) {

        const _F_INTEGER NBJ = *--jblk ;

        PB   -= LDP * NBJ ;
        IPB  -= NBJ ;
        VB   -= NBJ ;
        jmap -= NBJ * ldjmap ;

        /* Update current vector block */

        for ( k = 0 ; k < NBJ ; ++k , jmap += ldjmap ) {
          const _F_REAL_4 * const A = AJGI + jmap[0] ;
          const int isend = 2 * jmap[1] ;
          double tmp = 0.0 ;
          for ( is = 2 ; is < isend ; is += 2 ) {
            const int iv = mapj[ jmap[1+is] ] ;
            if ( j <= iv ) tmp += A[ jmap[is] * ldg ] * VI[iv] ;
          }
          VB[k] -= tmp ;
        }

        j -= NBJ ;

        /* Solve for current vector block */

        r8gbtrs("N",&NBJ,&HBW,&HBW,&IONE,PB,&LDP,IPB,VB,&NBJ,&INFO);

        if ( 0 != INFO ) {
          SLDIE("lapack block solve failed");
        }

        if ( omega != 1.0 ) 
	  for ( k = 0 ; k < NBJ ; ++k ) VB[k] *= omega ;

      }

      VI  += nloc ;
      PI  += LDP * nloc ;
      IPI += nloc ;
   }
   } break ;
  }
}

static void slpresslinesorsolco(
  const _F_REAL_8  * const X ,    /* Input  */
        _F_REAL_8  *       Y ,    /* Output */
  const _F_REAL_8  *      XX ,    /* Input labels */
        _F_REAL_8  *      YY ,    /* Work   */
        _F_REAL_8  *    Asum )    /* Input&work  */
{
  const int nblk   = solve_data->nblk ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );

  //subdomain values
        _F_REAL_8  * Fsub = Asum + nblk  ;
        _F_REAL_8  * Ysub = Fsub + nblk  ;
        _F_REAL_8  * Rsub = Ysub + nblk  ;

  const _F_REAL_8   OMEGA = 0.0 ;
  const int iomega = ( OMEGA != 0.0 );

  const _F_INTEGER IZERO = 0 ;
  const _F_REAL_8  ZERO  = 0.0 ;
  const _F_INTEGER   IONE = 1 ;
  const _F_INTEGER   HBW  = 1 ;
  const _F_INTEGER   LDP  = 3 * HBW + 1 ;
  const _F_INTEGER   N    = solve_data->nloc ;
        _F_INTEGER   INFO = 0 ;



  _F_INTEGER * jmap ;
  _F_INTEGER * jblk ;
  int i , j , k , is, istep ;
  int nstep;
  char buf[512] ;


  const int color = 0 ;
  char   * jcolor ;

  // get the current value of nstep from input file
  _set_gs_step(&nstep);
  

 /* Do nstep CRB-linesor sweeps */
 for (istep = 0; istep < nstep; ++istep ) {

    /* Coarse vector */
    const _F_REAL_8  * P  = solve_data->pwork ;
    const _F_INTEGER * IP = (_F_INTEGER *)( P + LDP * N );
          _F_REAL_8  * VI = Y ;
    const _F_REAL_8  * XI = XX ;
    const _F_REAL_8  * UI = X ;
          _F_REAL_8  * YI = YY ;


    if ( istep > 0 ){
       for (j=0;j<N;++j) if ( XX[j] != 0.0 ) YY[j] = 0.0 ;
       slvec2grid( 1, YY, 1.0, 0, 1);
    }

    for ( i = 0 ; i < nblk ; ++i ) {
      const solve_blk_type * const blk   = solve_data->blk + i ;
      const double                 omega = iomega ? OMEGA :
        /* linesoromega(i) ;    */
            1.0 + istep*(linesoromega(i) - 1.0)/(nstep+1);

      const int                    ldg   = blk->ldgrid ;
      const int                    nloc  = blk->nloc ;
      const _F_INTEGER     * const mapj = blk->mapj ;
      const _F_REAL_4      * const AJGI  = blk->gjac ;
            _F_REAL_8      * const GI    = blk->gres ;
      const _F_REAL_8      *       VX    = XI ;

      jmap   = blk->jmap ;
      jblk   = blk->jblk ;

      if ( istep == 0 ) {
         Fsub[i] = 0.0 ;
         for (j=0;j<nloc;++j) if ( XI[j] != 0.0 )  Fsub[i] += UI[j] ;
         if ( nloc != 0 ) {
            Ysub[i] = Fsub[i]/Asum[i] ;
            Rsub[i] = Ysub[i] *= omega ;
         }
         for (j=0;j<nloc;++j){          
            if ( XI[j] != 0.0 ) VI[j] = YI[j] = Ysub[i] ;
            else                YI[j] = 0.0 ;
            // needed for the first step of LSOR for red lines
         }
      }
      else{
         Ysub[i] = Fsub[i] ;

         for ( j = 0 ; j < nloc ; ) {
           const _F_INTEGER NBJ = *jblk++ ;

           if ( VX[0] == 0.5 ) { 
	      for ( k = 0 ; k < NBJ ; ++k , jmap += ldjmap ) {
		  const _F_REAL_4 * const A = AJGI + jmap[0] ;
		  const int isend = 2 * jmap[1] ;
		  double tmp = 0.0 ;
		  for ( is = 2 ; is <= isend ; is += 2 ) {
		      const int ig = jmap[1+is] ;
	              tmp += A[ jmap[is] * ldg ] * GI[ig] ;
		  }
                  Ysub[i] -= tmp ; 
	      }
           }
           else jmap += ldjmap * NBJ ;

           P  += LDP * NBJ ;
           IP += NBJ ;
           VX += NBJ ;
           j  += NBJ ;
         }

         /* Solve for coarse vector */
         if ( nloc != 0 ) {
            Ysub[i] /= Asum[i] ;
            Ysub[i] = Rsub[i] += omega*(Ysub[i]-Rsub[i]) ;
         }
         for (j=0;j<nloc;++j){
            if ( XI[j] != 0.0 ) VI[j] = YI[j] = Ysub[i] ;
            else                VI[j] = UI[j] ;
         }
      }

      VI += nloc ;
      XI += nloc ;
      UI += nloc ;
      YI += nloc ;
    }

    slvec2grid( 1, YY, 1.0, 0, 1);
    /* Update grid */
    {
      const _F_INTEGER I4DG = solve_data->idgres ;
      const _F_INTEGER K4TG = solve_data->idktmp ;
      const _F_INTEGER I4V1 = 1 ;
      const _F_INTEGER I4V2 = 1 ;
      _slupdate( &I4DG , &I4V1, &I4V2, &K4TG );
    }


    /* 'Red' lines */
    P  = solve_data->pwork ;
    IP = (_F_INTEGER *)( P + LDP * N );
    VI = Y ;
    XI = XX ;



    for ( i = 0 ; i < nblk ; ++i ) {
      const solve_blk_type * const blk   = solve_data->blk + i ;
      const double                 omega = iomega ? OMEGA : 
        /* linesoromega(i) ;    */
            1.0 + istep*(linesoromega(i) - 1.0)/(nstep+1); 
       
      const int                    ldg   = blk->ldgrid ;
      const int                    nloc  = blk->nloc ;
      const _F_INTEGER     * const mapj = blk->mapj ;
      const _F_REAL_4      * const AJGI  = blk->gjac ;
            _F_REAL_8      * const GI    = blk->gres ;
            _F_REAL_8      *       VB    = VI ;
      const _F_REAL_8      *       VX    = XI ;

      jmap   = blk->jmap ;
      jblk   = blk->jblk ;
      jcolor = blk->jcolor ;

      for ( j = 0 ; j < nloc ; ) {

        const _F_INTEGER NBJ = *jblk++ ;

        if ( color == *jcolor++ ) {

          const int igfirst = *jmap ;
          const int iglast  = *(jmap + ldjmap * ( NBJ - 1));

          /* Update current vector block */

      // GI is assumed to equal 0 
      // at istep=0 for black cells which are not coarse
            if ( VX[0] == 0.0 ) {
	      for ( k = 0 ; k < NBJ ; ++k , jmap += ldjmap ) {
		  const _F_REAL_4 * const A = AJGI + jmap[0] ;
		  const int isend = 2 * jmap[1] ;
		  double tmp = 0.0 ;
		  for ( is = 2 ; is <= isend ; is += 2 ) {
		      const int ig = jmap[1+is] ;
		      if ( ig < igfirst || iglast < ig ) {
			  tmp += A[ jmap[is] * ldg ] * GI[ig] ;
		      }
		  }
		  VB[k] -= tmp ;
	      }
            }
	    else jmap += ldjmap * NBJ ;

          /* Solve for current vector block */

          if ( VX[0] == 0.0 ) {
            r8gbtrs("N",(_F_INTEGER *)&NBJ,&HBW,&HBW,&IONE,P,&LDP,IP,VB,
                    (_F_INTEGER *)&NBJ,&INFO);
            if ( 0 != INFO ) {
              SLDIE("lapack band solve failed");
            }
          }


          if ( VX[0] == 0.0 ) { 
	      if (istep > 0 ) for ( k = 0 ; k < NBJ ; ++k ) 
                 VB[k] = GI[igfirst+k] += omega*(VB[k] - GI[igfirst+k]);
	      else for ( k = 0 ; k < NBJ ; ++k ) GI[igfirst+k] = VB[k] *= omega;
          }
	}
        else {
          jmap += ldjmap * NBJ ;
        }

        P  += LDP * NBJ ;
        IP += NBJ ;
        VB += NBJ ;
        VX += NBJ ;
        j  += NBJ ;
      }
      VI += nloc ;
      XI += nloc ;
    }

    /* Update grid */
    {
      const _F_INTEGER I4DG = solve_data->idgres ;
      const _F_INTEGER K4TG = solve_data->idktmp ;
      const _F_INTEGER I4V1 = 1 ;
      const _F_INTEGER I4V2 = 1 ;
      _slupdate( &I4DG , &I4V1, &I4V2, &K4TG );
    }

    /* 'Black' lines */

    P  = solve_data->pwork ;
    IP = (_F_INTEGER *)( P + LDP * N );
    VI = Y ;
    XI = XX;

    for ( i = 0 ; i < nblk ; ++i ) {
      const solve_blk_type * const blk   = solve_data->blk + i ;
      const double                 omega = iomega ? OMEGA :
          /* linesoromega(i) ;    */
               1.0 + istep*(linesoromega(i) - 1.0)/(nstep+1); 
      const int                    ldg   = blk->ldgrid ;
      const int                    nloc  = blk->nloc ;
      const _F_INTEGER     * const mapj = blk->mapj ;
      const _F_REAL_4      * const AJGI  = blk->gjac ;
            _F_REAL_8      * const GI    = blk->gres ;
            _F_REAL_8      *       VB    = VI ;
      const _F_REAL_8      *       VX    = XI ;

      jmap   = blk->jmap ;
      jblk   = blk->jblk ;
      jcolor = blk->jcolor ;

      for ( j = 0 ; j < nloc ; ) {

        const _F_INTEGER NBJ = *jblk++ ;

        if ( color == *jcolor++ ) {
          jmap += ldjmap * NBJ ;
        }
        else {
          const int igfirst = *jmap ;
          const int iglast  = *(jmap + ldjmap * ( NBJ - 1));

          /* Update current vector block */

         if ( VX[0] == 0.0 ) {
          for ( k = 0 ; k < NBJ ; ++k , jmap += ldjmap ) {
            const _F_REAL_4 * const A = AJGI + jmap[0] ;
            const int isend = 2 * jmap[1] ;
            double tmp = 0.0 ;
            for ( is = 2 ; is <= isend ; is += 2 ) {
              const int ig = jmap[1+is] ;
              if ( ig < igfirst || iglast < ig ) {
		tmp += A[ jmap[is] * ldg ] * GI[ig] ;
              }
            }
            VB[k] -= tmp ;
          }

          /* Solve for current vector block */
          r8gbtrs("N",&NBJ,&HBW,&HBW,&IONE,P,&LDP,IP,VB,&NBJ,&INFO);
          if ( 0 != INFO ) {
            SLDIE("lapack block solve failed");
          }

	  if (istep > 0 ) for ( k = 0 ; k < NBJ ; ++k ) 
              VB[k] = GI[igfirst+k] += omega*(VB[k] - GI[igfirst+k]);
	  else for ( k = 0 ; k < NBJ ; ++k ) GI[igfirst+k] = VB[k] *= omega ;
         }
         else jmap += ldjmap * NBJ ;
        }

        P  += LDP * NBJ ;
        IP += NBJ ;
        VB += NBJ ;
        VX += NBJ ;
        j  += NBJ ;
      }
      VI += nloc ;
      XI += nloc ;
    }

    /* Update grid */
    if (istep < nstep - 1 ) {
      const _F_INTEGER I4DG = solve_data->idgres ;
      const _F_INTEGER K4TG = solve_data->idktmp ;
      const _F_INTEGER I4V1 = 1 ;
      const _F_INTEGER I4V2 = 1 ;
      _slupdate( &I4DG , &I4V1, &I4V2, &K4TG );
      slgrid2vec( 1, YY, 1.0, 0, 1);
    }

 } 



}

static void slpressblockJac(
        _F_REAL_8  *       Y )    /* Inout-Output */
{
  const int nblk   = solve_data->nblk ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );

  const _F_INTEGER   IONE  = 1 ;
  const _F_INTEGER   HBW  = 1 ;
  const _F_INTEGER   LDP  = 3 * HBW + 1 ;
  const _F_INTEGER   N    = solve_data->nloc ;
        _F_INTEGER   INFO = 0 ;
  _F_REAL_8 * VI = Y ;
  _F_INTEGER * jmap ;
  _F_INTEGER * jblk ;
  int i , j , k , is ;
  char buf[512] ;

  const _F_REAL_8  * PI  = solve_data->pwork ;
  const _F_INTEGER * IPI = (_F_INTEGER *)( PI + LDP * N );

    for ( i = 0 ; i < nblk ; ++i ) {
      const solve_blk_type * const blk   = solve_data->blk + i ;
      const int                    ldg   = blk->ldgrid ;
      const int                    nloc  = blk->nloc ;
      const _F_INTEGER     * const mapj  = blk->mapj ;
            _F_REAL_8      *       VB    = VI + nloc ;
      const _F_REAL_8      *       PB    = PI + LDP * nloc ;
      const _F_INTEGER     *       IPB   = IPI + nloc ;

      jblk = blk->jblk + blk->nblk ;
      jmap = blk->jmap + nloc * ldjmap ;

      for ( j = nloc ; 0 < j ; ) {

        const _F_INTEGER NBJ = *--jblk ;

        PB   -= LDP * NBJ ;
        IPB  -= NBJ ;
        VB   -= NBJ ;
        jmap -= NBJ * ldjmap ;

        j -= NBJ ;

        /* Solve for current vector block */

        r8gbtrs("N",&NBJ,&HBW,&HBW,&IONE,PB,&LDP,IPB,VB,&NBJ,&INFO);

        if ( 0 != INFO ) {
          SLDIE("lapack block solve failed");
        }

      }

      VI  += nloc ;
      PI  += LDP * nloc ;
      IPI += nloc ;
   }
}
/*----------------------------------------------------------------------*/

static void slpresslinefac()
{
  const int nblk   = solve_data->nblk ;
  const int ns     = solve_data->ns ;
  const int nev    = solve_data->nev ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );

  const _F_INTEGER         IONE  = 1 ;
  const _F_INTEGER         NALL  = solve_data->nloc ;
  const _F_INTEGER         HBW   = 1 ;
  const _F_INTEGER         MB    = 2 * HBW ;
  const _F_INTEGER         LDP   = 3 * HBW + 1 ;
        _F_REAL_8  * const PALL  = solve_data->pwork ;
        _F_INTEGER * const IPALL = (_F_INTEGER *)( PALL + LDP * NALL );
        _F_INTEGER         INFO  = 0 ;

  int i, j, k, iv, ie, ib, is ;
  const _F_INTEGER * jblk = NULL ;
  const _F_INTEGER * jmap = NULL ;

  /* Fill the preconditioner matrix */

  _F_REAL_8 * P = PALL ;
  _F_INTEGER * IP = IPALL ;

  {
    const int iend = LDP * NALL ;
    for ( i = 0 ; i < iend ; ++i ) PALL[i] = 0.0 ;
  }

  for ( i = 0 ; i < nblk ; ++i ) {
    const solve_blk_type * const blk  = solve_data->blk + i ;
    const int                    ldg  = blk->ldgrid ;
    const int                    nloc = blk->nloc ;
    const _F_INTEGER     * const mapj = blk->mapj ;
    const _F_REAL_4      * const AJGI = blk->gjac ;

    jblk = blk->jblk ;
    jmap = blk->jmap ;

    for ( j = 0 ; j < nloc ; ) {

      const _F_INTEGER NBJ = *jblk++ ;

      /* Fill block matrix */

      for ( k = 0 ; k < NBJ ; ++k , jmap += ldjmap ) {
        const _F_REAL_4 * const A = AJGI + jmap[0] ;
        const int isend = 2 * jmap[1] ;

        for ( is = 2 ; is <= isend ; is += 2 ) {
          const int ib = mapj[ jmap[is+1] ] - ( j + k );
          if ( - HBW <= ib && ib <= HBW ) {
             P[(MB-ib)+(k+ib)*LDP] = A[ jmap[is] * ldg ];
          }
        }
      }

      if ( solve_data->pspec[0] == SL_PREC_NEUPCG ) {
        /* Symmetrization */
        for ( k = 1 ; k < NBJ ; ++k ){
         if ( fabs( P[MB-1+k*LDP] ) < fabs( P[MB+1+(k-1)*LDP] ) ){
            P[MB+1+(k-1)*LDP] = P[MB-1+k*LDP] ;
         }
         else {
            P[MB-1+k*LDP] = P[MB+1+(k-1)*LDP] ;
         }
        }
      }


      /* Band factorization */

      r8gbtrf(&NBJ,&NBJ,&HBW,&HBW,P,&LDP,IP,&INFO);

      if ( 0 != INFO ) {
        SLDIE("lapack band factorization failed");
      }

      IP += NBJ ;
      P  += LDP * NBJ ;
      j  += NBJ ;
    }
  }
}

/*----------------------------------------------------------------------*/
/* Block diagonal (Jacobi) preconditioning for component equations.
   The cell centered block has been "decoupled" to lower triangular
   -> forward substitution
 */

static void slcompblksol( _F_REAL_8 * X , _F_REAL_8 * Y )
{
  const int nblk   = solve_data->nblk ;
  const int ns     = solve_data->ns ;
  const int nev    = solve_data->nev ;
  const int nev1   = nev - 1 ;
  const int ldvec  = solve_data->nloc ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );

  const _F_REAL_8 * V = X ;
        _F_REAL_8 * W = Y ;

  int i, j, iv, ie, ib, is, ic ;

  const _F_INTEGER * jmap ;

#ifdef DEBUGGING
  _F_REAL_4 * ATMP = fr4_alloc( ( nev - 1 ) * ( nev - 1 ) );
#endif

  for ( i = 0 ; i < nblk ; ++i ) {
    const solve_blk_type * const blk   = solve_data->blk + i ;
    const int                    ldg   = blk->ldgrid ;
    const int                    ldgns = ldg * ns ;
    const int                    nloc  = blk->nloc ;
    const _F_INTEGER     * const jbeg  = blk->jmap ;
    const _F_INTEGER     * const jend  = jbeg + nloc * ldjmap ;
    const _F_REAL_4      * const AJGI  = blk->gjac + (nev+1) * ldgns ;

    for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap , ++V , ++W ) {

      const _F_REAL_4 * const A = AJGI + jmap[0] ;

#ifdef DEBUGGING
      for ( iv = 0 ; iv < nev1 ; ++iv ) {
        for ( ie = 0 ; ie < nev1 ; ++ie ) {
          ATMP[ie+iv*(nev-1)] = A[(ie+iv*nev)*ldgns] ;
        }
      }
#endif

      /* Forward substitution */

      for ( iv = 0 ; iv < nev1 ; ++iv ) {
        W[iv*ldvec] = V[iv*ldvec] / A[iv*(1+nev)*ldgns] ;
        for ( ie = iv + 1 ; ie < nev1 ; ++ie ) {
          W[ie*ldvec] -= A[(ie+iv*nev)*ldgns] * W[iv*ldvec] ;
        }
      }
    }
  }
#ifdef DEBUGGING
  free( ATMP );
#endif
}

/* Block diagonal (Jacobi) preconditioning for component equations.
   The cell centered block must be factorized first
 */

int flag_alloc = 1; //global flag for allocating small memory once
_F_REAL_8 * WA;
_F_INTEGER * IP;

static void slcompblksol_fctrz( _F_REAL_8 * X , _F_REAL_8 * Y )
{
  const int nblk   = solve_data->nblk ;
  const int ns     = solve_data->ns ;
  const int nev    = solve_data->nev ;
  const int nev1   = nev - 1 ;
  const int ldvec  = solve_data->nloc ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );

  const _F_REAL_8 * V = X ;
        _F_REAL_8 * W = Y ;

  int i, j, iv, ie, ib, is, ic, ivoff ;

  const _F_INTEGER * jmap ;

  _F_INTEGER NEV = nev1 ;
  _F_INTEGER INFO ;
  _F_INTEGER IONE = 1 ;

  if (flag_alloc) {
     WA = fr8_alloc( nev1 * ( nev1 + 1 ) ) ;
     IP = fi_alloc(  nev1  ) ;
     flag_alloc = 0 ;
  }


  for ( i = 0 ; i < nblk ; ++i ) {
    const solve_blk_type * const blk   = solve_data->blk + i ;
    const int                    ldg   = blk->ldgrid ;
    const int                    ldgns = ldg * ns ;
    const int                    nloc  = blk->nloc ;
    const _F_INTEGER     * const jbeg  = blk->jmap ;
    const _F_INTEGER     * const jend  = jbeg + nloc * ldjmap ;
    const _F_REAL_4      * const AJGI  = blk->gjac + (nev+1) * ldgns ;

    for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap , ++V , ++W ) {

      const _F_REAL_4 * const A = AJGI + jmap[0] ;
                 _F_REAL_8 * WS = WA + NEV*NEV ;


        for ( iv = 0 ; iv < NEV ; ++iv ) {
          WS[iv] = V[iv*ldvec] ;
          ivoff = iv * NEV ;
          for ( ie = 0 ; ie < NEV ; ++ie ) {
            WA[ivoff + ie] =  A[(ie+iv*nev)*ldgns] ;
          }
        }
        r8getrf(&NEV,&NEV,WA,&NEV,IP,&INFO);
        if ( 0 != INFO ) {
         SLDIE("lapack factorization failed");
        }
        r8getrs("N",&NEV,&IONE,WA,&NEV,IP,WS,&NEV,&INFO);
        if ( 0 != INFO ) {
         SLDIE("lapack solution failed");
        }

        for ( iv = 0 ; iv < nev1 ; ++iv ) {
         W[iv*ldvec] = WS[iv] ;
        }
    }
  }
}

static void slcompblksolCouple( _F_REAL_8 * X, _F_REAL_8 * Y )
{
  const int nblk   = solve_data->nblk ;
  const int ns     = solve_data->ns ;
  const int nev    = solve_data->nev ;
  const int ldvec  = solve_data->nloc ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );

        _F_REAL_8 * V = X ;
        _F_REAL_8 * W = Y ;

  int i, j, iv, ie, ib, is, ic ;

  const _F_INTEGER * jmap ;


  for ( i = 0 ; i < nblk ; ++i ) {
    const solve_blk_type * const blk   = solve_data->blk + i ;
    const int                    ldg   = blk->ldgrid ;
    const int                    ldgns = ldg * ns ;
    const int                    nloc  = blk->nloc ;
    const _F_INTEGER     * const jbeg  = blk->jmap ;
    const _F_INTEGER     * const jend  = jbeg + nloc * ldjmap ;
    const _F_REAL_4      * const AJGI  = blk->gjac ;

    for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap , ++V , ++W ) {

      const _F_REAL_4 * const A = AJGI + jmap[0] ;


      /* Forward substitution */

      for ( iv = 0 ; iv < nev ; ++iv ) {
        W[iv*ldvec] = V[iv*ldvec] / A[iv*(1+nev)*ldgns] ;
        for ( ie = iv + 1 ; ie < nev ; ++ie ) {
          W[ie*ldvec] -= A[(ie+iv*nev)*ldgns] * W[iv*ldvec] ;
        }
      }
    }
  }
}


static void ilu0()
{
  const int nblk   = solve_data->nblk ;
  const int ldvec  = solve_data->nloc ;
  const int ns     = solve_data->ns ;
  const int nev    = solve_data->nev ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );
  const int nall   = ldvec*nev ;

  int i,j,k, iv, ie, is ;
  const _F_INTEGER * jmap ;
  _F_REAL_8 element ;
  int       found ;

  _F_REAL_4  * val = solve_data->pworksr ;
  _F_INTEGER * row_ptr = solve_data->pworksi ;
  _F_INTEGER * col_ind = row_ptr + nall+1 ;
  _F_INTEGER * diag_ptr = col_ind + nall*nev*ns ;
  _F_INTEGER * iw = diag_ptr + nall ;

  for ( j = 0 ; j < nall + 1 ; ++j ) row_ptr[j] = 0 ;

  for ( iv = 0 ; iv < nev ; ++iv ) {
    const int ivoff = iv * nev ;
    for ( ie = 0 ; ie < nev ; ++ie ) {
      const int ieoff = ns * ( ie + ivoff );
      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    ldg  = blk->ldgrid ;
        const int                    nloc = blk->nloc ;
        const int                    disp = blk->disp ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const mapj = blk->mapj ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;


        for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap  ) {
          const int isend = 2 * jmap[1] ;
                int ir    =(jmap-jbeg)/ldjmap+1 +disp + nloc * ie;

          for ( is = 2 ; is <= isend ; is += 2 ){ 
              int iclo  = mapj[jmap[1+is]]+1;
              if ( iclo != 0 ) row_ptr[ir] += 1 ;
          }
        }
      }
    }
  }


  row_ptr[0] = 0 ;
  for ( j = 1 ; j < nall + 1 ; ++j ) row_ptr[j] += row_ptr[j-1]  ;
  for ( j = 0 ; j < row_ptr[ nall ] ; ++j ) col_ind[j] = -1  ;

  for ( iv = 0 ; iv < nev ; ++iv ) {
    const int ivoff = iv * nev ;
    for ( ie = 0 ; ie < nev ; ++ie ) {
      const int ieoff = ns * ( ie + ivoff );
      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    ldg  = blk->ldgrid ;
        const int                    nloc = blk->nloc ;
        const int                    disp = blk->disp ;
        const _F_INTEGER     * const mapj = blk->mapj ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;
        const _F_REAL_4      * const AJGI = blk->gjac + ldg * ieoff ;

        for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
          const _F_REAL_4 * const A = AJGI + jmap[0] ;
          const int isend = 2 * jmap[1] ;
                int ir    = (jmap-jbeg)/ldjmap+disp + nloc* ie;

          for ( is = 2 ; is <= isend ; is += 2 ) {
              int ic    = mapj[jmap[1+is]]+disp + nloc* iv ;
              int iclo  = mapj[jmap[1+is]]+1;
              if ( iclo != 0 ) {
                for ( j = row_ptr[ir] ; j < row_ptr[ir+1] ; ++j ) {
                    if ( col_ind[j] == -1 )  {
                       col_ind[j] = ic ;
                       val[j] = A[ jmap[is] * ldg ]; //*GI[ jmap[1+is] ];
                       break ;
                    }
                }
              }
          }
        }
      }
    }
  }

  for ( i=0; i<nall; ++i ) {
       for ( j = row_ptr[i] ; j < row_ptr[i+1] ; ++j ) {
           for ( k = j+1 ; k < row_ptr[i+1] ; ++k ) {
               if ( col_ind[j] > col_ind[k] ) {
                    int idum ;
                    _F_REAL_4 rdum ;
                    idum = col_ind[k]; rdum = val[k] ;
                    col_ind[k] = col_ind[j]; val[k] = val[j];
                    col_ind[j] = idum ; val[j] = rdum ;
               }
           }
       }
  } 

/*
  for ( i = 0 ; i < nall ; ++i ) {
         printf("%d :", i) ;
         for ( j = row_ptr[i] ; j < row_ptr[i+1] ; ++j ) 
             printf( " %d", col_ind[j] );
             //printf( " %.15g", val[j] );
         printf("\n") ;
  }
  SLDIE("stop");
*/
  for ( i=0; i<nall; ++i ) iw[i] = -1 ; 

  for ( k=0; k<nall; ++k ) {
      int j1,j2,jrow,jw,jj ;
      _F_REAL_4 tl, s ;
      j1 = row_ptr[k] ;
      j2 = row_ptr[k+1] ;
      for ( j=j1; j<j2; ++j ) iw[ col_ind[j] ] = j ;
      j = j1 ;
//    s = 0.0 ; //milu
A150: jrow = col_ind[j] ;
      if (jrow>=k) goto A200 ;
      tl = val[j]*val[diag_ptr[jrow]] ;
      val[j] = tl ;
      for ( jj=diag_ptr[jrow]+1; jj<row_ptr[jrow+1]; ++jj ) {
          jw = iw[ col_ind[ jj ] ] ;
          if ( jw != -1 ) val[jw] = val[jw]-tl*val[jj] ;
//        else            s += tl*val[jj] ; //milu
      }
      j += 1 ;
      if (j < j2 ) goto A150;
A200: diag_ptr[k] = j ;
//    val[j] -= s ; //milu
      if (jrow != k || val[j] == 0.0) SLDIE( "zero pivot. stop");
      val[j] = 1.0/val[j] ;
      for ( i=j1; i<j2; ++i ) iw[ col_ind[i] ] = -1;
  }

}

static void dilu()
{
  const int nblk   = solve_data->nblk ;
  const int ldvec  = solve_data->nloc ;
  const int ns     = solve_data->ns ;
  const int nev    = solve_data->nev ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );
  const int nall   = ldvec*nev ;

  int i,j,k, iv, ie, is ;
  const _F_INTEGER * jmap ;
  _F_REAL_4 element ;
  int       found ;

  _F_REAL_4  * val = solve_data->pworksr ;
  _F_REAL_4  * pivots = val + nall*nev*ns ;
  _F_INTEGER * row_ptr = solve_data->pworksi ;
  _F_INTEGER * col_ind = row_ptr + nall+1 ;
  _F_INTEGER * diag_ptr = col_ind + nall*nev*ns ;

  for ( j = 0 ; j < nall + 1 ; ++j ) row_ptr[j] = 0 ;

  for ( iv = 0 ; iv < nev ; ++iv ) {
    const int ivoff = iv * nev ;
    for ( ie = 0 ; ie < nev ; ++ie ) {
      const int ieoff = ns * ( ie + ivoff );
      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    ldg  = blk->ldgrid ;
        const int                    nloc = blk->nloc ;
        const int                    disp = blk->disp ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const mapj = blk->mapj ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;


        for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap  ) {
          const int isend = 2 * jmap[1] ;
                int ir    =(jmap-jbeg)/ldjmap+1 +disp + nloc * ie;

          for ( is = 2 ; is <= isend ; is += 2 ){ 
              int iclo  = mapj[jmap[1+is]]+1;
              if ( iclo != 0 ) row_ptr[ir] += 1 ;
          }
        }
      }
    }
  }


  row_ptr[0] = 0 ;
  for ( j = 1 ; j < nall + 1 ; ++j ) row_ptr[j] += row_ptr[j-1]  ;
  for ( j = 0 ; j < row_ptr[ nall ] ; ++j ) col_ind[j] = -1  ;

  for ( iv = 0 ; iv < nev ; ++iv ) {
    const int ivoff = iv * nev ;
    for ( ie = 0 ; ie < nev ; ++ie ) {
      const int ieoff = ns * ( ie + ivoff );
      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    ldg  = blk->ldgrid ;
        const int                    nloc = blk->nloc ;
        const int                    disp = blk->disp ;
        const _F_INTEGER     * const mapj = blk->mapj ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;
        const _F_REAL_4      * const AJGI = blk->gjac + ldg * ieoff ;

        for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
          const _F_REAL_4 * const A = AJGI + jmap[0] ;
          const int isend = 2 * jmap[1] ;
                int ir    = (jmap-jbeg)/ldjmap+disp + nloc* ie;

          for ( is = 2 ; is <= isend ; is += 2 ) {
              int ic    = mapj[jmap[1+is]]+disp + nloc* iv ;
              int iclo  = mapj[jmap[1+is]]+1;
              if ( iclo != 0 ) {
                for ( j = row_ptr[ir] ; j < row_ptr[ir+1] ; ++j ) {
                    if ( col_ind[j] == -1 )  {
                       col_ind[j] = ic ;
                       val[j] = A[ jmap[is] * ldg ]; //*GI[ jmap[1+is] ];
                       break ;
                    }
                }
              }
          }
        }
      }
    }
  }

  for ( i=0; i<nall; ++i ) {
       for ( j = row_ptr[i] ; j < row_ptr[i+1] ; ++j ) {
           for ( k = j+1 ; k < row_ptr[i+1] ; ++k ) {
               if ( col_ind[j] > col_ind[k] ) {
                    int idum ;
                    _F_REAL_4 rdum ;
                    idum = col_ind[k]; rdum = val[k] ;
                    col_ind[k] = col_ind[j]; val[k] = val[j];
                    col_ind[j] = idum ; val[j] = rdum ;
               }
           }
       }
       for ( j = row_ptr[i] ; j < row_ptr[i+1] ; ++j ) 
             if (col_ind[j]==i) diag_ptr[i] = j ;  
  } 

/*
  for ( i = 0 ; i < nall ; ++i ) {
         printf("%d :", i) ;
         for ( j = row_ptr[i] ; j < row_ptr[i+1] ; ++j ) 
             printf( " %d", col_ind[j] );
             //printf( " %.15g", val[j] );
         printf("\n") ;
  }
  SLDIE("stop");
*/

  // DILU
  for ( i=0; i<nall; ++i ) pivots[i] = val[ diag_ptr[ i ] ] ;

  for ( i=0; i<nall; ++i ) {
         pivots[i] = 1.0 / pivots[i] ;
         for ( j=diag_ptr[i]+1; j<row_ptr[i+1]; ++j ){
             found = 0 ;
             for ( k=row_ptr[ col_ind[j] ]; k<diag_ptr[ col_ind[ j ] ]; ++k ){
                 if (col_ind[k]==i) {
                    found = 1 ;
                    element = val[ k ];
                 }
             }
            if (found==1) pivots[col_ind[j]] -= element*pivots[i]*val[j] ;
         }
  }
}
/*----------------------------------------------------------------------*/
/* Main block Gauss-Seidel preconditioner using equation/component
   preconditioner for diagonal blocks.
*/

static void slprecmainsol(
  _F_INTEGER * IPRECPREP , /* Input:  */
  _F_INTEGER * IOPT , /* Input:  */
  _F_REAL_8  * X ,    /* Input:  */
  _F_REAL_8  * Y )    /* Output: */
{
  const _F_INTEGER IONE = 1 ;
  const _F_INTEGER ITWO = 2 ;
  const _F_INTEGER IZERO= 0 ;
  const _F_INTEGER NEV  = solve_data->nev ;
  const _F_INTEGER NLOC = solve_data->nloc ;
  const _F_INTEGER NS   = solve_data->ns   ;
  const _F_INTEGER NALL = NLOC * NEV ;

  const _F_INTEGER I4DG = solve_data->idgsol ;
  const _F_INTEGER K4TG = solve_data->idktmp ;

  int j ;

  /*------------------------------------------------------------------*/
/* For ipars version 3, to switch from decoupling preconditioner to lsor */
#ifdef SWITCH_TO_LSOR
    if ( *IOPT != 1 ) {
      _F_INTEGER   LIN    = 1 ;
      _F_INTEGER   NERR  ;
      _F_INTEGER   N_COF  = solve_data->idgjac;
      _F_INTEGER   N_DUNK = solve_data->idgsol;
      _F_INTEGER   N_RESID= solve_data->idgres;
      slvec2grid( 1, X, 1.0, 0, NEV );
      // Note: N_DUNK array is zeroed at the beginning of lsor
      // This implies initial guess is trivial
      _sllsori(&NERR);
      _sllsor (&N_COF,&N_DUNK,&N_RESID,&NEV,&LIN,&NERR);
      slgrid2vec( 0, Y, 1.0, 0, NEV );
      return ;
    }
#else
#endif


  if ( X != Y ) r8copy( &NALL, X, &IONE, Y, &IONE );

  /* The pressure (leading) block is dominant */

  switch( solve_data->pspec[0] ) {
  case SL_PREC_DIAG: slpressdiagsol(  IOPT, Y, Y ); break ;

  case SL_PREC_LINEJAC:
    {

    }
    break ;
  case SL_PREC_LINEGS:
    {
      const _F_REAL_8 OMEGA = 1.0 ;
      slpresslinesorsol( IOPT  , (_F_REAL_8 *) &OMEGA, X, Y )  ;

    }
    break ;
  case SL_PREC_LINESOR:
    {
      const _F_REAL_8 ZERO = 0.0 ;
      slpresslinesorsol( IOPT  , (_F_REAL_8 *) &ZERO, X, Y )  ;
    }
    break ;
  case SL_PREC_NEUPCG:
  case SL_PREC_NEUPBCGS:
  case SL_PREC_NEUGMRES:
  case SL_PREC_NEUSER:
    {
      const _F_INTEGER   HBW  = 1 ;
      const _F_INTEGER   LDP  = 3 * HBW + 1 ;
      const _F_INTEGER   N    = solve_data->nloc ;
            _F_REAL_8  * P  = solve_data->pwork ;
      const size_t nloci =
        ( sizeof(_F_INTEGER)*N + sizeof(_F_REAL_8)-1 )/sizeof(_F_REAL_8) ;
            _F_REAL_8  * WRK  = P + LDP * N + nloci ;

      slneumseries( X, Y, WRK )  ;
    }
    break ;
  case SL_PREC_FCTRZ:  
    {
            _F_REAL_4  * PR  = solve_data->pworkr;
            _F_REAL_4  * W  = PR + factor_for_real*NLOC;
       //   _F_REAL_4  * XX = W + 2*NLOC;
            _F_REAL_4  * XX = W + 4*NLOC; // need 4 because of add.memory YY8
            _F_REAL_4  * YY = XX + NLOC;
            _F_REAL_4  * Cntl  = YY + NLOC;
            _F_REAL_4  * Rinfo = Cntl + 10;
            _F_REAL_8  * Asum  = (_F_REAL_8  *) Rinfo+ 20;
            _F_REAL_8  * XX8 = (_F_REAL_8  *) W ;
            _F_REAL_8  * YY8 = XX8 + 2*NLOC ;
            _F_INTEGER * PI  = solve_data->pworki;
            _F_INTEGER * Keep= PI + factor_for_int *NLOC;
            _F_INTEGER * Icntl= Keep + 20;
            _F_INTEGER * InfoUMS = Icntl + 20;
      const _F_INTEGER ldw = factor_for_real*NLOC;
      const _F_INTEGER liw = factor_for_int *NLOC;
      const _F_INTEGER IZERO = 0 ;
      const _F_REAL_8 ZERO = 0.0 ;
            _F_INTEGER SingleProcessor ;

      for (j=0;j<NLOC;++j) XX[j]= X[j];  
      _ums2so(&NLOC,&IZERO,&ldw,&liw,PR,PI,Keep,
             XX,YY,W,Cntl,Icntl,InfoUMS,Rinfo);
      if (InfoUMS[0] < 0) SLDIE("Error in UMS2SO");
      for (j=0;j<NLOC;++j) Y[j]= YY[j];  

      _singleproc(&SingleProcessor) ;
      if ( SingleProcessor ) break ;

      // Compute residual
      // SOL = - Y , Y = X + A SOL
      slvec2grid( 0, Y, -1.0, 0, 1);
      {
      const _F_INTEGER I4DG = solve_data->idgsol ;
      const _F_INTEGER K4TG = solve_data->idktmp ;
      const _F_INTEGER I4V1 = 1 ;
      const _F_INTEGER I4V2 = 1 ;
      _slupdate( &I4DG , &I4V1, &I4V2, &K4TG );
      }
      r8copy( &NLOC, X, &IONE, Y, &IONE );
      sljxg(Y,0,1,0,1);

      // Precondition residual by LSOR(1): G_i Y = Y
      r8copy( &NLOC, Y, &IONE, YY8, &IONE );
      {
       _F_INTEGER IMRK[2] ;
       IMRK[0] = 1; IMRK[1] = solve_data->idgres ;
       mycallwork( _mrkdnk, &IMRK );
      }
      slgrid2vec( 1, XX8 , 1.0 , 0, 1);
      slpresslinesorsolco( YY8, Y, XX8, XX8+NLOC, Asum )  ;

      // Add to the separable output Y = Y - SOL
      slvecminusgrid( 0, Y, 1.0 , 0, 1);
    }
    break ;
  case SL_PREC_SEPARABLE:
    {
      slvec2grid( 1, Y , 1.0 , 0, 1);
      mycallwork( _precsol, IPRECPREP );
      slgrid2vec( 1, Y , 1.0 , 0, 1);
    }
    break ;
  case SL_PREC_SEPAR_GS:
  case SL_PREC_SEPAR_UMS:
/* separable-based-dc2d as a low frequency dump */
/* separable-based-ums as a low frequency dump */
    {
      _F_REAL_8  * Y1 = solve_data->pworkr ;
      const _F_REAL_8 ZERO = 0.0 ;

      // Apply separable  B Y = Y 
      slvec2grid( 1, Y , 1.0 , 0, 1);
      mycallwork( _precsol, IPRECPREP );
      slgrid2vec( 1, Y , 1.0 , 0, 1);

      // Compute residual 
      // SOL = - Y , Y = X + A SOL 
      slvec2grid( 0, Y, -1.0, 0, 1);
    {
      const _F_INTEGER I4DG = solve_data->idgsol ;
      const _F_INTEGER K4TG = solve_data->idktmp ;
      const _F_INTEGER I4V1 = 1 ;
      const _F_INTEGER I4V2 = 1 ;
      _slupdate( &I4DG , &I4V1, &I4V2, &K4TG );
    }
      r8copy( &NLOC, X, &IONE, Y, &IONE );
      sljxg(Y,0,1,0,1);

      // Precondition residual by LSOR(1): G_i Y = Y
      r8copy( &NLOC, Y, &IONE, Y1, &IONE );
      slpresslinesorsol( IOPT  , (_F_REAL_8 *) &ZERO, Y1, Y )  ;

      // Add to the separable output Y = Y - SOL 
      slvecminusgrid( 0, Y, 1.0 , 0, 1);
    }
    break ;
  case SL_PREC_MLILU:
    {
      _F_REAL_8  * XX = solve_data->pworkr ;
      _F_REAL_8  * YY = XX + 2*NLOC ;
      _F_REAL_8  * Asum = YY + NLOC ;
      _F_INTEGER * diag_positive = solve_data->pworki ; 
      extern typ **mat_init;
      extern int **index_init;
      extern void precond(typ **, int **, typ *, typ *, int, int);

            _F_INTEGER SingleProcessor ;

      const _F_REAL_8 ZERO = 0.0 ;

      const int nblk   = solve_data->nblk ;
      const int ns     = solve_data->ns ;
      const int ldjmap = 2 * ( solve_data->ns + 1 );
      const _F_INTEGER * jmap ;
      int i;
      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    nloc = blk->nloc ;
        const int                    disp = blk->disp ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;

        if ( diag_positive[i] ) {
         for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
             int ir = (jmap-jbeg)/ldjmap+1+disp;
             XX[ir-1] = -X[ir-1] ;
             Y[ir-1] = 0.0 ;
         }
        }
        else{
         for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
             int ir = (jmap-jbeg)/ldjmap+1+disp;
             XX[ir-1] = X[ir-1] ;
             Y[ir-1] = 0.0 ;
         }
        }
      }

     {
      _F_INTEGER WHICH = 1; // To apply MLILU 
      // WHICH is 0 for identity, 2 for Jacobi, 3 for Gauss-Seidel, 4 for ILU(0)
      precond(mat_init,index_init,Y,XX,NLOC,WHICH);
     }

      _singleproc(&SingleProcessor) ;
      if ( SingleProcessor ) break ;

      // Compute residual
      // SOL = - Y , Y = X + A SOL
      slvec2grid( 0, Y, -1.0, 0, 1);
      {
      const _F_INTEGER I4DG = solve_data->idgsol ;
      const _F_INTEGER K4TG = solve_data->idktmp ;
      const _F_INTEGER I4V1 = 1 ;
      const _F_INTEGER I4V2 = 1 ;
      _slupdate( &I4DG , &I4V1, &I4V2, &K4TG );
      }
      r8copy( &NLOC, X, &IONE, Y, &IONE );
      sljxg(Y,0,1,0,1);

      // Precondition residual by LSOR(1): G_i Y = Y
      r8copy( &NLOC, Y, &IONE, YY, &IONE );
      {
       _F_INTEGER IMRK[2] ;
       IMRK[0] = 1; IMRK[1] = solve_data->idgres ;
       mycallwork( _mrkdnk, &IMRK );
      }
      slgrid2vec( 1, XX , 1.0 , 0, 1);
      slpresslinesorsolco( YY, Y, XX, XX+NLOC, Asum )  ;
//    slpresslinesorsol( IOPT  , (_F_REAL_8 *) &ZERO, YY, Y )  ;

      // Add to the separable output Y = Y - SOL
      slvecminusgrid( 0, Y, 1.0 , 0, 1);

    }
    break ;
  case SL_PREC_MLILU2:
    {
      _F_INTEGER * PNLOC2 = solve_data->pworki ;
      _F_INTEGER NLOC2 = PNLOC2[0];
      _F_INTEGER * IP2 = PNLOC2 + 1 ;
      _F_INTEGER * JP2 = IP2 + NLOC + 1 ;
      _F_INTEGER * IP3 = JP2 + IP2[NLOC] ;
      _F_INTEGER * JP3 = IP3 + NLOC2 + 1 ;
      _F_INTEGER * diag_positive = JP3 + IP3[NLOC2]  ; 
      _F_REAL_8  * AP2 = solve_data->pworkr ;
      _F_REAL_8  * AP3 = AP2 + IP2[NLOC] ;
      _F_REAL_8  * XX = AP3 + IP3[NLOC2] ;
      _F_REAL_8  * YY = XX + 2*NLOC ;
      _F_REAL_8  * Asum = YY + NLOC ;
      extern typ **mat_init;
      extern int **index_init;
      extern void precond(typ **, int **, typ *, typ *, int, int);

            _F_INTEGER SingleProcessor ;

      const _F_REAL_8 ZERO = 0.0 ;

      const int nblk   = solve_data->nblk ;
      const int ns     = solve_data->ns ;
      const int ldjmap = 2 * ( solve_data->ns + 1 );
      const _F_INTEGER * jmap ;
      int i;
      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    nloc = blk->nloc ;
        const int                    disp = blk->disp ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;

        if ( diag_positive[i] ) {
         for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
             int ir = (jmap-jbeg)/ldjmap+1+disp;
             XX[ir-1] = -X[ir-1] ;
             Y[ir-1] = 0.0 ;
         }
        }
        else{
         for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
             int ir = (jmap-jbeg)/ldjmap+1+disp;
             XX[ir-1] = X[ir-1] ;
             Y[ir-1] = 0.0 ;
         }
        }
      }

//  YY = INT XX
      _amux(&NLOC2,XX,YY,AP3,JP3,IP3) ;
     {
      _F_INTEGER WHICH = 1; // To apply MLILU 
      // WHICH is 0 for identity, 2 for Jacobi, 3 for Gauss-Seidel, 4 for ILU(0)
      precond(mat_init,index_init,Y,YY,NLOC2,WHICH);
     }
//  YY = INT^t Y
      _amux(&NLOC,Y ,YY,AP2,JP2,IP2) ;
// Compute the residual
      slvec2grid( 0, YY, -1.0, 0, 1);
      {
       const _F_INTEGER I4DG = solve_data->idgsol ;
       const _F_INTEGER K4TG = solve_data->idktmp ;
       const _F_INTEGER I4V1 = 1 ;
       const _F_INTEGER I4V2 = 1 ;
       _slupdate( &I4DG , &I4V1, &I4V2, &K4TG );
      }
      r8copy( &NLOC, X, &IONE, Y, &IONE );
      sljxg(Y,0,1,0,1);
// Precondition the residual by LSOR(1)
      r8copy( &NLOC, Y, &IONE, YY, &IONE );
      {
       int nstep ;
       // get the value of nstep from input file
       _set_gs_step(&nstep);
       // set to 1 the value of nstep from input file
       _set_n_gs_step(&IONE);
       slpresslinesorsol( IOPT  , (_F_REAL_8 *) &ZERO, YY, Y )  ;
       // set back the value of nstep from input file
       _set_n_gs_step(&nstep);
      }
// Update the solution
      slvecminusgrid( 0, Y, 1.0 , 0, 1);


      _singleproc(&SingleProcessor) ;
      if ( SingleProcessor ) break ;

      // Compute residual
      // SOL = - Y , Y = X + A SOL
      slvec2grid( 0, Y, -1.0, 0, 1);
      {
      const _F_INTEGER I4DG = solve_data->idgsol ;
      const _F_INTEGER K4TG = solve_data->idktmp ;
      const _F_INTEGER I4V1 = 1 ;
      const _F_INTEGER I4V2 = 1 ;
      _slupdate( &I4DG , &I4V1, &I4V2, &K4TG );
      }
      r8copy( &NLOC, X, &IONE, Y, &IONE );
      sljxg(Y,0,1,0,1);

      // Precondition residual by LSOR(1): G_i Y = Y
      r8copy( &NLOC, Y, &IONE, YY, &IONE );
      {
       _F_INTEGER IMRK[2] ;
       IMRK[0] = 1; IMRK[1] = solve_data->idgres ;
       mycallwork( _mrkdnk, &IMRK );
      }
      slgrid2vec( 1, XX , 1.0 , 0, 1);
      slpresslinesorsolco( YY, Y, XX, XX+NLOC, Asum )  ;
//    slpresslinesorsol( IOPT  , (_F_REAL_8 *) &ZERO, YY, Y )  ;

      // Add to the separable output Y = Y - SOL
      slvecminusgrid( 0, Y, 1.0 , 0, 1);

    }
    break ;

  case SL_PREC_AMG:  
    {
            _F_INTEGER * JA = solve_data->pworki;
            _F_INTEGER * IA = JA + 7*(NS*NLOC) + 5*NLOC ;
            _F_INTEGER * IG = IA + (int) (2.2*NLOC) ;
            _F_INTEGER AdMemIG = 100 ;
            _F_INTEGER * diag_negative = IG + (int) (5.4*NLOC) + AdMemIG ;
            _F_REAL_8  * AA = solve_data->pworkr ;
            _F_REAL_8  * XX = AA + 7*(NS*NLOC) + 5*NLOC ;
            _F_REAL_8  * YY = XX + (int) (2.2*NLOC) ;
            _F_REAL_8  * Asum = YY + (int) (2.2*NLOC) ;
            _F_INTEGER NDA  = 7*(NS*NLOC) + 5*NLOC ;
            _F_INTEGER NDIA = (int)(2.2*NLOC) ;
            _F_INTEGER NDJA = 7*(NS*NLOC) + 5*NLOC ;
            _F_INTEGER NDU  = (int)(2.2*NLOC) ;
            _F_INTEGER NDF  = (int)(2.2*NLOC) ;
            _F_INTEGER NDIG = (int)(5.4*NLOC) + AdMemIG ;
            _F_INTEGER MATRIX = 22 ;
            _F_INTEGER ISWTCH = 3 ; /* or 2 ??? */
            _F_INTEGER IOUT   = 10 ;
            _F_INTEGER IPRINT = 10606 ;
            _F_INTEGER LEVELX = 25 ;
            _F_INTEGER IFIRST = 11 ;
            _F_INTEGER NCYC   = 1011 ;
            _F_REAL_8  EPS    = 1e-12 ;
            _F_INTEGER MADAPT = 27 ;
            _F_INTEGER NRD    = 1131 ;
            _F_INTEGER NSOLCO = 110 ;
            _F_INTEGER NRU    = 1131 ;
            _F_REAL_8  ECG1   = 0. ;
            _F_REAL_8  ECG2   = 0.25 ;
            _F_REAL_8  EWT2   = 0.35 ;
            _F_INTEGER NWT    = 2 ;
            _F_INTEGER NTR    = 0 ;
            _F_INTEGER IERR   = 0 ;

            _F_INTEGER SingleProcessor ;

      const _F_REAL_8 ZERO = 0.0 ;

      const int nblk   = solve_data->nblk ;
      const int ns     = solve_data->ns ;
      const int ldjmap = 2 * ( solve_data->ns + 1 );
      const _F_INTEGER * jmap ;
      int i;
      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    nloc = blk->nloc ;
        const int                    disp = blk->disp ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;

        if ( diag_negative[i] ) { 
         for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
             int ir = (jmap-jbeg)/ldjmap+1+disp;
             XX[ir-1] = -X[ir-1] ;
         }
        }
        else{
         for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
             int ir = (jmap-jbeg)/ldjmap+1+disp;
             XX[ir-1] = X[ir-1] ;
         }
        }
      }

      _amg1r5(AA,IA,JA,YY,XX,IG,
              &NDA,&NDIA,&NDJA,&NDU,&NDF,&NDIG,&NLOC,&MATRIX,
              &ISWTCH,&IOUT,&IPRINT,
              &LEVELX,&IFIRST,&NCYC,&EPS,&MADAPT,&NRD,&NSOLCO,&NRU,
              &ECG1,&ECG2,&EWT2,&NWT,&NTR,
              &IERR );
      if (IERR != 0) SLDIE("Error in AMG1R5 solve");
      for (j=0;j<NLOC;++j) Y[j]= YY[j];  


      _singleproc(&SingleProcessor) ;
      if ( SingleProcessor ) break ;

      // Compute residual
      // SOL = - Y , Y = X + A SOL
      slvec2grid( 0, Y, -1.0, 0, 1);
      {
      const _F_INTEGER I4DG = solve_data->idgsol ;
      const _F_INTEGER K4TG = solve_data->idktmp ;
      const _F_INTEGER I4V1 = 1 ;
      const _F_INTEGER I4V2 = 1 ;
      _slupdate( &I4DG , &I4V1, &I4V2, &K4TG );
      }
      r8copy( &NLOC, X, &IONE, Y, &IONE );
      sljxg(Y,0,1,0,1);

      // Precondition residual by LSOR(1): G_i Y = Y
      r8copy( &NLOC, Y, &IONE, YY, &IONE );
      {
       _F_INTEGER IMRK[2] ;
       IMRK[0] = 1; IMRK[1] = solve_data->idgres ;
       mycallwork( _mrkdnk, &IMRK );
      }
      slgrid2vec( 1, XX , 1.0 , 0, 1);
      slpresslinesorsolco( YY, Y, XX, XX+NLOC, Asum )  ;
//    slpresslinesorsol( IOPT  , (_F_REAL_8 *) &ZERO, YY, Y )  ;

      // Add to the separable output Y = Y - SOL
      slvecminusgrid( 0, Y, 1.0 , 0, 1);
    }
    break ;
  case SL_PREC_AMG2:  
    {
            _F_INTEGER * PNLOC2 = solve_data->pworki ;
            _F_INTEGER NLOC2 = PNLOC2[0];
            _F_INTEGER * IP2 = PNLOC2 + 1 ;
            _F_INTEGER * JP2 = IP2 + NLOC + 1 ;
            _F_INTEGER * IP3 = JP2 + IP2[NLOC] ;
            _F_INTEGER * JP3 = IP3 + NLOC2 + 1 ;
            _F_INTEGER * JA = JP3 + IP3[NLOC2] ;
            _F_INTEGER * IA = JA + 7*(NS*NLOC) + 5*NLOC ;
            _F_INTEGER * IG = IA + (int) (2.2*NLOC) ;
            _F_INTEGER AdMemIG = 100 ;
            _F_INTEGER * diag_negative = IG + (int) (5.4*NLOC) + AdMemIG ;
            _F_REAL_8  * AP2 = solve_data->pworkr ;
            _F_REAL_8  * AP3 = AP2 + IP2[NLOC] ;
            _F_REAL_8  * AA = AP3 + IP3[NLOC2] ;
            _F_REAL_8  * XX = AA + 7*(NS*NLOC) + 5*NLOC ;
            _F_REAL_8  * YY = XX + (int) (2.2*NLOC) ;
            _F_REAL_8  * Asum = YY + (int) (2.2*NLOC) ;
            _F_INTEGER NDA  = 7*(NS*NLOC) + 5*NLOC ;
            _F_INTEGER NDIA = (int)(2.2*NLOC) ;
            _F_INTEGER NDJA = 7*(NS*NLOC) + 5*NLOC ;
            _F_INTEGER NDU  = (int)(2.2*NLOC) ;
            _F_INTEGER NDF  = (int)(2.2*NLOC) ;
            _F_INTEGER NDIG = (int)(5.4*NLOC) + AdMemIG ;
            _F_INTEGER MATRIX = 22 ;
            _F_INTEGER ISWTCH = 3 ; /* or 2 ??? */
            _F_INTEGER IOUT   = 10 ;
            _F_INTEGER IPRINT = 10606 ;
            _F_INTEGER LEVELX = 25 ;
            _F_INTEGER IFIRST = 11 ;
            _F_INTEGER NCYC   = 1011 ;
            _F_REAL_8  EPS    = 1e-12 ;
            _F_INTEGER MADAPT = 27 ;
            _F_INTEGER NRD    = 1131 ;
            _F_INTEGER NSOLCO = 110 ;
            _F_INTEGER NRU    = 1131 ;
            _F_REAL_8  ECG1   = 0. ;
            _F_REAL_8  ECG2   = 0.25 ;
            _F_REAL_8  EWT2   = 0.35 ;
            _F_INTEGER NWT    = 2 ;
            _F_INTEGER NTR    = 0 ;
            _F_INTEGER IERR   = 0 ;

            _F_INTEGER SingleProcessor ;

      const _F_REAL_8 ZERO = 0.0 ;

      const int nblk   = solve_data->nblk ;
      const int ns     = solve_data->ns ;
      const int ldjmap = 2 * ( solve_data->ns + 1 );
      const _F_INTEGER * jmap ;
      int i;
      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    nloc = blk->nloc ;
        const int                    disp = blk->disp ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;

        if ( diag_negative[i] ) { 
         for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
             int ir = (jmap-jbeg)/ldjmap+1+disp;
             XX[ir-1] = -X[ir-1] ;
         }
        }
        else{
         for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
             int ir = (jmap-jbeg)/ldjmap+1+disp;
             XX[ir-1] = X[ir-1] ;
         }
        }
      }

//  YY = INT XX
      _amux(&NLOC2,XX,YY,AP3,JP3,IP3) ;
      _amg1r5(AA,IA,JA,XX,YY,IG,
              &NDA,&NDIA,&NDJA,&NDU,&NDF,&NDIG,&NLOC2,&MATRIX,
              &ISWTCH,&IOUT,&IPRINT,
              &LEVELX,&IFIRST,&NCYC,&EPS,&MADAPT,&NRD,&NSOLCO,&NRU,
              &ECG1,&ECG2,&EWT2,&NWT,&NTR,
              &IERR );
      if (IERR != 0) SLDIE("Error in AMG1R5 solve");
//  YY = INT^t XX
      _amux(&NLOC,XX,YY,AP2,JP2,IP2) ;
      for (j=0;j<NLOC;++j) Y[j]= YY[j];  
// Compute the residual
      slvec2grid( 0, Y, -1.0, 0, 1);
      {
       const _F_INTEGER I4DG = solve_data->idgsol ;
       const _F_INTEGER K4TG = solve_data->idktmp ;
       const _F_INTEGER I4V1 = 1 ;
       const _F_INTEGER I4V2 = 1 ;
       _slupdate( &I4DG , &I4V1, &I4V2, &K4TG );
      }
      r8copy( &NLOC, X, &IONE, Y, &IONE );
      sljxg(Y,0,1,0,1);
// Precondition the residual by LSOR(1)
      r8copy( &NLOC, Y, &IONE, YY, &IONE );
      {
       int nstep ;
       // get the value of nstep from input file
       _set_gs_step(&nstep);
       // set to 1 the value of nstep from input file
       _set_n_gs_step(&IONE);
       slpresslinesorsol( IOPT  , (_F_REAL_8 *) &ZERO, YY, Y )  ;
       // set back the value of nstep from input file
       _set_n_gs_step(&nstep);
      }
// Update the solution
      slvecminusgrid( 0, Y, 1.0 , 0, 1);


      _singleproc(&SingleProcessor) ;
      if ( SingleProcessor ) break ;

// In case of parallel run
      // Compute residual
      // SOL = - Y , Y = X + A SOL
      slvec2grid( 0, Y, -1.0, 0, 1);
      {
      const _F_INTEGER I4DG = solve_data->idgsol ;
      const _F_INTEGER K4TG = solve_data->idktmp ;
      const _F_INTEGER I4V1 = 1 ;
      const _F_INTEGER I4V2 = 1 ;
      _slupdate( &I4DG , &I4V1, &I4V2, &K4TG );
      }
      r8copy( &NLOC, X, &IONE, Y, &IONE );
      sljxg(Y,0,1,0,1);

      // Precondition residual by LSOR(1): G_i Y = Y
      r8copy( &NLOC, Y, &IONE, YY, &IONE );
      {
       _F_INTEGER IMRK[2] ;
       IMRK[0] = 1; IMRK[1] = solve_data->idgres ;
       mycallwork( _mrkdnk, &IMRK );
      }
      slgrid2vec( 1, XX , 1.0 , 0, 1);
      slpresslinesorsolco( YY, Y, XX, XX+NLOC, Asum )  ;
//    slpresslinesorsol( IOPT  , (_F_REAL_8 *) &ZERO, YY, Y )  ;

      // Add to the separable output Y = Y - SOL
      slvecminusgrid( 0, Y, 1.0 , 0, 1);
    }
    break ;


  default:
    ;
  }

  if ( 1 < NEV ) {

#ifdef EDWARDS_MULTISTAGE
    // Multistage block  -- BEGIN

    // Block Gauss-Seidel preconditioner
    // Given an approximation to pressure,
    // compute the residual for saturation and precondition it
    // Uses block Jacobi preconditioner for saturations
    // References: Klie, Edwards.

    slvec2grid( 0, Y, -1.0, 0, 1);
    {
      const _F_INTEGER I4DG = solve_data->idgsol ;
      const _F_INTEGER K4TG = solve_data->idktmp ;
      const _F_INTEGER I4V1 = 1 ;
      const _F_INTEGER I4V2 = 1 ;
      _slupdate( &I4DG , &I4V1, &I4V2, &K4TG );
    }
    sljxg(Y+NLOC,1,NEV,0,1);

    // Block Jacobi for remaining equations/variables 
    //in case of sldecouple,sldecouple_athos
    slcompblksol( Y + NLOC, Y + NLOC );  
    //in case of sldecouple_wallis,sldecouple_impes
    //slcompblksol_fctrz( Y + NLOC, Y + NLOC ); 

    // Multistage block  -- END
#else
    // Combinative block -- BEGIN

    // Combinative preconditioner
    // Given an approximation to pressure,
    // compute the residual for pressure and saturation,
    // precondition it and update pressure approximation.
    // Uses LIN  iterations LSOR written by J.Wheeler 
    // for the whole matrix.
    // Requires additional storage,  pressure vector T
    //     solve_data->pworks = (void *) fr8_alloc( nloc );
    // Additional operations compared to block Gauss-Seidel:
    // LIN  LSOR iterations  minus  1 block Jacobi preconditioner
    // References: Wallis, Klie, Dean.

    _F_REAL_8  ONE    = 1.0 ;
    _F_REAL_8  ZERO   = 0.0 ;
    _F_REAL_8  * T = solve_data->pworks ;

    r8copy( &NLOC, Y, &IONE, T, &IONE );
    r8copy( &NLOC, X, &IONE, Y, &IONE );
    slvec2grid( 0, T, -1.0, 0, 1);
    {
      const _F_INTEGER I4DG = solve_data->idgsol ;
      const _F_INTEGER K4TG = solve_data->idktmp ;
      const _F_INTEGER I4V1 = 1 ;
      const _F_INTEGER I4V2 = 1 ;
      _slupdate( &I4DG , &I4V1, &I4V2, &K4TG );
    }
    sljxg(Y,0,NEV,0,1);

    {
      _F_INTEGER   LIN    = 1 ;
      _F_INTEGER   NERR  ;
      _F_INTEGER   N_COF  = solve_data->idgjac;
      _F_INTEGER   N_DUNK = solve_data->idgsol;
      _F_INTEGER   N_RESID= solve_data->idgres;
      slvec2grid( 1, Y, 1.0, 0, NEV );
      // Note: N_DUNK array is zeroed at the beginning of lsor
      // This implies initial guess is trivial
      _sllsori(&NERR);
      _sllsor (&N_COF,&N_DUNK,&N_RESID,&NEV,&LIN,&NERR);
      slgrid2vec( 0, Y, 1.0, 0, NEV );

      r8axpy( &NLOC, &ONE, T, &IONE, Y, &IONE );
    }
/*
    // Combinative preconditioner
    // Given an approximation to pressure,
    // compute the residual for pressure and saturation,
    // precondition it and update pressure approximation.
    // Uses block Jacobi preconditioner
    // for the whole matrix
    // Requires additional storage,  pressure vector T
    //     solve_data->pworks = (void *) fr8_alloc( nloc );
    // Additional operations compared to block Gauss-Seidel:
    // block Jacobi preconditioner
    // minus  1 block Jacobi saturation preconditioner
    // References: Wallis, Klie, Dean.
    // applicable only for:
    // sldecouple,sldecouple_athos,sldecouple_wallis(zero upper block)

    _F_REAL_8  ONE    = 1.0 ;
    _F_REAL_8  ZERO   = 0.0 ;
    _F_REAL_8  * T = solve_data->pworks ;

    r8copy( &NLOC, Y, &IONE, T, &IONE );
    r8copy( &NLOC, X, &IONE, Y, &IONE );
    slvec2grid( 0, T, -1.0, 0, 1);
    {
      const _F_INTEGER I4DG = solve_data->idgsol ;
      const _F_INTEGER K4TG = solve_data->idktmp ;
      const _F_INTEGER I4V1 = 1 ;
      const _F_INTEGER I4V2 = 1 ;
      _slupdate( &I4DG , &I4V1, &I4V2, &K4TG );
    }
    sljxg(Y,0,NEV,0,1);

    // applicable only for:
    // sldecouple,sldecouple_athos,sldecouple_wallis(zero upper block)
    slcompblksolCouple( Y, Y ); 
    r8axpy( &NLOC, &ONE, T, &IONE, Y, &IONE );

    // Combinative preconditioner
    // Given an approximation to pressure,
    // compute the residual for pressure and saturation,
    // precondition it and update pressure approximation.
    // Uses two simple iterations with block Jacobi preconditioner
    // for the whole matrix and initial zero guess and parameter TAU.
    // requires additional storage,
    // pressure-saturations vector Z and pressure vector T
    //     solve_data->pworks = (void *) fr8_alloc( nloc * (nev+1) );
    // Additional operations compared to block Gauss-Seidel:
    // 1 jacobian matrix multiplication and 1 block Jacobi preconditioner
    // References: Wallis, Klie, Dean.
    // applicable only for:
    // sldecouple,sldecouple_athos,sldecouple_wallis(zero upper block)

    _F_REAL_8  ONE    = 1.0 ;
    const _F_REAL_8  TAU    = 1.0 ;
    _F_REAL_8  * T = solve_data->pworks ;
    _F_REAL_8  * Z = T + NLOC ;

    r8copy( &NLOC, Y, &IONE, T, &IONE );
    r8copy( &NLOC, X, &IONE, Y, &IONE );
    slvec2grid( 0, T, -1.0, 0, 1);
    {
      const _F_INTEGER I4DG = solve_data->idgsol ;
      const _F_INTEGER K4TG = solve_data->idktmp ;
      const _F_INTEGER I4V1 = 1 ;
      const _F_INTEGER I4V2 = 1 ;
      _slupdate( &I4DG , &I4V1, &I4V2, &K4TG );
    }
    sljxg(Y,0,NEV,0,1);

    r8copy( &NALL, Y, &IONE, Z, &IONE );
    // applicable only for:
    // sldecouple,sldecouple_athos,sldecouple_wallis(zero upper block)
    slcompblksolCouple( Y, Y );
    slvec2grid( 0, Y, -TAU, 0, NEV );
    {
      const _F_INTEGER I4DG = solve_data->idgsol ;
      const _F_INTEGER K4TG = solve_data->idktmp ;
      const _F_INTEGER I4V1 = NEV ;
      const _F_INTEGER I4V2 = NEV ;
      _slupdate( &I4DG , &I4V1, &I4V2, &K4TG );
    }
    sljxg(Z,0,NEV,0,NEV);
    // applicable only for:
    // sldecouple,sldecouple_athos,sldecouple_wallis(zero upper block)
    slcompblksolCouple( Z, Z );
    r8axpy( &NALL, &TAU, Z, &IONE, Y, &IONE );
    r8axpy( &NLOC, &ONE, T, &IONE, Y, &IONE );

    // Combinative preconditioner
    // Given an approximation to pressure,
    // compute the residual for pressure and saturation,
    // precondition it and update pressure approximation.
    // Uses DILU preconditioner  for the whole matrix
    // Requires additional storage,  pressure vector T
    //     solve_data->pworks = (void *) fr8_alloc( nloc );
    //     solve_data->pworksr=..
    //     solve_data->pworksi=..
    // Additional operations compared to block Gauss-Seidel:
    // DILU solve  minus  1 block Jacobi saturation preconditioner
    // References:  Dean.

    _F_REAL_8  ONE    = 1.0 ;
    _F_REAL_8  * T = solve_data->pworks ;


    r8copy( &NLOC, Y, &IONE, T, &IONE );
    r8copy( &NLOC, X, &IONE, Y, &IONE );
    slvec2grid( 0, T, -1.0, 0, 1);
    {
      const _F_INTEGER I4DG = solve_data->idgsol ;
      const _F_INTEGER K4TG = solve_data->idktmp ;
      const _F_INTEGER I4V1 = 1 ;
      const _F_INTEGER I4V2 = 1 ;
      _slupdate( &I4DG , &I4V1, &I4V2, &K4TG );
    }
    sljxg(Y,0,NEV,0,1);

    if ( 1 )
    {  //ILU(0)
      _F_REAL_4  * val = solve_data->pworksr ;
      _F_INTEGER * row_ptr = solve_data->pworksi ;
      _F_INTEGER * col_ind = row_ptr + NALL+1 ;
      _F_INTEGER * diag_ptr = col_ind + NALL*NEV*NS ;
      _F_REAL_8 sum ;
      int i ;
      for ( i=0; i<NALL; ++i ) {
         sum = 0.0 ;
         for ( j=row_ptr[i]; j<diag_ptr[i]; ++j )
             sum += val[ j ] * Y[ col_ind[ j ] ] ;
         Y[i] = Y[i]-sum ;
      }
      for ( i=NALL-1; i >= 0; --i ) {
         sum = 0.0 ;
         for ( j=diag_ptr[i]+1; j<row_ptr[i+1]; ++j )
             sum += val[ j ] * Y[ col_ind[ j ] ] ;
         Y[i] = val[diag_ptr[i]] * (Y[i] - sum) ;
      }
    }
    else
    {  //DILU
      _F_REAL_4  * val = solve_data->pworksr ;
      _F_REAL_4  * pivots = val + NALL*NEV*NS ;
      _F_INTEGER * row_ptr = solve_data->pworksi ;
      _F_INTEGER * col_ind = row_ptr + NALL+1 ;
      _F_INTEGER * diag_ptr = col_ind + NALL*NEV*NS ;
      _F_REAL_8 sum ;
      int i ;
      for ( i=0; i<NALL; ++i ) {
         sum = 0.0 ;
         for ( j=row_ptr[i]; j<diag_ptr[i]; ++j )
             sum += val[ j ] * Y[ col_ind[ j ] ] ;
         Y[i] = pivots[i] * (Y[i]-sum) ;
      }
      for ( i=NALL-1; i >= 0; --i ) {
         sum = 0.0 ;
         for ( j=diag_ptr[i]+1; j<row_ptr[i+1]; ++j ){
             sum += val[ j ] * Y[ col_ind[ j ] ] ;
         }
         Y[i] = Y[i] - pivots[i]*sum ;
      }
    }
    r8axpy( &NLOC, &ONE, T, &IONE, Y, &IONE );
*/

    // Combinative block -- END
#endif


  }
}

/*----------------------------------------------------------------------*/
/*----------------------------------------------------------------------*/
/* Grab pointers to IPARS' grid element arrays */

#ifdef DEBUGGING
static _F_REAL_8 AJACNORM = 0.0 ;
#endif

static void slptrwork(
  const _F_INTEGER * const IDIM ,
  const _F_INTEGER * const JDIM ,
  const _F_INTEGER * const KDIM ,
  const _F_INTEGER * const LDIM ,
  const _F_INTEGER * const IL1 ,
  const _F_INTEGER * const IL2 ,
  const _F_INTEGER * const JLV1 ,
  const _F_INTEGER * const JLV2 ,
  const _F_INTEGER * const KL1 ,
  const _F_INTEGER * const KL2 ,
  const _F_INTEGER * const KEYOUT ,
  const _F_INTEGER * const NBLK ,
        _F_REAL_4    * const GJAC,  /* IPARS' Jacobian grid */
        _F_REAL_8    * const GRES,  /* IPARS' Residual grid */
        _F_REAL_8    * const GDU )  /* IPARS' Solution grid */
{
  if ( *NBLK <= 0 || solve_data->nblk < *NBLK )
    SLDIE("Bad block number in a work routine");

  solve_data->blk[ *NBLK - 1 ].gjac = GJAC ;
  solve_data->blk[ *NBLK - 1 ].gres = GRES ;
  solve_data->blk[ *NBLK - 1 ].gsol = GDU ;

#ifdef DEBUGGING
  {
    _F_INTEGER NS = solve_data->ns ;
    _F_INTEGER NEV = solve_data->nev ;

    _sljacnorm(
      IDIM , JDIM , KDIM , LDIM ,
      IL1 , IL2 , JLV1 , JLV2 , KL1 , KL2 , KEYOUT , NBLK ,
      &NS, &NEV, GJAC , &AJACNORM );
  }
#endif

#ifdef DEBUGGING_JAC

  {
    _F_INTEGER NS = solve_data->ns ;
    _F_INTEGER NEV = solve_data->nev ;

    _sljacdebug(
      IDIM , JDIM , KDIM , LDIM ,
      IL1 , IL2 , JLV1 , JLV2 , KL1 , KL2 , KEYOUT , NBLK ,
      &NS, &NEV, GJAC );
  }

#endif
}

/*----------------------------------------------------------------------*/
/*----------------------------------------------------------------------*/
/* Apply "decoupling" to the multicomponent linear system.      */

static void sldecouple( _F_REAL_8 * V )
{
  const int NEV    = solve_data->nev ;
  const int nblk   = solve_data->nblk ;
  const int ldvec  = solve_data->nloc ;
  const int ns     = solve_data->ns ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );

  _F_REAL_8 * const W = solve_data->work ;
  _F_REAL_8 * const W2 = solve_data->work + NEV ;

  const _F_INTEGER * jmap ;

  _F_INTEGER INFO ;

  int i, iv, ne, ie, ivoff, ieoff, is ;

  for ( i = 0 ; i < nblk ; ++i ) {
    const solve_blk_type * const blk   = solve_data->blk + i ;
    const int                    nloc  = blk->nloc ;
    const int                    ldg   = blk->ldgrid ;
    const int                    ldgns = ldg * ns ;
    const _F_INTEGER     * const jbeg  = blk->jmap ;
    const _F_INTEGER     * const jend  = jbeg + nloc * ldjmap ;
          _F_REAL_4      * const AI    = blk->gjac ;

    for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap , ++V ) {
      const int isinc = 2 ;
      const int isbeg = isinc * 1 ;
      const int isend = isinc * jmap[1] ;

      for ( ne = NEV - 1 ; 0 < ne ; --ne ) {
        double mag ;

        { /* Generate Householder for cell center */

          _F_REAL_4 * const A = AI + jmap[0] + ne * NEV * ldgns ;

          mag = 0.0 ;
          for ( ie = 0 ; ie <= ne ; ++ie ) {
            const double val = W[ie] = A[ ldgns * ie ] ;
            mag += val * val ;
          }
        }

        W[ne] += ( 0 < W[ne] ) ? sqrt(mag) : - sqrt(mag) ;

        mag = 0.0 ;
        for ( ie = 0 ; ie <= ne ; ++ie ) mag += W[ie] * W[ie] ;

        /* Apply to all grid-cell columns */

        for ( is = isbeg ; is <= isend ; is += isinc ) {

          /* Top of column */

          _F_REAL_4 * const A = AI + jmap[0] + jmap[is] * ldg ;

          for ( iv = 0 ; iv < NEV ; ++iv ) {
            const int ivoff = iv * NEV ;
            double beta = 0.0 ;
            for ( ie = 0 ; ie <= ne ; ++ie ) {
              beta += W[ie] * A[ldgns * (ivoff + ie)] ;
            }
            beta *= 2.0 / mag ;
            for ( ie = 0 ; ie <= ne ; ++ie ) {
#ifdef DEBUGGING
              W2[ivoff+ie] = 
#endif
                A[ldgns*(ivoff+ie)] -= beta * W[ie] ;
            }
          }
        }

        /* Apply to vector */

        {
          _F_REAL_8 * const SV = V ;
          double beta = 0.0 ;
          for ( ie = 0 ; ie <= ne ; ++ie ) {
            beta += W[ie] * SV[ie*ldvec] ;
          }
          beta *= 2.0 / mag ;
          for ( ie = 0 ; ie <= ne ; ++ie ) {
            SV[ie*ldvec] -= beta * W[ie] ;
          }
        }
      }
    }
  }

}

static void sldecouple_wallis( _F_REAL_8 * V )
{
  const int NEV    = solve_data->nev ;
  const int nblk   = solve_data->nblk ;
  const int ldvec  = solve_data->nloc ;
  const int ns     = solve_data->ns ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );

  _F_REAL_8 * const WA = solve_data->work ;
  _F_REAL_8 * const WAA = solve_data->work + NEV*NEV ;
  _F_REAL_8 * const WORK = solve_data->work + 2*NEV*NEV ;
  _F_INTEGER       LWORK = NEV*ldvec ;
  _F_INTEGER * const IPALL = (_F_INTEGER *)( WA + 2*NEV*NEV + NEV*ldvec ) ;

  const _F_INTEGER * jmap ;

  _F_INTEGER INFO ;
  _F_INTEGER * IP = IPALL ;
  _F_INTEGER NEV_F = NEV ;

  int i, iv, ie, ivoff, ieoff, is, it ;

  for ( i = 0 ; i < nblk ; ++i ) {
    const solve_blk_type * const blk   = solve_data->blk + i ;
    const int                    nloc  = blk->nloc ;
    const int                    ldg   = blk->ldgrid ;
    const int                    ldgns = ldg * ns ;
    const _F_INTEGER     * const jbeg  = blk->jmap ;
    const _F_INTEGER     * const jend  = jbeg + nloc * ldjmap ;
          _F_REAL_4      * const AI    = blk->gjac ;

    for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap , ++V ) {
      const int isinc = 2 ;
      const int isbeg = isinc * 1 ;
      const int isend = isinc * jmap[1] ;

      {
        _F_REAL_4 * const A = AI + jmap[0] ;

        for ( iv = 0 ; iv < NEV ; ++iv ) {
          const int ivoff = iv * NEV ;
          for ( ie = 0 ; ie < NEV ; ++ie ) {
            WAA[ivoff + ie] =  A[ldgns * (ivoff + ie)] ;
          }
        }


        r8getrf(&NEV_F,&NEV_F,WAA,&NEV_F,IP,&INFO);
        if ( 0 != INFO ) {
         SLDIE("lapack factorization failed");
        }

        r8getri(&NEV_F,WAA,&NEV_F,IP,WORK,&LWORK,&INFO);
        if ( 0 != INFO ) {
         SLDIE("lapack matrix inversion failed");
        }

        /* generate the matrix of the transformation */
        for ( iv = 0 ; iv < NEV*NEV ; ++iv ) WA[iv] = 0. ;

        for ( iv = 0 ; iv < NEV ; ++iv ) {
            const int ivoff = iv * NEV ;
            WA[ivoff] = A[0] * WAA[ivoff] ; // zero only pressure line
        //  WA[ivoff+1] = A[ldgns * (NEV+1)] * WAA[ivoff+1] ;//zero upper block
        }
        for ( iv = 1 ; iv < NEV ; ++iv ) { // zero only pressure line
        //for ( iv = 2 ; iv < NEV ; ++iv ) { //zero upper block
            const int ivoff = iv * NEV ;
            WA[ivoff + iv] = 1. ;
        }
      }


        /* Apply to all grid-cell columns */

        for ( is = isbeg ; is <= isend ; is += isinc ) {

          /* Top of column */

          _F_REAL_4 * const A = AI + jmap[0] + jmap[is] * ldg ;

          for ( iv = 0 ; iv < NEV*NEV ; ++iv ) WAA[iv] = 0. ;

          for ( iv = 0 ; iv < NEV ; ++iv ) {
            const int ivoff = iv * NEV ;
            for ( ie = 0 ; ie < NEV ; ++ie ) {
              for ( it = 0 ; it < NEV ; ++it ) {
               const int itoff = it * NEV ;
               WAA[ivoff + ie] +=
                WA[itoff + ie] * A[ldgns * (ivoff + it)] ;
              }
            }
          }
          for ( iv = 0 ; iv < NEV ; ++iv ) {
            const int ivoff = iv * NEV ;
            for ( ie = 0 ; ie < NEV ; ++ie ) {
              A[ldgns * (ivoff + ie)] = WAA[ivoff + ie] ;
            }
          }
        }

        /* Apply to vector */

        {
          _F_REAL_8 * const SV = V ;
          for ( iv = 0 ; iv < NEV ; ++iv ) WAA[iv] = 0. ;
          for ( iv = 0 ; iv < NEV ; ++iv ) {
            for ( ie = 0 ; ie < NEV ; ++ie ) {
              const int ieoff = ie * NEV ;
              WAA[iv] += WA[ieoff + iv] * SV[ie*ldvec] ;
            }
          }
          for ( ie = 0 ; ie < NEV ; ++ie ) {
            SV[ie*ldvec] = WAA[ie] ;
          }
        }
    }
  }
}

/* Apply impes "decoupling" to the multicomponent linear system.      */

static void sldecouple_impes( _F_REAL_8 * V )
{
  const int NEV    = solve_data->nev ;
  const int nblk   = solve_data->nblk ;
  const int ldvec  = solve_data->nloc ;
  const int ns     = solve_data->ns ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );

  _F_REAL_8 * const WA = solve_data->work ;
  _F_REAL_8 * const WS = solve_data->work + NEV*NEV ;
  _F_INTEGER * const IPALL = ( _F_INTEGER *) (WA + 2*NEV*NEV ) ;

  _F_INTEGER *  IP = IPALL ;
  _F_INTEGER    INFO  ;
  _F_INTEGER    IONE = 1  ;
  _F_INTEGER    NEV_F = NEV ;



  const _F_INTEGER * jmap ;


  int i, iv, ne, ie, ivoff, ieoff, is ;

  for ( i = 0 ; i < nblk ; ++i ) {
    const solve_blk_type * const blk   = solve_data->blk + i ;
    const int                    nloc  = blk->nloc ;
    const int                    ldg   = blk->ldgrid ;
    const int                    ldgns = ldg * ns ;
    const _F_INTEGER     * const jbeg  = blk->jmap ;
    const _F_INTEGER     * const jend  = jbeg + nloc * ldjmap ;
          _F_REAL_4      * const AI    = blk->gjac ;

    for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap , ++V ) {
      const int isinc = 2 ;
      const int isbeg = isinc * 1 ;
      const int isend = isinc * jmap[1] ;

      _F_REAL_4 * const A = AI + jmap[0] ;

        for ( iv = 0 ; iv < NEV ; ++iv ) {
            const int ivoff = iv * NEV ;
            for ( ie = 0 ; ie < NEV ; ++ie ) {
               WA[ivoff+ie] = A[ldgns * (ivoff + ie)] ;
            }
        }

        r8getrf(&NEV_F,&NEV_F,WA,&NEV_F,IP,&INFO);
        if ( 0 != INFO ) {
         SLDIE("lapack factorization failed");
        }
//      WS[0] = 1. ;
        WS[0] = A[0] ;
        for ( iv = 1 ; iv < NEV ; ++iv ) WS[iv] = 0. ;
        r8getrs("T",&NEV_F,&IONE,WA,&NEV_F,IP,WS,&NEV_F,&INFO);
        if ( 0 != INFO ) {
         SLDIE("lapack solution failed");
        }


        /* Apply to all grid-cell columns */

        for ( is = isbeg ; is <= isend ; is += isinc ) {

          /* Top of column */

          _F_REAL_4 * const A = AI + jmap[0] + jmap[is] * ldg ;

          for ( iv = 0 ; iv < NEV ; ++iv ) {
            const int ivoff = iv * NEV ;
            A[ldgns * ivoff ] *= WS[0]  ;
            for ( ie = 1 ; ie < NEV ; ++ie ) {
              A[ldgns * ivoff ] += WS[ie] * A[ldgns * (ivoff + ie)] ;
            }
          }
        }

        /* Apply to vector */

        {
          _F_REAL_8 * const SV = V ;
          SV[0] *= WS[0] ;
          for ( ie = 1 ; ie < NEV ; ++ie ) {
            SV[0] += SV[ie*ldvec] * WS[ie] ;
          }
        }
    }
  }

}

static void sldecouple_athos( _F_REAL_8 * V )
{
  const int NEV    = solve_data->nev ;
  const int nblk   = solve_data->nblk ;
  const int ldvec  = solve_data->nloc ;
  const int ns     = solve_data->ns ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );

  _F_REAL_8 * const WA = solve_data->work ;
  _F_REAL_8 * const WAA = solve_data->work + NEV*NEV ;
  _F_REAL_8 * const WORK = solve_data->work + 2*NEV*NEV ;
  _F_INTEGER       LWORK = NEV*ldvec ;
  _F_INTEGER * const IPALL = (_F_INTEGER *)( WA + 2*NEV*NEV + NEV*ldvec ) ;

  const _F_INTEGER * jmap ;

  _F_INTEGER INFO ;
  _F_INTEGER * IP = IPALL ;
  _F_INTEGER NEV_F = NEV ;

  int i, iv, ie, ivoff, ieoff, is, it ;

  for ( i = 0 ; i < nblk ; ++i ) {
    const solve_blk_type * const blk   = solve_data->blk + i ;
    const int                    nloc  = blk->nloc ;
    const int                    ldg   = blk->ldgrid ;
    const int                    ldgns = ldg * ns ;
    const _F_INTEGER     * const jbeg  = blk->jmap ;
    const _F_INTEGER     * const jend  = jbeg + nloc * ldjmap ;
          _F_REAL_4      * const AI    = blk->gjac ;

    for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap , ++V ) {
      const int isinc = 2 ;
      const int isbeg = isinc * 1 ;
      const int isend = isinc * jmap[1] ;

      {
        _F_REAL_4 * const A = AI + jmap[0] ;

        for ( iv = 0 ; iv < NEV ; ++iv ) {
          const int ivoff = iv * NEV ;
          for ( ie = 0 ; ie < NEV ; ++ie ) {
            WAA[ivoff + ie] =  A[ldgns * (ivoff + ie)] ;
          }
        }


        r8getrf(&NEV_F,&NEV_F,WAA,&NEV_F,IP,&INFO);
        if ( 0 != INFO ) {
         SLDIE("lapack factorization failed");
        }

        r8getri(&NEV_F,WAA,&NEV_F,IP,WORK,&LWORK,&INFO);
        if ( 0 != INFO ) {
         SLDIE("lapack matrix inversion failed");
        }

        /* generate the matrix of the transformation */
        for ( iv = 0 ; iv < NEV*NEV ; ++iv ) WA[iv] = WAA[iv] ;
      }


        /* Apply to all grid-cell columns */

        for ( is = isbeg ; is <= isend ; is += isinc ) {

          /* Top of column */

          _F_REAL_4 * const A = AI + jmap[0] + jmap[is] * ldg ;

          for ( iv = 0 ; iv < NEV*NEV ; ++iv ) WAA[iv] = 0. ;

          for ( iv = 0 ; iv < NEV ; ++iv ) {
            const int ivoff = iv * NEV ;
            for ( ie = 0 ; ie < NEV ; ++ie ) {
              for ( it = 0 ; it < NEV ; ++it ) {
               const int itoff = it * NEV ;
               WAA[ivoff + ie] +=
                WA[itoff + ie] * A[ldgns * (ivoff + it)] ;
              }
            }
          }
          for ( iv = 0 ; iv < NEV ; ++iv ) {
            const int ivoff = iv * NEV ;
            for ( ie = 0 ; ie < NEV ; ++ie ) {
              A[ldgns * (ivoff + ie)] = WAA[ivoff + ie] ;
            }
          }
        }
        /* Apply to vector */

        {
          _F_REAL_8 * const SV = V ;
          for ( iv = 0 ; iv < NEV ; ++iv ) WAA[iv] = 0. ;
          for ( iv = 0 ; iv < NEV ; ++iv ) {
            for ( ie = 0 ; ie < NEV ; ++ie ) {
              const int ieoff = ie * NEV ;
              WAA[iv] += WA[ieoff + iv] * SV[ie*ldvec] ;
            }
          }
          for ( ie = 0 ; ie < NEV ; ++ie ) {
            SV[ie*ldvec] = WAA[ie] ;
          }
        }
    }
  }
}


static void store_jac( _F_REAL_4 *  jac ) 
{
  const int nblk   = solve_data->nblk ;
  const int ldvec  = solve_data->nloc ;
  const int ns     = solve_data->ns ;
  const int nev    = solve_data->nev ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );

  int i, iv, ie, is ;
  const _F_INTEGER * jmap ;

  for ( iv = 0 ; iv < nev ; ++iv ) {
    const int ivoff = iv * nev ;

    for ( ie = 0 ; ie < nev ; ++ie ) {
      const int ieoff = ns * ( ie + ivoff );

      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    ldg  = blk->ldgrid ;
        const int                    nloc = blk->nloc ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;
        const _F_REAL_4      * const AJGI = blk->gjac + ldg * ieoff ;

        for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
          const _F_REAL_4 * const A = AJGI + jmap[0] ;
          const int isend = 2 * jmap[1] ;

          for ( is = 2 ; is <= isend ; is += 2, ++jac ) {
            *jac = A[ jmap[is] * ldg ] ;
          }
        }
      }
    }
  }
}
static void mul_jac( _F_REAL_4 * jac, _F_REAL_8 * VBASE  ) 
{
  const int nblk   = solve_data->nblk ;
  const int ldvec  = solve_data->nloc ;
  const int ns     = solve_data->ns ;
  const int nev    = solve_data->nev ;
  const int ldjmap = 2 * ( solve_data->ns + 1 );

  int i, iv, ie, is ;
  const _F_INTEGER * jmap ;
  _F_REAL_8 * V ;

  for ( iv = 0 ; iv < nev ; ++iv ) {
    const int ivoff = iv * nev ;

    V = VBASE ;

    for ( ie = 0 ; ie < nev ; ++ie ) {
      const int ieoff = ns * ( ie + ivoff );

      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    ldg  = blk->ldgrid ;
        const int                    nloc = blk->nloc ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;
        const _F_REAL_8      * const SOL  = blk->gsol + ldg * iv ;

        for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap , ++V ) {
          const int isend = 2 * jmap[1] ;

          for ( is = 2 ; is <= isend ; is += 2, ++jac ) {
            *V += *jac  * SOL[ jmap[1+is] ];
          }
        }
      }
    }
  }
}



static void slpressglobfac( )
{
      const _F_INTEGER NLOC = solve_data->nloc ;
            _F_REAL_4  * PR  = solve_data->pworkr;
            _F_REAL_4  * W  = PR + factor_for_real*NLOC;
       //   _F_REAL_4  * XX = W + 2*NLOC;
            _F_REAL_4  * XX = W + 4*NLOC; // need 4 because of add.memory YY8
            _F_REAL_4  * YY = XX + NLOC;
            _F_REAL_4  * Cntl  = YY + NLOC;
            _F_REAL_4  * Rinfo = Cntl + 10;
            _F_REAL_8  * Asum  = (_F_REAL_8  *) Rinfo+ 20;
            _F_REAL_8  * XX8 = (_F_REAL_8  *) W ;
            _F_INTEGER * PI  = solve_data->pworki;
            _F_INTEGER * Keep= PI + factor_for_int *NLOC;
            _F_INTEGER * Icntl= Keep + 20;
            _F_INTEGER * InfoUMS = Icntl + 20;
      const _F_INTEGER ldw = factor_for_real*NLOC;
      const _F_INTEGER liw = factor_for_int *NLOC;
      const _F_INTEGER ZERO = 0 ;
            _F_INTEGER nel,ii;

      const int nblk   = solve_data->nblk ;
      const int ns     = solve_data->ns ;
      const int ldjmap = 2 * ( solve_data->ns + 1 );
      const _F_INTEGER * jmap ;

      int i,is,isT,iss;
      double skew, maxskew ;
      maxskew = 0.0 ;


      if (flag_first_fctrz) {
        _ums2in(Icntl, Cntl, Keep);
        Icntl[5] = 1; // Preserve symmetry of the pattern
        Icntl[2] = 0; // Silence
        Icntl[7] = 0; // No iterative refinement
      }

      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    nloc = blk->nloc ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;
              _F_REAL_8      * const   GI = blk->gres  ;
        for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
          const int isend = 2 * jmap[1] ;
          for ( is = 2 ; is <= isend ; is += 2 ) GI[ jmap[1+is] ] =0.0;
        }
      }
      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    nloc = blk->nloc ;
        const _F_INTEGER     * const mapj = blk->mapj ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;
              _F_REAL_8      * const   GI = blk->gres  ;
        for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
          const int isend = 2 * jmap[1] ;
          for ( is = 2 ; is <= isend ; is += 2 ){
              if ( (jmap-jbeg)/ldjmap==mapj[jmap[1+is]] ) GI[ jmap[1+is] ] =1.0;
          }
        }
      }

{
_F_INTEGER IMRK[2] ;
IMRK[0] = 1; IMRK[1] = solve_data->idgsol ;
mycallwork( _mrkdnk, &IMRK );
}
slgrid2vec( 0, XX8 , 1.0 , 0, 1);

      ii = 0;
      nel = 0;
      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    ldg  = blk->ldgrid ;
        const int                    nloc = blk->nloc ;
        const int                    disp = blk->disp ;
        const _F_INTEGER     * const mapj = blk->mapj ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;
        const _F_REAL_4      * const AJGI = blk->gjac  ;
        const _F_REAL_8      * const   GI = blk->gres  ;

        Asum[i] = 0.0 ;

        for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
          const _F_REAL_4 * const A = AJGI + jmap[0] ;
          const int isend = 2 * jmap[1] ;
                int ir    = (jmap-jbeg)/ldjmap+1+disp;

//        printf("row %d:",(jmap-jbeg)/ldjmap+disp);
          for ( is = 2 ; is <= isend ; is += 2 ) {
//          printf(" %d",mapj[jmap[1+is]]+disp);
//          const _F_INTEGER * jmapT = jbeg + mapj[jmap[1+is]]*ldjmap ;
//          const _F_REAL_4 * const AT = AJGI + jmapT[0];
//          const int isendT = 2 * jmapT[1] ;
//          int isT, iss ;
            int iclo  = mapj[jmap[1+is]]+1;
            int ic    = mapj[jmap[1+is]]+1+disp;
           if ( iclo != 0 ) {
            PI[ii]=ir;
            PI[ii+1]=ic;
            PR[nel]=A[ jmap[is] * ldg ] * GI[ jmap[1+is] ];
//          printf(" %d %d %.15g  \n", PI[ii],PI[ii+1],A[ jmap[is] * ldg ]);
/* To compute skew
            for ( iss = 2 ; iss <= isendT ; iss += 2 ) {
             if ( mapj[jmapT[1+iss]] == (jmap-jbeg)/ldjmap ) isT = iss; }
            if (fabs(A[ jmap[is] * ldg ]) < fabs(AT[ jmapT[isT] * ldg ]) )
               skew = fabs(AT[ jmapT[isT] * ldg ]-A[ jmap[is] * ldg ])
                      / fabs(AT[ jmapT[isT] * ldg ]);
            else
               skew = fabs(AT[ jmapT[isT] * ldg ]-A[ jmap[is] * ldg ])
                      / fabs(A[ jmap[is] * ldg ]);
            if (skew > maxskew) maxskew = skew ;
*/
/* To factorize simmetrized matrix
            for ( iss = 2 ; iss <= isendT ; iss += 2 ) {
             if ( mapj[jmapT[1+iss]] == (jmap-jbeg)/ldjmap ) isT = iss; }
            if (fabs(A[ jmap[is] * ldg ]) < fabs(AT[ jmapT[isT] * ldg ]) )
               { PR[nel]=A[ jmap[is] * ldg ]; }
            else
               { PR[nel]=AT[ jmapT[isT] * ldg ]; } 
*/
            ii+=2;
            nel+=1;
            if ( XX8[ir-1] != 0.0 && XX8[ic-1] != 0.0 )
               Asum[i] += A[ jmap[is] * ldg ];
           }
          }
        }
    }
    for (i=0;i<2*nel;i+=2) PI[2*nel+i/2]=PI[i+1];
    for (i=0;i<2*nel;i+=2) PI[i/2] = PI[i];
    for (i=0;i<nel;i+=1)   PI[nel+i] = PI[2*nel+i];

    if (flag_first_fctrz) {
      _ums2fa(&NLOC,&nel,&ZERO,&ldw,&liw,PR,PI,
             Keep,Cntl,Icntl,InfoUMS,Rinfo);
       flag_first_fctrz = 0;
       if (InfoUMS[0] < 0) SLDIE("Error in UMS2FA");
    }
    else {
      _ums2rf(&NLOC,&nel,&ZERO,&ldw,&liw,PR,PI,
             Keep,Cntl,Icntl,InfoUMS,Rinfo);
       if (InfoUMS[0] < 0) SLDIE("Error in UMS2RF");
    }
//  printf("maxskew = %.15g \n",maxskew);
}


static void initialisemlilu( )
{
      const _F_INTEGER NLOC = solve_data->nloc ;
      const _F_INTEGER NS   = solve_data->ns   ;
            _F_REAL_8  * XX = solve_data->pworkr ;
            _F_REAL_8  * Asum = XX + 3*NLOC ;
            _F_INTEGER * diag_positive = solve_data->pworki ;

      const int nblk   = solve_data->nblk ;
      const int ns     = solve_data->ns ;
      const int ldjmap = 2 * ( solve_data->ns + 1 );
      const _F_INTEGER * jmap ;

      extern double temps;
      extern typ **matt;
      extern int **indext;
      extern typ **mat_init;
      extern int **index_init;
      extern typ ***LU;
      extern int ***indexLU;
      extern double *vdi;
      extern double *vd;
      extern void initialise(typ ***,int ***, typ ***, int ***, int);



      int i,j,is;

if ( (*LU)[0] == NULL )
{
 for ( j = 0 ; j < NLOC ; ++j )
    {
     mat_init[j] = (typ*) malloc(sizeof(typ)*7);
     index_init[j] = (int*) malloc(sizeof(int)*7);
     matt[j] = (typ*) malloc(sizeof(typ)*7);
     indext[j] = (int*) malloc(sizeof(int)*7);
     (*indexLU)[j] = (int*) malloc(sizeof(int)*7);
     (*LU)[j] = (typ*) malloc(sizeof(typ)*7);
    }
}



      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    nloc = blk->nloc ;
        const int                    disp = blk->disp ;
        const _F_INTEGER     * const mapj = blk->mapj ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;
              _F_REAL_8      * const   GI = blk->gres  ;


        for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
          const int isend = 2 * jmap[1] ;
                int ir    =(jmap-jbeg)/ldjmap+disp;
                index_init[ir][0] = indext[ir][0] = 0 ;
                (*LU)[ir][0] = (*indexLU)[ir][0] = 1 ;
                vdi[ir] = vd[ir] = 0;
          for ( is = 2 ; is <= isend ; is += 2 ){
              int iclo  = mapj[jmap[1+is]]+1;
              if ( iclo != 0 ) {
                 index_init[ir][0] += 1 ;
                 indext[ir][0] += 1;
              }
              GI[ jmap[1+is] ] =0.0;
          }
        }
      }

      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    nloc = blk->nloc ;
        const _F_INTEGER     * const mapj = blk->mapj ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;
              _F_REAL_8      * const   GI = blk->gres  ;

        for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
          const int isend = 2 * jmap[1] ;
          for ( is = 2 ; is <= isend ; is += 2 ){
            if ( (jmap-jbeg)/ldjmap==mapj[jmap[1+is]] ) GI[ jmap[1+is] ] =1.0;
          }
        }
      }
      

{
_F_INTEGER IMRK[2] ;
IMRK[0] = 1; IMRK[1] = solve_data->idgsol ;
mycallwork( _mrkdnk, &IMRK );
}
slgrid2vec( 0, XX , 1.0 , 0, 1);

      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    ldg  = blk->ldgrid ;
        const int                    nloc = blk->nloc ;
        const int                    disp = blk->disp ;
        const _F_INTEGER     * const mapj = blk->mapj ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;
        const _F_REAL_4      * const AJGI = blk->gjac  ;
        const _F_REAL_8      * const   GI = blk->gres  ;

        diag_positive[i] = 0 ;
        Asum[i] = 0.0 ;

        for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
          const _F_REAL_4 * const A = AJGI + jmap[0] ;
          const int isend = 2 * jmap[1] ;
                int ir    = (jmap-jbeg)/ldjmap+disp;

          j=1;
          for ( is = 2 ; is <= isend ; is += 2 ) {
                int ic    = mapj[jmap[1+is]]+disp;
                int iclo  = mapj[jmap[1+is]]+1;
                int ok    = 0 ;
                
              if ( iclo != 0 ) {
                 if ( ic == ir ){
                    if ( A[ jmap[is] * ldg ]>0.0 ) diag_positive[i] = 1 ;
                    matt[ir][0] = mat_init[ir][0] = 
                     (_F_REAL_8) A[ jmap[is] * ldg ]*GI[ jmap[1+is] ];
                 }
                 else{
                    if ( j>=index_init[ir][0] ){ printf(" ERROR %d",j);exit(1);}
                    index_init[ir][j] =  ic ;
                    indext[ir][j] = ic;
                    matt[ir][j] = mat_init[ir][j] = 
                    (_F_REAL_8) A[ jmap[is] * ldg ]*GI[ jmap[1+is] ];
                    j++;
                 }


                if ( XX[ir] != 0.0 && XX[ic] != 0.0 ) 
                     Asum[i] += (double) A[ jmap[is] * ldg ]; 
              }
          }
        }
      }



      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    ldg  = blk->ldgrid ;
        const int                    nloc = blk->nloc ;
        const int                    disp = blk->disp ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;

        if ( diag_positive[i] && nloc != 0 ) { 
         for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
             int ir = (jmap-jbeg)/ldjmap+disp;
             for ( j = 0 ; j < index_init[ir][0] ; ++j ) {
                   mat_init[ir][j] = -mat_init[ir][j];
                   matt[ir][j] = -matt[ir][j];
             }
         }
        }
      }

       /*         
      for ( j = 0 ; j < NLOC ;++j ) {
      	  printf(" %d  :  ",j );
	   for (i=0; i< index_init[j][0]; i++)
		{ 
			printf(" %.15g ", mat_init[j][i]);
		}
	printf("\n");
	}
	*/
      initialise(&mat_init,&index_init,&matt,&indext,NLOC);

}
/*----------------------------------------------------------------------*/
static void initialisemlilu2( )
{
      const _F_INTEGER NLOC = solve_data->nloc ;
      const _F_INTEGER NS   = solve_data->ns   ;
      const _F_INTEGER NB   = solve_data->nblk ;
      _F_INTEGER * PNLOC2 = solve_data->pworki ;
      _F_INTEGER NLOC2 = PNLOC2[0];
      _F_INTEGER * IP2 = PNLOC2 + 1 ;
      _F_INTEGER * JP2 = IP2 + NLOC + 1 ;
      _F_INTEGER * IP3 = JP2 + IP2[NLOC] ;
      _F_INTEGER * JP3 = IP3 + NLOC2 + 1 ;
      _F_INTEGER * diag_positive = JP3 + IP3[NLOC2]  ;
      _F_REAL_8  * AP2 = solve_data->pworkr ;
      _F_REAL_8  * AP3 = AP2 + IP2[NLOC] ;
      _F_REAL_8  * XX = AP3 + IP3[NLOC2] ;
      _F_REAL_8  * YY = XX + 2*NLOC ;
      _F_REAL_8  * Asum = YY + NLOC ;
      _F_REAL_8  * AA  = Asum + NB ; 
      _F_INTEGER * IA  = diag_positive + NB ; 
      _F_INTEGER * JA  = IA + NLOC+1 ; 
      _F_REAL_8  * AA2 = solve_data->pwork ; //memory for tridiagonal
                                             // factorization is used
                                             // as temporary
      _F_INTEGER * IA2 ; //unknown since the length of JA is unknown
      _F_INTEGER * JA2 ;



      const int nblk   = solve_data->nblk ;
      const int ns     = solve_data->ns ;
      const int ldjmap = 2 * ( solve_data->ns + 1 );
      const _F_INTEGER * jmap ;


      extern double temps;
      extern typ **matt;
      extern int **indext;
      extern typ **mat_init;
      extern int **index_init;
      extern typ ***LU;
      extern int ***indexLU;
      extern double *vdi;
      extern void initialise(typ ***,int ***, typ ***, int ***, int);


      int i,j,k,is;

      for ( j = 0 ; j < NLOC ; ++j ) IA[j+1] = 0 ;
      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    nloc = blk->nloc ;
        const int                    disp = blk->disp ;
        const _F_INTEGER     * const mapj = blk->mapj ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;
              _F_REAL_8      * const   GI = blk->gres  ;
        for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
          const int isend = 2 * jmap[1] ;
                int ir    =(jmap-jbeg)/ldjmap+1+disp;
          for ( is = 2 ; is <= isend ; is += 2 ){
              int iclo  = mapj[jmap[1+is]]+1;
              if ( iclo != 0 ) IA[ir] += 1 ;
              GI[ jmap[1+is] ] =0.0;
          }
        }
      }

      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    nloc = blk->nloc ;
        const _F_INTEGER     * const mapj = blk->mapj ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;
              _F_REAL_8      * const   GI = blk->gres  ;
        for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
          const int isend = 2 * jmap[1] ;
          for ( is = 2 ; is <= isend ; is += 2 ){
            if ( (jmap-jbeg)/ldjmap==mapj[jmap[1+is]] ) GI[ jmap[1+is] ] =1.0;
          }
        }
      }
      
      IA[0] = 1 ;
      for ( j = 1 ; j < NLOC + 1 ; ++j ) IA[j] += IA[j-1]  ;
      for ( j = 1 ; j < IA[ NLOC ] ; ++j ) JA[j-1] = 0  ;

{
_F_INTEGER IMRK[2] ;
IMRK[0] = 1; IMRK[1] = solve_data->idgsol ;
mycallwork( _mrkdnk, &IMRK );
}
slgrid2vec( 0, XX , 1.0 , 0, 1);

      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    ldg  = blk->ldgrid ;
        const int                    nloc = blk->nloc ;
        const int                    disp = blk->disp ;
        const _F_INTEGER     * const mapj = blk->mapj ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;
        const _F_REAL_4      * const AJGI = blk->gjac  ;
        const _F_REAL_8      * const   GI = blk->gres  ;

        diag_positive[i] = 0 ;
        Asum[i] = 0.0 ;

        for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
          const _F_REAL_4 * const A = AJGI + jmap[0] ;
          const int isend = 2 * jmap[1] ;
                int ir    = (jmap-jbeg)/ldjmap+1+disp;

          for ( is = 2 ; is <= isend ; is += 2 ) {
                int ic    = mapj[jmap[1+is]]+1+disp;
                int iclo  = mapj[jmap[1+is]]+1;
              if ( iclo != 0 ) {
                for ( j = IA[ir-1] ; j < IA[ir] ; ++j ) {
                    if ( JA[j-1] == 0 )  {
                       JA[j-1] = ic ;
                       AA[j-1] =(_F_REAL_8)A[ jmap[is] * ldg ]*GI[ jmap[1+is] ];
                       if ( ir==ic && AA[j-1]>0.0 ) diag_positive[i] = 1 ;
                       break ;
                    }
                }
                if ( XX[ir-1] != 0.0 && XX[ic-1] != 0.0 ) 
                     Asum[i] += (double) A[ jmap[is] * ldg ]; 
               }
          }
        }
      }

      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    ldg  = blk->ldgrid ;
        const int                    nloc = blk->nloc ;
        const int                    disp = blk->disp ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;

        if ( diag_positive[i] && nloc != 0 ) {
         for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
             int ir = (jmap-jbeg)/ldjmap+1+disp;
             for ( j = IA[ir-1] ; j < IA[ir] ; ++j ) AA[j-1] = -AA[j-1] ;
         }
        }
      }

      for ( i = 0 ; i < NLOC ; ++i ) {
         for ( j = IA[i] ; j < IA[i+1] ; ++j ) {
             if ( i+1 == JA[j-1] ) {
                _F_REAL_8 dum = AA[j-1] ;
                AA[j-1] = AA[ IA[i]-1 ] ; 
                JA[j-1] = JA[ IA[i]-1 ] ; 
                AA[ IA[i]-1 ] = dum ;
                JA[ IA[i]-1 ] = i+1 ; 
                break ;
             }
         }
      }
                

 // Galerkin projection of the pressure block onto the coarse mesh
 {
  _F_INTEGER   IERR ;
  _F_INTEGER   IONE = 1 ;
  _F_INTEGER * IA2 = JA + IA[NLOC] ;
  _F_INTEGER * JA2 = IA2 + NLOC + 1 ;
  _F_INTEGER * IG    = (_F_INTEGER *)( AA2 + NS*NLOC );
  _F_INTEGER   MAXENTRY  = NS*NLOC ;
  _F_INTEGER   MAXENTRY2 = IA[NLOC]-1 ;
  _amub(&NLOC,&NLOC2,&IONE,AA,JA,IA,AP2,JP2,IP2,AA2,JA2,IA2,&MAXENTRY,IG,&IERR);
  if (IERR != 0) SLDIE("Error in amub1");
 _amub(&NLOC2,&NLOC,&IONE,AP3,JP3,IP3,AA2,JA2,IA2,AA,JA,IA,&MAXENTRY2,IG,&IERR);
  if (IERR != 0) SLDIE("Error in amub2");
 }

if ( (*LU)[0] == NULL )
{
 int max_entr_row = 0;
 for ( j = 0 ; j < NLOC2 ; ++j ) 
     if (IA[j+1]-IA[j] > max_entr_row) max_entr_row = IA[j+1]-IA[j] ;
 max_entr_row = (int) (max_entr_row/7)  ;
 max_entr_row = (max_entr_row +1)*7 ;
 for ( j = 0 ; j < NLOC2 ; ++j )
    {
     mat_init[j] = (typ*) malloc(sizeof(typ)*max_entr_row);
     index_init[j] = (int*) malloc(sizeof(int)*max_entr_row);
     matt[j] = (typ*) malloc(sizeof(typ)*max_entr_row);
     indext[j] = (int*) malloc(sizeof(int)*max_entr_row);
     (*indexLU)[j] = (int*) malloc(sizeof(int)*7);
     (*LU)[j] = (typ*) malloc(sizeof(typ)*7);
    }
}

      for ( j = 0 ; j < NLOC2 ;++j ) {
          (*LU)[j][0] = (*indexLU)[j][0] = 1 ;
          vdi[j] = 0;


          index_init[j][0] = indext[j][0] = IA[j+1]-IA[j] ;
          for ( i=0, k=IA[j]-1 ; i< index_init[j][0]; i++,k++ ) {

               matt[j][i] = mat_init[j][i] = AA[k] ; 
                if(j!=JA[k]-1) index_init[j][i] = indext[j][i] = JA[k]-1;
          }    
      }

/*
      for ( j = 0 ; j < NLOC2 ;++j ) {
          printf(" %d  :  ",j );
          for (i=0; i< index_init[j][0]; i++)
               printf(" %d ", index_init[j][i]);
            // printf(" %.15g ", mat_init[j][i]);
          printf("\n");
      }
*/
      initialise(&mat_init,&index_init,&matt,&indext,NLOC2);

}
/*----------------------------------------------------------------------*/
static void slpressinitamg( )
{
      const _F_INTEGER NLOC = solve_data->nloc ;
      const _F_INTEGER NS   = solve_data->ns   ;
            _F_REAL_8  * AA = solve_data->pworkr ;
            _F_REAL_8  * XX = AA + 7*(NS*NLOC) + 5*NLOC ;
            _F_REAL_8  * YY = XX + (int) (2.2*NLOC) ;
            _F_REAL_8  * Asum = YY + (int) (2.2*NLOC) ;
            _F_INTEGER * JA = solve_data->pworki;
            _F_INTEGER * IA = JA + 7*(NS*NLOC) + 5*NLOC ;
            _F_INTEGER * IG = IA + (int) (2.2*NLOC) ;
            _F_INTEGER AdMemIG = 100 ;
            _F_INTEGER * diag_negative = IG + (int) (5.4*NLOC) + AdMemIG ;
            _F_INTEGER NDA  = 7*(NS*NLOC) + 5*NLOC ;
            _F_INTEGER NDIA = (int)(2.2*NLOC) ;
            _F_INTEGER NDJA = 7*(NS*NLOC) + 5*NLOC ;
            _F_INTEGER NDU  = (int)(2.2*NLOC) ;
            _F_INTEGER NDF  = (int)(2.2*NLOC) ;
            _F_INTEGER NDIG = (int)(5.4*NLOC) + AdMemIG ;
            _F_INTEGER MATRIX = 22 ;
            _F_INTEGER ISWTCH = 4 ; 
            _F_INTEGER IOUT   = 10 ;
            _F_INTEGER IPRINT = 10606 ;
            _F_INTEGER LEVELX = 25 ;
            _F_INTEGER IFIRST = 11 ;
            _F_INTEGER NCYC   = 1011 ;
            _F_REAL_8  EPS    = 1e-12 ;
            _F_INTEGER MADAPT = 27 ;
            _F_INTEGER NRD    = 1131;
            _F_INTEGER NSOLCO = 110 ;
            _F_INTEGER NRU    = 1131;
            _F_REAL_8  ECG1   = 0. ;
            _F_REAL_8  ECG2   = 0.25 ;
            _F_REAL_8  EWT2   = 0.35 ;
            _F_INTEGER NWT    = 2 ;
            _F_INTEGER NTR    = 0 ;
            _F_INTEGER IERR   = 0 ;

      const int nblk   = solve_data->nblk ;
      const int ns     = solve_data->ns ;
      const int ldjmap = 2 * ( solve_data->ns + 1 );
      const _F_INTEGER * jmap ;

      int i,j,is;


//    printf(" NS= %d, NDA= %d \n ", NS,NDA) ;
      for ( j = 0 ; j < NLOC ; ++j ) IA[j+1] = 0 ;

      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    nloc = blk->nloc ;
        const int                    disp = blk->disp ;
        const _F_INTEGER     * const mapj = blk->mapj ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;
              _F_REAL_8      * const   GI = blk->gres  ;


        for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
          const int isend = 2 * jmap[1] ;
                int ir    =(jmap-jbeg)/ldjmap+1+disp;

          for ( is = 2 ; is <= isend ; is += 2 ){
              int iclo  = mapj[jmap[1+is]]+1;
              if ( iclo != 0 ) IA[ir] += 1 ;
              GI[ jmap[1+is] ] =0.0;
          }
        }
      }

      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    nloc = blk->nloc ;
        const _F_INTEGER     * const mapj = blk->mapj ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;
              _F_REAL_8      * const   GI = blk->gres  ;

        for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
          const int isend = 2 * jmap[1] ;
          for ( is = 2 ; is <= isend ; is += 2 ){
            if ( (jmap-jbeg)/ldjmap==mapj[jmap[1+is]] ) GI[ jmap[1+is] ] =1.0;
          }
        }
      }
      
      IA[0] = 1 ;
      for ( j = 1 ; j < NLOC + 1 ; ++j ) IA[j] += IA[j-1]  ;
      for ( j = 1 ; j < IA[ NLOC ] ; ++j ) JA[j-1] = 0  ;

{
_F_INTEGER IMRK[2] ;
IMRK[0] = 1; IMRK[1] = solve_data->idgsol ;
mycallwork( _mrkdnk, &IMRK );
}
slgrid2vec( 0, XX , 1.0 , 0, 1);

      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    ldg  = blk->ldgrid ;
        const int                    nloc = blk->nloc ;
        const int                    disp = blk->disp ;
        const _F_INTEGER     * const mapj = blk->mapj ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;
        const _F_REAL_4      * const AJGI = blk->gjac  ;
        const _F_REAL_8      * const   GI = blk->gres  ;

        diag_negative[i] = 0 ;
        Asum[i] = 0.0 ;

        for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
          const _F_REAL_4 * const A = AJGI + jmap[0] ;
          const int isend = 2 * jmap[1] ;
                int ir    = (jmap-jbeg)/ldjmap+1+disp;

          for ( is = 2 ; is <= isend ; is += 2 ) {
                int ic    = mapj[jmap[1+is]]+1+disp;
                int iclo  = mapj[jmap[1+is]]+1;
                int ok    = 0 ;
                
              if ( iclo != 0 ) {
                for ( j = IA[ir-1] ; j < IA[ir] ; ++j ) {
                    if ( JA[j-1] == 0 )  {
                       ok  = 1 ;
                       JA[j-1] = ic ;
                       AA[j-1] =(_F_REAL_8)A[ jmap[is] * ldg ]*GI[ jmap[1+is] ];
                       if ( ir==ic && AA[j-1]<0.0 ) diag_negative[i] = 1 ;
                       break ;
                    }
                }
                if ( ok == 0 ) SLDIE( "Error in filling AMG matrix" ) ;

                if ( XX[ir-1] != 0.0 && XX[ic-1] != 0.0 ) 
                     Asum[i] += (double) A[ jmap[is] * ldg ]; 
               }
          }
        }
      }



      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    ldg  = blk->ldgrid ;
        const int                    nloc = blk->nloc ;
        const int                    disp = blk->disp ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;

        if ( diag_negative[i] && nloc != 0 ) { 
         for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
             int ir = (jmap-jbeg)/ldjmap+1+disp;
             for ( j = IA[ir-1] ; j < IA[ir] ; ++j ) AA[j-1] = -AA[j-1] ;
         }
        }
      }

      for ( i = 0 ; i < NLOC ; ++i ) {
         for ( j = IA[i] ; j < IA[i+1] ; ++j ) {
             if ( i+1 == JA[j-1] ) {
                _F_REAL_8 dum = AA[j-1] ;

                AA[j-1] = AA[ IA[i]-1 ] ; 
                JA[j-1] = JA[ IA[i]-1 ] ; 
                AA[ IA[i]-1 ] = fabs( (double) dum) ;
                //fabs--otherwise amg1r5 may fail
                JA[ IA[i]-1 ] = i+1 ; 
                break ;
             }
         }
      }
                

/*
      for ( i = 0 ; i < NLOC ; ++i ) {
         printf("%d :", i+1) ;
         for ( j = IA[i] ; j < IA[i+1] ; ++j ) printf( " %d", JA[j-1] );
         printf("\n") ;
      }
      SLDIE("stop");
*/
      for (j=0;j<NLOC;++j) XX[j]= 0.;  
      _amg1r5(AA,IA,JA,YY,XX,IG,
              &NDA,&NDIA,&NDJA,&NDU,&NDF,&NDIG,&NLOC,&MATRIX,
              &ISWTCH,&IOUT,&IPRINT,
              &LEVELX,&IFIRST,&NCYC,&EPS,&MADAPT,&NRD,&NSOLCO,&NRU,
              &ECG1,&ECG2,&EWT2,&NWT,&NTR,
              &IERR );
      if (IERR > 0) SLDIE("Error in AMG1R5 init");
}
/*----------------------------------------------------------------------*/
static void slpressinitamg2( )
{
      const _F_INTEGER NLOC = solve_data->nloc ;
      const _F_INTEGER NS   = solve_data->ns   ;
            _F_INTEGER * PNLOC2 = solve_data->pworki ;
            _F_INTEGER NLOC2 = PNLOC2[0];
            _F_INTEGER * IP2 = PNLOC2 + 1 ;
            _F_INTEGER * JP2 = IP2 + NLOC + 1 ;
            _F_INTEGER * IP3 = JP2 + IP2[NLOC] ;
            _F_INTEGER * JP3 = IP3 + NLOC2 + 1 ;
            _F_INTEGER * JA = JP3 + IP3[NLOC2] ;
            _F_INTEGER * IA = JA + 7*(NS*NLOC) + 5*NLOC ;
            _F_INTEGER * IG = IA + (int) (2.2*NLOC) ;
            _F_INTEGER AdMemIG = 100 ;
            _F_INTEGER * diag_negative = IG + (int) (5.4*NLOC) + AdMemIG ;
            _F_REAL_8  * AP2 = solve_data->pworkr ;
            _F_REAL_8  * AP3 = AP2 + IP2[NLOC] ;
            _F_REAL_8  * AA = AP3 + IP3[NLOC2] ;
            _F_REAL_8  * XX = AA + 7*(NS*NLOC) + 5*NLOC ;
            _F_REAL_8  * YY = XX + (int) (2.2*NLOC) ;
            _F_REAL_8  * Asum = YY + (int) (2.2*NLOC) ;
            _F_INTEGER NDA  = 7*(NS*NLOC) + 5*NLOC ;
            _F_INTEGER NDIA = (int)(2.2*NLOC) ;
            _F_INTEGER NDJA = 7*(NS*NLOC) + 5*NLOC ;
            _F_INTEGER NDU  = (int)(2.2*NLOC) ;
            _F_INTEGER NDF  = (int)(2.2*NLOC) ;
            _F_INTEGER NDIG = (int)(5.4*NLOC) + AdMemIG ;
            _F_INTEGER MATRIX = 22 ;
            _F_INTEGER ISWTCH = 4 ; 
            _F_INTEGER IOUT   = 10 ;
            _F_INTEGER IPRINT = 10606 ;
            _F_INTEGER LEVELX = 25 ;
            _F_INTEGER IFIRST = 11 ;
            _F_INTEGER NCYC   = 1011 ;
            _F_REAL_8  EPS    = 1e-12 ;
            _F_INTEGER MADAPT = 27 ;
            _F_INTEGER NRD    = 1131;
            _F_INTEGER NSOLCO = 110 ;
            _F_INTEGER NRU    = 1131;
            _F_REAL_8  ECG1   = 0. ;
            _F_REAL_8  ECG2   = 0.25 ;
            _F_REAL_8  EWT2   = 0.35 ;
            _F_INTEGER NWT    = 2 ;
            _F_INTEGER NTR    = 0 ;
            _F_INTEGER IERR   = 0 ;

      const int nblk   = solve_data->nblk ;
      const int ns     = solve_data->ns ;
      const int ldjmap = 2 * ( solve_data->ns + 1 );
      const _F_INTEGER * jmap ;
      const _F_INTEGER * jblk = NULL ;


      int i,j,k,is;


//    printf(" NS= %d, NDA= %d \n ", NS,NDA) ;
      for ( j = 0 ; j < NLOC ; ++j ) IA[j+1] = 0 ;

      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    nloc = blk->nloc ;
        const int                    disp = blk->disp ;
        const _F_INTEGER     * const mapj = blk->mapj ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;
              _F_REAL_8      * const   GI = blk->gres  ;


        for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
          const int isend = 2 * jmap[1] ;
                int ir    =(jmap-jbeg)/ldjmap+1+disp;

          for ( is = 2 ; is <= isend ; is += 2 ){
              int iclo  = mapj[jmap[1+is]]+1;
              if ( iclo != 0 ) IA[ir] += 1 ;
              GI[ jmap[1+is] ] =0.0;
          }
        }
      }

      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    nloc = blk->nloc ;
        const _F_INTEGER     * const mapj = blk->mapj ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;
              _F_REAL_8      * const   GI = blk->gres  ;

        for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
          const int isend = 2 * jmap[1] ;
          for ( is = 2 ; is <= isend ; is += 2 ){
            if ( (jmap-jbeg)/ldjmap==mapj[jmap[1+is]] ) GI[ jmap[1+is] ] =1.0;
          }
        }
      }
      
      IA[0] = 1 ;
      for ( j = 1 ; j < NLOC + 1 ; ++j ) IA[j] += IA[j-1]  ;
      for ( j = 1 ; j < IA[ NLOC ] ; ++j ) JA[j-1] = 0  ;



{
_F_INTEGER IMRK[2] ;
IMRK[0] = 1; IMRK[1] = solve_data->idgsol ;
mycallwork( _mrkdnk, &IMRK );
}
slgrid2vec( 0, XX , 1.0 , 0, 1);

      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    ldg  = blk->ldgrid ;
        const int                    nloc = blk->nloc ;
        const int                    disp = blk->disp ;
        const _F_INTEGER     * const mapj = blk->mapj ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;
        const _F_REAL_4      * const AJGI = blk->gjac  ;
        const _F_REAL_8      * const   GI = blk->gres  ;

        diag_negative[i] = 0 ;
        Asum[i] = 0.0 ;

        for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
          const _F_REAL_4 * const A = AJGI + jmap[0] ;
          const int isend = 2 * jmap[1] ;
                int ir    = (jmap-jbeg)/ldjmap+1+disp;

          for ( is = 2 ; is <= isend ; is += 2 ) {
                int ic    = mapj[jmap[1+is]]+1+disp;
                int iclo  = mapj[jmap[1+is]]+1;
                int ok    = 0 ;
                
              if ( iclo != 0 ) {
                for ( j = IA[ir-1] ; j < IA[ir] ; ++j ) {
                    if ( JA[j-1] == 0 )  {
                       ok  = 1 ;
                       JA[j-1] = ic ;
                       AA[j-1] =(_F_REAL_8)A[ jmap[is] * ldg ]*GI[ jmap[1+is] ];
                       if ( ir==ic && AA[j-1]<0.0 ) diag_negative[i] = 1 ;
                       break ;
                    }
                }
                if ( ok == 0 ) SLDIE( "Error in filling AMG matrix" ) ;

                if ( XX[ir-1] != 0.0 && XX[ic-1] != 0.0 ) 
                     Asum[i] += (double) A[ jmap[is] * ldg ]; 
               }
          }
        }
      }



      for ( i = 0 ; i < nblk ; ++i ) {
        const solve_blk_type * const blk  = solve_data->blk + i ;
        const int                    ldg  = blk->ldgrid ;
        const int                    nloc = blk->nloc ;
        const int                    disp = blk->disp ;
        const _F_INTEGER     * const jbeg = blk->jmap ;
        const _F_INTEGER     * const jend = jbeg + nloc * ldjmap ;

        if ( diag_negative[i] && nloc != 0 ) { 
         for ( jmap = jbeg ; jmap < jend ; jmap += ldjmap ) {
             int ir = (jmap-jbeg)/ldjmap+1+disp;
             for ( j = IA[ir-1] ; j < IA[ir] ; ++j ) AA[j-1] = -AA[j-1] ;
         }
        }
      }

      for ( i = 0 ; i < NLOC ; ++i ) {
         for ( j = IA[i] ; j < IA[i+1] ; ++j ) {
             if ( i+1 == JA[j-1] ) {
                _F_REAL_8 dum = AA[j-1] ;

                AA[j-1] = AA[ IA[i]-1 ] ; 
                JA[j-1] = JA[ IA[i]-1 ] ; 
                AA[ IA[i]-1 ] = fabs( (double) dum) ;
                //fabs--otherwise amg1r5 may fail
                JA[ IA[i]-1 ] = i+1 ; 
                break ;
             }
         }
      }
                

 // Galerkin projection of the pressure block onto the coarse mesh
 {
  _F_INTEGER IONE = 1 ;
  _F_INTEGER * IA2 = IA + NLOC + 1 ;
  _F_INTEGER * JA2 = JA + IA[NLOC] ;
  _F_REAL_8  * AA2 = AA + IA[NLOC] ;
  _F_INTEGER MAXENTRY2, MAXENTRY ;
  MAXENTRY = 7*(NS*NLOC) + 5*NLOC - IA[NLOC] ;
  MAXENTRY2 = IA[NLOC]-1 ;
  _amub(&NLOC,&NLOC2,&IONE,AA,JA,IA,AP2,JP2,IP2,AA2,JA2,IA2,&MAXENTRY,IG,&IERR);
  if (IERR != 0) SLDIE("Error in amub1");
 _amub(&NLOC2,&NLOC,&IONE,AP3,JP3,IP3,AA2,JA2,IA2,AA,JA,IA,&MAXENTRY2,IG,&IERR);
  if (IERR != 0) SLDIE("Error in amub2");
 }
 for (j=0;j<NLOC2;++j) XX[j]= 0.;
 for ( i = 0 ; i < NLOC ; ++i ) {
    if (AA[ IA[i]-1 ]<0.0)  AA[ IA[i]-1 ] = fabs( (double) AA[ IA[i]-1 ] );
 }

 _amg1r5(AA,IA,JA,YY,XX,IG,
              &NDA,&NDIA,&NDJA,&NDU,&NDF,&NDIG,&NLOC2,&MATRIX,
              &ISWTCH,&IOUT,&IPRINT,
              &LEVELX,&IFIRST,&NCYC,&EPS,&MADAPT,&NRD,&NSOLCO,&NRU,
              &ECG1,&ECG2,&EWT2,&NWT,&NTR,
              &IERR );
 if (IERR > 0) SLDIE("Error in AMG1R5 init");
}
/*----------------------------------------------------------------------*/
/* The four iteration parameters { TOL_BLK, MAX_ITER, RES_BLK, NUM_ITER }
   are one dimensional arrays of NEV+1 elements each.
   The first through NEV'th element of each array is associated with the
   component block.  The (NEV+1)'th element is associated with the overall
   block iteration.
*/

#define MAX_NEV 128

_F_REAL_8  r2all_Previous,r2all_Current,eta_Previous_In_Sqr,R8_Previous_Out;

#ifdef CHECK_RESIDUALS
_F_REAL_4  jacOr[2000000] ; // ok for up to 20x40x40 black oil
_F_REAL_8  rhsOr[100000] ;
#endif

void _slblk(
  _F_INTEGER * IP_GJAC,  /* input:  IPARS id of Jacobian      */
  _F_INTEGER * IP_GRES,  /* input:  IPARS id of Residual      */
  _F_INTEGER * IP_GSOL,  /* in/out: IPARS id of 'GXDELTA'     */
  _F_REAL_4  * RES,      /* in/out: Convergence/actual residual ratio */
  _F_REAL_4  * ARES,     /* in/out: Absolute Convergence tolerance */
  _F_INTEGER * ITER,     /* in/out: Max/Actual iterations             */
  _F_INTEGER * INFO ,    /* output: Status of overall solve           */
  _F_INTEGER * IPRECPREP )/*input: IPARS id of preconditioned pressure block */
{
  const _F_INTEGER IZERO = 0 ;
  const _F_INTEGER IONE  = 1 ;
  const _F_REAL_8  ZERO  = 0.0 ;
  const _F_REAL_8  ONE   = 1.0 ;

  _F_INTEGER NBLK ;
  _F_INTEGER NEV ;
  _F_INTEGER NS ;
  _F_INTEGER NLOC ;
  _F_INTEGER NALL ;

  _F_REAL_8 * VSOL ;
  _F_REAL_8 * VRES ;
  _F_REAL_8 * WORK ;
  _F_REAL_4 * RNORM ;
  _F_REAL_4   RNORM_MIN = 0.0 ;

  _F_INTEGER fnunit = 0 ;
  _F_INTEGER imatvec[4] ;
  _F_INTEGER igdsum = 0 ;
  _F_INTEGER iprecon = 0 ;
  int i , j ;

  /*------------------------------------------------------------------*/
  /* Qin Lu, get the current model number */ 
  current_model = _get_currentmodel();

  NBLK = solve_data->nblk ;
  NEV  = solve_data->nev ;
  NS   = solve_data->ns ;
  NLOC = solve_data->nloc ;
  NALL = NLOC * NEV ;

  VSOL  = solve_data->sol ;
  VRES  = solve_data->res ;
  WORK  = solve_data->work ;
  RNORM = solve_data->rnorm ;
  /*------------------------------------------------------------------*/

#ifdef DEBUGGING
  _slmsgunit( &fnunit );
  SLMSGLINE ;
  SLMSG("SLSOLVE BEGIN");
  if ( memcmp( solve_data_backup , solve_data , solve_data_size ) ) {
    SLDIE("SLSOLVE DATA Corrupted!");
  }
#endif

  /*------------------------------------------------------------------*/
  /* Obtain pointers to IPARS arrays */

  solve_data->idgjac = *IP_GJAC ;
  solve_data->idgres = *IP_GRES ;
  solve_data->idgsol = *IP_GSOL ;

  for ( i = 0 ; i < NBLK ; ++i ) {
    solve_data->blk[i].gjac = NULL ;
    solve_data->blk[i].gres = NULL ;
    solve_data->blk[i].gsol = NULL ;
  }

  {
    _F_INTEGER callworkdata[4] ;
#ifdef DEBUGGING
    _F_REAL_8 r1 , r2 ;

    AJACNORM = 0 ;
#endif
    callworkdata[0] = 3 ;
    callworkdata[1] = *IP_GJAC ;
    callworkdata[2] = *IP_GRES ;
    callworkdata[3] = *IP_GSOL ;
    mycallwork( slptrwork , callworkdata );

#ifdef DEBUGGING
    {
      char buf[128] ;
      r1 = AJACNORM ;

      _gr8sum( &igdsum, &IONE, &r1, &r2 );

      r2 = sqrt( r2 );
      sprintf(buf,"JAC-NORM = %.15g\n",r2);
      SLMSG(buf);
    }
#endif
  }

#ifdef DEBUGGING
  memcpy( solve_data_backup , solve_data , solve_data_size );
#endif

  /*------------------------------------------------------------------*/
  /* Copy residual to a more compact vector */

  slgrid2vec( 1 , VRES , ONE , IZERO , NEV );

  /*------------------------------------------------------------------*/

#ifdef DEBUGGING

  /*------------------------------------------------------------------*/
  /* DEBUGGING: Test grid-2-vector */

  slvec2grid( 0 , VRES , ONE , IZERO , NEV );
  slgrid2vec( 0 , WORK , ONE , IZERO , NEV );

  for ( i = 0 ; i < NALL ; ++i ) {
    if ( WORK[i] != VRES[i] ) {
      char buf[128] ;
      sprintf(buf,"grid2vec->vec2grid failed\n");
      SLDIE(buf);
    }
  }

#endif

  /*------------------------------------------------------------------*/
  /* DEBUGGING: replace RHS with JAC * RHS */

#ifdef DEBUGGING_SOL

  {
    char buf[128] ;
    _F_REAL_8 r1all, r2all ;
    int ir ;
    r1all = r8dot(&NALL,VRES,&IONE,VRES,&IONE);
    _gr8sum( &igdsum, &IONE, &r1all, &r2all );
    r1all = sqrt( r1all );
    r2all = sqrt( r2all );
    sprintf(buf,"    Input RHS : %.15g [local] %.15g [global]",
       r1all,r2all);
    SLMSG(buf);
  }

  *RES  = 1.0e-15 ;
  *ARES = 1.0e-15 ;
  *ITER = 500 ;

  imatvec[0] = 1 ;
  imatvec[1] = NEV ;
  imatvec[2] = 1 ;
  imatvec[3] = NEV ;

  r8copy( &NALL, VRES, &IONE, VSOL, &IONE );
  slmatvec( imatvec , &ONE, VSOL, &ZERO, VRES );

  {
    char buf[128] ;
    _F_REAL_8 r1all, r2all ;
    int ir ;
    r1all = r8dot(&NALL,VRES,&IONE,VRES,&IONE);
    _gr8sum( &igdsum, &IONE, &r1all, &r2all );
    r1all = sqrt( r1all );
    r2all = sqrt( r2all );
    sprintf(buf,"    JAC * RHS : %.15g [local] %.15g [global]",
       r1all,r2all);
    SLMSG(buf);
  }

  SLMSG("  Debugging: replaced RHS with JAC * RHS");

#endif

  /* END DEBUGGING */
  /*------------------------------------------------------------------*/
  /* Input residual norms */

  {
    char buf[128] ;
    _F_REAL_8 r1[MAX_NEV], r2[MAX_NEV], r1all, r2all ;
    int ir ;
    r1all = r2all = 0.0 ;
    for ( ir = 0 ; ir < NEV ; ir++ )
      r1all += r1[ir] = r8dot(&NLOC,VRES+ir*NLOC,&IONE,VRES+ir*NLOC,&IONE);
    _gr8sum( &igdsum, &NEV, r1, r2 );
#ifdef DEBUGGING
    sprintf(buf,"  Input residuals");
    SLMSG(buf);
#endif
    for ( ir = 0 ; ir < NEV ; ir++ ) {
      r2all += r2[ir] ;
      r1[ir] = sqrt( r1[ir] );
      RNORM[ir] = sqrt( r2[ir] );
#ifdef DEBUGGING
      sprintf(buf,"    BLK #%d : %.10g [local] %.10g [global]",
        ir+1,r1[ir],RNORM[ir]);
      SLMSG(buf);
#endif
    }
    r1all = sqrt( r1all );
    r2all = sqrt( r2all );
    r2all_Current = r2all;
#ifdef DEBUGGING
    sprintf(buf,"    ALL    : %.10g [local] %.10g [global]",
       r1all,r2all);
    SLMSG(buf);
#endif
  }

  /*------------------------------------------------------------------*/
  /* Householder preconditioning of pressure block */

#ifdef DEBUGGING
  memcpy( solve_data_backup , solve_data , solve_data_size );
#endif

// Store the original jacobian
#ifdef CHECK_RESIDUALS
{
    char buf[128] ;
    int i; for ( i = 0 ; i < NALL ; i++ ) rhsOr[i] = VRES[i] ;
    store_jac( jacOr ); 
    sprintf(buf,"  Input residual  :  %.10g ", r2all_Current);
    SLMSG(buf);
}
#endif

  sldecouple( VRES );
//sldecouple_athos( VRES );
//sldecouple_impes( VRES ); 
//sldecouple_wallis( VRES ); 

//dilu(); 
//ilu0(); 


#ifdef CHECK_RESIDUALS
  {
    char buf[128] ;
    _F_REAL_8 r1[MAX_NEV], r2[MAX_NEV], r1all, r2all ;
    int ir ;
    r1all = r2all = 0.0 ;
    for ( ir = 0 ; ir < NEV ; ir++ )
      r1all += r1[ir] = r8dot(&NLOC,VRES+ir*NLOC,&IONE,VRES+ir*NLOC,&IONE);
    _gr8sum( &igdsum, &NEV, r1, r2 );
    sprintf(buf,"  Transformed residual");
    SLMSG(buf);
    for ( ir = 0 ; ir < NEV ; ir++ ) {
      r2all += r2[ir] ;
      r1[ir] = sqrt( r1[ir] );
      RNORM[ir] = sqrt( r2[ir] );
      sprintf(buf,"    BLK #%d : %.10g ", ir+1,RNORM[ir]);
      SLMSG(buf);
    }
    r2all = sqrt( r2all );
    sprintf(buf,"    ALL    : %.10g ", r2all);
    SLMSG(buf);
  }
#endif


#ifdef DEBUGGING
  if ( memcmp( solve_data_backup , solve_data , solve_data_size ) ) {
    SLDIE("SLSOLVE DATA Corrupted!");
  }
#endif

#ifdef DEBUGGING
  {
    char buf[128] ;
    _F_REAL_8 r1all, r2all ;
    int ir ;
    r1all = r8dot(&NALL,VRES,&IONE,VRES,&IONE);
    _gr8sum( &igdsum, &IONE, &r1all, &r2all );
    r1all = sqrt( r1all );
    r2all = sqrt( r2all );
    sprintf(buf,"    ALL'dec: %.15g [local] %.15g [global]",
       r1all,r2all);
    SLMSG(buf);
  }
#endif

  /*------------------------------------------------------------------*/
  /* Form the pressure preconditioner */

  {
    char buf[128] ;
#ifdef DEBUGGING
    strcpy(buf,"  PRESSURE PRECONDITIONER: ");
#endif
    switch( solve_data->pspec[0] ) {
    case SL_PREC_DIAG:     strcat(buf,"DIAGONAL"); break ;
    case SL_PREC_LINEJAC:  strcat(buf,"LINE JAC");   slpresslinefac(); break;
    case SL_PREC_LINEGS:   strcat(buf,"LINE G-S");   slpresslinefac(); break;
    case SL_PREC_LINESOR:  strcat(buf,"LINE SOR");   slpresslinefac(); break;
    case SL_PREC_SEPARABLE:strcat(buf,"SEPARABLE");  
                                      mycallwork(_precprep1,IPRECPREP ); break;
    case SL_PREC_FCTRZ:    strcat(buf,"FACTORIZATION"); 
                                      slpresslinefac(); slpressglobfac(); break;
    case SL_PREC_NEUPCG:   strcat(buf,"NEUMANN PCG");   slpresslinefac(); break;
    case SL_PREC_NEUPBCGS: strcat(buf,"NEUMANN PBCGS"); slpresslinefac(); break;
    case SL_PREC_NEUGMRES: strcat(buf,"NEUMANN GMRES"); slpresslinefac(); break;
    case SL_PREC_NEUSER:   strcat(buf,"NEUMANN SER");   slpresslinefac(); break;
    case SL_PREC_SEPAR_GS: strcat(buf,"SEPAR_GS ");  slpresslinefac(); 
                                      mycallwork(_precprep1,IPRECPREP ); break;
    case SL_PREC_SEPAR_UMS:strcat(buf,"SEPAR_UMS");  slpresslinefac(); 
                                      mycallwork(_precprep2,IPRECPREP ); break;
    case SL_PREC_MLILU:    strcat(buf,"MLILU"); 
                                   slpresslinefac();  initialisemlilu(); break;
    case SL_PREC_MLILU2:   strcat(buf,"MLILU"); 
                                   initialisemlilu2(); slpresslinefac(); break;
    case SL_PREC_AMG:      strcat(buf,"AMG"); 
                                    slpresslinefac();  slpressinitamg(); break;
    case SL_PREC_AMG2:     strcat(buf,"AMG"); 
                                   slpresslinefac();  slpressinitamg2(); break;
    default: strcat(buf,"UNKNOWN - TERMINATING"); SLDIE(buf);
    }
#ifdef DEBUGGING
    SLMSG(buf);
#endif
  }

  /*------------------------------------------------------------------*/
  /* Ready to solve full matrix */

  imatvec[0] = 1 ;
  imatvec[1] = NEV ;
  imatvec[2] = 1 ;
  imatvec[3] = NEV ;

#ifdef TIME_OF_ITERATIONS
  t1 = (double)clock() / CLOCKS_PER_SEC;
#endif

  /* Initial guess of zero */

  for ( j = 0 ; j < NALL ; ++j ) VSOL[j] = 0.0 ;

#ifdef DEBUGGIN
  if ( memcmp( solve_data_backup , solve_data , solve_data_size ) ) {
    SLDIE("SLSOLVE DATA Corrupted!");
  }
#endif


#ifdef EDWARDS_STOP_TEST
  RNORM_MIN = RNORM[0] ;
  for ( j = 1 ; j < NEV ; ++j )
    if ( RNORM[j] < RNORM_MIN ) RNORM_MIN = RNORM[j] ;
#else
  RNORM_MIN = r2all_Current ;
#endif
 
  if( *RES * RNORM_MIN < *ARES ) RNORM_MIN = *ARES / *RES;

  switch( solve_data->sspec[0] ) {
  case SL_SOLVE_GMRES:
  case SL_SOLVE_FGMRES:
    {
      const _F_INTEGER restart = solve_data->sspec[1] ;
      const _F_INTEGER MH      = restart + 1 ;
      const _F_INTEGER NH      = restart + 6 ;
            _F_INTEGER NWORK   = restart + 3 ;
            _F_REAL_8  R8      = *RES * RNORM_MIN ;
            _F_REAL_8  eta;  /* forcing term */
            

     if ( solve_data->sspec[0] == SL_SOLVE_FGMRES ) NWORK += restart+1 ;

     if (*ARES < 0.) /* in case of forcing term */
     {
      if (*INFO == -1)
       { eta = 0.5; }
      else
       {
         eta = fabs(r2all_Current-R8_Previous_Out)/r2all_Previous;
         if (eta < eta_Previous_In_Sqr) eta=eta_Previous_In_Sqr;
         if (eta > 0.9999) eta = 0.9999;
        }
      R8 = eta*r2all_Current;


      eta_Previous_In_Sqr = eta*eta;
      r2all_Previous = r2all_Current;

      R8 *= - *ARES ;
      /* |ARES| < 1 implies oversolving the linear system: 
         the number of total GMRES iterations
         grows as compared to pure forcing term (|ARES| = 1). BUT,
         a) the Newton is monotone ( we do not apply backtracking )
         b) the increase of GMRES is little compared to the decrease of Jacobian
            generations which also takes a while.
         Besides, it is necessary safe scaling of forcing term for SEPARABLE */
     }

     if ( solve_data->sspec[0] == SL_SOLVE_GMRES )
      _slgmres(
        _gr8sum,      &igdsum,
        slprecmainsol,IPRECPREP,
        slmatvec,      imatvec,
        WORK , &NALL, &NWORK,                  /* WORK(NALL,NWORK) */
        WORK + NALL * NWORK, &MH, &NH,         /* H(MH,NH) */
        &NALL, VRES , VSOL , ITER, &R8, INFO, &fnunit );

     if ( solve_data->sspec[0] == SL_SOLVE_FGMRES )
      _slfgmres(
        _gr8sum,      &igdsum,
        slprecmainsol,IPRECPREP,
        slmatvec,      imatvec,
        WORK , &NALL, &NWORK,                  /* WORK(NALL,NWORK) */
        WORK + NALL * NWORK, &MH, &NH,         /* H(MH,NH) */
        &NALL, VRES , VSOL , ITER, &R8, INFO, &fnunit );

      R8_Previous_Out = R8;

      *RES = R8 ;
    }
    break ;
  }

#ifdef TIME_OF_ITERATIONS
t2 = (double)clock() / CLOCKS_PER_SEC;
t3 += t2-t1; printf(" lin solver time: %f \n", t3);
#endif

#ifdef DEBUGGING
  if ( memcmp( solve_data_backup , solve_data , solve_data_size ) ) {
    SLDIE("SLSOLVE DATA Corrupted!");
  }
#endif

  /* Done iterating, converged or not.  Copy result to output grid. */

  slvec2grid( 0, VSOL, ONE, IZERO, NEV );

  slvec2grid( 1, VRES, ONE, IZERO, NEV );
  /*------------------------------------------------------------------*/
#ifdef CHECK_RESIDUALS
{
    char buf[256] ;
    _F_REAL_8 r1[MAX_NEV], r2[MAX_NEV], r2all ;
    int ir, i ;
    for ( i = 0 ; i < NALL ; i++ ) WORK[i] = -rhsOr[i] ;
    mul_jac( jacOr,  WORK  );
    r2all = 0.0 ;
    for ( ir = 0 ; ir < NEV ; ir++ ) {
      r1[ir] = r8dot(&NLOC,WORK+ir*NLOC,&IONE,WORK+ir*NLOC,&IONE);
    }
    _gr8sum( &igdsum, &NEV, r1, r2 );
    for ( ir = 0 ; ir < NEV ; ir++ ) {
      r2all  += r2[ir] ;
      r2[ir]     = sqrt( r2[ir] );
    }
    r2all = sqrt( r2all );
    sprintf(buf,"  Resulting true residual");
    SLMSG(buf);
    for ( ir = 0 ; ir < NEV ; ir++ ) {
      sprintf(buf, "    BLK #%d : %.10g ", ir+1,r2[ir]);
      SLMSG(buf);
    }
    sprintf(buf,"    ALL    : %.10g ", r2all);
    SLMSG(buf);
}
#endif
  /* Output residual & solution norms */

  {
    char buf[256] ;
    _F_REAL_8 r1[MAX_NEV*2], r2[MAX_NEV*2], r1all[2], r2all[2] ;
    _F_INTEGER NEV2 = NEV * 2 ;
    int ir ;
    r1all[0] = r2all[0] = 0.0 ;
    r1all[1] = r2all[1] = 0.0 ;
    for ( ir = 0 ; ir < NEV ; ir++ ) {
      r1all[0] += r1[ir]
        = r8dot(&NLOC,WORK+ir*NLOC,&IONE,WORK+ir*NLOC,&IONE);
      r1all[1] += r1[ir+NEV]
        = r8dot(&NLOC,VSOL+ir*NLOC,&IONE,VSOL+ir*NLOC,&IONE);
    }
    _gr8sum( &igdsum, &NEV2, r1, r2 );
    for ( ir = 0 ; ir < NEV ; ir++ ) {
      r2all[0]  += r2[ir] ;
      r2all[1]  += r2[NEV+ir] ;
      r1[ir]     = sqrt( r1[ir] );
      r1[ir+NEV] = sqrt( r1[ir+NEV] );
      r2[ir]     = sqrt( r2[ir] );
      r2[ir+NEV] = sqrt( r2[ir+NEV] );
    }
    r1all[0] = sqrt( r1all[0] );
    r1all[1] = sqrt( r1all[1] );
    r2all[0] = sqrt( r2all[0] );
    r2all[1] = sqrt( r2all[1] );
#ifdef DEBUGGING
    sprintf(buf,"  Resulting residuals");
    SLMSG(buf);
    for ( ir = 0 ; ir < NEV ; ir++ ) {
      sprintf(buf,
        "    BLK #%d : %.10g [local] %.10g [global]",
        ir+1,r1[ir],r2[ir]);
      SLMSG(buf);
    }
    sprintf(buf,"    ALL    : %.10g [local] %.10g [global]", r1all[0],r2all[0]);
    SLMSG(buf);
    sprintf(buf,"  Resulting solutions");
    SLMSG(buf);
    for ( ir = 0 ; ir < NEV ; ir++ ) {
      sprintf(buf,
       "    BLK #%d : %.10g [local] %.10g [global]",
        ir+1,r1[ir+NEV],r2[ir+NEV]);
      SLMSG(buf);
    }
    sprintf(buf,"    ALL    : %.10g [local] %.10g [global]", r1all[1],r2all[1]);
    SLMSG(buf);
#endif
  }

  /*------------------------------------------------------------------*/

#ifdef DEBUGGING_SOL

  /* Compare it to the cooked solution, the original residual */

  slgrid2vec( 1 , VRES , ONE , IZERO , NEV );

  {
    char buf[128];
    const _F_INTEGER ITWO = 2 ;
    _F_REAL_8 tmp[2] , tmp2[2] ;
    tmp[0] = tmp[1] = tmp2[0] = tmp2[1] = 0.0 ;
    for ( j = 0 ; j < NALL ; ++j ) {
      const double mag = VRES[j] ;
      const double err = VSOL[j] - VRES[j] ;
      tmp[0] += mag * mag ;
      tmp[1] += err * err ;
    }
    _gr8sum( NULL, &ITWO, tmp, tmp2 );
    tmp[0] = sqrt( tmp2[0] );
    tmp[1] = sqrt( tmp2[1] );
    sprintf(buf,"Debugging solution mag = %.15g, error = %.15g\n",
      tmp[0],tmp[1]);
    SLMSG(buf);
  }

  SLDIE("SLBLK - end debugging solution");
#endif

#ifdef DEBUGGING
  if ( memcmp( solve_data_backup , solve_data , solve_data_size ) ) {
    SLDIE("SLSOLVE DATA Corrupted!");
  }

  SLMSG("SLSOLVE END");
  SLMSGLINE ;
#endif
  return ;
}

/* -------  MultiModel extension -----------------------------------*/
#undef solve_data
/*------------------------------------------------------------------*/


