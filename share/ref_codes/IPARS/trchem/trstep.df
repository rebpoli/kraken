C  TRSTEP.F - MAKE ONE TIME STEP WITH THE 
C  FLOW - AND - TRANSPORT-CHEMISTRY TIME STEPPING EXECUTIVE ROUTINES

C  ROUTINES IN THIS MODULE:

C  SUBROUTINE TRSTEP   (NERR)

C  CODE HISTORY:

C M. PESZYNSKA, 8/00    INITIAL VERSION
C S. G. THOMAS  4/09    INITIAL VERSION USING ENHANCED VELOCITY METHOD
C              NOTE: MANY IMPROVEMENTS CAN BE MADE W.R.T THE FLOWMODEL 
C              VARIABLE, SHOULD BE BLOCK INDEXED AS IS ALREADY AVAILABLE 
C              VIA FMODBLK. ALSO CALLS TO L2PROJ_BC_EX(NC) AND TRBCINI_EX
C              (NC,NERR) FOR THE MORTAR CASE HAVE BEEN DELETED, LIKEWISE 
C              ALSO THE NSTEP=NSTEP-1 STATEMENT WHEN MORTAR_STEP IS DONE 
C              (MORTFLAG=1) AT START OF CONCENTRATION STEP. 
C G. SINGH     6/16  FULLY IMPLICIT REACTIVE FLOW AND TRANSPORT
C*********************************************************************
      SUBROUTINE TRSTEP (NERR)
C*********************************************************************

C  ROUTINE MAKES ONE TIME STEP FOR FLOW+TRANSPORT/CHEMISTRY
C  MULTIMODEL IN IPARS

C  NERR = ERROR NUMBER STEPED BY 1 ON ERROR (INPUT & OUTPUT, INTEGER)

C*********************************************************************
      IMPLICIT NONE

      INCLUDE 'control.h'
      INCLUDE 'trmodel.h'
      INCLUDE 'trarydat.h'
      INCLUDE 'wells.h'

      INTEGER NERR
      INTEGER NC, NR, NS_BAL, L
      INTEGER NBEM($MXMOD)
      INCLUDE 'blkary.h'
      REAL*8 CBALT, CBAL_S
      DATA NBEM/$MXMOD*0/

      NBEM($TMODEL)=3
      NBEM($HMODEL)=10
      NBEM($IMODEL)=32
$SINGLEI      IF(FLOWMODEL.EQ.$TMODEL.AND.MODELON($TMODEL)) THEN
$SINGLEI         NBEM($TRMODEL)=3
$SINGLEI      ENDIF
$HYDROI      IF(FLOWMODEL.EQ.$HMODEL.AND.MODELON($HMODEL)) THEN
$HYDROI         NBEM($TRMODEL)=10
$HYDROI      ENDIF
$BLACKI      IF(FLOWMODEL.EQ.$IMODEL.AND.MODELON($IMODEL)) THEN
$BLACKI         NBEM($TRMODEL)=32
$BLACKI      ENDIF

C --------------------------------------------------------------
C INITIALIZE MASS BALANCE VALUES : THIS COULD BE MOVED TO INITIALIZATION

      IF(NSTEP.EQ.1) THEN
         DO NC = 1, NSPECIES
            CBAL(NC) = 0.D0
            CIN(NC) = 0.D0
            COUT_DECAY(NC) = 0.D0
            DO NR = 1, NROCKTYPE
               CBAL_DECAY(NR, NC) = 0.D0
            ENDDO
         ENDDO
      ENDIF

      IF((NHISUSE == 0).AND.(NSTEP < 1)) GOTO 1203
C --------------------------------------------------------------
      FLOWTIM         = TIM
      FLOWTIM_NEW     = TIM + DELTIM

C      WRITE(*,*) 'FLOW MODEL ',FLOWMODEL,' FROM ',
C     & FLOWTIM,' TO ',FLOWTIM_NEW, ' TIM = ',TIM

C SAVE OR ZERO WELL RATES FROM FLOW

      CALL TRSAVEWELLS()

C PRECOMPUTE DARCY VELOCITIES AND SATURATIONS AT FLOWTIM

$SINGLEI$DUAL      MODACT=$TMODEL
$SINGLEI$DUAL      IF(FLOWMODEL.EQ.$TMODEL.AND.MODELON($TMODEL)) CALL TDUALS()
$HYDROI$DUAL       MODACT=$HMODEL
$HYDROI$DUAL      IF(FLOWMODEL.EQ.$HMODEL.AND.MODELON($HMODEL)) CALL HDUALS()
$MANY$DUAL         CALL PIFBUF8(NBEM,NERR)

$COMP         MODACT=$XMODEL
$COMP         IF(FLOWMODEL.EQ.$XMODEL)  CALL X2TR_PROP(OLD)
$CMFMFE       MODACT=$XMMODEL
$CMFMFE       IF(FLOWMODEL.EQ.$XMMODEL)  CALL X2TR_PROP(OLD)
$HYDROI       MODACT=$HMODEL
$HYDROI       IF(FLOWMODEL.EQ.$HMODEL)  CALL H2TR_PROP(OLD)
$SINGLEI      MODACT=$TMODEL
$SINGLEI      IF(FLOWMODEL.EQ.$TMODEL)  CALL T2TRVEL_EX(OLD)
$AIR          IF(FLOWMODEL.EQ.AIR) CALL A2TR_PROP(OLD)
      MODACT=$TRMODEL

C TAKE A FLOW STEP
 1203 CONTINUE
      IF(NSTEP.NE.1.AND.SKIP_FLOW) GOTO 1204
      CALL STEPIV3(NERR)
      IF((NHISUSE == 0).AND.(NSTEP < 1)) RETURN

 1204 CONTINUE

C COMPUTE DARCY VELOCITIES AND SATURATIONS AT FLOWTIM_NEW

$SINGLEI$DUAL      MODACT=$TMODEL
$SINGLEI$DUAL      IF(FLOWMODEL.EQ.$TMODEL.AND.MODELON($TMODEL)) CALL TDUALS()
$HYDROI$DUAL       MODACT=$HMODEL
$HYDROI$DUAL      IF(FLOWMODEL.EQ.$HMODEL.AND.MODELON($HMODEL)) CALL HDUALS()
$MANY$DUAL         CALL PIFBUF8(NBEM,NERR)

$COMP         MODACT=$XMODEL
$COMP         IF(FLOWMODEL.EQ.$XMODEL)  CALL X2TR_PROP(NEW)
$CMFMFE       MODACT=$XMMODEL
$CMFMFE       IF(FLOWMODEL.EQ.$XMMODEL)  CALL X2TR_PROP(NEW)
$HYDROI       MODACT=$HMODEL
$HYDROI       IF(FLOWMODEL.EQ.$HMODEL)  CALL H2TR_PROP(NEW)
$SINGLEI      MODACT=$TMODEL
$SINGLEI      IF(FLOWMODEL.EQ.$TMODEL)  CALL T2TRVEL_EX(NEW)
$AIR          IF(FLOWMODEL.EQ.AIR)   CALL  A2TR_PROP(NEW)
      MODACT=$TRMODEL

      CDELTIM = DELTIM / NCSTEP               

      IF(SKIP_FLOW.AND.ICSTEP.EQ.0)THEN
         CALL TRPHIS (NC,OLD)
         CALL TRPHIS (NC,NEW)
      ENDIF

C ====================================
C EXECUTE MULTIPLE CONCENTRATION STEPS

       DO ICSTEP = 1, NCSTEP

C INITIALIZE NEW CONCENTRATION STEP BALANCE VALUES 

         DO NC = 1, NSPECIES

            IF(NSTEP.EQ.1.AND.ICSTEP.EQ.1) THEN
               CBAL_NEW(NC) = 0.0D0

               CALL TRPHIS (NC,OLD)
               CALL TRCOMPBAL(NC,OLD)
               CBAL_ZERO(NC) = CBAL_NEW(NC)
            ENDIF

         ENDDO

C COMPUTE TIME IN THE MIDDLE OF CURRENT CONCENTRATION STEP         

         CONCTIM      = FLOWTIM + (ICSTEP -1)*CDELTIM
         CONCTIM_NEW  = CONCTIM + CDELTIM
         CONCTIM_HALF = CONCTIM + 0.5D0*CDELTIM
C --------------------------------------------------------------
C      WRITE(*,*) 'CONC MODEL ',MODEL,' FROM ',CONCTIM,' TO ',
C     &            CONCTIM_NEW,' TIM = ',TIM

C     UPDATE THE COMMUNICATION LAYER  
C     THIS MAKES SURE THAT THE CONCENTRATION HAVE CORRECT VALUES FOR
C     THE ADVECTION IN NEXT TRANSPORT TIME STEP.
$MANY      CALL TIMON(22)
$MANY      DO NC = 1, NSPECIES
$MANY        CALL UPDATE(N_CONCARR(NC),1)
$MANY      ENDDO
$MANY      CALL TIMOFF(22)

C -----------------------------------------------------------         
C          FULLY IMPLICIT REACTIVE FLOW AND TRANSPORT
C -----------------------------------------------------------
CGUS CURRENTLY ONLY FOR SINGLE PHASE FLOW
C
         IF (NO_OPSPLIT) THEN
             CALL TRFIM(NERR)
             GO TO 14
         ENDIF
         

C -----------------------------------------------------------           
C                       ADVECTION
C -----------------------------------------------------------
         IF (NO_ADV) GOTO 12       

C ADVECTION LOOP OVER MULTIPLE SPECIES
        
         DO NC = 1, NSPECIES
C  ONLY THE SPECIES IN FLOWING PHASE ARE ADVECTED
            IF (PHASETYPE(NC).EQ.1) THEN              
               
C COMPUTE PHASE WEIGHTED CAPACITIES FOR SPECIES NC AT CONCTIM ... 
               CALL TRPHIS (NC,OLD)
C                           ... AND AT CONCTIM_NEW
               CALL TRPHIS (NC,NEW)

C INTEGRATE VELOCITIES AT IN (CONCTIM, CONCTIM_NEW) FOR SPECIES NC
               CALL TRVEL(NC,MID)

C INTEGRATE WELL FLOW RATES IN (CONCTIM, CONCTIM_NEW) FOR SPECIES NC
               CALL TRCOMPWELLS(NC)

C SEND FAULT-BLOCK INTERFACIAL CONCENTRATIONS
$DUAL               CALL TRDUALS(NC,0)
$DUAL               NBEM($TRMODEL)=1
$MANY$DUAL               CALL PIFBUF8(NBEM,NERR)

C COMPUTE ELEMENT SLOPES FOR ADVECTION SCALAR VARIABLE FOR SPECIES NC

$MANY               CALL UPDATE(N_CONCARR(NC),1)
               IF(.NOT.TRNOFLXLMTR) THEN
                  CALL TRCSLP(NC)
$DUAL                  CALL TRDCSLP(NC)
$DUAL                  CALL TRDUALS(NC,1)
$DUAL                  NBEM($TRMODEL)=1
$MANY$DUAL                  CALL PIFBUF8(NBEM,NERR)
               ENDIF

C CALL ADVECTION ROUTINE
C               WRITE(*,*) 'ADVECT SPECIES ',NC,
C     &              ' FROM ',CONCTIM,' TO ',CONCTIM_NEW

               CALL TRADVECT (NC,NERR)
               
            ENDIF
         ENDDO

 12       CONTINUE

C -----------------------------------------------------------         
C                    CHEMICAL REACTION
C -----------------------------------------------------------

C    NPRODUCTS < 0:  MEANINGLESS
C    NPRODUCTS = 0:  NO CHEMICAL REACTION / ADSORPTION
C    NPRODUCTS > 0:  THERE IS CHEMICAL REACTION OR ADSORPTION

          IF (NPRODUCTS
$COMP$XREAC     &       +NXPRODUCTS
$CMFMFE$XREAC     &       +NXPRODUCTS
     &       .GT.0) THEN
             IF (INITIALCHEM) THEN
C     PERFORM THE INITIAL EQUILIBRIUM IF IT IS THE FIRST TIME TO CALL CHEM
C     NOTE:  INITIALCHEM IS DECLARED IN TRMODEL.DH AND IT IS INITIALIZED 
C     AS .TRUE. IN TRISDAT.DF
C     IT WILL BE PASSED BY COMMON BLOCK TO AND USED IN REACTONECELL(), 
C     WHICH WILL BE CALLED ULTIMATELY FROM TRX_STEP(NERR),
C     THUS IT CANNOT BE DECLARED AS THE LOCAL VARIABLE IN THIS ROUTINE
C      WRITE(*,*) " >>> INSIDE INITIAL CHEMISTRY "
                IF (NRQ
$COMP$XREAC     &             +NXRQ
$CMFMFE$XREAC     &             +NXRQ
     &             .GT.0) THEN
C      WRITE(*,*) " >>> PERFORM INITIAL CHEMISTRY "
                   CALL TRREACT(NERR)
                ENDIF
                INITIALCHEM = .FALSE.
             ENDIF
C      WRITE(*,*) " >>> PERFORM CHEMISTRY "
             CALL TRREACT(NERR)
          ELSE
C     WRITE(*,*) " <<< SKIP CHEMISTRY (AS NPRODUCTS<=0) "
          ENDIF
          
          
C     UPDATE THE COMMUNICATION LAYER AFTER ADVECTION AND CHEMICAL REACTION
$MANY      CALL TIMON(22)
$MANY      DO NC = 1, NSPECIES
$MANY        CALL UPDATE(N_CONCARR(NC),1)
$MANY      ENDDO
$MANY      CALL TIMOFF(22)

C -----------------------------------------------------------         
C                    DIFFUSION/DISPERSION
C -----------------------------------------------------------
   13    CONTINUE

         IF (NO_DISP) GOTO 14

C      WRITE(*,*) " >>>>>>>> PERFORM DISPERSION >>>>>>>>>> , NSPECIES=",
C     &            NSPECIES
         DO NC = 1, NSPECIES

C           ONLY THE SPECIES IN FLOWING PHASE ARE DIFF/DISP

            IF (PHASETYPE(NC).EQ.1) THEN

               CALL TRPHIS (NC,OLD)
               CALL TRPHIS (NC,NEW)
               CALL TRDIFFUSE(NC,NEW,NERR)

            ENDIF
         ENDDO
         
 14      CONTINUE


C CORRECT PLACEMENT FOR TWO-PHASE MODEL WOULD REQUIRE THAT 
C THE PHIS IS COMPUTED FOR EACH SPECIES

C -----------------------------------------------------------
C PERFORM BALANCE CALCULATIONS

         DO NC=1,NSPECIES

            CBAL_NEW(NC) = 0.D0

            CALL TRPHIS (NC,OLD)
            CALL TRPHIS (NC,NEW)
            CALL TRCOMPBAL(NC,NEW)
            CBAL(NC) = CBAL_NEW(NC)               

         ENDDO

$MANY            CALL TIMON(22)
$MANY            CALL SUMIT(NSPECIES, CBAL)
$MANY            IF(NSTEP.EQ.1.AND.ICSTEP.EQ.1) THEN
$MANY              CALL SUMIT(NSPECIES, CBAL_ZERO)
$MANY            ENDIF
$MANY            CALL TIMOFF(22)

C COMPUTE BALANCE CONTRIBUTIONS FROM BOUNDARY TERMS

         CALL TRBDBAL()

C REPORT OVERALL MASS BALANCE FOR EACH SPECIES

      IF(LEVELC) THEN
         IF (REPORT_BAL_ALL) THEN
           NS_BAL = NSPECIES
         ELSE 
           NS_BAL = 1
         ENDIF
         DO NC = 1, NS_BAL
            CBALT = 1.0D0 + 2.0D0 * 
     &       (CBAL(NC)-CBAL_ZERO(NC)-CIN(NC)+COUT_DECAY(NC))
     &       /(CBAL(NC)+CBAL_ZERO(NC))

            IF(DABS(CBAL(NC)+CBAL_ZERO(NC)).LT.1.0D-14)CBALT=0.0D0

            WRITE(*,100) ICSTEP, CONCTIM_NEW,NC,CBALT

            WRITE(*,*) "CBAL(NC)=", CBAL(NC), 
     &         " CBAL_ZERO(NC)=", CBAL_ZERO(NC),
     &         " CIN(NC)=", CIN(NC),
     &         " COUT_DECAY(NC)=", COUT_DECAY(NC)
         ENDDO
      ENDIF

 100  FORMAT(' CSTEP',I4,' TIME',E14.6,' BAL(',I2,')',F10.7,1X,F18.6)


C REPORT OVERALL MASS BALANCE FOR ALL SPECIES SUMMING TOGETHER

      IF(LEVELC) THEN
         IF(NSTEP.EQ.1.AND.ICSTEP.EQ.1) THEN
             CBAL_ZERO_S = 0.0D0
             DO NC = 1, NSPECIES
                CBAL_ZERO_S = CBAL_ZERO_S + 
     &                        CBAL_ZERO(NC)*MOLWEIGHT(NC)
             ENDDO
         ENDIF
         CBAL_S = 0.0D0
         DO NC = 1, NSPECIES
            CBAL_S = CBAL_S + 
     &        (CBAL(NC)-CIN(NC)+COUT_DECAY(NC))*MOLWEIGHT(NC)
         ENDDO
         CBALT = 1.0D0 + 2.0D0 *
     &       (CBAL_S-CBAL_ZERO_S) / (CBAL_S+CBAL_ZERO_S)
         IF(DABS(CBAL_S+CBAL_ZERO_S).LT.1.0D-14)CBALT=0.0D0
         WRITE(*,110) ICSTEP, CONCTIM_NEW,NC,CBALT
         WRITE(*,*) "CBAL_S=", CBAL_S,
     &         " CBAL_ZERO_S=", CBAL_ZERO_S
      ENDIF

 110  FORMAT(' CSTEP',I4,' TIME',E14.6,' BAL_SUM(',I2,')',
     &         F10.7,1X,F18.6)
C -----------------------------------------------------------


       ENDDO
C ==============================
C PRINT WELL OUTPUT

      CALL TRWELOUT()
      IF (REPORT_BD_FLUX) CALL TROUT_BDFLUX(NERR)

      END


C*********************************************************************
      SUBROUTINE STEPIV3 (NERR)
C*********************************************************************

C  ROUTINE MAKES ONE TIME STEP FOR FLOW MODEL COUPLED TO TRCHEM

C  NERR = ERROR NUMBER STEPED BY 1 ON ERROR (INPUT & OUTPUT, INTEGER)

C*********************************************************************
$POWER      INCLUDE 'msjunk.h' 

      INCLUDE 'control.h'
      INCLUDE 'blkary.h'
      INCLUDE 'wells.h'

      REAL*8 DUM
      INTEGER NBEM($MXMOD)
      CHARACTER*8 ERT
      DATA NBEM/$MXMOD*0/

      IF((NHISUSE == 0).AND.(NSTEP < 1)) GO TO 31

!      IF (MYPRC.EQ.0) THEN
!        WRITE(*,*)REPEAT('-',72)
!        WRITE(*,*)'Begin time step: NSTEP=',NSTEP
!        WRITE(*,*)'TIME=',TIM+DELTIM
!        WRITE(*,*)'DELTIM=',DELTIM
!        WRITE(*,*)'NCUT=',NCUT
!        WRITE(*,*)REPEAT('-',72)
!      ENDIF

      NCUT=0
      ERT='(MODEL)'
      NBEM($TMODEL)=3
      NBEM($HMODEL)=10
      NBEM($IMODEL)=32
$SINGLEI      IF(FLOWMODEL.EQ.$TMODEL.AND.MODELON($TMODEL)) THEN
$SINGLEI         NBEM($TRMODEL)=3
$SINGLEI      ENDIF
$HYDROI      IF(FLOWMODEL.EQ.$HMODEL.AND.MODELON($HMODEL)) THEN
$HYDROI         NBEM($TRMODEL)=10
$HYDROI      ENDIF
$BLACKI      IF(FLOWMODEL.EQ.$IMODEL.AND.MODELON($IMODEL)) THEN
$BLACKI         NBEM($TRMODEL)=32
$BLACKI      ENDIF

    7 NEWT=0
      ITLIN=0
      ITLINT=0

C  NEWTONIAN ITERATION LOOP
C  COMPUTE JACOBIAN AND RESIDUALS
C  START INTER-BLOCK DATA TRANSFER

    1 NEWT=NEWT+1

   31 CONTINUE

      IF (VMDEBUG) CALL PRINT_VM_INFO('Before STEP1')

$BLACKI      MODACT=$IMODEL
$BLACKI      IF (FLOWMODEL.EQ.$IMODEL) CALL ISTEP1(NERR)
$COMP      MODACT=$XMODEL
$COMP      IF (FLOWMODEL.EQ.$XMODEL) CALL XSTEP1(NERR)
$CMFMFE      MODACT=$XMMODEL
$CMFMFE      IF (FLOWMODEL.EQ.$XMMODEL) CALL XSTEP1(NERR)
$HYDROI      MODACT=$HMODEL
$HYDROI      IF (FLOWMODEL.EQ.$HMODEL) CALL HSTEP1(NERR)
$AHYDROI      MODACT=$HAMODEL
$AHYDROI      IF (FLOWMODEL.EQ.$HAMODEL) CALL HSTEP1(NERR)
$HIMFMFE      MODACT=$HMMODEL
$HIMFMFE      IF (FLOWMODEL.EQ.$HMMODEL) CALL HSTEP1(NERR)
$MMODEL      MODACT=$MMMODEL
$MMODEL      IF (FLOWMODEL.EQ.$MMMODEL) CALL MSTEP1(NERR)
$SINGLEI      MODACT=$TMODEL
$SINGLEI      IF (FLOWMODEL.EQ.$TMODEL) CALL TSTEP1(NERR)
$SIMFMFE      MODACT=$TMMODEL
$SIMFMFE      IF (FLOWMODEL.EQ.$TMMODEL) CALL TSTEP1(NERR)

      MODACT=$TRMODEL
      IF((NHISUSE == 0).AND.(NSTEP < 1)) GO TO 32
      IF (NERR.GT.0) GO TO 3


C  PASS INTERFACE BUFFERS FROM B BLOCK PROCESSOR TO A BLOCK PROCESSOR

$MANY$DUAL       IF(MODELON($XMODEL).OR.FLOWMODEL.EQ.$XMODEL) THEN
$MANY$DUAL          NBEM($XMODEL)=NBEMC($XMODEL)
$MANY$DUAL       ENDIF
$MANY$DUAL       IF(MODELON($XMMODEL).OR.FLOWMODEL.EQ.$XMMODEL) THEN
$MANY$DUAL          NBEM($XMMODEL)=NBEMC($XMMODEL)
$MANY$DUAL       ENDIF
$MANY$DUAL       CALL PIFBUF8(NBEM,NERR)

C  COLLECT INITIAL MASS DATA ON PROCESSOR 0 THEN DISTRIBUTE IT

$MANY      IF (NEWT.EQ.1.AND.TIM.EQ.0.D0) THEN
$MANY         CALL SUMIT($MXNUMEQ*$MXMOD,BALANCE(1,1,4))
$MANY         CALL SPREAD8($MXNUMEQ*$MXMOD,BALANCE(1,1,4))
$MANY      ENDIF

C  CONTINUE TIME STEP
C  COMPLETE INTER-BLOCK JACOBIAN/RESIDUAL CALCULATIONS
C  CHECK NEWTONIAN CONVERGENCE

   32 CONTINUE

      KONVG=1
      KV=1

      IF (VMDEBUG) CALL PRINT_VM_INFO('Before STEP2')

$BLACKI      MODACT=$IMODEL
$BLACKI      IF (FLOWMODEL.EQ.$IMODEL) CALL ISTEP2(KV,NERR)
$BLACKI      KONVG=MAX(KONVG,KV)

$COMP      MODACT=$XMODEL
$COMP      IF (FLOWMODEL.EQ.$XMODEL) CALL XSTEP2(KV,NERR)
$COMP      KONVG=MAX(KONVG,KV)

$CMFMFE      MODACT=$XMMODEL
$CMFMFE      IF (FLOWMODEL.EQ.$XMMODEL) CALL XSTEP2(KV,NERR)
$CMFMFE      KONVG=MAX(KONVG,KV)

$HYDROI      MODACT=$HMODEL
$HYDROI      IF (FLOWMODEL.EQ.$HMODEL) CALL HSTEP2(KV,NERR)
$HYDROI      KONVG=MAX(KONVG,KV)

$AHYDROI      MODACT=$HAMODEL
$AHYDROI      IF (FLOWMODEL.EQ.$HAMODEL) CALL HSTEP2(KV,NERR)
$AHYDROI      KONVG=MAX(KONVG,KV)

$HIMFMFE      MODACT=$HMMODEL
$HIMFMFE      IF (FLOWMODEL.EQ.$HMMODEL)) CALL HSTEP2(KV,NERR)
$HIMFMFE      KONVG=MAX(KONVG,KV)

$MMODEL      MODACT=$MMMODEL
$MMODEL      IF (FLOWMODEL.EQ.$MMMODEL) CALL MSTEP2(KV,NERR)
$MMODEL      KONVG=MAX(KONVG,KV)

$SINGLEI      MODACT=$TMODEL
$SINGLEI      IF (FLOWMODEL.EQ.$TMODEL) CALL TSTEP2(KV,NERR)
$SINGLEI      KONVG=MAX(KONVG,KV)

$SIMFMFE      MODACT=$TMMODEL
$SIMFMFE      IF (FLOWMODEL.EQ.$TMMODEL) CALL TSTEP2(KV,NERR)
$SIMFMFE      KONVG=MAX(KONVG,KV)
      MODACT=$TRMODEL

      IF((NHISUSE == 0).AND.(NSTEP < 1)) GO TO 2

C  KONVG = NEWTONIAN CONVERGENCE FLAG
C        = 1 ==> CONVERGED
C        = 2 ==> CONTINUE ITERATION
C        = 3 ==> FAILED
C        = 4 ==> CUT TIME STEP (SET BELOW ONLY BY THIS ROUTINE)

      IF (NEWT.GT.1) THEN
$MANY         DUM=KONVG
$MANY         CALL MAXIT(1,DUM)
$MANY         KONVG=DUM+.1D0
$MANY         CALL SPREAD(1,KONVG)
         IF (KONVG.EQ.1) GO TO 2
         IF (KONVG.EQ.3) THEN
            ERT='(NEWTON)'
            GO TO 3
         ENDIF
      ENDIF

C  SOLVE LINEAR SYSTEM
 
      CALL TIMON(9)

$MSOLL$LSOR      CALL LSOR(ITLIN,NERR)
$MSOLMG$MULGRD      CALL MULGRD(ITLIN,NERR)
$MSOLB$TICAMA      CALL TICAMA(ITLIN,NERR)
$MSOLG$GMRES      CALL GMRES(ITLIN,NERR)
$MSOLP$PCG      CALL PCG(ITLIN,NERR)
$HYPRE      CALL HYPRE_SOLVE(ITLIN,NERR)

      ITLINT=ITLINT+ITLIN
      CALL TIMOFF(9)
      IF (NERR.EQ.0) GO TO 2
      ERT='(LINEAR)'

C  STEP FAILED; CUT TIME STEP OR ABORT

    3 NCUT=NCUT+1

C      IF (NCUT.GT.2 .OR. (NCUT.EQ.1 .AND. DELTIM.LT..24D0*DTIMMAX
      IF (NCUT.GT.10 .OR. (NCUT.EQ.1 .AND. DELTIM.LT..01D0*DTIMMAX
     &    .AND. (.NOT.MODELON($XMODEL).AND.(FLOWMODEL.NE.$XMODEL))  
     &    .AND. (.NOT.MODELON($XMMODEL).AND.(FLOWMODEL.NE.$XMMODEL)))) 
     & THEN
         IF (KONVG.EQ.3) THEN
            NERR=NERR+1
            IF (LEVELC) THEN
               WRITE(NFOUT,4) NSTEP
               WRITE(*,4) NSTEP
            ENDIF
    4       FORMAT(' ERROR - NEWTONIAN ITERATION FAILURE AT STEP',I5)
         ELSE
            KONVG=3
            IF (LEVELC) THEN
               WRITE(NFOUT,5) NSTEP
               WRITE(*,5) NSTEP
            ENDIF
    5       FORMAT(' ERROR - LINEAR ITERATION FAILURE AT STEP',I5)
         ENDIF
         GO TO 2
      ENDIF

      DELTIM=.5001*DELTIM
      NERR=0
      KONVG=4
 
      IF (LEVELC) THEN
         WRITE(NFOUT,6) DELTIM,NSTEP,TIM,ERT
         WRITE(*,6) DELTIM,NSTEP,TIM,ERT
    6    FORMAT(' FLOW CUTTING TIME STEP TO',F9.4,' AT STEP',I5,
     &     '  TIME',F11.3,2X,A8)
      ENDIF

C  COMPLETE, CONTINUE, CUT, OR ABORT TIMESTEP

    2 CONTINUE
    
      IF (VMDEBUG) CALL PRINT_VM_INFO('Before STEP3')    

$BLACKI      MODACT=$IMODEL
$BLACKI      IF (FLOWMODEL.EQ.$IMODEL) CALL ISTEP3(KONVG,NERR)
$COMP      MODACT=$XMODEL
$COMP      IF (FLOWMODEL.EQ.$XMODEL) CALL XSTEP3(KONVG,NERR)
$CMFMFE      MODACT=$XMMODEL
$CMFMFE      IF (FLOWMODEL.EQ.$XMMODEL) CALL XSTEP3(KONVG,NERR)
$HYDROI      MODACT=$HMODEL
$HYDROI      IF (FLOWMODEL.EQ.$HMODEL) CALL HSTEP3(KONVG,NERR)
$AHYDROI      MODACT=$HAMODEL
$AHYDROI      IF (FLOWMODEL.EQ.$HAMODEL) CALL HSTEP3(KONVG,NERR)
$HIMFMFE      MODACT=$HMMODEL
$HIMFMFE      IF (FLOWMODEL.EQ.$HMMODEL) CALL HSTEP3(KONVG,NERR)
$MMODEL      MODACT=$MMMODEL
$MMODEL      IF (FLOWMODEL.EQ.$MMMODEL) CALL MSTEP3(KONVG,NERR)
$SINGLEI      MODACT=$TMODEL
$SINGLEI      IF (FLOWMODEL.EQ.$TMODEL) CALL TSTEP3(KONVG,NERR)
$SIMFMFE      MODACT=$TMMODEL
$SIMFMFE      IF (FLOWMODEL.EQ.$TMMODEL) CALL TSTEP3(KONVG,NERR)
      MODACT=$TRMODEL

      IF((NHISUSE == 0).AND.(NSTEP < 1)) RETURN

C  LOOP TO NEXT NEWTONIAN ITERATION OR RESTART TIME STEP

      IF (NERR.EQ.0) THEN
         IF (KONVG.EQ.2) GO TO 1
         IF (KONVG.EQ.4) GO TO 7
      ENDIF

C  COMPUTE BALANCES

$MANY      CALL SUMIT(3*$MXNUMEQ*$MXMOD,BALANCE(1,1,1))

      ITLINR=ITLINR+ITLINT
      ITNEWTR=ITNEWTR+NEWT-1
      NSTEPR=NSTEPR+1

      IF (MYPRC.EQ.0) THEN

         N=0
         DO 8 I=1,$MXMOD
         IF (FLOWMODEL.EQ.I) THEN
            N=N+1
            DO 9 J=1,MODEQS(I)

            BALANCE(J,I,5)=BALANCE(J,I,5)+BALANCE(J,I,2)
            BALANCE(J,I,6)=BALANCE(J,I,6)+BALANCE(J,I,3)
            DUM=BALANCE(J,I,1)+BALANCE(J,I,4)
            IF (DUM.NE.0.D0) THEN

               BALANCE(J,I,8)=1.D0+2.D0*(BALANCE(J,I,1)-BALANCE(J,I,4)
     &         -BALANCE(J,I,5)+BALANCE(J,I,6)-BALANCE(J,I,7))/DUM
            ELSE
               BALANCE(J,I,8)=1.D0
            ENDIF

            IF (BUGKEY(5)) WRITE(NFOUT,15) NSTEP,I,J,BALANCE(J,I,1),
     &         BALANCE(J,I,4),BALANCE(J,I,1)-BALANCE(J,I,4),
     &         BALANCE(J,I,5),BALANCE(J,I,6),BALANCE(J,I,2),
     &         BALANCE(J,I,3),BALANCE(J,I,7),BALANCE(J,I,8)
   15       FORMAT(' STEP',I6,' MODEL',I3,' EQS.',I2,' CURRENT',
     &         G17.10,' INITIAL',G17.10/' ACCUM.',G17.10,
     &         ' CUM. INJ.',G17.10,' CUM. TRANS.',G17.10/
     &         ' STEP INJ.',G17.10,' STEP TRANS.',G17.10,
     &         ' BC FLUX',G17.10,' BAL.',G17.10)

    9       CONTINUE

            IF (LEVELC) THEN
               MM=MODEQS(I)
               IF (MM.GT.3) MM=3
               IF (N.EQ.1) THEN
                  IF (TIM.LT.999.D0) THEN
                     WRITE(*,10) NSTEP,TIM+DELTIM,NEWT-1,ITLINT,I,
     &                  (BALANCE(J,I,8),J=1,MM)
   10                FORMAT(1P,' STEP',I6,' TIME',G11.4,' NEWT',I3,
     &                 ' LIN',I4,' MODEL',I3,' BAL ',0P,3F10.7)
                  ELSE
                     WRITE(*,14) NSTEP,TIM+DELTIM,NEWT-1,ITLINT,I,
     &                  (BALANCE(J,I,8),J=1,MM)
   14                FORMAT(1P,' STEP',I8,' TIME',G11.4,' NEWT',I3,
     &                 ' LIN',I4,' MODEL',I3,' BAL ',0P,3F10.7)
                  ENDIF
               ELSE
                  WRITE(*,11) I,(BALANCE(J,I,8),J=1,MM)
   11             FORMAT(T38,' MODEL',I3,' BAL',3F10.7)
               ENDIF
               IF (MM.LT.MODEQS(I))
     &            WRITE(*,12) I,(BALANCE(J,I,8),J=4,MODEQS(I))
   12             FORMAT(T49,3F10.7)
            ENDIF
         ENDIF
    8    CONTINUE
      ENDIF
cgp dbg: after printing step summary
c         PAUSE

      END
