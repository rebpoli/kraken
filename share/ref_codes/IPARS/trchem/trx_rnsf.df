      SUBROUTINE CONSTR(G,X,NCOMP,NMIN,EPSCONC,MININDEX)

      IMPLICIT NONE

C     COMMON AREAS FOR NIPS 

      INTEGER N,ME,MI,NEQ,NIPARAM,NRPARAM
      COMMON /NIPS_SIZES/N,ME,MI,NEQ,NIPARAM,NRPARAM

      INTEGER I,NCOMP,NMIN,MININDEX(NMIN)
      REAL*8 G(*),X(N),EPSCONC

      DO I = 1,NMIN
         G(I) = X(NCOMP+I) - EPSCONC
      ENDDO

      RETURN
      END
      
      SUBROUTINE JAC(MATRIX,X,Z,G,NSPECIES,NCOMP,NRXN,NMIN,
     &     AA,BB,MU0,MINLIST,MININDEX,IONPROD)

      IMPLICIT NONE
      INTRINSIC EXP

      INTEGER N,ME,MI,NEQ,NIPARAM,NRPARAM
      COMMON /NIPS_SIZES/N,ME,MI,NEQ,NIPARAM,NRPARAM 

      INTEGER I,J,K,NCOMP,NSPECIES,NRXN,NMIN,ROWIND,
     &     MINLIST(NRXN),MININDEX(NMIN)

      REAL*8 MATRIX(NEQ,NEQ),X(N),G(*),Z(*),MU0(NSPECIES),BIGEXP,
     &     SMALLEXP,AA(NCOMP,NSPECIES),BB(NCOMP),IONPROD(NRXN),
     &     SUM,ZERO,ONE

      PARAMETER (ZERO = 0.0D0, ONE = 1.0D0, 
     &     BIGEXP = 50.0, SMALLEXP = -500.0)


C     EVALUATE THE SECONDARY UNKNOWNS (IONPROD)

      CALL MASSACTION(IONPROD,X,AA,MU0,MINLIST,NSPECIES,NCOMP,NRXN)

C ---------------------------------------------------------------
C     (NCOMP) ROWS CORRESPONDING TO MASS-BALANCE
C     THIS PART OF THE JACOBIAN IS SYMMETRIC.
C ---------------------------------------------------------------

C     DERIVATIVES W.R.T. FIRST (NCOMP) VARIABLES

      DO I = 1,NCOMP
         DO J = I,NCOMP
            SUM = ZERO
            DO K = 1,NRXN
               IF (MINLIST(K).NE.1) THEN
                  SUM = SUM + AA(I,NCOMP+K)*AA(J,NCOMP+K)*IONPROD(K)
               ENDIF
            ENDDO
            MATRIX(I,J) = SUM
         ENDDO
      ENDDO

      DO I = 1,NCOMP
         MATRIX(I,I) = MATRIX(I,I) + 
     &        EXP(DMIN1(BIGEXP, DMAX1(X(I),SMALLEXP)))
      ENDDO

      DO I = 2,NCOMP
         DO J = 1,I-1
            MATRIX(I,J) = MATRIX(J,I)
         ENDDO
      ENDDO


C     IF THIS IS THE UNCONSTRAINED CASE WE ARE DONE

      IF (MI.EQ.0) RETURN


C     DERIVATIVES W.R.T. SECOND SET OF (NMIN) VARIABLES

      DO I = 1,NCOMP
         DO J = 1,NMIN
            MATRIX(I,NCOMP+J) = AA(I,NCOMP+MININDEX(J))
         ENDDO
      ENDDO

C     DERIVATIVES W.R.T. THIRD SET OF (NMIN) VARIABLES

      DO I = 1,NCOMP
         DO J = 1,NMIN
            MATRIX(I,NCOMP+NMIN+J) = ZERO
         ENDDO
      ENDDO

C ---------------------------------------------------------------
C     (NMIN) ROWS CORRESPONDING TO THE OPTIMALITY OF MINERALS 
C ---------------------------------------------------------------

      ROWIND = NCOMP

C     DERIVATIVES W.R.T. FIRST (NCOMP) VARIABLES

      DO I = 1,NMIN
         DO J = 1,NCOMP
            MATRIX(ROWIND+I,J) = AA(J,NCOMP+MININDEX(I))
         ENDDO
      ENDDO

C     DERIVATIVES W.R.T. SECOND SET OF (NMIN) VARIABLES

      DO I = 1,NMIN
         DO J = 1,NMIN
            MATRIX(ROWIND+I,NCOMP+J) = ZERO
         ENDDO
      ENDDO

C     DERIVATIVES W.R.T. THIRD SET OF (NMIN) VARIABLES

      DO I = 1,NMIN
         DO J = 1,NMIN
            IF (I.EQ.J) THEN
               MATRIX(ROWIND+I,NCOMP+NMIN+J) = ONE
            ELSE
               MATRIX(ROWIND+I,NCOMP+NMIN+J) = ZERO
            ENDIF
         ENDDO
      ENDDO


C ---------------------------------------------------------------
C     (NMIN) ROWS CORRESPONDING TO COMPLEMENTARITY FOR MINERALS 
C ---------------------------------------------------------------

      ROWIND = NCOMP + NMIN

C     DERIVATIVES W.R.T. FIRST (NCOMP) VARIABLES

      DO I = 1,NMIN
         DO J = 1,NCOMP
            MATRIX(ROWIND+I,J) = ZERO
         ENDDO
      ENDDO

C     DERIVATIVES W.R.T. SECOND SET OF (NMIN) VARIABLES

      DO I = 1,NMIN
         DO J = 1,NMIN
            IF (I.EQ.J) THEN
               MATRIX(ROWIND+I,NCOMP+J) =  Z(I)
            ELSE
               MATRIX(ROWIND+I,NCOMP+J) =  ZERO
            ENDIF

         ENDDO
      ENDDO

C     DERIVATIVES W.R.T. THIRD SET OF (NMIN) VARIABLES

      DO I = 1,NMIN
         DO J = 1,NMIN
            IF (I.EQ.J) THEN
               MATRIX(ROWIND+I,NCOMP+NMIN+J) = G(I)
            ELSE
               MATRIX(ROWIND+I,NCOMP+NMIN+J) = ZERO
            ENDIF
         ENDDO
      ENDDO


      RETURN
      END	

      SUBROUTINE MASSACTION(IONPROD,X,AA,MU0,MINLIST,NSPECIES,
     &     NCOMP,NRXN)

      IMPLICIT NONE
      INTRINSIC EXP

      INTEGER NSPECIES,NCOMP,NRXN,MINLIST(NRXN),I,J
      REAL*8 IONPROD(NRXN),X(NCOMP),AA(NCOMP,NSPECIES),MU0(NSPECIES),
     &     SUM,BIGEXP,SMALLEXP
      PARAMETER (BIGEXP = 50.0, SMALLEXP = -500.0)

      DO I = 1,NRXN
         SUM = -MU0(NCOMP+I)
         DO J = 1,NCOMP
            SUM = SUM + AA(J,NCOMP+I)*X(J)
         ENDDO
         IF (MINLIST(I).EQ.0) THEN
            SUM = DMIN1(BIGEXP, DMAX1(SUM,SMALLEXP))
            IONPROD(I) = EXP(SUM)
         ELSE
            IONPROD(I) = SUM
         ENDIF
      ENDDO


      RETURN
      END
      
      SUBROUTINE RES(RESIDUAL,X,G,Z,MU,NSPECIES,NCOMP,NRXN,NMIN,
     &     AA,BB,MU0,MINLIST,MININDEX,IONPROD)

      IMPLICIT NONE
      INTRINSIC EXP

      INTEGER N,ME,MI,NEQ,NIPARAM,NRPARAM
      COMMON /NIPS_SIZES/N,ME,MI,NEQ,NIPARAM,NRPARAM 

      INTEGER I,J,NCOMP,NSPECIES,NRXN,NMIN,MINLIST(NRXN),IND,
cgp   In the case of NO minerals, NMIN=0 and MININDEX is a dummy
c     & MININDEX(NMIN)
     & MININDEX(*)

      REAL*8 RESIDUAL(NEQ),X(N),G(*),Z(*),MU,MU0(NSPECIES),
     &     AA(NCOMP,NSPECIES),BB(NCOMP),IONPROD(NRXN),SUM,
     &     BIGEXP,SMALLEXP

      PARAMETER (BIGEXP = 50.0, SMALLEXP = -500.0)

C     EVALUATE THE SECONDARY UNKNOWNS (IONPROD)

      CALL MASSACTION(IONPROD,X,AA,MU0,MINLIST,NSPECIES,NCOMP,NRXN)

C ---------------------------------------------------------------
C     MASS-BALANCES (NCOMP FIRST ENTRIES)
C ---------------------------------------------------------------

      DO J = 1,NCOMP
         SUM = -BB(J) + EXP(DMIN1(BIGEXP,DMAX1(X(J),SMALLEXP)))
         IND = 0
         DO I = 1, NRXN
            IF (MINLIST(I).EQ.1) THEN
               IND = IND + 1
               SUM = SUM + X(NCOMP+IND)*AA(J,NCOMP + I)
            ELSE
               SUM = SUM + IONPROD(I)*AA(J,NCOMP + I)
            ENDIF
         ENDDO
         RESIDUAL(J) = SUM
      ENDDO

C ---------------------------------------------------------------
C     OPTIMALITY CONDITIONS FOR MINERALS (NMIN ENTRIES)
C ---------------------------------------------------------------

      DO I = 1,NMIN
         RESIDUAL(NCOMP+I) = IONPROD(MININDEX(I)) + Z(I)
      ENDDO

C ---------------------------------------------------------------
C     COMPLEMENTARITY CONDITIONS FOR MINERALS (NMIN ENTRIES)
C ---------------------------------------------------------------

      DO I = 1,NMIN
         RESIDUAL(NCOMP+NMIN+I) = G(I)*Z(I) - MU
      ENDDO

C ---------------------------------------------------------------
C     REVERSE THE SIGN OF THE RESIDUAL FOR THE NEWTON STEP
C ---------------------------------------------------------------

      DO I = 1,NEQ
         RESIDUAL(I) = -RESIDUAL(I)
      ENDDO

      RETURN
      END	

C--------------------------------------------------------------------
C STOPTESTEVAL.F
C
C "STANDARD INTERFACE FOR EVALUATION OF STOPPING CRITERIA"
C--------------------------------------------------------------------
C
C INPUT 
C
C X                      INDEPENDENT VARIABLES
C IPARAM                 INTEGER PARAMETERS
C RPARAM                 REAL PARAMETERS
C
C OUTPUT:
C
C DESCRIPTION:
C 
C THIS ROUTINE SERVES THE FOLLOWING PURPOSES:
C
C (1) UNPACK INTEGER (IPARAM) AND REAL (RPARAM) PARAMETERS
C     NEEDED IN EVALUATION OF THE STOPPING CRITERIA FOR
C     A GIVEN APPLICATION.
C 
C (2) POSSIBLY ALLOCATE WORKSPACE (IF NECCESARY)
C
C (3) EVALUATE THE STOPPING CRITERION.
C     EITHER A USER-SUPPLIED ROUTINE IS CALLED FOR
C     THIS PURPOSE, OR ELSE A STANDARD TEST IS PERFORMED
C
C ---------------------------------------------------------------

      SUBROUTINE STOPTESTEVAL(RESIDUAL,X,Z,G,IPARAM,RPARAM,RWK,DIMRWK,
     &     IWK,DIMIWK,JOB,TOL,CONSTRAINTS,CONVERGED,ERROR)

      IMPLICIT NONE
      INTRINSIC SQRT

C     COMMON AREAS FOR NIPS 

      INTEGER N,ME,MI,NEQ,NIPARAM,NRPARAM
      COMMON /NIPS_SIZES/N,ME,MI,NEQ,NIPARAM,NRPARAM

C     PROBLEM-INDEPENDENT DECLARATIONS

      INTEGER DIMIWK,DIMRWK,IPARAM(NIPARAM),IWK(DIMIWK),JOB,I

cgp   To prevent out-of-bounds when using IPARAM array in the call
c     to STOPTEST, dummy variable in the case when there are NO minerals   
      INTEGER IDUM 

      REAL*8 RESIDUAL(NEQ),X(N),Z(*),G(*),RPARAM(NRPARAM),RWK(DIMRWK),
     &     ERROR,TOL,EPSCONC,ZERO,DNRM2

      LOGICAL CONVERGED,CONSTRAINTS

C     OTHER DECLARATIONS

      INTEGER NCOMP,NSPECIES,NRXN,NMIN,IP_MINLIST,IP_MININDEX,
     &     RP_AA,RP_B,RP_MU0

      PARAMETER (ZERO=0.0D0)

C --------------------------------------------------------------------
C     COMPUTE THE L-2 NORM OF THE RESIDUAL IN THE 
C     UNPERTURBED KKT-CONDITIONS.
C --------------------------------------------------------------------

      IF (CONSTRAINTS) THEN
         ERROR = ZERO
         DO I = 1,NEQ-MI
            ERROR = ERROR + RESIDUAL(I)**2
         ENDDO
         DO I = 1,MI
            ERROR = ERROR + (G(I)*Z(I))**2
         ENDDO
         ERROR = SQRT(ERROR)
      ELSE
         ERROR = DNRM2(NEQ,RESIDUAL,1)
      ENDIF

      IF (JOB.EQ.0) THEN

C --------------------------------------------------------------------
C     THIS IS THE DEFAULT BRANCH: STOPPING CRITERION 
C     IS BASED SOLELY ON THE L2-NORM OF THE ERROR.
C --------------------------------------------------------------------

         CONVERGED = ERROR.LE.TOL
         RETURN

      ELSE

C --------------------------------------------------------------------
C     THIS IS THE "PROBLEM-SPECIFIC" BRANCH.
C     GENERAL STOPPING CRITERIA THAT HAVE ACCESS TO 
C     ALL DATA PERTAINING TO THE PROBLEM ARE TESTED.
C     DATA IS FIRST UNPACKED AND THEN PASSED TO A SUITABLE
C     SUBROUTINE FOR THE PURPOSES OF CHECKING THE OPTIMALITY
C     OF THE CURRENT ITERATE.
C --------------------------------------------------------------------

C
C     INTEGER PARAMETERS
C
         NCOMP            = IPARAM(1) 
         NSPECIES         = IPARAM(2)
         NRXN             = NSPECIES - NCOMP
         NMIN             = IPARAM(3)
         IP_MINLIST       = 4
         IP_MININDEX      = IP_MINLIST + NRXN
C
C     REAL PARAMETERS
C
         EPSCONC = RPARAM(1)
         RP_AA   = 2
         RP_B    = RP_AA + NCOMP*NSPECIES
         RP_MU0  = RP_B + NCOMP

         
C ---------------------------------------------------------------
C     CALL SPECIFIC STOP-TEST EVALUATION
C ---------------------------------------------------------------

cgp   Ensuring we pass valid array pointer for IPARAM
         IF (NMIN.GT.0) THEN
            CALL STOPTEST(X,NSPECIES,NCOMP,NRXN,NMIN,RPARAM(RP_AA),
     &           RPARAM(RP_B),RPARAM(RP_MU0),IPARAM(IP_MINLIST),
     &           IPARAM(IP_MININDEX),RWK(1),EPSCONC,TOL,
     &           CONVERGED,CONSTRAINTS)
         ELSE
            CALL STOPTEST(X,NSPECIES,NCOMP,NRXN,NMIN,RPARAM(RP_AA),
     &           RPARAM(RP_B),RPARAM(RP_MU0),IPARAM(IP_MINLIST),
     &           IDUM,RWK(1),EPSCONC,TOL,
     &           CONVERGED,CONSTRAINTS)

         ENDIF
      ENDIF

      RETURN
      END


      SUBROUTINE CONSTREVAL(X,G,IPARAM,RPARAM,RWK,DIMRWK,IWK,DIMIWK)

      IMPLICIT NONE

C     COMMON AREAS FOR NIPS 

      INTEGER N,ME,MI,NEQ,NIPARAM,NRPARAM
      COMMON /NIPS_SIZES/N,ME,MI,NEQ,NIPARAM,NRPARAM

C     PROBLEM-INDEPENDENT DECLARATIONS

      INTEGER DIMIWK,DIMRWK,IPARAM(NIPARAM),IWK(DIMIWK)
      REAL*8 X(N),G(*),RPARAM(NRPARAM),RWK(DIMRWK)

C     OTHER DECLARATIONS

      INTEGER NCOMP,NSPECIES,NRXN,NMIN,IP_MINLIST,IP_MININDEX,
     &     RP_AA,RP_B,RP_MU0

      REAL*8 EPSCONC

C ---------------------------------------------------------------
C     UNPACK PARAMETERS
C ---------------------------------------------------------------

C     INTEGER PARAMETERS

      NCOMP            = IPARAM(1) 
      NSPECIES         = IPARAM(2)
      NRXN             = NSPECIES - NCOMP
      NMIN             = IPARAM(3)
      IP_MINLIST       = 4
      IP_MININDEX      = IP_MINLIST + NRXN

C     REAL PARAMETERS

      EPSCONC = RPARAM(1)
      RP_AA   = 2
      RP_B    = RP_AA + NCOMP*NSPECIES
      RP_MU0  = RP_B + NCOMP

C ---------------------------------------------------------------
C     CALL FUNCTION FOR CONSTRAINT EVALUATION
C ---------------------------------------------------------------

cgp   Do only if there are minerals
      IF (NMIN.GT.0) 
     &    CALL CONSTR(G,X,NCOMP,NMIN,EPSCONC,IPARAM(IP_MININDEX))

      RETURN 
      END




      SUBROUTINE JACEVAL(MATRIX,X,Z,G,IPARAM,RPARAM,
     &     RWK,DIMRWK,IWK,DIMIWK)

      IMPLICIT NONE

C     COMMON AREAS FOR NIPS 

      INTEGER N,ME,MI,NEQ,NIPARAM,NRPARAM
      COMMON /NIPS_SIZES/N,ME,MI,NEQ,NIPARAM,NRPARAM

C     PROBLEM-INDEPENDENT DECLARATIONS

      INTEGER DIMIWK,DIMRWK,IPARAM(NIPARAM),IWK(DIMIWK)
      REAL*8 MATRIX(NEQ,NEQ),X(N),G(*),Z(*),RPARAM(NRPARAM),
     &     RWK(DIMRWK)

cgp   To prevent out-of-bounds when using IPARAM array in the call
c     to RES, dummy variable in the case when there are NO minerals   
      INTEGER IDUM 

C     OTHER DECLARATIONS

      INTEGER NCOMP,NSPECIES,NRXN,NMIN,IP_MINLIST,IP_MININDEX,
     &     RP_AA,RP_B,RP_MU0

      REAL*8 EPSCONC

C ---------------------------------------------------------------
C     UNPACK PARAMETERS
C ---------------------------------------------------------------

C
C     INTEGER PARAMETERS
C
      NCOMP            = IPARAM(1) 
      NSPECIES         = IPARAM(2)
      NRXN             = NSPECIES - NCOMP
      NMIN             = IPARAM(3)
      IP_MINLIST       = 4
      IP_MININDEX      = IP_MINLIST + NRXN
C
C
C     REAL PARAMETERS
C
      EPSCONC = RPARAM(1)
      RP_AA   = 2
      RP_B    = RP_AA + NCOMP*NSPECIES
      RP_MU0  = RP_B + NCOMP


C ---------------------------------------------------------------
C     CALL FUNCTION FOR JACOBIAN EVALUATION
C ---------------------------------------------------------------

cgp   Ensuring we pass valid array pointer for IPARAM
      IF (NMIN.GT.0) THEN
         CALL JAC(MATRIX,X,Z,G,NSPECIES,NCOMP,NRXN,NMIN,
     &        RPARAM(RP_AA),RPARAM(RP_B),RPARAM(RP_MU0),
     &        IPARAM(IP_MINLIST),IPARAM(IP_MININDEX),RWK(1))
      ELSE
         CALL JAC(MATRIX,X,Z,G,NSPECIES,NCOMP,NRXN,NMIN,
     &        RPARAM(RP_AA),RPARAM(RP_B),RPARAM(RP_MU0),
     &        IPARAM(IP_MINLIST),IDUM,RWK(1))

      ENDIF

      RETURN 
      END
C--------------------------------------------------------------------
C NLEQ.F
C
C  MAIN ROUTINE FOR THE NON-LINEAR EQUATIONS W/ CONSTRAINTS SOLVER
C  FOR THE CHEMISTRY PROBLEM (ENTRY POINT FOR CALLING ROUTINES)
C
C --------------------------------------------------------------------
C
      SUBROUTINE NLEQ(SOLUTION,IPARAM,RPARAM,IWK,NIWK,RWK,NRWK,
     &     RELTOL,ALPHA,TAUMIN,RHO,MAXITER,NVIOL,SCALEFLAG,
     &     INTERPFLAG,VERBOSITY,OUTUNIT,ITER,RETURNFLAG)

      IMPLICIT NONE

      INTEGER N,ME,MI,NEQ,NIPARAM,NRPARAM
      COMMON /NIPS_SIZES/N,ME,MI,NEQ,NIPARAM,NRPARAM

      INTEGER NIWK,NRWK,IWK(NIWK),IPARAM(NIPARAM),ITER,
     &     VERBOSITY,OUTUNIT,RETURNFLAG,RP_RHS,RP_MATRIX,
     &     RP_G,RP_NEXT,RWK_SIZE,IP_NEXT,IWK_SIZE,
     &     MAXITER,NVIOL,SCALEFLAG,INTERPFLAG

      REAL*8 RELTOL,ALPHA,TAUMIN,RHO,SOLUTION(NEQ),RWK(NRWK),
     &     RPARAM(NRPARAM)

cgp   To prevent out-of-bounds when using SOLUTION array in the call
c     to NLEQDRIVER, use dummy variable in the case when ME and MI are zero
c     ME = Number of equality constraints, currently set to zero
c     MI = Number of inequality constraints
      REAL*8 RDUM

      LOGICAL INTERPOLATE,SCALING

C 	SHUYU DEBUG
C       WRITE(*,*) " OK IN NLEQ"
C        RETURN

      SCALING     = (SCALEFLAG.EQ.1)
      INTERPOLATE = (INTERPFLAG.EQ.1)

C--------------------------------------------------------------------     
C     ALLOCATE STORAGE
C--------------------------------------------------------------------     

C     /INTEGER WORK-SPACE/

      IP_NEXT = 1
      IWK_SIZE = NIWK - IP_NEXT + 1

C     /REAL WORK-SPACE/

      RP_G = 1
      RP_RHS = RP_G + MAX(MI,1)
      RP_MATRIX = RP_RHS + NEQ
      RP_NEXT =  RP_MATRIX + NEQ*NEQ
      RWK_SIZE = NRWK - RP_NEXT + 1

C--------------------------------------------------------------------     
C     ERROR TRAP
C--------------------------------------------------------------------   

      IF ((IWK_SIZE.LE.0).OR.(RWK_SIZE.LE.0)) GOTO 90
      IF (N.LE.0) GOTO 91

C--------------------------------------------------------------------     
C     CALL THE DRIVER
C-------------------------------------------------------------------- 

cgp   Ensuring we pass valid array pointer as second argument
      IF (N.LT.NEQ) THEN
         CALL NLEQDRIVER(SOLUTION(1),SOLUTION(1+N),RWK(RP_G),
     &        RWK(RP_MATRIX),RWK(RP_RHS),RELTOL,ALPHA,TAUMIN,RHO,
     &        MAXITER,NVIOL,INTERPOLATE,SCALING,IPARAM,RPARAM,
     &        IWK(IP_NEXT),IWK_SIZE,RWK(RP_NEXT),RWK_SIZE,VERBOSITY,
     &        OUTUNIT,ITER,RETURNFLAG)
      ELSE
         CALL NLEQDRIVER(SOLUTION(1),RDUM,RWK(RP_G),
     &        RWK(RP_MATRIX),RWK(RP_RHS),RELTOL,ALPHA,TAUMIN,RHO,
     &        MAXITER,NVIOL,INTERPOLATE,SCALING,IPARAM,RPARAM,
     &        IWK(IP_NEXT),IWK_SIZE,RWK(RP_NEXT),RWK_SIZE,VERBOSITY,
     &        OUTUNIT,ITER,RETURNFLAG)
      ENDIF
      GOTO 100

 90   WRITE(*,*)'OUT OF MEMORY IN NLEQ - STOP RUNNING'
      WRITE(*,*)'REQUIRED REAL WORKSPACE:',RP_NEXT
      WRITE(*,*)'AVAILABLE REAL WORKSPACE:',NRWK
      WRITE(*,*)'REQUIRED INTEGER WORKSPACE:',IP_NEXT
      WRITE(*,*)'AVAILABLE INTEGER WORKSPACE:',NIWK
      STOP
 91   WRITE(*,*)'MUST HAVE N >= 1 - STOP RUNNING'
      STOP
 92   WRITE(*,*)'MUST HAVE 1 =< ME =< N-1  - STOP RUNNING'
      STOP
 93   WRITE(*,*)'MUST HAVE MI >= 0 - STOP RUNNING'
      STOP

 100  RETURN
      END

      SUBROUTINE RESEVAL(RESIDUAL,X,G,Z,MU,IPARAM,RPARAM,
     &     RWK,DIMRWK,IWK,DIMIWK)

      IMPLICIT NONE

C     COMMON AREAS FOR NIPS 

      INTEGER N,ME,MI,NEQ,NIPARAM,NRPARAM
      COMMON /NIPS_SIZES/N,ME,MI,NEQ,NIPARAM,NRPARAM

C     PROBLEM-INDEPENDENT DECLARATIONS

      INTEGER DIMIWK,DIMRWK,IPARAM(NIPARAM),IWK(DIMIWK)

cgp   To prevent out-of-bounds when using IPARAM array in the call
c     to RES, dummy variable in the case when there are NO minerals   
      INTEGER IDUM 
     
      REAL*8 RESIDUAL(NEQ),X(N),G(*),Z(*),RPARAM(NRPARAM),
     &     RWK(DIMRWK),MU

C     OTHER DECLARATIONS

      INTEGER NCOMP,NSPECIES,NRXN,NMIN,IP_MINLIST,IP_MININDEX,
     &     RP_AA,RP_B,RP_MU0

      REAL*8 EPSCONC

C ---------------------------------------------------------------
C     UNPACK PARAMETERS
C ---------------------------------------------------------------

C     /INTEGER/

      NCOMP            = IPARAM(1) 
      NSPECIES         = IPARAM(2)
      NRXN             = NSPECIES - NCOMP
      NMIN             = IPARAM(3)
      IP_MINLIST       = 4
      IP_MININDEX      = IP_MINLIST + NRXN

C     /REAL/

      EPSCONC = RPARAM(1)
      RP_AA   = 2
      RP_B    = RP_AA + NCOMP*NSPECIES
      RP_MU0  = RP_B + NCOMP

C ---------------------------------------------------------------
C     CALL FUNCTION FOR RESIDUAL EVALUATION
C ---------------------------------------------------------------

cgp   Ensuring we pass valid array pointer for IPARAM
      IF (NMIN.GT.0) THEN
         CALL RES(RESIDUAL,X,G,Z,MU,NSPECIES,NCOMP,NRXN,NMIN,
     &        RPARAM(RP_AA),RPARAM(RP_B),RPARAM(RP_MU0),
     &        IPARAM(IP_MINLIST),IPARAM(IP_MININDEX),RWK(1))
      ELSE
         CALL RES(RESIDUAL,X,G,Z,MU,NSPECIES,NCOMP,NRXN,NMIN,
     &        RPARAM(RP_AA),RPARAM(RP_B),RPARAM(RP_MU0),
     &        IPARAM(IP_MINLIST),IDUM,RWK(1))

      ENDIF 
      RETURN 
      END
C--------------------------------------------------------------------
C DAMPING.F
C
C PERFORM DAMPING OF THE PERTURBED NEWTON STEP TO INSURE FEASIBILITY
C --------------------------------------------------------------------
C
C INPUTS:
C
C Z(MI)
C G(MI)
C
C INPUTS/OUTPUT:
C
C STEP(NEQ)                 PERTURBED NEWTON STEP ON INPUT
C                           ADJUSTED-LENGTH STEP ON OUTPUT
C
C DG(MI)                 WORK VECTOR
C
C OUTPUTS:
C
C ALPHA_HAT                 DAMPING FOR FEASIBILITY
C
C EXTERNAL ROUTINES:
C
C DDOT()                    BLAS-ROUTINE FOR DOT-PRODUCT
C DSCAL()                   BLAS-ROUTINE FOR SCALING A VECTOR
C
C ALGORITHM:
C
C FEASIBILITY
C 
C LET G+(I) = G_I[X(I)+ ALPHA*STEP_X(I)]
C AND Z+(I) = Z(I) + ALPHA*STEP_Z(I)
C
C ENSURE THAT THE CONDITIONS G+(I) >= 0 FOR I = 1,...,MI
C                            Z+(I) >= 0 FOR I = 1,...,MI
C
C
C THE LARGEST ALPHA SATISFYING THE ABOVE CONDITIONS IS DENOTED ALPHA_HAT
C SINCE ALPHA =< 1, WE TAKE  ALPHA_HAT = MIN(ALPHA_HAT,1)       
C
C --------------------------------------------------------------------
C  

      SUBROUTINE DAMPING(STEP,X,Z,G,DG,IPARAM,RPARAM,
     &     TAUMIN,ALPHA_HAT)

      IMPLICIT NONE

      INTEGER N,ME,MI,NEQ,NIPARAM,NRPARAM
      COMMON /NIPS_SIZES/N,ME,MI,NEQ,NIPARAM,NRPARAM
      
      INTEGER I,IND,IPARAM(NIPARAM)

      REAL*8 STEP(NEQ),G(*),DG(*),X(N),Z(*),RPARAM(NRPARAM),ALPHA_HAT,
     &     DOTPROD,TAU,TAUMIN,MINQ,Q,BIG,ONE,ZERO,ETA,DDOT

      PARAMETER (
     &     BIG = 1.0D20,
     &     ZERO = 0.0D0,
     &     ONE = 1.0D0,
     &     ETA = 1.0D2)

C --------------------------------------------------------------------
C     INITIALIZE
C --------------------------------------------------------------------

C     COMPUTE "APPROACH TO THE BOUNDARY" PARAMETER TAU

      DOTPROD = DDOT(MI,G,1,Z,1)
      TAU = DMAX1(TAUMIN, 1.0D0 - ETA*DOTPROD)

C --------------------------------------------------------------------     
C     FEASIBILITY
C --------------------------------------------------------------------
    
      ALPHA_HAT = ONE
      MINQ = BIG

C     CONSTRAINT VIOLATIONS 

      DO I = 1,MI
         IND = N - MI + I
         IF (G(I).LE.ZERO) THEN
            IF (STEP(IND).LE.ZERO) STEP(IND) = ZERO
         ELSE
            Q = STEP(IND)/G(I)
            MINQ = DMIN1(MINQ,Q)            
         ENDIF
      ENDDO

C     CONSTRAINTS ON INEQUALITY MULTIPLIERS

      DO I = 1,MI
         IND = N+I
         IF (Z(I).LE.ZERO) THEN
            IF (STEP(IND).LE.ZERO) STEP(IND) = ZERO
         ELSE
            Q = STEP(IND)/Z(I)
            MINQ = DMIN1(MINQ,Q)
         ENDIF
      ENDDO

      IF (MINQ.GE.ZERO) THEN
         ALPHA_HAT = ONE
      ELSE
         ALPHA_HAT = DMIN1(-TAU/MINQ,ONE)
      ENDIF

C --------------------------------------------------------------------     
C     EFFECT SCALING OF THE STEP
C --------------------------------------------------------------------     

      CALL DSCAL(NEQ,ALPHA_HAT,STEP,1)


      RETURN
      END	




C--------------------------------------------------------------------
C LNSRCH.F
C     
C BACKTRACKING LINESEARCH ALGORITHM, DESIGNED FOR THE NLEQ ARISING
C  IN THE INTERIOR-POINT METHOD.
C--------------------------------------------------------------------
C     
C INPUT:
C
C  DIRDER           DIRECTIONAL DERIVATIVE IN THE NEWTON-DIRECTION
C  ALPHA            PARAMETER FOR ALPHA-CONDITION
C  INTERPOLATE      PARAMETER CONTROLLING THE TYPE OF LINE-SEARCH
C  ONETRIP          IF .TRUE.  NO REDUCTION OF STEPLENGTH OCCURS
C                   OF .FALSE. A REGULAR LINESEARCH IS PERFORMED
C
C
C INPUT/OUTPUT:
C
C X,Z,G             ON CALL: CURRENT ITERATES
C                   ON RETURN: NEW ITERATES FROM LINE-SEARCH 
C
C RESIDUAL          ON CALL:    DAMPED NEWTON-STEP
C                   ON RETURN : RESIDUALS AT THE NEW POINT
C
C COST              ON CALL: CURRENT VALUE OF MERITFUNCTION
C                   ON RETURN : NEW VALUE OF MERITFUNCTION
C
C OUTPUT:
C 
C RETCODE           ERROR (1) OR SUCCESFUL COMPLETION (0)
C
C ALGORITHM:
C     
C BACK-TRACKING ALONG NEWTON (DESCENT) DIRECTION.
C FOR DETAILS, SEE DENNIS & SCHNABEL'S "NUMERICAL METHODS FOR
C UNCONSTRAINED OPTIMIZATION AND NONLINEAR EQUATIONS", PP. 325-326.
C 
C NOTE: IF FLAG INTERPOLATE = .TRUE. A QUADRATIC/CUBIC INTERPOLATION
C  METHOD IS USED (PP. 325-326 ABOVE). OTHERWISE, A SIMPLE REDUCTION
C  SCHEME OF THE FORM LAMBDA := LAMBDA*RHO IS USED WITH SOME RHO,
C  SATISFYING 0 < RHO < 1.
C--------------------------------------------------------------------


      SUBROUTINE LNSRCH(X,Z,MU,RESIDUAL,G,XT,ZT,PNEWTON,
     &     IPARAM,RPARAM,RWK,DIMRWK,IWK,DIMIWK,COST,
     &     DIRDER,ALPHA,INTERPOLATE,LAMBDA,ONETRIP,RETCODE)


      IMPLICIT NONE
      INTRINSIC SQRT

      INTEGER N,ME,MI,NEQ,NIPARAM,NRPARAM
      COMMON /NIPS_SIZES/N,ME,MI,NEQ,NIPARAM,NRPARAM

      INTEGER RETCODE,MAXSTEP,ITER,I,IPARAM(NIPARAM),
     &     DIMIWK,DIMRWK,IWK(DIMIWK)


      REAL*8 X(N),XT(N),Z(*),ZT(*),G(*),MU,RPARAM(NRPARAM),
     &     RWK(DIMRWK),RESIDUAL(NEQ),PNEWTON(NEQ),ALPHA,DCOMPI,
     &     COST,COSTPLUS,LAMBDA,DIRDER,TERM1,TERM2,TERM3,A,B,DISCR,
     &     LAMBDATMP,PCOSTPLUS,PLAMBDA,UPPERB,LOWERB,RHO,DNRM2

      LOGICAL INTERPOLATE,ONETRIP,OKCOSTPLUS

      PARAMETER(
     &     MAXSTEP = 100,
     &     UPPERB = 0.5D0,
     &     LOWERB = 0.1D0,
     &     RHO = 0.5D0)

      ITER       = 1
      RETCODE    = 1
      LAMBDA     = 1.0D0

C------------------------------------------------------------------------
C     TOP OF LINE-SEARCH LOOP
C------------------------------------------------------------------------

      CALL DCOPY(NEQ,RESIDUAL,1,PNEWTON,1)     

C------------------------------------------------------------------------
C     COMPUTE NEW CANDIDATE POINT
C------------------------------------------------------------------------

 100  DO I = 1,NEQ
         DCOMPI = LAMBDA*PNEWTON(I)
         IF (I.LE.N) THEN
            XT(I) = X(I) + DCOMPI
         ELSEIF (I.GT.N .AND. I.LE. N+MI) THEN
            ZT(I-N-ME) = Z(I-N-ME) + DCOMPI
         ENDIF
      ENDDO

C------------------------------------------------------------------------
C     EVALUATE RESIDUALS AT THE NEW CANDIDATE POINT
C     AND COMPUTE THE VALUE OF THE MERIT FUNCTION
C------------------------------------------------------------------------

      
      CALL CONSTREVAL(XT,G,IPARAM,RPARAM,RWK(1),DIMRWK,IWK(1),DIMIWK)
      CALL RESEVAL(RESIDUAL,XT,G,ZT,MU,IPARAM,RPARAM,
     &     RWK(1),DIMRWK,IWK(1),DIMIWK)

      COSTPLUS   = DNRM2(NEQ,RESIDUAL,1)**2

C     THIS REPRESENTS AN UPPER LIMIT FOR HOW POOR A STEP WE 
C     WILL EVER ACCEPT. IT SERVES AS A SAFEGUARD. THE PARAMETER 
C     SELECTION IS AD-HOC.

      OKCOSTPLUS = (COSTPLUS.LE.1.0D3*COST)

C------------------------------------------------------------------------
C      DETERMINE IF ALPHA-CONDITION IS SATISFIED FOR THIS LAMBDA 
C------------------------------------------------------------------------

      IF (COSTPLUS .LE. (COST + DIRDER*ALPHA*LAMBDA)) THEN

C------------------------------------------------------------------------     
C     SOLUTION FOUND; ALGORITHM TERMINATES WITH OK FLAG
C------------------------------------------------------------------------  
 
         CALL DCOPY(N,XT,1,X,1)     
         CALL DCOPY(MI,ZT,1,Z,1)     
         COST = COSTPLUS
         RETCODE = 0
         RETURN

C------------------------------------------------------------------------          
C     RETURN WITH ERROR (NONSATISFACTION OF A-G COND) IN TWO CASES:
C
C     (1) WHEN ONLY ONE TRIP WAS PERMITTED (AND WE DON'T INCREASE TOO MUCH),
C             OR
C     (2) WHEN THE MAX NUMBER OF ITERATIONS IS EXCEEDED
C------------------------------------------------------------------------     

      ELSEIF ((ONETRIP.AND.OKCOSTPLUS).OR.(ITER.GT.MAXSTEP)) THEN

         CALL DCOPY(N,XT,1,X,1)     
         CALL DCOPY(MI,ZT,1,Z,1)     
         COST = COSTPLUS
         RETCODE = 1
         RETURN

      ELSE
C     
C       FIND NEW LAMBDA THROUGH BACK-TRACKING 
C     

         IF (INTERPOLATE) THEN

C------------------------------------------------------------------------
C     USE QUADRATIC/CUBIC INTERPOLATION  
C------------------------------------------------------------------------

            IF (ITER .EQ. 1) THEN
C     
C     FIRST BACKTRACK: USE QUADRATIC FIT
C     
               LAMBDATMP = -DIRDER/(2.0*(COSTPLUS-COST-DIRDER))

            ELSE
C     
C     ALL OTHER BACKTRACKS: USE QUBIC FIT
C     
               TERM1 = COSTPLUS - COST - DIRDER*LAMBDA
               TERM2 = PCOSTPLUS - COST - DIRDER*PLAMBDA
               TERM3 = 1.0D0/(LAMBDA-PLAMBDA)
               A = TERM3*(TERM1/LAMBDA**2 - TERM2/PLAMBDA**2)
               B = TERM3*(TERM2*LAMBDA/PLAMBDA**2 - 
     &              TERM1*PLAMBDA/LAMBDA**2)
               DISCR = B**2 - 3.0D0*A*DIRDER

               IF (DISCR .GT. B**2) THEN
C     
C     ONLY ONE POSITIVE CRITICAL POINT
C     
                  LAMBDATMP = (-B + SIGN(1.0D0,A)*
     &                 SQRT(DISCR))/(3.0D0*A)
               ELSE
C     
C     TWO POSITIVE CRITICAL POINTS, FIRST IS MINIMUM
C     
                  LAMBDATMP = (-B - SIGN(1.0D0,A)*
     &                 SQRT(DISCR))/(3.0D0*A)
               ENDIF
            ENDIF
C     
C     MAKE SURE NEW LAMBDA SATISFIES CONSTRAINTS 
C     
            IF (LAMBDATMP .GT. UPPERB*LAMBDA) THEN
               LAMBDATMP = LAMBDA*UPPERB
            ELSEIF (LAMBDATMP .LT. LOWERB*LAMBDA) THEN
               LAMBDATMP = LAMBDA*LOWERB
            ENDIF
            PLAMBDA = LAMBDA
            LAMBDA = LAMBDATMP
            PCOSTPLUS = COSTPLUS
            
            
         ELSE

C------------------------------------------------------------------------
C     USE SIMPLE REDUCTION OF STEPLENGTH
C------------------------------------------------------------------------

            LAMBDA = RHO * LAMBDA


         ENDIF

C     INCREASE ITERATION COUNTER AND PROCEED WITH NEXT ITERATION

         ITER = ITER + 1
         GOTO 100

      ENDIF

      RETURN
      END





C--------------------------------------------------------------------
C NLEQDRIVER.F
C
C NON-LINEAR EQUATIONS SOLVER MODIFIED TO INCLUDE INEQUALITY CONSTRAINT
C --------------------------------------------------------------------
C
C INPUTS/OUTPUTS:
C
C X(N)                ON CALL:  INITIAL GUESS FOR PRIMARY VARIABLES 
C Z(MI)                         NO GUESS FOR MULTIPLIERS
C
C                     ON RETURN: THE SOLUTION.
C     
C OUTPUTS:
C
C RETURNFLAG          INDICATES STATUS UPON COMPLETION
C                     0 - NORMAL COMPLETION
C                     1 - EXCEEDED MAXIMUM NUMBER OF ITERATIONS
C                     2 - EXCEEDED MAXIMUM NUMBER OF BACKTRACKS
C                     3 - ILL-CONDITIONING OF LINEAR SYSTEM 
C                         (NOT IMPLEMENTED)
C                     4 - INFEASIBLE INITIAL POINT
C
C BRIEF VARIABLE DEFINITIONS:
C
C X(N)                PRIMARY VARIABLES
C Z(MI)               LAGRANGE MULTIPLIERS CORRESPONDING TO THE 
C                     INEQUALITY CONSTRAINTS
C
C MATRIX(NEQ,NEQ)     HOLDS THE GENERALLY NON-SPARSE MATRIX RESULTING WHEN
C                     THE (PERTURBED) NEWTON METHOD IS APPLIED TO THE
C                     NON-LINEAR SYSTEM OF EQUATIONS + COMPLEMENTARITY
C
C RESIDUAL(NEQ)       HOLDS THE RIGHT-HAND SIDE THAT RESULTS IN THE
C                     PERTURBED NEWTON METHOD.
C
C
C EXTERNAL ROUTINES:
C
C >> USER-SUPPLIED
C
C RESIDUAL             
C JACOBIAN
C
C >> BLAS
C
C DNRM2                COMPUTE THE 2-NORM OF A VECTOR
C DCOPY                COPY VECTORS
C DGEMV                MATRIX/VECTOR MULTIPLICATION + UPDATE
C
C --------------------------------------------------------------------

      SUBROUTINE NLEQDRIVER(X,Z,G,MATRIX,RESIDUAL,TOL,ALPHA,TAUMIN,RHO,
     &     MAXITER,NVIOL,INTERPOLATE,SCALING,IPARAM,RPARAM,IWK,DIMIWK,
     &     RWK,DIMRWK,VERBOSITY,OUTUNIT,ITER,RETURNFLAG)

      IMPLICIT NONE
      INTRINSIC SQRT

      INTEGER N,ME,MI,NEQ,NIPARAM,NRPARAM
      COMMON /NIPS_SIZES/N,ME,MI,NEQ,NIPARAM,NRPARAM
      
      LOGICAL INTERPOLATE,SCALING,LNSRCHERROR,FEASIBLEIC,
     &     ONETRIP,CONVERGED,CONSTRAINTS

      INTEGER I,DIMIWK,DIMRWK,IWK_SIZE,RWK_SIZE,IP_NEXT,RP_GSTEP,RP_XT,
     &     RP_ZT,RP_STEP,RP_NEXT,IWK(DIMIWK),IPARAM(NIPARAM),VERBOSITY,
     &     OUTUNIT,RETURNFLAG,LFLAG,MAXITER,NVIOL,VIOLCTR,ITER,JOB

      REAL*8 X(N),Z(*),G(*),MATRIX(NEQ,NEQ),RESIDUAL(NEQ),
     &     DNRM2,DDOT,ERRORL2,RCOND,COST,ZERO,ONE,TOL,ALPHA,DIRDER,
     &     CC,RHO,MU0HI,MU0LO,Z0HI,Z0LO,SUM,MU,TAUMIN,
     &     RPARAM(NRPARAM),LAMBDA_LNSRCH,LAMBDA_DMP,RWK(DIMRWK)

      PARAMETER (ZERO = 0.0D0, ONE = 1.0D0,
     &     Z0HI = 1.0D-1, Z0LO = 1.0D-3, 
     &     MU0HI = 1.0D-3, MU0LO = 1.0D-6)

C --------------------------------------------------------------------
C     INITIALIZE STORAGE FOR THE DRIVER 
C --------------------------------------------------------------------

C      /REAL WORKSPACE/

      RP_GSTEP  = 1
      RP_XT     = RP_GSTEP + MAX(MI,1)
      RP_ZT     = RP_XT + N
      RP_STEP   = RP_ZT + MAX(MI,1)
      RP_NEXT   = RP_STEP + 4*NEQ
      RWK_SIZE  = DIMRWK - RP_NEXT + 1

      IF (RWK_SIZE.LE.0) THEN
         WRITE(*,*)'OUT OF REAL MEMORY IN NLEQ DRIVER'
         STOP
      ENDIF

C     /INTEGER WORKSPACE/

      IP_NEXT = 1
      IWK_SIZE = DIMIWK - IP_NEXT + 1

      IF (IWK_SIZE.LE.0) THEN
         WRITE(*,*)'OUT OF INTEGER MEMORY IN NLEQ DRIVER'
         STOP
      ENDIF

C --------------------------------------------------------------------
C     INITIALIZE
C --------------------------------------------------------------------

      VIOLCTR = 0
      LNSRCHERROR = .FALSE.
      ITER = 0
      CONSTRAINTS = (MI.NE.0)
      
      IF (CONSTRAINTS) THEN

         JOB = 0

C     EVALUATE CONSTRAINTS
         
         CALL CONSTREVAL(X,G,IPARAM,RPARAM,RWK(RP_NEXT),
     &        RWK_SIZE,IWK(IP_NEXT),IWK_SIZE)
         
C     CHECK THE FEASIBILITY OF THE INITIAL POINT
         
         FEASIBLEIC = .TRUE.
         DO I = 1,MI
            FEASIBLEIC = (G(I).GT.ZERO.AND.FEASIBLEIC)
         ENDDO

         IF (.NOT.FEASIBLEIC) THEN
            RETURNFLAG = 4
            RETURN
         ENDIF

C     SELECT A GUESS FOR THE MULTIPLIERS AND INITIAL PERTURBATION,
C     USING COMPLEMENTARITY CONDITION. THIS IS HEURISTIC. 

         DO I = 1,MI
            Z(I) = DMIN1(Z0HI, DMAX1(Z0LO, 1.0/G(I)))
         ENDDO

         MU  = DDOT(MI, G(1), 1, Z(1), 1)
         MU  = DMIN1(MU0HI, DMAX1(MU0LO, MU))

      ELSE

         MU  = ZERO
         JOB = 1

      ENDIF

C     EVALUATE RESIDUALS AT (X0,Z0)

      CALL RESEVAL(RESIDUAL,X,G,Z,MU,IPARAM,RPARAM,RWK(RP_NEXT),
     &     RWK_SIZE,IWK(IP_NEXT),IWK_SIZE)


C ---------------------------------------------------------------- 
C     CHECK ERROR AT INITIAL POINT
C     RETURN QUICKLY IF POSSIBLE
C ---------------------------------------------------------------- 

      CALL STOPTESTEVAL(RESIDUAL,X,Z,G,IPARAM,RPARAM,RWK(RP_NEXT),
     &     RWK_SIZE,IWK(IP_NEXT),IWK_SIZE,1,TOL,CONSTRAINTS,
     &     CONVERGED,ERRORL2)

      IF (CONVERGED) THEN
         IF (VERBOSITY.GT.0) WRITE(OUTUNIT,975)
         RETURNFLAG = 0
         ITER = 0
         RETURN
      ENDIF

      IF (VERBOSITY.GT.0) WRITE(OUTUNIT,972) ERRORL2

      IF (VERBOSITY.EQ.1) THEN
         WRITE(OUTUNIT,900)
      ELSEIF (VERBOSITY.GE.2) THEN
         WRITE(OUTUNIT,950)
      ENDIF


C ----------------------------------------------------------------      
C     TOP OF THE MAIN LOOP
C ---------------------------------------------------------------       

 100  IF (.NOT.(CONVERGED).AND.(ITER.LE.MAXITER).AND. 
     &     .NOT.(LNSRCHERROR)) THEN

C ---------------------------------------------------------------       
C  CHECK THE CENTRALITY OF THE CURRENT POINT
C
C   CC = || G(X)ZE - MU*E ||_2
C
C  IF CURRENT MU SATISFIES CC < MU 
C  THEN MU SHOULD BE DECREASED BY A FACTOR RHO IN (0,1),
C  OTHERWISE MU REMAINS UNCHANGED FOR NEXT ITERATION.
C  IF A NEW MU IS SELECTED, THEN NEW RESIDUALS MUST BE 
C  COMPUTED.
C ---------------------------------------------------------------       

         IF (CONSTRAINTS) THEN
            SUM = ZERO
            DO I = 1,MI
               SUM = SUM + (G(I)*Z(I) - MU)**2
            ENDDO
            CC = SQRT(SUM)
            IF (CC.LT.MU)  THEN
               MU = MU * RHO
               CALL RESEVAL(RESIDUAL,X,G,Z,MU,IPARAM,RPARAM,
     &              RWK(RP_NEXT),RWK_SIZE,IWK(IP_NEXT),IWK_SIZE)
            ENDIF
         ENDIF

C --------------------------------------------------------------- 
C     EVALUATE JACOBIAN
C ---------------------------------------------------------------       

         CALL JACEVAL(MATRIX,X,Z,G,IPARAM,RPARAM,
     &        RWK(RP_NEXT),RWK_SIZE,IWK(IP_NEXT),IWK_SIZE)

C ---------------------------------------------------------------  
C     EVALUATE COST-FUNCTION AT CURRENT POINT 
C ---------------------------------------------------------------       

         COST = DNRM2(NEQ,RESIDUAL,1)**2

C ---------------------------------------------------------------       
C     SOLVE THE LINEAR SYSTEM 
C     RESULT IS TRANSFERED TO RESIDUAL, MATRIX IS DESTROYED
C     NOTE: JOB = 0 NON-SYMMETRIC SOLVE, JOB = 1 SYMMETRIC SOLVE
C ---------------------------------------------------------------       

         CALL LINEARSOLVER(MATRIX,RESIDUAL,RCOND,JOB,VERBOSITY.GE.2,
     &        IWK(IP_NEXT),IWK_SIZE,RWK(RP_NEXT),RWK_SIZE,OUTUNIT)

C ---------------------------------------------------------------       
C     PERFORM DAMPING OF STEP TO ENSURE FEASIBILITY.
C     THE STEP, CONTAINED IN 'RESIDUAL' IS SCALED BY THE FACTOR
C     'LAMBDA_DMP'.
C ---------------------------------------------------------------       
         
         IF (CONSTRAINTS) THEN
            CALL DAMPING(RESIDUAL,X,Z,G,RWK(RP_GSTEP),IPARAM,
     &           RPARAM,TAUMIN,LAMBDA_DMP)
         ELSE
            LAMBDA_DMP = ONE
         ENDIF

C     COMPUTE THE INITIAL RATE OF DECRESE OF THE MERIT FUNCTION.
C     THE COMPUTED RATE ACCOUNTS FOR THE DAMPING  

         DIRDER = -2.0D0*COST*LAMBDA_DMP

C ---------------------------------------------------------------       
C     PERFORM LINESEARCH
C     NOTE THAT LFLAG = 0 SIGNALS NORMAL COMPLETION
C               LFLAG = 1 SIGNALS A VIOLATION 
C
C     THE USER-SPECIFIED PARAMETER NVIOL SPECIFIES HOW
C     MANY CONSEQUTIVE VIOLATIONS WILL BE ACCEPTED.
C
C     NOTE: THIS STEP WILL UPDATE THE UNKNOWNS 'X' ,'Z' AND 'G'.
C           IN ADDITION, THE VECTOR 'RESIDUAL' WILL BE 
C           REPLACED BY THE VALUE OF THE RESIDUALS AT THE 
C           NEW POINT (X,Z).
C ---------------------------------------------------------------       

         IF (VIOLCTR.LT.NVIOL) THEN
            ONETRIP = .TRUE.
         ELSE
            ONETRIP = .FALSE.
         ENDIF

         CALL LNSRCH(X,Z,MU,RESIDUAL,G,RWK(RP_XT),RWK(RP_ZT),
     &        RWK(RP_STEP),IPARAM,RPARAM,RWK(RP_NEXT),
     &        RWK_SIZE,IWK(IP_NEXT),IWK_SIZE,COST,DIRDER,ALPHA,
     &        INTERPOLATE,LAMBDA_LNSRCH,ONETRIP,LFLAG)
         
         IF (LFLAG.EQ.1) THEN
            VIOLCTR = VIOLCTR + 1 
         ELSE
            VIOLCTR = 0
         ENDIF

         IF (VIOLCTR.GT.NVIOL) LNSRCHERROR = .TRUE.

C ---------------------------------------------------------------       
C     CHECK STOPPING CRITERIA
C ---------------------------------------------------------------       

         CALL STOPTESTEVAL(RESIDUAL,X,Z,G,IPARAM,RPARAM,
     &        RWK(RP_NEXT),RWK_SIZE,IWK(IP_NEXT),IWK_SIZE,0,
     &        TOL,CONSTRAINTS,CONVERGED,ERRORL2)

C ---------------------------------------------------------------       
C     GENERATE OUTPUT FOR THIS ITERATION
C ---------------------------------------------------------------       

         ITER = ITER + 1

         IF (VERBOSITY.EQ.1) THEN
            WRITE(OUTUNIT,1000) ITER,COST,LAMBDA_LNSRCH
         ELSEIF (VERBOSITY.GE.2) THEN
            WRITE(OUTUNIT,1050) ITER,COST,ERRORL2,
     &           LAMBDA_LNSRCH,LAMBDA_DMP,MU,RCOND
         ENDIF


C ----------------------------------------------------------------      
C     END OF LOOP
C ----------------------------------------------------------------  

         GOTO 100
      ENDIF


C ----------------------------------------------------------------      
C     DETERMINE RETURN STATUS
C ----------------------------------------------------------------           

      IF (ITER .GT. MAXITER) THEN 
         RETURNFLAG = 1
      ELSEIF (LNSRCHERROR) THEN
         RETURNFLAG = 2
      ELSE
         RETURNFLAG = 0
      ENDIF

      
C ---------------------------------------------------------------- 
C     FORMAT STATEMENTS 
C     

 900  FORMAT(/,
     &     T10, ' -----------------------',/,
     &     T10, '| ITERATION INFORMATION |',/,
     &     T10, ' -----------------------'//,
     &     'ITERATION',TR10,'MERITFCN',TR10,'LAMBDA')

 950  FORMAT(/,
     &     T15, ' ------------------------------',/,
     &     T15, '| FULL CONVERGENCE INFORMATION |',/,
     &     T15, ' ------------------------------'//,
     &     'ITERATION',TR5,'MERITFCN',TR10,'L2-ERROR',
     &     TR8, 'LINESEARCH',TR6,'FEASIBILITY',TR9,
     &     'MU',TR13,'CONDITION')

 972  FORMAT(/,'INITIAL L2-ERROR IS',1X,E10.4)
 975  FORMAT(/,'THIS IS THE EQUILIBRIUM STEP, VERSION RNSF', /,
     &     'THE INITIAL POINT IS SATISFACTORY')

 1000 FORMAT(T1,I3,TR13,E10.4,TR7,E10.4)
 1050 FORMAT(T1,I3,TR11,E10.4,5(TR7,E10.4))
 2000 FORMAT(/,A,TR1,I3)
      
      RETURN
      END	





      
      SUBROUTINE STOPTEST(X,NSPECIES,NCOMP,NRXN,NMIN,AA,BB,MU0,MINLIST,
     &     MININDEX,IONPROD,EPSCONC,TOL,CONVERGED,CONSTRAINTS)

      IMPLICIT NONE
      INTRINSIC SQRT , EXP

      INTEGER N,ME,MI,NEQ,NIPARAM,NRPARAM
      COMMON /NIPS_SIZES/N,ME,MI,NEQ,NIPARAM,NRPARAM 

      INTEGER I,J,NCOMP,NSPECIES,NRXN,NMIN,MINLIST(NRXN),
     &     MININDEX(NMIN),IND

      REAL*8 X(N),MU0(NSPECIES),AA(NCOMP,NSPECIES),BB(NCOMP),
     &     IONPROD(NRXN),MASSJ,EPSCONC,TOL,ERROR,ZERO,PSI,
     &     BIGEXP,SMALLEXP,LOW,HIGH

      LOGICAL CONVERGED,CONSTRAINTS

      PARAMETER (ZERO = 0.0D0, BIGEXP = 50.0, SMALLEXP = -500.0)

C
C     EVALUATE THE SECONDARY UNKNOWNS (IONPROD)
C

      CALL MASSACTION(IONPROD,X,AA,MU0,MINLIST,NSPECIES,NCOMP,NRXN)

C ---------------------------------------------------------------
C     COMPUTE L2-ERROR OF MASS-BALANCES
C ---------------------------------------------------------------

      ERROR = ZERO

      DO J = 1,NCOMP
         MASSJ = EXP(DMIN1(BIGEXP,DMAX1(X(J),SMALLEXP)))
         IND = 0
         DO I = 1, NRXN
            IF (MINLIST(I).EQ.1) THEN
               IND = IND + 1
               MASSJ = MASSJ + X(NCOMP+IND)*AA(J,NCOMP + I)
            ELSE
               MASSJ = MASSJ + IONPROD(I)*AA(J,NCOMP + I)
            ENDIF
         ENDDO
         ERROR = ERROR + (MASSJ - BB(J))**2
      ENDDO

      ERROR = SQRT(ERROR)

      CONVERGED = (ERROR.LE.TOL)

C
C     IF MASS-BALANCE IS NOT MET, OR IF THIS IS THE ONLY
C     TEST TO BE PERFORMED, RETURN HERE.
C      

      IF ((.NOT.CONVERGED).OR.(.NOT.CONSTRAINTS)) RETURN

C ---------------------------------------------------------------
C     CHECK OPTIMALITY CONDITIONS FOR MINERALS
C     A MINERAL IS CONSIDERED AT EQUILIBRIUM IF IT HOLDS THAT:
C
C     PSI < TOL       (OTHERWISE, IT WOULD BE OVERSATURATED)
C
C     AND
C
C     PSI > -TOL*(1 + 1/(MINERAL CONCENTRATION))
C
C      THIS IS ESSENTIALLY SAYING THAT A MINERAL WHICH 
C      IS PRESENT, I.E., MINERAL CONCENTRATION >> TOL MUST 
C      HAVE A SOLUBILITY PRODUCT WHOSE LOGARITHM SATISFIES
C     
C       -TOL =< PSI =< TOL
C
C      ON THE OTHER HAND, FOR A MINERAL WHICH IS ABSENT (<< TOL),
C      THE APPROXIMATE INEQUALITY 
C
C      -TOL/EPSCONC =< PSI =< TOL
C  
C      HOLDS. 
C
C
C     THE ABOVE INEQUALITIES ARE GUARANTEED TO HOLD AT A SOLUTION 
C     THAT SATISFIES THE USER-SPECIFIED TOLERANCE ON THE RESIDUALS.
C
C     WE ALLOW A SLIGHTLY WIDER MARGIN AS SPECIFIED BY THE 
C     MULTIPLICATIVE CONSTANTS BELOW.
C      
C ---------------------------------------------------------------

      DO I = 1,NMIN

         PSI  =  IONPROD(MININDEX(I))
         LOW  = -1.001*TOL*(1.0 + 1.0/X(NCOMP+I))
         HIGH =  1.001*TOL

         CONVERGED = CONVERGED.AND.(LOW.LE.PSI.AND.PSI.LE.HIGH)

      ENDDO


      RETURN
      END	

