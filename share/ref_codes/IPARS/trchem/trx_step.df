      SUBROUTINE TRREACT(NERR)

      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'trmodel.h'
      INCLUDE 'trarydat.h'
      INCLUDE 'blkary.h'
$COMP$XREAC      INCLUDE 'xarydat.h'
$CMFMFE$XREAC      INCLUDE 'xarydat.h'
      INTEGER NERR, I, COUNTRXNSTEP, KERR
      CHARACTER*20 OUTFILENAME
      DATA COUNTRXNSTEP /0/

      INTEGER IRXN(5)
$COMP$XREAC     &       ,IXRXN(5)
$CMFMFE$XREAC     &       ,IXRXN(5)
      EXTERNAL RXN_STEP_WK
      DATA IRXN /5*0/
$COMP$XREAC     &    ,IXRXN /5*0/,FROMXMOD/.FALSE./
$CMFMFE$XREAC     &    ,IXRXN /5*0/,FROMXMOD/.FALSE./
C -----------------------------------------------------

      COUNTRXNSTEP = COUNTRXNSTEP + 1

C      CALL PASTE_SIS(OUTFILENAME, 'CHEM_DBG_', 
C     &                COUNTRXNSTEP , '.OUT', KERR)
C      OPEN(DEBUGUNIT, FILE=OUTFILENAME, STATUS='UNKNOWN') 

C      WRITE(*,*) " ENTER RXN_STEP(NERR): FLOWTIM=",  FLOWTIM,
C     &           " FLOWTIM_NEW=", FLOWTIM_NEW,
C     &           " CONCTIM_HALF=", CONCTIM_HALF,
C     &           " COUNTRXNSTEP=", COUNTRXNSTEP

C      WRITE(DEBUGUNIT,*) " ENTER RXN_STEP(NERR): FLOWTIM=",  FLOWTIM,
C     &           " FLOWTIM_NEW=", FLOWTIM_NEW,
C     &           " CONCTIM_HALF=", CONCTIM_HALF,
C     &           " COUNTRXNSTEP=", COUNTRXNSTEP

C SETUP FOR CALLWORK ROUTINE
      IF(NPRODUCTS.GT.0) THEN
         IRXN (1) = 4
         IRXN (2) = N_CONC
         IRXN (3) = N_SATU
         IRXN (4) = N_SATUN
         IRXN (5) = N_POR
         NERRCHEM = 0
         CALL CALLWORK (RXN_STEP_WK, IRXN)
      ENDIF

C SETUP FOR CALLWORK ROUTINE FOR COMPOSITIONAL COMPONENT REACTION

$COMP$XREAC      IF(FLOWMODEL.EQ.$XMODEL.AND.NXPRODUCTS.GT.0) THEN
$COMP$XREAC         FROMXMOD  = .TRUE.
$COMP$XREAC         IXRXN (1) = 4
$COMP$XREAC         IXRXN (2) = N_CONCX
$COMP$XREAC         IXRXN (3) = N_SATU
$COMP$XREAC         IXRXN (4) = N_SATUN
$COMP$XREAC         IXRXN (5) = N_POR
$COMP$XREAC         CALL CALLWORK (RXN_STEP_WK, IXRXN)
$COMP$XREAC         FROMXMOD  = .FALSE.
$COMP$XREAC      ENDIF

$CMFMFE$XREAC      IF(FLOWMODEL.EQ.$XMODEL.AND.NXPRODUCTS.GT.0) THEN
$CMFMFE$XREAC         FROMXMOD  = .TRUE.
$CMFMFE$XREAC         IXRXN (1) = 4
$CMFMFE$XREAC         IXRXN (2) = N_CONCX
$CMFMFE$XREAC         IXRXN (3) = N_SATU
$CMFMFE$XREAC         IXRXN (4) = N_SATUN
$CMFMFE$XREAC         IXRXN (5) = N_POR
$CMFMFE$XREAC         CALL CALLWORK (RXN_STEP_WK, IXRXN)
$CMFMFE$XREAC         FROMXMOD  = .FALSE.
$CMFMFE$XREAC      ENDIF

      IF (NERRCHEM.NE.0) THEN
         NERR = NERR+1
         STOP  ' ERROR IN RXN_STEP: NERRCHEM > 0'
      ENDIF

C      WRITE(DEBUGUNIT,*)  "  IN THE END OF RXN_STEP(NERR)",
C     &                     " NERRCHEM=", NERRCHEM, " NERR=", NERR
C      CLOSE(DEBUGUNIT)
C      WRITE(*,*) "  IN THE END OF RXN_STEP(NERR) ",
C     &                     " NERRCHEM=", NERRCHEM, " NERR=", NERR

      RETURN
      END


C *****************************************************************
      SUBROUTINE RXN_STEP_WK(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &                       KL1,KL2,KEYOUT,NBLK,CONC,SAT,SATN,POR)
C ****************************************************************

      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'trmodel.h'
$COMP$XREAC      INCLUDE 'xmodel.h'
$CMFMFE$XREAC      INCLUDE 'xmodel.h'

      INTEGER IL1, IL2, JL1, JL2, KL1, KL2, NSPEC
      INTEGER IDIM, JDIM, KDIM, LDIM, NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),   KEYOUT(IDIM,JDIM,KDIM)
      INTEGER I, J, K, L, NS

      REAL*8 CONC(IDIM,JDIM,KDIM,*), POR(IDIM,JDIM,KDIM) 
      REAL*8 SAT(IDIM,JDIM,KDIM,NPHASES-1), 
     &       SATN(IDIM,JDIM,KDIM,NPHASES-1)

$COMP$XREAC      REAL*8 DIFFC(IDIM,JDIM,KDIM,$MXNSPEC),SUMC($MXNSPEC)
$COMP$XREAC      SUMC=0.0D0

$CMFMFE$XREAC      REAL*8 DIFFC(IDIM,JDIM,KDIM,$MXNSPEC),SUMC($MXNSPEC)
$CMFMFE$XREAC      SUMC=0.0D0

      DO K = KL1,KL2
         DO J = JL1V(K),JL2V(K)
            DO I = IL1,IL2
               IF (KEYOUT(I,J,K).EQ.1) THEN

$COMP$XREAC                IF(FLOWMODEL.EQ.$XMODEL.AND.(.NOT.FROMXMOD)) THEN
$CMFMFE$XREAC                IF(FLOWMODEL.EQ.$XMMODEL.AND.(.NOT.FROMXMOD)) THEN
                  CALL GETLOCALSATR(SATR,I,J,K,IDIM,JDIM,KDIM,FLOWTIM,
     &                              FLOWTIM_NEW,CONCTIM_HALF,SAT,SATN,
     &                              NPHASES)
CDBG                  WRITE(*,*) " BEFORE:C(1,2,3)=",CONC(I,J,K,1),
CDBG     &                       CONC(I,J,K,2),CONC(I,J,K,3)
                  CALL GETLOCALCONC(MOLES,I,J,K,NSPECIES,IDIM,JDIM,KDIM,
     &                              CONC,.FALSE.)
                  CALL CONVERTTOTOTALCONC(MOLES,SATR,EQLBCOEF,PHASETYPE,
     &                                    NPHASES,NSPECIES)
                  NSPEC=NSPECIES
$COMP$XREAC                ELSEIF(FLOWMODEL.EQ.$XMODEL.AND.FROMXMOD) THEN
$COMP$XREAC                   CALL GETLOCALCONC(MOLES,I,J,K,NXSPECIES,IDIM,JDIM,
$COMP$XREAC     &                              KDIM,CONC,.TRUE.)
$COMP$XREAC                   DO L=2,NRC
$COMP$XREAC                      DIFFC(I,J,K,L)=CONC(I,J,K,L)
$COMP$XREAC                   ENDDO
$COMP$XREAC                NSPEC=NXSPECIES 
$COMP$XREAC                ELSE
$COMP$XREAC                   STOP 'ERROR IN RXN_STEP_WK: WRONG MODEL !!'
$COMP$XREAC                ENDIF

$CMFMFE$XREAC                ELSEIF(FLOWMODEL.EQ.$XMODEL.AND.FROMXMOD) THEN
$CMFMFE$XREAC                   CALL GETLOCALCONC(MOLES,I,J,K,NXSPECIES,IDIM,JDIM,
$CMFMFE$XREAC     &                              KDIM,CONC,.TRUE.)
$CMFMFE$XREAC                   DO L=2,NRC
$CMFMFE$XREAC                      DIFFC(I,J,K,L)=CONC(I,J,K,L)
$CMFMFE$XREAC                   ENDDO
$CMFMFE$XREAC                NSPEC=NXSPECIES 
$CMFMFE$XREAC                ELSE
$CMFMFE$XREAC                   STOP 'ERROR IN RXN_STEP_WK: WRONG MODEL !!'
$CMFMFE$XREAC                ENDIF

                  DO NS = 1, NSPEC
                     NEWMOLES(NS) = 0.0D0
                     INITGUESS(NS) = MOLES(NS)
                  ENDDO

                  CALL REACTONECELL()

$COMP$XREAC                IF(FLOWMODEL.EQ.$XMODEL.AND.(.NOT.FROMXMOD)) THEN
$CMFMFE$XREAC                IF(FLOWMODEL.EQ.$XMMODEL.AND.(.NOT.FROMXMOD)) THEN
                  CALL CONVERTTOREFCONC(NEWMOLES,SATR,EQLBCOEF,PHASETYPE
     &                                 ,NPHASES,NSPECIES)
                  CALL SAVELOCALCONC(NEWMOLES,I,J,K,NSPECIES,IDIM,JDIM,
     &                               KDIM,CONC,.FALSE.)
$COMP$XREAC                ELSEIF(FLOWMODEL.EQ.$XMODEL.AND.FROMXMOD) THEN
$COMP$XREAC                   CALL SAVELOCALCONC(NEWMOLES,I,J,K,NXSPECIES,IDIM,
$COMP$XREAC     &                                JDIM,KDIM,CONC,.TRUE.)
$COMP$XREAC                   DO L=2,NRC
$COMP$XREAC                      SUMC(L)=SUMC(L) + 
$COMP$XREAC     &                        (DIFFC(I,J,K,L)-CONC(I,J,K,L))*POR(I,J,K)
$COMP$XREAC                      BALANCE(L,$XMODEL,2)=BALANCE(L,$XMODEL,2)+SUMC(L)
$COMP$XREAC                   ENDDO 
$COMP$XREAC                ELSE
$COMP$XREAC                  STOP 'ERROR IN RXN_STEP_WK: WRONG MODEL !!'
$COMP$XREAC                ENDIF

$CMFMFE$XREAC                ELSEIF(FLOWMODEL.EQ.$XMODEL.AND.FROMXMOD) THEN
$CMFMFE$XREAC                   CALL SAVELOCALCONC(NEWMOLES,I,J,K,NXSPECIES,IDIM,
$CMFMFE$XREAC     &                                JDIM,KDIM,CONC,.TRUE.)
$CMFMFE$XREAC                   DO L=2,NRC
$CMFMFE$XREAC                      SUMC(L)=SUMC(L) + 
$CMFMFE$XREAC     &                        (DIFFC(I,J,K,L)-CONC(I,J,K,L))*POR(I,J,K)
$CMFMFE$XREAC                      BALANCE(L,$XMODEL,2)=BALANCE(L,$XMODEL,2)+SUMC(L)
$CMFMFE$XREAC                   ENDDO 
$CMFMFE$XREAC                ELSE
$CMFMFE$XREAC                  STOP 'ERROR IN RXN_STEP_WK: WRONG MODEL !!'
$CMFMFE$XREAC                ENDIF
               ENDIF
            ENDDO
         ENDDO
      ENDDO

      RETURN
      END

C ------------------------------------------------------------------
C  
      SUBROUTINE REACTONECELL()
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'trmodel.h'
      INTEGER COUNTRXN1CELL,NS,NSPEC
$COMP$XREAC     &       ,XCOUNTRXN1CELL  
$CMFMFE$XREAC     &       ,XCOUNTRXN1CELL  
      REAL*8  LOWER
      DATA COUNTRXN1CELL/0/
$COMP$XREAC     &    ,XCOUNTRXN1CELL/0/
$CMFMFE$XREAC     &    ,XCOUNTRXN1CELL/0/

$COMP$XREAC      IF(FLOWMODEL.EQ.$XMODEL.AND.(.NOT.FROMXMOD)) THEN
$CMFMFE$XREAC      IF(FLOWMODEL.EQ.$XMODEL.AND.(.NOT.FROMXMOD)) THEN
         COUNTRXN1CELL = COUNTRXN1CELL+1
         NSPEC=NSPECIES
$COMP$XREAC      ELSEIF(FLOWMODEL.EQ.$XMODEL.AND.FROMXMOD) THEN
$COMP$XREAC         XCOUNTRXN1CELL = XCOUNTRXN1CELL+1
$COMP$XREAC         NSPEC=NXSPECIES
$COMP$XREAC      ELSE
$COMP$XREAC         STOP 'ERROR IN REACTONECELL: WRONG MODEL !!'
$COMP$XREAC      ENDIF

$CMFMFE$XREAC      ELSEIF(FLOWMODEL.EQ.$XMODEL.AND.FROMXMOD) THEN
$CMFMFE$XREAC         XCOUNTRXN1CELL = XCOUNTRXN1CELL+1
$CMFMFE$XREAC         NSPEC=NXSPECIES
$CMFMFE$XREAC      ELSE
$CMFMFE$XREAC         STOP 'ERROR IN REACTONECELL: WRONG MODEL !!'
$CMFMFE$XREAC      ENDIF

C      WRITE(DEBUGUNIT,*) " ******************************************"
C      WRITE(DEBUGUNIT,*) "       IN REACTONECELL  (COUNT=",
C     &                           COUNTRXN1CELL, ") "
C$COMP$XREAC     &               ," ("XCOUNT=COUNTRXN1CELL, ") "
C      WRITE(DEBUGUNIT,*) " SATURATIONS = ", SATR(1), SATR(2)
C      WRITE(DEBUGUNIT,*) " ******************************************"
      
C      IF (COUNTRXN1CELL.GT.2
C$COMP$XREAC     &    .OR.XCOUNTRXN1CELL.GT.2
C     &    ) THEN
C         WRITE(*,*) " STOP AS COUNTRXN1CELL = ", COUNTRXN1CELL
C$COMP$XREAC     &              ," XCOUNTRXN1CELL = ", XCOUNTRXN1CELL
C         STOP
C      ENDIF

      IERRCHEM = 0

C     CALCULATE MU(NS),RATECONST(NPRODUCTS,2)
$COMP$XREAC      IF(FLOWMODEL.EQ.$XMODEL.AND.(.NOT.FROMXMOD)) THEN
$CMFMFE$XREAC      IF(FLOWMODEL.EQ.$XMODEL.AND.(.NOT.FROMXMOD)) THEN
         CALL CALMURATECONST(MU,RATECONST,PKF,PKB,PEQK,SATR,EQLBCOEF,
     &       RATEPOW,STOICH,REACTIONTYPE,NSPECIES,NCOMPS,NPRODUCTS,
     &       NPHASES,.FALSE.,DEBUGUNIT)
$COMP$XREAC      ELSEIF(FLOWMODEL.EQ.$XMODEL.AND.FROMXMOD) THEN
$COMP$XREAC         CALL XCALMURATECONST(XMU,XRATECONST,XPKF,XPKB,XPEQK,SATR,
$COMP$XREAC     &         XEQLBCOEF,XRATEPOW,XSTOICH,XREACTIONTYPE,NXSPECIES,
$COMP$XREAC     &         NXCOMPS,NXPRODUCTS,NPHASES,.FALSE.,DEBUGUNIT)
$COMP$XREAC      ELSE
$COMP$XREAC         STOP 'ERROR IN REACTONECELL: WRONG MODEL !!'
$COMP$XREAC      ENDIF

$CMFMFE$XREAC      ELSEIF(FLOWMODEL.EQ.$XMODEL.AND.FROMXMOD) THEN
$CMFMFE$XREAC         CALL XCALMURATECONST(XMU,XRATECONST,XPKF,XPKB,XPEQK,SATR,
$CMFMFE$XREAC     &         XEQLBCOEF,XRATEPOW,XSTOICH,XREACTIONTYPE,NXSPECIES,
$CMFMFE$XREAC     &         NXCOMPS,NXPRODUCTS,NPHASES,.FALSE.,DEBUGUNIT)
$CMFMFE$XREAC      ELSE
$CMFMFE$XREAC         STOP 'ERROR IN REACTONECELL: WRONG MODEL !!'
      LOWER = 1.1D0 * EPSCONC

C     IMPOSE CONCENTRATION THRESHOLD ON THE CELL MOLES
      DO NS =1, NSPEC
         IF (MOLES(NS).LT.LOWER) MOLES(NS) = LOWER
      ENDDO

C     IMPOSE CONCENTRATION THRESHOLD ON THE INITIAL GUESS
      DO NS =1, NSPEC
         IF (INITGUESS(NS).LT.LOWER) INITGUESS(NS) = LOWER
      ENDDO

C     SET THE .FALSE. TO DISABLE THE DEBUG INFO
      IF (((COUNTRXN1CELL.LE.5) .AND. .FALSE.
$COMP$XREAC     &   .AND.FLOWMODEL.EQ.$XMODEL.AND.(.NOT.FROMXMOD)
     &    )
$COMP$XREAC     &   .OR.((XCOUNTRXN1CELL.LE.5).AND. .FALSE.
$COMP$XREAC     &    .AND.FLOWMODEL.EQ.$XMODEL.AND.(FROMXMOD))
     &   ) THEN
C         WRITE(DEBUGUNIT,*) " ---------------------------------------"
C         WRITE(DEBUGUNIT,*) "    BEFORE CALLING REACTION ROUTINE     "
C         WRITE(DEBUGUNIT,*) " ---------------------------------------"
$COMP$XREAC      IF(FLOWMODEL.EQ.$XMODEL.AND.(.NOT.FROMXMOD)) THEN
            CALL ECHOCHEMPARAMETERS(MOLES,INITGUESS,NEWMOLES,ODEALGTYPE,
     &            RATES,AVGRATE,REFRATE,EPSCONC,CONCTIM,CDELTIM,NTREACT,
     &            SWITCHENABLED,PIMULTI,PIPURE,NRQ,NRK,NPRODUCTS,NPHASE,
     &            NSPECIES,NCOMPS,PHASEIDENTITY,REACTIONTYPE,
     &            REACTIONTYPESAVE,NIPSIPARM,FORMULAMATRIX,VMATRIX,
     &            MU,RATECONST,RATEPOW,HALFSATCONST,COMPCHARGE,
     &            NIPSRPARM,RWK,DIMRWK,IWK,DIMIWK,IDEBUGEQ,IDEBUG,
     &            DEBUGUNIT,NTTAKEN,PEAKITER,CUMITER,IERRCHEM,NIPSCPARM)
$COMP$XREAC      ELSEIF(FLOWMODEL.EQ.$XMODEL.AND.FROMXMOD) THEN
$COMP$XREAC            CALL ECHOCHEMPARAMETERS(MOLES,INITGUESS,NEWMOLES,ODEALGTYPE,
$COMP$XREAC     &           RATES,AVGRATE,REFRATE,EPSCONC,CONCTIM,CDELTIM,NTREACT,
$COMP$XREAC     &           SWITCHENABLED, PIXMULTI,PIXPURE,NXRQ,NXRK,NXPRODUCTS,
$COMP$XREAC     &           NXPHASE,NXSPECIES,NXCOMPS,XPHASEIDENTITY,XREACTIONTYPE,
$COMP$XREAC     &           REACTIONTYPESAVE,NIPSIPARM,XFORMULAMATRIX,XVMATRIX,
$COMP$XREAC     &           XMU,XRATECONST,XRATEPOW,XHALFSATCONST,XCOMPCHARGE,
$COMP$XREAC     &           NIPSRPARM,RWK,DIMRWK,IWK,DIMIWK,IDEBUGEQ,IDEBUG,
$COMP$XREAC     &           DEBUGUNIT,NTTAKEN,PEAKITER,CUMITER,IERRCHEM,NIPSCPARM)
$COMP$XREAC      ELSE
$COMP$XREAC         STOP 'ERROR IN REACTONECELL: WRONG MODEL !!'
$COMP$XREAC      ENDIF
      ENDIF

C ------------- PERFORM REACTION ------------------------------
$COMP$XREAC      IF(FLOWMODEL.EQ.$XMODEL.AND.(.NOT.FROMXMOD)) THEN
         IF ((INITIALCHEM).OR.(NRK.EQ.0)) THEN
            DO NS = 1, NSPECIES
               NEWMOLES(NS) = INITGUESS(NS)
            ENDDO

C            WRITE(DEBUGUNIT,*) "       TO-CALL EQSTEP    "
C            WRITE(DEBUGUNIT,*) "  INITIALCHEM=",INITIALCHEM," NRK=",NRK

            CALL EQSTEP(NEWMOLES, INITGUESS,
     &        EPSCONC,PIMULTI,PIPURE,NRQ,NPRODUCTS,
     &        NPHASE,NSPECIES, NCOMPS,PHASEIDENTITY,
     &        REACTIONTYPE,NIPSIPARM,
     &        FORMULAMATRIX,VMATRIX,MU,COMPCHARGE,NIPSRPARM,
     &        RWK,DIMRWK,IWK,DIMIWK,IDEBUG,DEBUGUNIT,
     &        CUMITER,IERRCHEM,NIPSCPARM)
         ELSE 

C           WRITE(DEBUGUNIT,*) "       TO-CALL ODEDRIVER    "
            CALL ODEDRIVER(MOLES,
     &        INITGUESS,NEWMOLES,ODEALGTYPE,RATES,AVGRATE,
     &        REFRATE,EPSCONC,CONCTIM,CDELTIM,NTREACT,
     &        SWITCHENABLED, PIMULTI,PIPURE,
     &        NRQ,NRK,NPRODUCTS,NPHASE,NSPECIES,NCOMPS,PHASEIDENTITY,
     &        REACTIONTYPE,REACTIONTYPESAVE,NIPSIPARM,
     &        FORMULAMATRIX,VMATRIX,
     &        MU,RATECONST,RATEPOW,HALFSATCONST,COMPCHARGE,NIPSRPARM,
     &        RWK,DIMRWK,IWK,DIMIWK,IDEBUGEQ,IDEBUG,DEBUGUNIT,
     &        NTTAKEN,PEAKITER,CUMITER,IERRCHEM,NIPSCPARM)

         ENDIF

$COMP$XREAC      ELSEIF(FLOWMODEL.EQ.$XMODEL.AND.FROMXMOD) THEN

$COMP$XREAC         IF ((INITIALCHEM).OR.(NXRK.EQ.0)) THEN
$COMP$XREAC            DO NS = 1, NXSPECIES
$COMP$XREAC               NEWMOLES(NS) = INITGUESS(NS)
$COMP$XREAC            ENDDO

C$COMP$XREAC            WRITE(DEBUGUNIT,*) "       TO-CALL EQSTEP    "
C$COMP$XREAC            WRITE(DEBUGUNIT,*) "  INITIALCHEM=",INITIALCHEM,
C$COMP$XREAC     &                         " NXRK=",NXRK

$COMP$XREAC            CALL EQSTEP(NEWMOLES,INITGUESS,EPSCONC,PIXMULTI,
$COMP$XREAC     &        PIXPURE,NXRQ,NXPRODUCTS,NXPHASE,NXSPECIES,NXCOMPS,
$COMP$XREAC     &        XPHASEIDENTITY,XREACTIONTYPE,NIPSIPARM,XFORMULAMATRIX,
$COMP$XREAC     &        XVMATRIX,XMU,XCOMPCHARGE,NIPSRPARM,RWK,DIMRWK,IWK,
$COMP$XREAC     &        DIMIWK,IDEBUG,DEBUGUNIT,CUMITER,IERRCHEM,NIPSCPARM)

$COMP$XREAC         ELSE

C$COMP$XREAC           WRITE(DEBUGUNIT,*) "       TO-CALL ODEDRIVER    "

$COMP$XREAC             CALL ODEDRIVER(MOLES,INITGUESS,NEWMOLES,ODEALGTYPE,
$COMP$XREAC     &        RATES,AVGRATE,REFRATE,EPSCONC,CONCTIM,CDELTIM,
$COMP$XREAC     &        NTREACT,SWITCHENABLED,PIXMULTI,PIXPURE,NXRQ,NXRK,
$COMP$XREAC     &        NXPRODUCTS,NXPHASE,NXSPECIES,NXCOMPS,XPHASEIDENTITY,
$COMP$XREAC     &        XREACTIONTYPE,REACTIONTYPESAVE,NIPSIPARM,
$COMP$XREAC     &        XFORMULAMATRIX,XVMATRIX,XMU,XRATECONST,
$COMP$XREAC     &        XRATEPOW,XHALFSATCONST,XCOMPCHARGE,NIPSRPARM,
$COMP$XREAC     &        RWK,DIMRWK,IWK,DIMIWK,IDEBUGEQ,IDEBUG,DEBUGUNIT,
$COMP$XREAC     &        NTTAKEN,PEAKITER,CUMITER,IERRCHEM,NIPSCPARM)

$COMP$XREAC         ENDIF
$COMP$XREAC      ELSE
$COMP$XREAC         STOP 'ERROR IN REACTONECELL: WRONG MODEL !!'
$COMP$XREAC      ENDIF


C -------------  END OF PERFORMING REACTION --------------------------

C     SET THE .FALSE. TO DISABLE THE DEBUG INFO
      IF (((COUNTRXN1CELL.LE.5) .AND. .FALSE.
$COMP$XREAC     &   .AND.FLOWMODEL.EQ.$XMODEL.AND.(.NOT.FROMXMOD)
     &    )
$COMP$XREAC     &   .OR.((XCOUNTRXN1CELL.LE.5).AND. .FALSE.
$COMP$XREAC     &    .AND.FLOWMODEL.EQ.$XMODEL.AND.(FROMXMOD))
     &   ) THEN

         WRITE(DEBUGUNIT,*) " ---------------------------------------"
         WRITE(DEBUGUNIT,*) "     AFTER CALLING REACTION ROUTINE     "
         WRITE(DEBUGUNIT,*) " ---------------------------------------"

$COMP$XREAC         IF(FLOWMODEL.EQ.$XMODEL.AND.(.NOT.FROMXMOD)) THEN
            CALL ECHOCHEMPARAMETERS(MOLES,
     &        INITGUESS,NEWMOLES,ODEALGTYPE,RATES,AVGRATE,
     &        REFRATE,EPSCONC,CONCTIM,CDELTIM,NTREACT,
     &        SWITCHENABLED, PIMULTI,PIPURE,
     &        NRQ,NRK,NPRODUCTS,NPHASE,NSPECIES,NCOMPS,PHASEIDENTITY,
     &        REACTIONTYPE,REACTIONTYPESAVE,NIPSIPARM,
     &        FORMULAMATRIX,VMATRIX,
     &        MU,RATECONST,RATEPOW,HALFSATCONST,COMPCHARGE,NIPSRPARM,
     &        RWK,DIMRWK,IWK,DIMIWK,IDEBUGEQ,IDEBUG,DEBUGUNIT,
     &        NTTAKEN,PEAKITER,CUMITER,IERRCHEM,NIPSCPARM)
$COMP$XREAC         ELSEIF(FLOWMODEL.EQ.$XMODEL.AND.FROMXMOD) THEN
$COMP$XREAC            CALL ECHOCHEMPARAMETERS(MOLES,
$COMP$XREAC     &        INITGUESS,NEWMOLES,ODEALGTYPE,RATES,AVGRATE,
$COMP$XREAC     &        REFRATE,EPSCONC,CONCTIM,CDELTIM,NTREACT,
$COMP$XREAC     &        SWITCHENABLED, PIXMULTI,PIXPURE,NXRQ,NXRK,
$COMP$XREAC     &        NXPRODUCTS,NXPHASE,NXSPECIES,NXCOMPS,XPHASEIDENTITY,
$COMP$XREAC     &        XREACTIONTYPE,REACTIONTYPESAVE,NIPSIPARM,
$COMP$XREAC     &        XFORMULAMATRIX,XVMATRIX,XMU,XRATECONST,
$COMP$XREAC     &        XRATEPOW,XHALFSATCONST,XCOMPCHARGE,NIPSRPARM,
$COMP$XREAC     &        RWK,DIMRWK,IWK,DIMIWK,IDEBUGEQ,IDEBUG,DEBUGUNIT,
$COMP$XREAC     &        NTTAKEN,PEAKITER,CUMITER,IERRCHEM,NIPSCPARM)
$COMP$XREAC         ELSE
$COMP$XREAC            STOP 'ERROR IN REACTONECELL: WRONG MODEL !!'
$COMP$XREAC         ENDIF
      ENDIF

C     CHECK IERRCHEM
      IF (IERRCHEM.NE.0) THEN
         WRITE(*,*) " ERROR: IERRCHEM =", IERRCHEM
         WRITE(NFOUT,*) " ERROR: IERRCHEM =", IERRCHEM
         NERRCHEM = NERRCHEM + 1
      ENDIF

C      WRITE(DEBUGUNIT,*) " ******************************************"
C      WRITE(DEBUGUNIT,*) "       IN END OF REACTONECELL (IERRCHEM=",
C     &                    IERRCHEM, ", NERRCHEM=", NERRCHEM, ") "
C      WRITE(DEBUGUNIT,*) " ******************************************"

      RETURN
      END


C------------------------------------------------------------------
C  GET LCOAL SATURATION
      SUBROUTINE GETLOCALSATR(SATR, I,J,K, IDIM,JDIM,KDIM, 
     &       FLOWTIM, FLOWTIM_NEW,  CONCTIM_HALF, SAT, SATN, NPHASES)
      IMPLICIT NONE
      INTEGER NS, I,J,K, IDIM,JDIM,KDIM, NPHASES
      REAL*8 SATR(*), FLOWTIM, FLOWTIM_NEW,  CONCTIM_HALF
      REAL*8 SAT(IDIM,JDIM,KDIM,NPHASES-1), 
     &       SATN(IDIM,JDIM,KDIM,NPHASES-1)

      IF (NPHASES.EQ.1) THEN
         SATR(1) = 1.0D0
      ELSE IF (NPHASES.EQ.2) THEN
         CALL GETLOCALSATR2(SATR, I,J,K, IDIM,JDIM,KDIM, 
     &       FLOWTIM, FLOWTIM_NEW,  CONCTIM_HALF, SAT, SATN)
      ELSE IF (NPHASES.EQ.3) THEN
         CALL GETLOCALSATR3(SATR, I,J,K, IDIM,JDIM,KDIM, 
     &       FLOWTIM, FLOWTIM_NEW,  CONCTIM_HALF, SAT, SATN)
      ELSE
         STOP 'ERROR IN GETLOCALSATR: UNSUPPORTED NO. OF PHASES !!'
      ENDIF

      RETURN
      END

C ------------------------------------------------------------------
C   GET LOCAL SATURATION (2 FLOWING PHASES' VERSION)

      SUBROUTINE GETLOCALSATR2(SATR, I,J,K, IDIM,JDIM,KDIM, 
     &       FLOWTIM, FLOWTIM_NEW,  CONCTIM_HALF, SAT, SATN)
      IMPLICIT NONE
      INTEGER NS, I,J,K, IDIM,JDIM,KDIM
      REAL*8 SATR(*), FLOWTIM, FLOWTIM_NEW,  CONCTIM_HALF
      REAL*8 SAT(IDIM,JDIM,KDIM), SATN(IDIM,JDIM,KDIM)

C      WRITE(*,*) "IN GETLOCALSATR2:  I=", I, " J=", J, " K=", K,
C     &           "   SAT=", SAT(I,J,K) , " SATN=", SATN(I,J,K)
C      WRITE(*,*) "IN GETLOCALSATR2: FLOWTIM=",  FLOWTIM,
C     &           " FLOWTIM_NEW=", FLOWTIM_NEW,
C     &           " CONCTIM_HALF=", CONCTIM_HALF

      SATR(1) = (FLOWTIM_NEW - CONCTIM_HALF)/(FLOWTIM_NEW-FLOWTIM)*
     &            SAT(I,J,K)  +  SATN(I,J,K) *
     &          (CONCTIM_HALF - FLOWTIM)/(FLOWTIM_NEW-FLOWTIM)

C      WRITE(*,*) "IN GETLOCALSATR2:  SATR(1) =", SATR(1) 

      IF (SATR(1).GT.1.0D0) THEN
         WRITE(*,*) "ERROR:  SATURATION(1) > 1.0D0.  SET IT = 1.0D0"
         SATR(1) = 1.0D0
      ELSE IF (SATR(1).LT.0.0D0) THEN
         WRITE(*,*) "ERROR:  SATURATION(1) < 0.0D0.  SET IT = 0.0D0"
         SATR(1) = 0.0D0
      ENDIF

      SATR(2) = 1.0D0 - SATR(1)
      
      RETURN
      END

C ------------------------------------------------------------------
C   GET LOCAL SATURATION (3 FLOWING PHASES' VERSION)

      SUBROUTINE GETLOCALSATR3(SATR, I,J,K, IDIM,JDIM,KDIM,
     &       FLOWTIM, FLOWTIM_NEW,  CONCTIM_HALF, SAT, SATN)
      IMPLICIT NONE
      INTEGER NS, I,J,K, IDIM,JDIM,KDIM
      REAL*8 SATR(*), FLOWTIM, FLOWTIM_NEW,  CONCTIM_HALF
      REAL*8 SAT(IDIM,JDIM,KDIM,2), SATN(IDIM,JDIM,KDIM,2)

C      WRITE(0,*) "IN GETLOCALSATR2:  I=", I, " J=", J, " K=", K,
C     &    " SAT1=", SAT(I,J,K,1), " SAT1N=", SATN(I,J,K,1),
C     &    " SAT2=", SAT(I,J,K,1), " SAT2N=", SATN(I,J,K,2)
C      WRITE(0,*) "IN GETLOCALSATR2: FLOWTIM=",  FLOWTIM,
C     &           " FLOWTIM_NEW=", FLOWTIM_NEW,
C     &           " CONCTIM_HALF=", CONCTIM_HALF

      SATR(1) = (FLOWTIM_NEW - CONCTIM_HALF)/(FLOWTIM_NEW-FLOWTIM)*
     &            SAT(I,J,K,1)  +  SATN(I,J,K,1) *
     &          (CONCTIM_HALF - FLOWTIM)/(FLOWTIM_NEW-FLOWTIM)

      SATR(2) = (FLOWTIM_NEW - CONCTIM_HALF)/(FLOWTIM_NEW-FLOWTIM)*
     &            SAT(I,J,K,2)  +  SATN(I,J,K,2) *
     &          (CONCTIM_HALF - FLOWTIM)/(FLOWTIM_NEW-FLOWTIM)

C      WRITE(0,*) "IN GETLOCALSATR2:  SATR(1) =", SATR(1)," SATR(2)=",
C     &           SATR(2)

      IF ((SATR(1)-1.0D0).GT.1.0D-4) THEN
         WRITE(0,*) "ERROR:  SATURATION(1) > 1.0D0 BY ",
     &              SATR(1)-1.0D0,". SET IT = 1.0D0"
         SATR(1) = 1.0D0
         SATR(2) = 0.0D0
      ELSE IF (SATR(1).LT.-1.0D-4) THEN
         WRITE(0,*) "ERROR:  SATURATION(1) < 0.0D0 BY ",
     &              SATR(1),". SET IT = 0.0D0"
         SATR(1) = 0.0D0
      ENDIF

      IF ((SATR(2)-1.0D0).GT.1.0D-4) THEN
         WRITE(0,*) "ERROR:  SATURATION(2) > 1.0D0 BY ",
     &              SATR(2)-1.0D0,". SET IT = 1.0D0"
         SATR(2) = 1.0D0
         SATR(1) = 0.0D0
      ELSE IF (SATR(2).LT.-1.0D-4) THEN
         WRITE(0,*) "ERROR:  SATURATION(2) < 0.0D0 BY ",
     &              SATR(2),". SET IT = 0.0D0"
         SATR(2) = 0.0D0
      ENDIF

      SATR(3) = 1.0D0 - SATR(1) - SATR(2)

      RETURN
      END



C ------------------------------------------------------------------

      SUBROUTINE GETLOCALCONC(MOLES,I,J,K, NSPECIES, IDIM,JDIM,KDIM, 
     &     CONC,FROMXM)

      IMPLICIT NONE
      INCLUDE 'control.h'
      INTEGER NS, I,J,K, NSPECIES, IDIM,JDIM,KDIM
      LOGICAL FROMXM
      REAL*8 MOLES(*)
      REAL*8 CONC(IDIM,JDIM,KDIM,*)

C      IF ((NSPECIES.LT.1).OR.(NSPECIES.GT.20)) THEN
C         WRITE(*,*) " FATAL ERROR IN SAVELOCALCONC: BAD NSPECIES! "
C         STOP
C      ENDIF

      DO NS=1, NSPECIES
$COMP$XREAC         IF(FLOWMODEL.EQ.$XMODEL.AND.(.NOT.FROMXM)) THEN
         MOLES(NS) = CONC(I,J,K,NS)
$COMP$XREAC         ELSEIF(FLOWMODEL.EQ.$XMODEL.AND.FROMXM) THEN
$COMP$XREAC            MOLES(NS)=CONC(I,J,K,NS+1)
$COMP$XREAC         ENDIF
      ENDDO
 
C       WRITE(*,*) " NSPECIES=",NSPECIES," GETCONC(1,2,3)=", MOLES(1), 
C     &            MOLES(2),  MOLES(3)

      RETURN
      END

C  ------------------------------------------------------------

      SUBROUTINE SAVELOCALCONC(MOLES,I,J,K, NSPECIES,IDIM,JDIM,KDIM, 
     &     CONC,FROMXM)

      IMPLICIT NONE
      INCLUDE 'control.h'
      INTEGER NS, I,J,K, NSPECIES, IDIM,JDIM,KDIM
      LOGICAL FROMXM
      REAL*8 MOLES(*)
      REAL*8 CONC(IDIM,JDIM,KDIM,*)

C      IF ((NSPECIES.LT.1).OR.(NSPECIES.GT.20)) THEN
C         WRITE(*,*) " FATAL ERROR IN SAVELOCALCONC: BAD NSPECIES! "
C         STOP
C      ENDIF

      DO NS=1, NSPECIES
$COMP$XREAC         IF(FLOWMODEL.EQ.$XMODEL.AND.(.NOT.FROMXM)) THEN
         CONC(I,J,K,NS) = MOLES(NS)
$COMP$XREAC         ELSEIF(FLOWMODEL.EQ.$XMODEL.AND.FROMXM) THEN
$COMP$XREAC            CONC(I,J,K,NS+1)=MOLES(NS)
$COMP$XREAC         ENDIF
      ENDDO

C       WRITE(*,*) " SAVECONC(1,2,3)=", MOLES(1), MOLES(2),  MOLES(3)

      RETURN
      END

C ***************************************************************
C     CALCULATE MU(NS),RATECONST(NPRODUCTS,2)

      SUBROUTINE CALMURATECONST(MU,RATECONST,PKF,PKB,PEQK,SATR,EQLBCOEF,
     &     RATEPOW,STOICH,REACTIONTYPE,NSPECIES,NCOMPS,NPRODUCTS,
     &     NPHASES, LEVELC, NFOUT)

      IMPLICIT NONE
      INTEGER NSPECIES,NCOMPS,NPRODUCTS,NFOUT,I,P,J,NPHASES,
     &        REACTIONTYPE(NPRODUCTS) 
      LOGICAL LEVELC
      REAL*8 MU(NSPECIES),RATECONST(NPRODUCTS,2),PKF($MXPHAST,$MXNSPEC),
     &       PKB($MXPHAST,$MXNSPEC),PEQK(NPRODUCTS),SATR($MXPHAST),
     &       PEQKX(NPRODUCTS),EQLBCOEF($MXPHAST,$MXNSPEC),
     &       PCOEFF(NPHASES,NSPECIES),RATEPOW(NCOMPS,NPRODUCTS),
     &       STOICH($MXNSPEC,$MXNSPEC),SUM,PROD(NPHASES,NPRODUCTS)

C     CALCULATE PCOEFF(NPHASES, NSPECIES)
      DO I=1, NSPECIES
         SUM = 0.0
         DO P = 1, NPHASES
            SUM = SUM + SATR(P)*EQLBCOEF(P,I)
         ENDDO
         DO P = 1, NPHASES
            PCOEFF(P,I) = EQLBCOEF(P,I) / SUM
C            WRITE(*,*)  " P=",P," I=",I," PCOEFF(P,I)=",PCOEFF(P,I)
         ENDDO
      ENDDO

C     CALCUALTE PROD(NPHASES, NPRODUCTS)
      DO P=1, NPHASES
         DO J=1, NPRODUCTS
            PROD(P,J) = 1.0
            DO I=1, NCOMPS
               IF (REACTIONTYPE(J).EQ.0) THEN
                 PROD(P,J) = PROD(P,J) * (PCOEFF(P,I)**STOICH(J,I))
C                 WRITE(*,*)  " RATEPOW(,",I,",",J,")=",STOICH(I,J)
               ELSE
                 PROD(P,J) = PROD(P,J) * (PCOEFF(P,I)**RATEPOW(I,J))
C                 WRITE(*,*)  " RATEPOW(,",I,",",J,")=",RATEPOW(I,J)
               ENDIF
            ENDDO
C            WRITE(*,*)  " P=",P," J=",J," PROD(P,J)=",PROD(P,J)
         ENDDO
      ENDDO
            
      DO I=1, NPRODUCTS
         IF (REACTIONTYPE(I).EQ.0) THEN
            SUM = 0.0
            DO P=1, NPHASES
               SUM = SUM + SATR(P)*EQLBCOEF(P,I+NCOMPS)
            ENDDO
C     NOTE WE CHOOSE PHASE 1 AS THE REFERENCE PHASE HERE
            RATECONST(I,1) = (10.0 ** PEQK(I))* PROD(1,I)*SUM
            RATECONST(I,2) = 0.0

C             WRITE(*,*)  " I=", I, "  PEQK(I)=",PEQK(I), 
C     &                 " RATECONST(I,1)=",  RATECONST(I,1), 
C     &                 " RATECONST(I,2)=",  RATECONST(I,2)
C             WRITE(*,*) "PROD(1,I)=", PROD(1,I), "SUM=", SUM
         ELSE
            SUM = 0.0
            DO  P=1, NPHASES
               SUM = SUM + SATR(P)*PROD(P,I)*(10.0 ** PKF(P,I))
            ENDDO
            RATECONST(I,1) = SUM

C            WRITE(*,*) "PKF(1,I)=",PKF(1,I), " RATECONST(I,1)=",
C     &                  RATECONST(I,1)

            SUM = 0.0
            DO  P=1, NPHASES
               SUM = SUM + SATR(P)*PCOEFF(P,I+NCOMPS)
     &                     *(10.0 ** PKB(P,I))
            ENDDO
            RATECONST(I,2) = SUM

C            WRITE(*,*) "PKB(1,I)=",PKB(1,I), " RATECONST(I,2)=",
C     &                  RATECONST(I,2)

         ENDIF
      ENDDO

C     CONVERT FROM  PEQK --> PEQKX   (RNSF VERSION)
C     USES MOLAR VARIABLES
      DO I = 1,NPRODUCTS
         IF (REACTIONTYPE(I).EQ.0) THEN
C            SUM = PEQK(I)
            SUM = DLOG(RATECONST(I,1)) / DLOG(10.0D0)
         ELSE
C            SUM = PKF(I) - PKB(I)
            SUM = DLOG(RATECONST(I,1)/RATECONST(I,2)) / DLOG(10.0D0) 
         ENDIF
C         DO J = 1,NCOMP
C            IF (J.EQ.LOCWATER) THEN
C               RHOJ = PHASEDENSITY(PHASEIDENTITY(J))
C               SUM = SUM - STOICH(I,J)*DLOG10(RHOJ)
C            ENDIF
C         ENDDO
         PEQKX(I) = SUM
      ENDDO
C
C     COMPUTE MU0 FROM PEQKX
C
      DO I = 1,NCOMPS
         MU(I) = 0.0D0
      ENDDO
      DO I = 1,NPRODUCTS
         MU(NCOMPS + I) = -DLOG(10.0D0)*PEQKX(I)

C         WRITE(*,*) "PEQKX(I)=", PEQKX(I),
C     &                "     MU(NCOMPS + I)=",MU(NCOMPS + I)


      ENDDO

C     ECHO MU(NSPECIES), RATECONST(NPRODUCTS,2)
      IF (LEVELC) THEN
         WRITE (NFOUT, "(' MU(*) = ',
     &             99(1X, E10.2)  )")
     &       (MU(I), I=1, NSPECIES)
         WRITE (NFOUT, "(' RATECONST(*,1) = ',
     &             99(1X, E10.2)  )")
     &       (RATECONST(I,1), I=1, NPRODUCTS)
         WRITE (NFOUT, "(' RATECONST(*,2) = ',
     &             99(1X, E10.2)  )")
     &       (RATECONST(I,2), I=1, NPRODUCTS)
      ENDIF

      RETURN
      END

C ***************************************************************
      SUBROUTINE XCALMURATECONST(MU,RATECONST,PKF,PKB,PEQK,SATR,
     &    EQLBCOEF,RATEPOW,STOICH,REACTIONTYPE,NSPECIES,NCOMPS,
     &    NPRODUCTS,NPHASES,LEVELC,NFOUT)
C ***************************************************************
C Lot simpler on account of the fact that concentrations are 
C already overall molar values (not per phase) and that we avoid  
C equilibrium partitioning coefficients. 
      IMPLICIT NONE
      INTEGER NSPECIES, NCOMPS, NPRODUCTS, NFOUT, I, P, J,
     &        NPHASES, REACTIONTYPE(NPRODUCTS)
      LOGICAL LEVELC
      REAL*8 MU(NSPECIES),RATECONST(NPRODUCTS,2),PKF($MXNSPEC),
     &       PKB($MXNSPEC),PEQK(NPRODUCTS),SATR($MXPHAST),
     &       PEQKX(NPRODUCTS),EQLBCOEF($MXPHAST, $MXNSPEC), 
     &       RATEPOW(NCOMPS,NPRODUCTS),STOICH($MXNSPEC,$MXNSPEC),
     &       SUM,PROD(NPRODUCTS)

      DO I=1, NPRODUCTS
         IF (REACTIONTYPE(I).EQ.0) THEN
            RATECONST(I,1) = 10.0D0**PEQK(I)
            RATECONST(I,2) = 0.0D0
C             WRITE(*,*)  " I=", I, "  PEQK(I)=",PEQK(I),
C     &                 " RATECONST(I,1)=",  RATECONST(I,1),
C     &                 " RATECONST(I,2)=",  RATECONST(I,2)
         ELSE
            RATECONST(I,1) = 10.0D0**PKF(I)
C            WRITE(*,*) "PKF(I)=",PKF(I), " RATECONST(I,1)=",
C     &                  RATECONST(I,1)

            RATECONST(I,2) = 10.0D0**PKB(I)
C            WRITE(*,*) "PKB(1,I)=",PKB(1,I), " RATECONST(I,2)=",
C     &                  RATECONST(I,2)
         ENDIF
      ENDDO

C     CONVERT FROM  PEQK --> PEQKX   (RNSF VERSION)
C     USES MOLAR VARIABLES
      DO I = 1,NPRODUCTS
         IF (REACTIONTYPE(I).EQ.0) THEN
C            SUM = PEQK(I)
            SUM = DLOG(RATECONST(I,1)) / DLOG(10.0D0)
         ELSE
C            SUM = PKF(I) - PKB(I)
            SUM = DLOG(RATECONST(I,1)/RATECONST(I,2))/DLOG(10.0D0)
         ENDIF
C         DO J = 1,NCOMP
C            IF (J.EQ.LOCWATER) THEN
C               RHOJ = PHASEDENSITY(PHASEIDENTITY(J))
C               SUM = SUM - STOICH(I,J)*DLOG10(RHOJ)
C            ENDIF
C         ENDDO
         PEQKX(I) = SUM
      ENDDO
C
C     COMPUTE MU0 FROM PEQKX
C
      DO I = 1,NCOMPS
         MU(I) = 0.0D0
      ENDDO
      DO I = 1,NPRODUCTS
         MU(NCOMPS + I) = -DLOG(10.0D0)*PEQKX(I)

C         WRITE(*,*) "PEQKX(I)=", PEQKX(I),
C     &                "     MU(NCOMPS + I)=",MU(NCOMPS + I)
      ENDDO

C     ECHO MU(NSPECIES), RATECONST(NPRODUCTS,2)
      IF (LEVELC) THEN
         WRITE (NFOUT, "(' MU(*) = ',
     &             99(1X, E10.2)  )")
     &       (MU(I), I=1, NSPECIES)
         WRITE (NFOUT, "(' RATECONST(*,1) = ',
     &             99(1X, E10.2)  )")
     &       (RATECONST(I,1), I=1, NPRODUCTS)
         WRITE (NFOUT, "(' RATECONST(*,2) = ',
     &             99(1X, E10.2)  )")
     &       (RATECONST(I,2), I=1, NPRODUCTS)
      ENDIF

      RETURN
      END


C ***************************************************************
      SUBROUTINE CONVERTTOTOTALCONC(MOLES, SATR, EQLBCOEF,
     &                  PHASETYPE, NPHASES, NSPECIES)
      IMPLICIT NONE
      INTEGER NSPECIES, NCOMPS, I, P,NPHASES,PHASETYPE(NSPECIES)
      REAL*8 MOLES(NSPECIES), SATR(NSPECIES),
     &       EQLBCOEF($MXPHAST, $MXNSPEC), COEFF

C      WRITE(*,*) " ENTER CONVERTTOTOTALCONC: "

      DO I=1, NSPECIES 

C      WRITE(*,*) " BEFORE COMP: I=",I, " MOLES=", MOLES(I),
C     &         " NPHASES=", NPHASES, " STAR=", SATR(0), SATR(1),
C     &         " PHASETYPE=", PHASETYPE(I), " EQLBCOEF=", EQLBCOEF(1,I)

         IF (PHASETYPE(I).EQ.1) THEN
            COEFF = 0.0
            DO P=1, NPHASES
               COEFF = COEFF + SATR(P)*EQLBCOEF(P,I)
            ENDDO
            MOLES(I) = MOLES(I)*COEFF
         ENDIF

C      WRITE(*,*) " AFTER COMP: MOLES(I)=", MOLES(I)

      ENDDO

C      WRITE(*,*) " LEAVE CONVERTTOTOTALCONC: "


      RETURN
      END

C ***************************************************************

      SUBROUTINE CONVERTTOREFCONC(MOLES, SATR, EQLBCOEF,
     &                  PHASETYPE, NPHASES, NSPECIES)
      IMPLICIT NONE
      INTEGER NSPECIES, NCOMPS, I, P,NPHASES,PHASETYPE(NSPECIES)
      REAL*8 MOLES(NSPECIES), SATR(NSPECIES),
     &       EQLBCOEF($MXPHAST, $MXNSPEC), COEFF

C      WRITE(*,*) " ENTER CONVERTTOREFCONC: "

      DO I=1, NSPECIES

C      WRITE(*,*) " BEFORE COMP: I=",I, " MOLES=", MOLES(I),
C     &         " NPHASES=", NPHASES, " STAR=", SATR(0), SATR(1),
C     &         " PHASETYPE=", PHASETYPE(I), " EQLBCOEF=", EQLBCOEF(1,I)

         IF (PHASETYPE(I).EQ.1) THEN
            COEFF = 0.0
            DO P=1, NPHASES
               COEFF = COEFF + SATR(P)*EQLBCOEF(P,I)
            ENDDO
            COEFF = EQLBCOEF(1,I)/COEFF
C       NOTE: THE REFERENCE PHASE IS PHASE 1.  
C             BY DEFAULT, EQLBCOEF(1,I) = 1

            MOLES(I) = MOLES(I)*COEFF

         ENDIF

C      WRITE(*,*) " AFTER COMP: MOLES(I)=", MOLES(I)

      ENDDO

C      WRITE(*,*) " LEAVE CONVERTTOREFCONC: "

      RETURN
      END

C ***************************************************************

C  ----------------------- END OF THIS FILE --------------------------


