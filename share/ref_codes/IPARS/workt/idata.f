C  IDATA.F - PROCESS INITIAL DATA

C  ROUTINES IN THIS MODULE:

C  SUBROUTINE GETIDAT (NERR)
C  SUBROUTINE GETSCAL (NERR)
C  SUBROUTINE GETROCK (NERR)
C  SUBROUTINE SETGEOM (NERR)
C  SUBROUTINE CREATE  (NERR)
C  SUBROUTINE GETGAPI (PRT,NERR)
C  SUBROUTINE MAKEMAP (NC,NERR)

C  CODE HISTORY:

C  JOHN WHEELER     11/28/95    ALPHA CODE
C  JOHN WHEELER      1/23/97    ADD COLUMN KEYOUT PATTERN
C  QIN LU            4/08/98    CREATE BOUNDARY CONDITION FLAGS IN CREATE()
C  JOHN WHEELER      4/13/98    ADD LINEAR SOLVER CONTROL
C  JOHN WHEELER      1/15/99    ADD DUAL APPROXIMATION BLOCK INTERFACE
C  JOHN WHEELER      4/20/99    ADD GENERIC MULTI-MODEL CAPABILITY
C  RICK DEAN        11/29/01    REPLACED PNTVAR BY PNTVAR4 AND PNTVAR8
C                               MINOR BUG FIX FOR SPLNOUT AND MOD TO XARRAY
C  SUNIL G. THOMAS 8-6/1-31/07-08 VARIOUS CHANGES TO ACCOMODATE BETTER
C                               VISUALIZATION, COUPLING TO REACTIVE TRANSPORT.
C                               NOTE: MODEL MAY NEED TO BE BETTER DEFINED IN
C                               CASE MULTI_MODEL IS ACTIVE OR SAME METHOD AS
C                               WITH TRANSPORT CHEMISTRY (WHICH BECOMES DRIVING
C                               PHYSICAL MODEL) CAN BE USED.
C  XIANHUI KONG     06/11/14    ADD FLEXIBLE PERM READIN USING XPERM OR YPERM
C                               ADD DEPTH1_TOP FROM TOP SURFACE IN Y-Z PLANE
C  SAUMIK DANA      09/16/15    ADD BIN WANG METHODS FOR METIS PARTITIONING
C  GURPREET SINGH   11/11/2015  ADDED 2PHASE IMPLICIT MFMFE
C  GERGINA PENCHEVA 04/22/2016  ADDED STOP STATEMENTS FOR INPUT ERRORS
C  BEN GANIS        04/25/2016  ADDED MFMFE BRICK OPTION

C  NOTES:

C  1)  Subroutine GETIDAT should be called by all models; thus it
C      should contain no model specific input but may contain model
C      specific calls to other routines.

C  2)  Subroutines GETSCAL, GETROCK, and GETGEOM are intended for use
C      by all models but may be replaced for specific models if
C      necessary.

C  3)  Creation of grid-element arrays should be done in a separate
C      routine, CREATE(), which can also be called during restart.

C  4)  Model specific input and array creation should be done in
C      separate routines.  See the substitution keys, C,
C      C, C, and C in this and other files.

C*********************************************************************
      SUBROUTINE GETIDAT (NERR)
C*********************************************************************

C  Executive routine for extracting initial data from the keyword super
C  array.

C  NERR = Error number steped by 1 on error (input & output, INTEGER)

C*********************************************************************
      IMPLICIT NONE
C      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'blkary.h'

      INTEGER IA(2),NERR,I,N,IVA(5)
      REAL*8 D(19)
      EXTERNAL COUNTE
C      EXTERNAL calcEVOL

      IF (LEVELE.AND.BUGKEY(1)) THEN
         WRITE (NFBUG,*)'PROC',MYPRC,' ENTERING SUBROUTINE GETIDAT'
         WRITE (*,*)'PROC',MYPRC,' ENTERING SUBROUTINE GETIDAT'
      ENDIF

C  GET SCALAR DATA (INCLUDING MODEL SPECIFIC SCALARS)

      LEVELC=.FALSE.
      IF (MYPRC.EQ.0) LEVELC=.TRUE.
      CALL GETSCAL(NERR)
      IF (NERR.GT.0) STOP 'Error in GETSCAL'
      IF (LEVERR.GT.2) RETURN

C  PROCESS INITIAL GEOMETRY DATA

      ILAY=1
      JLAY=1
      KLAY=1
      MAXREF=1
      IF (EV_PRCBLK.EQ.0) THEN
        CALL SETGEOM(NERR)
        IF (NERR.GT.0) STOP 'Error in SETGEOM'
      ELSE
        CALL SETGEOMNEW(NERR)
        IF (NERR.GT.0) STOP 'Error in SETGEOMNEW'
      ENDIF
      IF (LEVERR.GT.2) RETURN

C  EXTRACT 2-PHASE RELATIVE PERMEABILITIES AND CAPILLARY PRESSURES

      CALL GETROCK(NERR)
      IF (NERR.GT.0) STOP 'Error in GETROCK'
      IF (LEVERR.GT.2) RETURN

C  GET WELL DATA (INCLUDING MODEL SPECIFIC DATA)

      CALL IWELLS (NERR,1)
      IF (NERR.GT.0) STOP 'Error in IWELLS'
      IF (LEVERR.GT.2) RETURN

C  INITIALIZE BLOCK INTERFACE DATA STRUCTURES AND COMMUNICATIONS

      CALL TIMON(12)
      CALL SBLKIN (NERR)
      CALL TIMOFF(12)
      IF (NERR.GT.0) STOP 'Error in DUAL initialization'

C  GET BC SPECIFICATION

      CALL BDARYIN(1,NERR)
      IF (NERR.GT.0) STOP 'Error in BDARYIN'
      IF (LEVERR.GT.2) RETURN

C  CHANGE DEPTHS TO REFLECT SMALL ANGLE APPROXIMATION
C  CHANGE POROSITIES AND PERMEABILITIES WITH USER PROGRAMS

      CALL ROCKPROG(NERR)
      IF (NERR.GT.0) STOP 'Error in ROCKPROG'

C  COUNT GRID ELEMENTS

      DO 2 I=1,19
    2 NEMOD(I)=0
      IA(1)=0
      CALL CALLWORK(COUNTE,IA)
      DO 3 I=1,19
    3 D(I)=NEMOD(I)
      CALL SUMIT(19,D)
      IF (MYPRC.EQ.0) THEN
         DO 4 I=1,19
    4    NEMOD(I)=D(I)+.1D0
      ENDIF
      CALL SPREAD(19,NEMOD)
      NACTMOD=0
      DO 8 I=1,19
         IF(NEMOD(I).GT.0) NACTMOD=NACTMOD+1
    8 CONTINUE

      IF (LEVELC) THEN
         WRITE (NFOUT,*)
         TITU='ACTIVE GRID ELEMENTS'
         CALL PRTTIT(TITU)
         WRITE (NFOUT,5)
    5    FORMAT(/' MODEL    ELEMENTS')
         DO 6 I=1,19
         IF (NEMOD(I).GT.0) WRITE(NFOUT,7) I,NEMOD(I)
    6    CONTINUE
    7    FORMAT(I4,4X,I8)
      ENDIF

c bag8, djw - EVOL needed before EIADAT
C      IF (KNDGRD.EQ.3) THEN
C        IVA(1) = 4
C        IVA(2) = N_XC
C        IVA(3) = N_YC
C        IVA(4) = N_ZC
C        IVA(5) = N_EVOL
C        CALL CALLWORK(calcEVOL,IVA)
C      ENDIF

C  COMPLETE INPUT OF MODEL SPECIFIC INITIAL DATA

C      MODACT=15
C      IF (MODELON(15)) THEN
C         CALL EIADAT(NERR)
C         IF (NERR.GT.0) STOP 'Error in EIADAT'
C         GOTO 9
C      ENDIF

C      MODACT=14
C      IF (MODELON(14)) THEN
C         CALL TRIADAT(NERR)
C         IF (NERR.GT.0) STOP 'Error in TRIADAT'
C         GOTO 9
C      ENDIF

C      MODACT=7
C      IF (MODELON(7)) THEN
C         CALL MIADAT(NERR)
C         IF (NERR.GT.0) STOP 'Error in MIADAT'
C         GOTO 9
C      ENDIF

C      MODACT=2
C      IF (MODELON(2)) CALL IIADAT(NERR)
C      IF (NERR.GT.0) STOP 'Error in IIADAT'

C      MODACT=3
C      IF (MODELON(3)) CALL XIADAT(NERR)
C      IF (NERR.GT.0) STOP 'Error in XIADAT'

C      MODACT=16
C      IF (MODELON(16)) CALL XIADAT(NERR)
C      IF (NERR.GT.0) STOP 'Error in XIADAT'

C      MODACT=5
C      IF (MODELON(5)) CALL HIADAT(NERR)
C      IF (NERR.GT.0) STOP 'Error in HIADAT'

C       MODACT=19
C       IF (MODELON(19)) CALL HIADAT(NERR)
C       IF (NERR.GT.0) STOP 'Error in HIADAT'

C       MODACT=18
C       IF (MODELON(18)) CALL HIADAT(NERR)
C       IF (NERR.GT.0) STOP 'Error in HIADAT'

C       MODACT=6
C       IF (MODELON(6)) CALL GIADAT(NERR)
C       IF (NERR.GT.0) STOP 'Error in GIADAT'

      MODACT=13
      IF (MODELON(13)) CALL TIADAT(NERR)
      IF (NERR.GT.0) STOP 'Error in TIADAT'

C      MODACT=17
C      IF (MODELON(17)) CALL TIADAT(NERR)
C      IF (NERR.GT.0) STOP 'Error in TIADAT'

    9 CONTINUE
      MODEQS(1)=2
      MODEQS(2)=3
      MODEQS(3)=1
      MODEQS(16)=1
      MODEQS(4)=1
      MODEQS(5)=2
      MODEQS(19)=2
      MODEQS(18)=2
      MODEQS(6)=1
      MODEQS(7)=1
      MODEQS(9)=1
      MODEQS(13)=1
      MODEQS(17)=1
      MODEQS(14)=1
      MODACT=0

      MXNUMEQS=1
      DO 1 N=1,NUMBLK
      NUMEQS(N)=MODEQS(MODBLK(N))
C      IF (MXNUMEQS.LT.NUMEQS(N)) MXNUMEQS=NUMEQS(N)
      IF (MXNUMEQS.LT.MODEQS(FMODBLK(N))) MXNUMEQS=MODEQS(FMODBLK(N))
    1 CONTINUE

      IF (LEVERR.GT.2) RETURN

C  GET LINEAR SOLVER INITIAL DATA

C        CALL LSORI (NERR,1)
C      CALL MULGRDI (NERR,1)
C      CALL SOLI (NERR,1)
C      CALL SOLGI (NERR,1)
C      CALL PCGI (NERR,1)
      CALL HYPREI(NERR,1)
      IF (NERR.GT.0)  STOP 'Error in SOLVER INIT'
      IF (LEVERR.GT.2) RETURN

C  OUTPUT GRID PLOT DATA (TECPLOT)

      IF(.NOT.MBPOROE) THEN
      CALL VISGRID()
      ENDIF

C  INITIALIZE VISUALIZATION

           CALL TIMON(13)
           CALL VIS_INIT(NERR)
           IF (NERR.GT.0) STOP 'Error in VIS_INIT'
           CALL TIMOFF(13)

cgp: table visualization exists already in getscal and table
cC  PRINT TABLE DATA FOR VISUALIZATION
c      CALL TABLE_OUT()
cgp

C  CHECK FOR UNDEFINED DATA

      CALL UNDEF(NERR)
c      IF ((NERR.GT.0).AND.LEVELC) THEN
c     &   WRITE (NFOUT,*) 'TOTAL INITIAL DATA ERRORS =',NERR
      IF (NERR.GT.0) THEN
         IF (LEVELC) WRITE (NFOUT,*) 'TOTAL INITIAL DATA ERRORS =',NERR
         STOP 'Errors in Initial Data'
      ENDIF

      END
C*********************************************************************
      SUBROUTINE GETSCAL (NERR)
C*********************************************************************

C  EXTRACT SCALAR DATA FROM THE INITIAL KEY-WORD INPUT AND PRINT IT

C  NERR = ERROR NUMBER STEPED BY 1 ON ERROR (INPUT & OUTPUT, INTEGER)

C*********************************************************************
      USE adaptmod
C      USE dealiimod
      IMPLICIT NONE
C      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'unitsex.h'
      INCLUDE 'times.h'
      INCLUDE 'blkary.h' ! SAUMIK,BGANIS

      CHARACTER*79 DAS(22)
      CHARACTER*26 MNAMS(10),BNAMS,TNAMS
      INTEGER NDUM,NERR,I,N,L
      LOGICAL DEALII_DUM,ADAPTIVITY_DUM

      IF (LEVELE.AND.BUGKEY(1)) THEN
         WRITE (NFBUG,*)'PROC',MYPRC,' ENTERING SUBROUTINE GETSCAL'
         WRITE (*,*)'PROC',MYPRC,' ENTERING SUBROUTINE GETSCAL'
      ENDIF

C  GET THE DATA SET TITLE AND CASE DESCRIPTION

      DATTL(1)='******'
      DATTL(2)='UNTITLED DATA SET'
      DATTL(3)='******'
      CALL GETVALS('TITLE ',DATTL,'CS',3,0,0,50,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'TITLE'
      DAS(1)=' '
      CALL GETVALS('DESCRIPTION ',DAS,'CS',22,0,0,79,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'DESCRIPTION'
      IF (LEVELC) THEN
         CALL PRTTIT(DATTL(1))
         CALL PRTTIT(DATTL(2))
         CALL PRTTIT(DATTL(3))
         WRITE(NFOUT,'(1X,A79)') DAS(1)
         DO I=2,NDUM
         IF (DAS(I).NE.DAS(I-1))
     &      WRITE(NFOUT,'(1X,A79)') DAS(I)
         ENDDO
      ENDIF
   77 FORMAT(/' Input file ERROR for ',A)

C  GET THE SIMULATION PHYSICAL MODEL(S)
C  MODELON() WILL HERE BE SET TO TRUE IF THE MODEL IS ACTIVE IN ANY FAULT
C  BLOCK.  AFTER GRID ELEMENTS ARE DIVIDED AMONG PROCESSORS, IT WILL BE
C  RESET TO FALSE IF THE ACTIVE PROCESSOR IS ASSIGNED NO ELEMENTS THAT USE
C  THE MODEL.

      BNAMS=' '
      DO 32 I=1,10
      MODBLK(I)=0
      FMODBLK(I)=0
   32 MNAMS(I)=BNAMS
      DO 35 I=1,19
   35 MODELON(I)=.FALSE.

      CALL GETVALS('BLOCKMODEL ',MNAMS,'CS',10,0,0,26,NUMBLK,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'BLOCKMODEL'

      IF (LEVELC) WRITE(NFOUT,*)
      DO 33 I=1,NUMBLK

      N=1
      TNAMS='BLACK_OIL_IMPES '
C       IF (MNAMS(I).EQ.TNAMS) GO TO 34
      N=2
      TNAMS='BLACK_OIL_IMPLICIT '
C       IF (MNAMS(I).EQ.TNAMS) GO TO 34
      N=3
      TNAMS='COMPOSITIONAL_MODEL '
C         IF (MNAMS(I).EQ.TNAMS) GO TO 34
      N=16
      TNAMS='COMPOSITIONAL_MFMFE '
C         IF (MNAMS(I).EQ.TNAMS) GO TO 34
      N=4
      TNAMS='CHEMICAL_MODEL '
C         IF (MNAMS(I).EQ.TNAMS) GO TO 34
      N=5
      TNAMS='HYDROLOGY_IMPLICIT '
C       IF (MNAMS(I).EQ.TNAMS) GO TO 34
      N=19
      TNAMS='HYDROLOGY_IMPLICIT_APPROX '
C       IF (MNAMS(I).EQ.TNAMS) GO TO 34
      N=18
      TNAMS='HYDROLOGY_IMPLICIT_MFMFE '
C       IF (MNAMS(I).EQ.TNAMS) GO TO 34
      N=6
      TNAMS='HYDROLOGY_IMPES '
C       IF (MNAMS(I).EQ.TNAMS) GO TO 34
      N=7
      TNAMS='MULTI_MODEL '
C       IF (MNAMS(I).EQ.TNAMS) GO TO 34
      N=9
      TNAMS='SINGLE_PHASE_EXPLICIT '
C      IF (MNAMS(I).EQ.TNAMS) GO TO 34
      N=13
      TNAMS='SINGLE_PHASE_IMPLICIT '
      IF (MNAMS(I).EQ.TNAMS) GO TO 34
      N=17
      TNAMS='SINGLE_PHASE_MFMFE '
C      IF (MNAMS(I).EQ.TNAMS) GO TO 34
      N=14
      TNAMS='TRANSPORT_CHEMISTRY '
C      IF (MNAMS(I).EQ.TNAMS) GO TO 34
      N=15
      TNAMS='POROELASTIC '
C      IF (MNAMS(I).EQ.TNAMS) GO TO 34

      LEVERR=3
      NERR=NERR+1
      IF(MNAMS(I).EQ.BNAMS) MNAMS(I)='NONE SPECIFIED'
      IF (LEVELC) WRITE (NFOUT,12) I,MNAMS(I)
   12 FORMAT (/' ERROR # 432; INVALID SIMULATION MODEL FOR BLOCK',
     &   I4,' :'/1X,A26)
      RETURN

   34 MODBLK(I)=N
      MODELON(N)=.TRUE.
      IF (LEVELC) WRITE(NFOUT,36) I,MNAMS(I)
   36 FORMAT(' BLOCK',I4,' SIMULATION MODEL',T53,A26)

   33 CONTINUE

      NUMMODEL=0
      DO 37 I=1,19
      IF (MODELON(I)) NUMMODEL=NUMMODEL+1
   37 CONTINUE

      MODEL=0
      DO 101 I=1,19
      IF (MODELON(I)) MODEL=I
  101 CONTINUE
      IF (MODEL.EQ.0) THEN
         LEVERR=2
         MODEL=1
         IF (LEVELC) THEN
            WRITE (NFOUT,102)
  102       FORMAT (/' ERROR # 432; NO SIMULATION MODEL SPECIFIED'/
     &      ' BLACK OIL IMPES MODEL ASSUMED DURING INPUT')
         ENDIF
      ELSE
         IF (LEVELC) THEN
            IF (MODELON(1)) WRITE (NFOUT,1)
            IF (MODELON(2)) WRITE (NFOUT,2)
            IF (MODELON(3)) WRITE (NFOUT,3)
            IF (MODELON(16)) WRITE (NFOUT,115)
            IF (MODELON(4)) WRITE (NFOUT,4)
            IF (MODELON(5)) WRITE (NFOUT,5)
            IF (MODELON(18)) WRITE (NFOUT,117)
            IF (MODELON(6)) WRITE (NFOUT,6)
            IF (MODELON(7)) WRITE (NFOUT,7)
            IF (MODELON(9)) WRITE (NFOUT,9)
            IF (MODELON(13)) WRITE (NFOUT,13)
            IF (MODELON(17)) WRITE (NFOUT,116)
            IF (MODELON(14)) WRITE (NFOUT,14)
            IF (MODELON(15)) WRITE (NFOUT,100)
         ENDIF
      ENDIF
    1 FORMAT(/' SIMULATION MODEL',T56,'BLACK OIL IMPES')
    2 FORMAT(/' SIMULATION MODEL',T56,'BLACK OIL IMPLICIT')
    3 FORMAT(/' SIMULATION MODEL',T56,'COMPOSITIONAL')
    4 FORMAT(/' SIMULATION MODEL',T56,'CHEMICAL FLOOD')
    5 FORMAT(/' SIMULATION MODEL',T56,'HYDROLOGY IMPLICIT')
    6 FORMAT(/' SIMULATION MODEL',T56,'HYDROLOGY IMPES')
    7 FORMAT(/' SIMULATION MODEL',T56,'MULTI MODEL')
    9 FORMAT(/' SIMULATION MODEL',T56,'SINGLE PHASE_EXPLICIT')
   13 FORMAT(/' SIMULATION MODEL',T56,'SINGLE PHASE_IMPLICIT')
   14 FORMAT(/' SIMULATION MODEL',T56,'TRANSPORT_CHEMISTRY')
  115 FORMAT(/' SIMULATION MODEL',T56,'COMPOSITIONAL MFMFE')
  116 FORMAT(/' SIMULATION MODEL',T56,'SINGLE PHASE MFMFE')
  117 FORMAT(/' SIMULATION MODEL',T56,'HYDROLOGY IMPLICIT MFMFE')
  100 FORMAT(/' SIMULATION MODEL',T56,'POROELASTIC')

C  SET C POINTERS

      MODACT=0
      CALL PNTMMOD(MODACT,FMODBLK,MODBLK)

C  INITIALIZE AND INPUT DEFAULT EXTERNAL UNITS

      CALL SETEXU(NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'SETEXU'

C  INITIALIZE ACTION TIMES AND READ TERMINATION TIME

      NACTTIM=6
      DO 24 I=1,10
   24 ACTTIM(I)=99.D15

      ACTTIM(1)=10.D0
      CALL DEFAULT(EXTTIME)
      CALL GETVAL('TIMEEND[day] ',ACTTIM(1),'R8',0,0,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'TIMEEND'
      IF (LEVELC) WRITE (NFOUT,16) ACTTIM(1)*CVMTIME,EXTTIME
   16 FORMAT(/' SIMULATION STOP TIME (TIMEEND)',T49,F10.2,1X,A20)

      IF (RTIMIN.GT.0.D0) THEN
         IF (LEVELC) WRITE (NFOUT,51) RTIMIN*CVMTIME,EXTTIME
   51    FORMAT(' RESTART SIMULATION TIME (RESTART)',T49,F10.2,1X,A20)
      ELSE
         IF (LEVELC) WRITE (NFOUT,15)
   15    FORMAT(' RESTART SIMULATION (RESTART)',T56,'NO')
      ENDIF

C  PRINT NUMBER OF PROCESSORS

      IF (LEVELC) WRITE (NFOUT,25) NUMPRC
   25 FORMAT(' NUMBER OF PROCESSORS',T50,I7)

C  INPUT MAX NEWTONIAN ITERATIONS

      MAXITS=14
      CALL GETVAL('MAXNEWT ',MAXITS,'I4',0,0,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'MAXNEWT'
      IF (LEVELC) WRITE (NFOUT,40) MAXITS
   40 FORMAT(' MAX NEWTONIAN ITERATIONS (MAXNEWT)',T50,I7)

C  GET OUTPUT CONTROL

      L=2
      CALL GETVAL('OUTLEVEL ',L,'I4',0,0,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'OUTLEVEL'
      LEVELA=.FALSE.
      LEVELB=.FALSE.
      LEVELC=.FALSE.
      IF (MYPRC.EQ.0) THEN
         LEVELC=.TRUE.
         IF (L.GT.1) LEVELB=.TRUE.
         IF (L.GT.2) LEVELA=.TRUE.
         IF (L.EQ.1) WRITE (NFOUT,17)
         IF (L.EQ.2) WRITE (NFOUT,18)
         IF (L.EQ.3) WRITE (NFOUT,19)
      ENDIF
   17 FORMAT(' USER OUTPUT LEVEL (OUTLEVEL)',T56,'MINIMUM')
   18 FORMAT(' USER OUTPUT LEVEL (OUTLEVEL)',T56,'STANDARD')
   19 FORMAT(' USER OUTPUT LEVEL (OUTLEVEL)',T56,'MAXIMUM')

      LEVELD=.FALSE.
      CALL GETVAL('DEBUGS ',LEVELD,'FG',0,0,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'DEBUGS'
      LEVELE=.FALSE.
      CALL GETVAL('DEBUGM ',LEVELE,'FG',0,0,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'DEBUGM'
      DO I=1,15
      BUGKEY(I)=.FALSE.
      ENDDO
      CALL GETVAL('BUGKEY ',BUGKEY,'FG',15,0,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'BUGKEY'
      IF (NDUM.GT.0) CALL OPENBUG()

! bag8 - see memman/divide.df:PRINT_VM_INFO
      VMDEBUG=.FALSE.
      CALL GETVAL('VMDEBUG ',VMDEBUG,'FG',0,0,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'VMDEBUG'

      IF (MYPRC.EQ.0) THEN
         IF (LEVELD) THEN
            WRITE (NFOUT,26)
         ELSE
            WRITE (NFOUT,47)
         ENDIF
   26    FORMAT(' SINGLE PROCESSOR DEBUG OUTPUT (DEBUGS)',T56,'YES')
   47    FORMAT(' SINGLE PROCESSOR DEBUG OUTPUT (DEBUGS)',T56,'NO')
         IF (LEVELE) WRITE (NFOUT,27)
   27    FORMAT(' MULTI-PROCESSOR DEBUG OUTPUT (DEBUGM)',T56,'YES')
      ENDIF

      SPLNOUT=.FALSE.
      CALL GETVAL('SPLINEOUT ',SPLNOUT,'FG',0,0,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'SPLINEOUT'
      IF (SPLNOUT) THEN
         IF (LEVELC) WRITE (NFOUT,20)
   20    FORMAT(' DETAILED SPLINE OUTPUT (SPLINEOUT)',T56,'YES')
      ELSE
         IF (LEVELC) WRITE (NFOUT,21)
   21    FORMAT(' DETAILED SPLINE OUTPUT (SPLINEOUT)',T56,'NO')
      ENDIF

      GEOMOUT=.FALSE.
      CALL GETVAL('GEOMOUT ',GEOMOUT,'FG',0,0,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'GEOMOUT'
      IF (GEOMOUT) THEN
         IF (LEVELC) WRITE (NFOUT,22)
   22    FORMAT(' DETAILED GEOMETRY OUTPUT (GEOMOUT)',T56,'YES')
      ELSE
         IF (LEVELC) WRITE (NFOUT,23)
   23    FORMAT(' DETAILED GEOMETRY OUTPUT (GEOMOUT)',T56,'NO')
      ENDIF

      ALLTIMES=.FALSE.
      CALL GETVAL('ALLTIMES ',ALLTIMES,'FG',0,0,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'ALLTIMES'
      IF (ALLTIMES) THEN
         IF (LEVELC) WRITE (NFOUT,38)
   38    FORMAT(' DETAILED TIMER OUTPUT (ALLTIMES)',T56,'YES')
      ELSE
         IF (LEVELC) WRITE (NFOUT,39)
   39    FORMAT(' DETAILED TIMER OUTPUT (ALLTIMES)',T56,'NO')
      ENDIF

      SEISMIC=.FALSE.
      CALL GETVAL('SEISMIC ',SEISMIC,'FG',0,0,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'SEISMIC'
      IF (SEISMIC) THEN
         IF (LEVELC) WRITE (NFOUT,49)
   49    FORMAT(' SEISMIC DATA OUTPUT (SEISMIC)',T56,'YES')
      ELSE
         IF (LEVELC) WRITE (NFOUT,50)
   50    FORMAT(' SEISMIC DATA OUTPUT (SEISMIC)',T56,'NO')
      ENDIF

      IF (MYPRC.NE.0) THEN
         LEVELD=.FALSE.
         SPLNOUT=.FALSE.
         GEOMOUT=.FALSE.
      ENDIF

C  GET PLOT OUTPUT CONTROL

      CALL VTABINIT(NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,78) 'VTABINIT'

C  GET CONTROL FOR PROCESSOR DISTRIBUTION

      METHOD=1
      CALL GETVAL('METHOD ',METHOD,'I4',0,0,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'METHOD'
      IF (LEVELC.AND.NUMPRC.GT.1) THEN
         IF (METHOD.EQ.1) WRITE (NFOUT,29)
   29    FORMAT(' SQUARE PROCESSOR ASSIGNMENT (METHOD)')
         IF (METHOD.EQ.2) WRITE (NFOUT,30)
   30    FORMAT(' K-STRIP PROCESSOR ASSIGNMENT (METHOD)')
         IF (METHOD.EQ.3) WRITE (NFOUT,31)
   31    FORMAT(' J-STRIP PROCESSOR ASSIGNMENT (METHOD)')

C         IF (METHOD.EQ.5) WRITE (NFOUT,300)
C  300    FORMAT(' METIS 7-PT ELEMENT PARTITIONING (METHOD)')
C         IF (METHOD.EQ.6) WRITE (NFOUT,301)
C  301    FORMAT(' METIS 27-PT ELEMENT PARTITIONING (METHOD)')
C         IF (METHOD.EQ.7) WRITE (NFOUT,302)
C  302    FORMAT(' METIS 27-PT NODE PARTITIONING (METHOD)')

      ENDIF

! bag8 - option to inherit processor assignment from one fault block
!        (defaults to zero, off)
      EV_PRCBLK=0
      CALL GETVAL('EV_PRCBLK ',EV_PRCBLK,'I4',0,0,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'EV_PRCBLK'

! bag8
C      CALL GETVAL('DEALII ',DEALII_DUM,'FG',0,0,0,0,NDUM,NERR)
C      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'DEALII'
C      IF (DEALII) THEN
C        IF (.NOT.DEALII_DUM) THEN
C          STOP 'DEALII: dealii flag must be set in input file'
C        ELSEIF (NUMBLK.NE.NLEV) THEN
C          STOP 'DEALII: NUMBLK must equal NLEV'
C        ELSEIF (EV_PRCBLK.LE.0) THEN
C          STOP 'DEALII: EV_PRCBLK should be used'
C        ENDIF
C      ENDIF

! bag8
      ADAPTIVITY_DUM =.FALSE.
      CALL GETVAL('ADAPTIVITY ',ADAPTIVITY_DUM,'FG',0,0,0,0,NDUM,NERR)
      IF (.NOT.DEALII) THEN
        ADAPTIVITY = ADAPTIVITY_DUM
      ENDIF
      ADAPT_MODE=0
      ADAPT_VARS=0
      IF (ADAPTIVITY.AND.(.NOT.DEALII)) THEN
        CALL GETVAL('ADAPT_VARS ',ADAPT_VARS,'I4',0,0,0,0,NDUM,NERR)
        IF (ADAPT_VARS.GT.MXADAPT) THEN
          CALL KILL_IPARS('Error: ADAPT_VARS exceeds MXADAPT')
        ENDIF
        CALL GETVAL('ADAPT_MODE ',ADAPT_MODE,'I4',0,0,0,0,NDUM,NERR)
        IF (MYPRC.EQ.0) WRITE(*,*)'ADAPT_MODE=',ADAPT_MODE

        IF ((ADAPT_MODE.GE.1).AND.(ADAPT_MODE.LE.3)) THEN
          CALL GETVALS('ADAPT_VAR ',ADAPT_VAR,'CS',ADAPT_VARS,
     &      0,0,20,NDUM,NERR)
          ADAPT_TOL=5.D-2
          CALL GETVAL('ADAPT_TOL ',ADAPT_TOL,'R8',ADAPT_VARS,
     &      0,0,0,NDUM,NERR)
          IF (MYPRC.EQ.0) THEN
            DO I=1,ADAPT_VARS
              WRITE(*,'(1X,A,I2,2A,T30,A,I2,A,1P,G9.2)')
     &          'ADAPT_VAR(',I,')=',TRIM(ADAPT_VAR(I)),
     &          'ADAPT_TOL(',I,')=',ADAPT_TOL(I)
            ENDDO
          ENDIF

        ELSEIF ((ADAPT_MODE.GE.4).AND.(ADAPT_MODE.LT.6)) THEN
          REFINE_TOL=99999.D15
          CALL GETVAL('REFINE_TOL ',REFINE_TOL,'R8',0,0,0,0,
     &      NDUM,NERR)
          IF (MYPRC.EQ.0) WRITE(*,*)'REFINE_TOL=',REFINE_TOL
          COARSE_TOL=0.0D0
          CALL GETVAL('COARSE_TOL ',COARSE_TOL,'R8',0,0,0,0,
     &      NDUM,NERR)
          IF (MYPRC.EQ.0) WRITE(*,*)'COARSE_TOL=',COARSE_TOL
          ADAPT_START_FINE = .FALSE.
          CALL GETVAL('ADAPT_START_FINE ',ADAPT_START_FINE,
     &      'L4',0,0,0,0,NDUM,NERR)
          ADAPT_INDICATOR = 1
          CALL GETVAL('ADAPT_INDICATOR ',ADAPT_INDICATOR,
     &      'I4',0,0,0,0,NDUM,NERR)
          ADAPT_REFINE_MOVE1 = .FALSE.
          CALL GETVAL('ADAPT_REFINE_MOVE1 ',ADAPT_REFINE_MOVE1,
     &      'L4',0,0,0,0,NDUM,NERR)
          ADAPT_RESET = .FALSE.
          CALL GETVAL('ADAPT_RESET ',ADAPT_RESET,
     &      'L4',0,0,0,0,NDUM,NERR)
        ENDIF

      ENDIF

      IF (ADAPTIVITY.OR.DEALII) THEN
        NLEVA=NUMBLK
        CALL GETVAL('NLEVA ',NLEVA,'I4',0,0,0,0,NDUM,NERR)
        IF (MYPRC.EQ.0) WRITE(*,*)'NLEVA=',NLEVA
        NDIMA=2
        CALL GETVAL('NDIMA ',NDIMA,'I4',0,0,0,0,NDUM,NERR)
        IF (MYPRC.EQ.0) WRITE(*,*)'NDIMA=',NDIMA
        NSTRIDE=2
        CALL GETVAL('NSTRIDE ',NSTRIDE,'I4',0,0,0,0,NDUM,NERR)
        IF (MYPRC.EQ.0) WRITE(*,*)'NSTRIDE=',NSTRIDE
        ADAPT_MARK_LEVEL = .FALSE.
        CALL GETVAL('ADAPT_MARK_LEVEL ',ADAPT_MARK_LEVEL,
     &    'L4',0,0,0,0,NDUM,NERR)
      ENDIF

      IF (.FALSE.) THEN
        IF (ADAPTIVITY) CALL KILL_IPARS('Error: ADAPTIVITY needs DUAL')
        IF (DEALII) CALL KILL_IPARS('Error: DEALII needs DUAL')
      ENDIF

!---saumik
      MBPOROE=.FALSE.
      ! SAUMIK,BGANIS
      ! FLAG TO SWITCH MBPOROE CODE ON OR OFF
      CALL GETVAL('MBPOROE ',MBPOROE,'FG',0,0,0,0,NDUM,NERR)
      IF(LEVELC) THEN
        WRITE (NFOUT,"('MBPOROE = ',T55,L10)") MBPOROE
      ENDIF

      NONMATCHING=.FALSE.
      ! SAUMIK,BGANIS
      ! FLAG TO SWITCH PROJECTION OPERATORS ON OR OFF
      CALL GETVAL('NONMATCHING ',NONMATCHING,'FG',0,0,0,0,NDUM,NERR)
      IF(LEVELC) THEN
        WRITE (NFOUT,"('NONMATCHING = ',T55,L10)") NONMATCHING
      ENDIF

      IF (MBPOROE) THEN
        IF (EV_PRCBLK.EQ.0) THEN
          CALL KILL_IPARS('MBPOROE requires EV_PRCBLK > 0')
        ENDIF
        IF (NONMATCHING) THEN
C          GOTO 213
          CALL KILL_IPARS('NONMATCHING requires $TETGEN')
 213      CONTINUE
        ENDIF
      ENDIF
!---saumik

c mpesz call to setblks establishes which model is present in which
c faultblock and how many different physcial models are present

      CALL SETBLKS (NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,78) 'SETBLKS'
   78 FORMAT(/' Error in ',A)

! bag8 - multirate is off by default
        Q_MULTIRATE=1

! bag8 - binary input
      BINARY_INPUTS=0
      CALL GETVAL('BINARY_INPUTS ',BINARY_INPUTS,'I4',0,0,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'BINARY_INPUTS'
      IF (BINARY_INPUTS.GT.MXBINARY)
     &  CALL KILL_IPARS('Error: Need to increase MXBINARY')

      CALL GETVALS('INCLUDE_BINARY ',INCLUDE_BINARY,'CS',
     &  BINARY_INPUTS,0,0,50,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'INCLUDE_BINARY'
      IF (MYPRC.EQ.0) THEN
      DO I=1,BINARY_INPUTS
      WRITE(*,'(1x,a,i2,2a)')'INCLUDE_BINARY(',I,')=',
     &  TRIM(INCLUDE_BINARY(I))
      ENDDO
      ENDIF

! bag8 - flag for ignoring time information when reading a restart file
!        (useful for inputting initial conditions from prior runs)
      ZERO_RESTART = .FALSE.
      CALL GETVAL('ZERO_RESTART ',ZERO_RESTART,'FG',
     &  0,0,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77)'ZERO_RESTART'

C  READ MODEL SPECIFIC SCALARS

C bag8, djw - special case for driving models that are not flow models

C        MODACT=15
C        IF (MODELON(15)) THEN
C           CALL EISDAT(NERR)
C           IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,78) 'EISDAT'
C           GOTO 1000
C        ENDIF
C      MODACT=14
C      IF (MODELON(14)) THEN
C         CALL TRISDAT(NERR)
C         IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,78) 'TRISDAT'
C         GOTO 1000
C      ENDIF
C      MODACT=7
C      IF (MODELON(7)) THEN
C         CALL MISDAT(NERR)
C         IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,78) 'MISDAT'
C         GOTO 1000
C      ENDIF
C      MODACT=7
C      MODACT=2
C      IF (MODELON(2)) CALL IISDAT(NERR)
C      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,78) 'IISDAT'
C      MODACT=3
C      IF (MODELON(3)) CALL XISDAT(NERR)
C      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,78) 'XISDAT'
C      MODACT=16
C      IF (MODELON(16)) CALL XISDAT(NERR)
C      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,78) 'XISDAT'
C      MODACT=5
C      IF (MODELON(5)) CALL HISDAT(NERR)
C      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,78) 'HISDAT'
C      MODACT=19
C      IF (MODELON(19)) CALL HISDAT(NERR)
C      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,78) 'HISDAT'
C       MODACT=18
C       IF (MODELON(18)) CALL HISDAT(NERR)
C       IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,78) 'HISDAT'
      MODACT=13
      IF (MODELON(13)) CALL TISDAT(NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,78) 'TISDAT'
C      MODACT=17
C      IF (MODELON(17)) CALL TISDAT(NERR)
C      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,78) 'TISDAT'

 1000 MODACT=0

C  IF TRCHEM IS DRIVING PHYSICAL MODEL ASSIGN FAULT BLOCK
C  FLOW MODELS (NOTE: CURRENTLY ASSUMING ONE FOR WHOLE
C  RESERVOIR. BUT THIS CAN BE TRIVIALLY CORRECTED BUT
C  CHANGES NEED TO BE POPULATED THROUGOUT TRCHEM BY USING
C  MODELON(FLOWMODEL #) THERE INSTEAD OF FLOWMODEL!)

      DO I=1,10
         IF(MODBLK(I).NE.0) THEN
            IF((MODELON(14).OR.MODELON(7).OR.
     &         MODELON(15)).AND.(.NOT.MBPOROE)) THEN
               FMODBLK(I)=FLOWMODEL
            ELSE
            ! SAUMIK,BGANIS
            ! ASSIGN FMODBLK=MODBLK IF MBPOROE IS TRUE
               FMODBLK(I)=MODBLK(I)
            ENDIF
         ENDIF
      ENDDO

! bag8
      GEADBG=0
      CALL GETVAL('GEADBG ',GEADBG,'I4',0,0,0,0,NDUM,NERR)
      IF ((GEADBG.NE.0).AND.(MYPRC.EQ.0)) THEN
        WRITE(*,*) REPEAT('*',72)
        WRITE(*,*) 'GEADBG = ',GEADBG
        WRITE(*,*) REPEAT('*',72)
      ENDIF

      RETURN
      END

C*********************************************************************
      SUBROUTINE GETROCK (NERR)
C*********************************************************************

C  Extracts 2-phase relative permeabilities and capillary pressures
C  and forms 1-D tables.  Assigns rock types to grid elements.  Extracts
C  permeabiities and porosities.

C  NERR = Error number steped by 1 on error (input & output, INTEGER)

C*********************************************************************
      IMPLICIT NONE

C      INCLUDE 'msjunk.h'

      INCLUDE 'control.h'
      INCLUDE 'rock.h'
      INCLUDE 'blkary.h'
      INCLUDE 'unitsex.h'
      INCLUDE 'utldat.h'
      INCLUDE 'layout.h'
      CHARACTER*1 BLKBUF(4000)
      CHARACTER*50 TABTIT
      INTEGER LOCTA(50),LENTA(50),MARG(3)

      INTEGER KERR,NDUM,NERR,KFERR,NDUM1,NDUM2,NDUM3,NDUM4,I

      EXTERNAL SETARYI4,CPYARYR4,SETARYR4,PERMSCALE,GETPOR,SETARYR8

      IF (LEVELE.AND.BUGKEY(1)) THEN
         WRITE (NFBUG,*)'PROC',MYPRC,' ENTERING SUBROUTINE GETROCK'
         WRITE (*,*)'PROC',MYPRC,' ENTERING SUBROUTINE GETROCK'
      ENDIF

      IF (LEVELC) THEN
         WRITE (NFOUT,*)
         TITU='******'
         CALL PRTTIT(TITU)
         TITU='ROCK DATA'
         CALL PRTTIT(TITU)
      ENDIF
      MXROCK=0

C  EXTRACT ROCK TYPES OF THE GRID ELEMENTS

      MARG(1)=2
      MARG(2)=N_ROCK
      MARG(3)=N_I4U
      I4UTIL=1
      CALL CALLWORK (SETARYI4,MARG)
      KERR = 0
      CALL GETGRDA ('ROCK ',1,NDUM,KERR)

      IF (KERR.GT.0) THEN
         IF (LEVELC) WRITE (NFOUT,14)
   14    FORMAT (/' ERROR 503; INVALID ROCK TYPES SPECIFIED')
         NERR=NERR+1
      ELSE
         TITU='ELEMENT ROCK TYPES FOR FAULT BLOCK'
         CALL GEAOUT(N_ROCK,1,1)
      ENDIF

C  EXTRACT POROSITIES OF THE GRID ELEMENTS

      IF (KNDGRD==3) THEN
CGUS ---- real*8 porosity for MFMFE discretization
         MARG(1)=2
         MARG(2)=N_POR
         MARG(3)=N_R8U
         R8UTIL=0.15D0
         CALL CALLWORK (SETARYR8,MARG)
         KERR = 0
         CALL GETGRDA ('POROSITY ',1,NDUM,KERR)
      ELSE
         MARG(1)=2
         MARG(2)=N_POR
         MARG(3)=N_R4U
         R4UTIL=.15
         CALL CALLWORK (SETARYR4,MARG)
         KERR = 0
         CALL GETGRDA ('POROSITY ',1,NDUM,KERR)
         MARG(1)=2
         MARG(2)=N_POR
         MARG(3)=N_PORO
         CALL CALLWORK(GETPOR,MARG)
      ENDIF

      IF (KERR.GT.0) THEN
         IF (LEVELC) WRITE (NFOUT,15)
   15    FORMAT (/' ERROR 504; POROSITY ERROR')
         NERR=NERR+1
      ELSE
         TITU='ELEMENT POROSITIES FOR FAULT BLOCK'
         CALL GEAOUT(N_POR,1,1)
      ENDIF

C  EXTRACT PERMEABILITIES OF THE GRID ELEMENTS
C  SET A FLAG FOR OPTIONALLY SCALING Y- AND Z-PERMS BY A FACTOR
C  TIMES THE X-PERM

      KFERR=0
      NDUM4=0
      PERM_HTOV=1.0
      CALL GETVAL('PERM_HTOV_RATIO ',PERM_HTOV,'R4',0,0,0,0,NDUM4,KFERR)
      IF(KFERR.GT.0) THEN
         IF (LEVELC) WRITE (NFOUT,31)
   31    FORMAT (' ERROR 508; ERROR READING PERM_HTOV_RATIO')
         NERR=NERR+1
         NDUM4=0
      else
         IF (LEVELC) WRITE (NFOUT,19) PERM_HTOV
   19    FORMAT(' RATIO OF HOR to VERT PERMEABILITY',T48,F12.3)

      ENDIF

      MARG(1)=2
      MARG(2)=N_XPERM
      MARG(3)=N_R4U
      R4UTIL=50.
      CALL CALLWORK (SETARYR4,MARG)
      CALL DEFAULT(EXTPERM)
      KERR = 0
      CALL GETGRDA ('XPERM[md] ',1,NDUM1,KERR)
      IF (KERR.GT.0) THEN
         IF (LEVELC) WRITE (NFOUT,16)
   16    FORMAT (/' ERROR 505; X PERMEABILITY ERROR')
         NERR=NERR+1
         NDUM1=0
      ELSE
         IF (NDUM1.GT.0) THEN
            TITU='X PERMEABILITIES FOR FAULT BLOCK'
            CALL GEAOUT(N_XPERM,1,1)
         ENDIF
      ENDIF

      CALL DEFAULT(EXTPERM)
      KERR = 0
      CALL GETGRDA ('YPERM[md] ',1,NDUM2,KERR)
      IF (KERR.GT.0) THEN
         IF (LEVELC) WRITE (NFOUT,17)
   17    FORMAT (/' ERROR 505; Y PERMEABILITY ERROR')
         NERR=NERR+1
         NDUM2=0
      ENDIF
      IF (NDUM2.GT.0) THEN
         TITU='Y PERMEABILITIES FOR FAULT BLOCK'
         CALL GEAOUT(N_YPERM,1,1)
      ENDIF
Cxk   XPERM IS READIN WITHOUT YPERM
      IF (NDUM1.GT.0.AND.NDUM2.EQ.0) THEN
        IF(NDUM4.GT.0.AND.KFERR.EQ.0.AND.PERM_HTOV.NE.1.0) THEN
         MARG(1)=2
         MARG(2)=N_XPERM
         MARG(3)=N_YPERM
         CALL CALLWORK(PERMSCALE,MARG)
         IF (LEVELC) WRITE (NFOUT,32) PERM_HTOV
   32    FORMAT(/' Y-PERMEABILITY SCALED ON X-PERMEABILITY FOR',
     &           ' ALL FAULT BLOCKS WITH FACTOR=',F7.4)
      ELSE
         MARG(1)=2
         MARG(2)=N_XPERM
         MARG(3)=N_YPERM
         CALL CALLWORK(CPYARYR4,MARG)
         IF (LEVELC) WRITE (NFOUT,20)
   20    FORMAT(/' X PERMEABILITY COPIED TO Y PERMEABILITY FOR',
     &   ' ALL FAULT BLOCKS')
        ENDIF
      ENDIF
Cxk   YPERM IS READIN WITHOUT XPERM
      IF (NDUM1.EQ.0.AND.NDUM2.GT.0) THEN
        IF(NDUM4.GT.0.AND.KFERR.EQ.0.AND.PERM_HTOV.NE.1.0) THEN
         MARG(1)=2
         MARG(2)=N_YPERM
         MARG(3)=N_XPERM
         CALL CALLWORK(PERMSCALE,MARG)
         IF (LEVELC) WRITE (NFOUT,34) PERM_HTOV
   34    FORMAT(/' X-PERMEABILITY SCALED ON Y-PERMEABILITY FOR',
     &           ' ALL FAULT BLOCKS WITH FACTOR=',F7.4)
        ELSE
         MARG(1)=2
         MARG(2)=N_YPERM
         MARG(3)=N_XPERM
         CALL CALLWORK(CPYARYR4,MARG)
         IF (LEVELC) WRITE (NFOUT,24)
   24    FORMAT(/' Y PERMEABILITY COPIED TO X PERMEABILITY FOR',
     &   ' ALL FAULT BLOCKS')
        ENDIF
      ENDIF
      IF (.NOT.DEALII.AND.NDUM1.EQ.0.AND.NDUM2.EQ.0) THEN
         WRITE (*,*) ' XPERM and YPERM ERROR, STOP!'
         STOP
      ENDIF

      CALL DEFAULT(EXTPERM)
      KERR = 0
      CALL GETGRDA ('ZPERM[md] ',1,NDUM3,KERR)
      IF (KERR.GT.0) THEN
         IF (LEVELC) WRITE (NFOUT,18)
   18    FORMAT (/' ERROR 505; INVALID Z PERMEABILITY')
         NERR=NERR+1
         NDUM3=0
      ENDIF
      IF (NDUM3.GT.0) THEN
         TITU='Z PERMEABILITIES FOR FAULT BLOCK'
         CALL GEAOUT(N_ZPERM,1,1)
      ELSE
         MARG(1)=2
         MARG(2)=N_YPERM
         MARG(3)=N_ZPERM
         CALL CALLWORK(CPYARYR4,MARG)
         IF (LEVELC) WRITE (NFOUT,21)
   21    FORMAT(/' Y PERMEABILITY COPIED TO Z PERMEABILITY FOR',
     &   ' ALL FAULT BLOCKS')
      ENDIF

C  EXTRACT 2 PHASE RELATIVE PERMEABILITY DATA AND FORM TABLES

      DO 1 I=1,50
      NKOSW(I)=0
    1 LENTA(I)=0
      CALL GETBLK('KOSW ',BLKBUF,4000,50,LOCTA,LENTA,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,*) 'Error reading KOSW'
      DO 2 I=1,50
      IF (LENTA(I).GT.0) THEN
         TABTIT='Ko VS Sw FOR ROCK TYPE'
         CALL MAKTIT(TABTIT,50,I)
         CALL TABLE(BLKBUF(LOCTA(I)),LENTA(I),'Sw ','Ko ',TABTIT,
     &    NKOSW(I),NERR)
         IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,*)'Error in KoSw table'
         IF (MXROCK.LT.I) MXROCK=I
cgp      CALL VIS_SETTAB(I,NKOSW(I),'KOSW_',0.D0,1.D0 )
      ENDIF
    2 CONTINUE

      DO 3 I=1,50
      NKWSW(I)=0
    3 LENTA(I)=0
      CALL GETBLK('KWSW ',BLKBUF,4000,50,LOCTA,LENTA,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,*) 'Error reading KWSW'
      DO 4 I=1,50
      IF (LENTA(I).GT.0) THEN
         TABTIT='Kw VS Sw FOR ROCK TYPE'
         CALL MAKTIT(TABTIT,50,I)
         CALL TABLE(BLKBUF(LOCTA(I)),LENTA(I),'SW ','Kw ',TABTIT,
     &    NKWSW(I),NERR)
         IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,*)'Error in KwSw table'
         IF (MXROCK.LT.I) MXROCK=I
cgp      CALL VIS_SETTAB(I,NKWSW(I),'KWSW_',0.D0,1.D0 )
      ENDIF
    4 CONTINUE

      DO 5 I=1,50
      NKOSG(I)=0
    5 LENTA(I)=0
      CALL GETBLK('KOSG ',BLKBUF,4000,50,LOCTA,LENTA,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,*) 'Error reading KOSG'
      DO 6 I=1,50
      IF (LENTA(I).GT.0) THEN
         TABTIT='Ko VS Sg FOR ROCK TYPE'
         CALL MAKTIT(TABTIT,50,I)
         CALL TABLE(BLKBUF(LOCTA(I)),LENTA(I),'Sg ','Ko ',TABTIT,
     &    NKOSG(I),NERR)
         IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,*)'Error in KoSg table'
         IF (MXROCK.LT.I) MXROCK=I
cgp      CALL VIS_SETTAB(I,NKOSG(I),'KOSG_',0.D0,1.D0 )
      ENDIF
    6 CONTINUE

      DO 7 I=1,50
      NKGSG(I)=0
    7 LENTA(I)=0
      CALL GETBLK('KGSG ',BLKBUF,4000,50,LOCTA,LENTA,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,*) 'Error reading KGSG'
      DO 8 I=1,50
      IF (LENTA(I).GT.0) THEN
         TABTIT='Kg VS Sg FOR ROCK TYPE'
         CALL MAKTIT(TABTIT,50,I)
         CALL TABLE(BLKBUF(LOCTA(I)),LENTA(I),'Sg ','Kg ',TABTIT,
     &    NKGSG(I),NERR)
         IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,*)'Error in KgSg table'
         IF (MXROCK.LT.I) MXROCK=I
cgp      CALL VIS_SETTAB(I,NKGSG(I),'KGSG_',0.D0,1.D0 )
      ENDIF
    8 CONTINUE

C  SET PARAMETERS FOR 3 PHASE RELATIVE PERMEABILITIES

      CALL SETREL3(NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,*) 'Error in SETREL3'

C  EXTRACT 2 PHASE CAPILLARY PRESSURE DATA AND FORM TABLES

      DO 9 I=1,50
      NPCOW(I)=0
    9 LENTA(I)=0
      CALL GETBLK('PCOW ',BLKBUF,4000,50,LOCTA,LENTA,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,*) 'Error reading PCOW'
      DO 10 I=1,50
      IF (LENTA(I).GT.0) THEN
         TABTIT='Pcow VS Sw FOR ROCK TYPE'
         CALL MAKTIT(TABTIT,50,I)
         CALL TABUNT ('[]',EXTPRES)
         CALL TABLE(BLKBUF(LOCTA(I)),LENTA(I),'Sw ','Pc[psi] ',
     &    TABTIT,NPCOW(I),NERR)
         IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,*)'Error in PcSw table'
         IF (MXROCK.LT.I) MXROCK=I
         SATWC(I)=TRANC1(NPCOW(I))
cgp      CALL VIS_SETTAB(I,NPCOW(I),'PCOW_',
cgp     &        SATWC(I)*1.1D0,1.D0 )
      ENDIF
   10 CONTINUE

      DO 11 I=1,50
      NPCGO(I)=0
   11 LENTA(I)=0
      CALL GETBLK('PCGO ',BLKBUF,4000,50,LOCTA,LENTA,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,*) 'Error reading PCGO'
      DO 12 I=1,50
      IF (LENTA(I).GT.0) THEN
         TABTIT='Pcgo VS So FOR ROCK TYPE'
         CALL MAKTIT(TABTIT,50,I)
         CALL TABUNT ('[]',EXTPRES)
         CALL TABLE(BLKBUF(LOCTA(I)),LENTA(I),'So ','Pc[psi] ',
     &    TABTIT,NPCGO(I),NERR)
         IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,*)'Error in PcSo table'
         IF (MXROCK.LT.I) MXROCK=I
         SATOC(I)=TRANC1(NPCGO(I))
cgp      CALL VIS_SETTAB(I,NPCGO(I),'PCGO_',
cgp     &        SATOC(I)*1.1D0,1.D0 )
      ENDIF
   12 CONTINUE

      END

C*********************************************************************
      SUBROUTINE SETGEOMNEW (NERR)
C*********************************************************************

C  Extracts geometry data from the keyword super array, divides the
C  grid elements among the processors, and initializes memory management.
C  Gets activated only for multiblock problem

C  NERR = Error number steped by 1 on error (input & output, INTEGER)

C*********************************************************************
C      USE dealiimod
      IMPLICIT NONE
C      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'blkary.h'
      INCLUDE 'output.h'
      INCLUDE 'unitsex.h'
      INCLUDE 'mpif.h' ! SAUMIK,BGANIS
      INCLUDE 'readdat.h' ! BGANIS

      INTEGER NERR,ND
      CHARACTER*60 BNAM(10)
      INTEGER MXR,NARG(5),NX(10),NY(10),NZ(10),NVALS,
     &        NBM,N,N0,N0N,NYM,NYMN,NFRE,NCPB,I,J,K,NERRO,M,KERR,
     &        L,LDUM,NDUM,NDUM1,NDUM2,NDUM3,NUMCOL,NUMZZZ
      PARAMETER (MXR=3)
      LOGICAL PRCOUT,TOPSURF,FLAG,REF_GRID_SET
      REAL*8 DUB1,DUB2,DUB3
      EXTERNAL DEPTH1,DEPTH2,DEPTH1_TOP,SETARYI4
C     &          ,DEPTH3,SET_MFMFE_BRICKS
C      EXTERNAL D2TOKEYOUT,D2TOKEYOUT_DS

C --- SAUMIK,BGANIS
      INTEGER IDIMG,JDIMG,KDIMG
! saumik - tempmap1 and tempmap2 needed for appending processor map
      INTEGER,ALLOCATABLE::TEMPMAP1(:),TEMPMAP2(:)
! saumik - temp,flowcount,ecount,flowprocs,flowprocsval,flowproc,
!          orig_group,new_group,ii needed to generate communicator
      INTEGER TEMP,FLOWCOUNT,ECOUNT
      INTEGER,ALLOCATABLE::FLOWPROCS(:),FLOWPROCSVAL(:),FLOWPROC(:)
      INTEGER ORIG_GROUP(10),NEW_GROUP(10),II
      EXTERNAL APPENDMAP
      REAL*8, ALLOCATABLE :: XLOC(:,:,:)
      CHARACTER*10 STR
C --- SAUMIK,BGANIS
      REAL*8 CV

      IF (CONV_FACTOR.EQ.1) THEN
        CV = 1.D0
      ELSE
        CV = 3.280839895D0   ! meters to feet
      ENDIF

      NERRO=NERR

      IF (LEVELE.AND.BUGKEY(1)) THEN
         WRITE (NFBUG,*)'PROC',MYPRC,' ENTERING SUBROUTINE SETGEOMNEW'
         WRITE (*,*)'PROC',MYPRC,' ENTERING SUBROUTINE SETGEOMNEW'
      ENDIF

      IF (LEVELC) THEN
         WRITE (NFOUT,*)
         TITU='******'
         CALL PRTTIT(TITU)
         TITU='GEOMETRY DATA'
         CALL PRTTIT(TITU)
      ENDIF

C  SET GRAVITY CONSTANT (PSI SQ-FT / LB)

      GRAV=.006944445D0

C  bag8 - SET CONVERSION FACTOR ((CU-FT CP) / (PSI DAY))

      CONV_FACTOR = 6.3282864D-3
      CALL GETVAL('CONV_FACTOR ',CONV_FACTOR,'R8',0,0,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'CONV_FACTOR'
!      IF (LEVELC) WRITE(NFOUT,*)'CONV_FACTOR=',CONV_FACTOR
      IF (CONV_FACTOR.LE.0.D0) THEN
        STOP 'CONV_FACTOR must be greater than zero'
      ENDIF

C  PROCESS GRID BLOCK NAMES AND SIZES

      DO 1 I=1,10
      NX(I)=-1
      NY(I)=-1
      NZ(I)=-1
      DOWN(1,I)=1.D0
      DOWN(2,I)=0.D0
      DOWN(3,I)=0.D0
    1 WRITE (BNAM(I),33) I
   33 FORMAT ('FAULT BLOCK',I4)

! bag8
C      IF (DEALII) THEN
C        ! Check for input errors
C        IF ((NDIM.NE.2).AND.(NDIM.NE.3)) THEN
C          STOP 'DEALII: NDIM must be 2 or 3'
C        ELSEIF ((NDIM.EQ.2).AND.(NCOARSE(1).NE.1)) THEN
C          STOP 'DEALII: When NDIM=2, NCOARSE(1) must be 1'
C        ENDIF
C        ! Set dimensions of quadtree or octree mesh from dealii
C        DO I=1,NLEV
C          IF (NDIM.EQ.3) THEN
C            NX(I)=NCOARSE(1)*2**(I-1)
C          ELSE
C            NX(I)=1
C          ENDIF
C          NY(I)=NCOARSE(2)*2**(I-1)
C          NZ(I)=NCOARSE(3)*2**(I-1)
C        ENDDO
C      ELSE
      CALL GETVALS('BLOCKNAME ',BNAM,'CS',10,0,0,
     &   60,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'BLOCKNAME'
      CALL GETVAL('NX ',NX,'I4',10,0,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'NX'
      CALL GETVAL('NY ',NY,'I4',10,0,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'NY'
      CALL GETVAL('NZ ',NZ,'I4',10,0,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'NZ'
C      ENDIF

      CALL GETVAL('DOWN ',DOWN,'R8',3,10,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'DOWN'
      DO I=1,10
         GMAG(I)=SQRT(DOWN(1,I)**2+DOWN(2,I)**2+DOWN(3,I)**2)
         IF (GMAG(I).GT.0.D0) THEN
            DOWN(1,I)=DOWN(1,I)/GMAG(I)
            DOWN(2,I)=DOWN(2,I)/GMAG(I)
            DOWN(3,I)=DOWN(3,I)/GMAG(I)
         ENDIF
         NXDIM(I)=NX(I)
         NYDIM(I)=NY(I)
         NZDIM(I)=NZ(I)

C bag8 - CRASH IF GRID IS TOO FINE FOR FRAME SIZE FILE
      IF ((NX(I)+2*ILAY.GT.3).OR.
     &    (NY(I)+2*JLAY.GT.2562).OR.
     &    (NZ(I)+2*KLAY.GT.2562)) THEN
        WRITE(*,*)'Error: grid too fine on block',I
        WRITE(*,*)'NX,NY,NZ=            ',NX(I),NY(I),NZ(I)
        WRITE(*,*)'MXRECX,MXRECY,MXRECZ=',3,2562,2562
        WRITE(NFOUT,*)'Error: grid too fine on block',I
        WRITE(NFOUT,*)'NX,NY,NZ=            ',NX(I),NY(I),NZ(I)
        WRITE(NFOUT,*)'MXRECX,MXRECY,MXRECZ=',3,2562,2562
        STOP 1
      ENDIF

      ENDDO

C  STORE NUMBER OF BLOCKS FOR CHECK LATER ON
      NBM=NUMBLK

C  DEFINE GRID FOR MAIN FAULT BLOCKS
      NUMBLK=0
      NUMCOL=0
      NUMZZZ=0
      DO I=1,EV_PRCBLK
      IF (NX(I).GT.0.OR.NY(I).GT.0.OR.NZ(I).GT.0) THEN
         IF (NX(I).LT.1) THEN
            IF (LEVELC) WRITE (NFOUT,30) NX(I),I
   30       FORMAT(/' ERROR 507; NX =',I6,' FOR FAULT BLOCK',I4)
            GO TO 13
         ENDIF
         IF (NY(I).LT.1) THEN
            IF (LEVELC) WRITE (NFOUT,31) NY(I),I
   31       FORMAT(/' ERROR 507; NY =',I6,' FOR FAULT BLOCK',I4)
            GO TO 13
         ENDIF
         IF (NZ(I).LT.1) THEN
            IF (LEVELC) WRITE (NFOUT,32) NZ(I),I
   32       FORMAT(/' ERROR 507; NZ =',I6,' FOR FAULT BLOCK',I4)
            GO TO 13
         ENDIF
         KERR = 0
         CALL DEFBLK (NX(I),NY(I),NZ(I),BNAM(I),NUMBLK,NUMPRC,KERR)
         IF (KERR.GT.0) GO TO 13

         NUMCOL=NUMCOL+NY(I)*NZ(I)
         NUMZZZ=NUMZZZ+NZ(I)
      ENDIF
      ENDDO

C  ENSURE THAT THE NUMBER OF GRID COLUMNS EQUALS OR EXCEEDS THE NUMBER
C  OF PROCESSORS

      IF (NUMPRC.GT.NUMCOL) THEN
         IF (LEVELC) WRITE (NFOUT,52)
   52    FORMAT (/' ERROR 512; MORE PROCESSORS THAN GRID COLUMNS')
         NERR=NERR+1
         IF (LEVERR.LT.2) LEVERR=2
         RETURN
      ENDIF

C  DEFINE AERIAL GRID CONFIGURATION

      CALL MAKEMAP(NUMCOL+NUMZZZ+NUMBLK,NERR)
      IF ((NERR.GT.0).AND.LEVELC) STOP 'Errors in MAKEMAP 1'

C  DIVIDE GRID ELEMENTS AMONG PROCESSORS AND COMPLETE GRID INDEXING

      CALL DIVIDE ()
      KERR = 0
      CALL DEFGRD (MYPRC,ILAY,JLAY,KLAY,MAXREF,N0MAP,NYMAP,PRCMAP,KERR)
      IF (KERR.GT.0) THEN
         IF (LEVELC) WRITE(NFOUT,77) 'DEFGRD'
         GO TO 13
      ENDIF

C  ORTHOGONAL GRID OPTION
      KNDGRD=1

C  MPFA CORNER POINT GEOMETRY
C      KNDGRD=3

!bag8
      EVFEM_HEX=0
C      CALL GETVAL('EVFEM_HEX ',EVFEM_HEX,'I4',0,0,0,0,NDUM,NERR)
C      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'EVFEM_HEX'
C      IF (LEVELC) WRITE(NFOUT,*)'EVFEM_HEX=',EVFEM_HEX
      MFMFE_BRICKS=.FALSE.
C      CALL GETVAL('MFMFE_BRICKS ',MFMFE_BRICKS,'FG',0,0,0,0,NDUM,NERR)

      DO 41 N=1,NBM
      XYZ111(1,N)=0.
      XYZ111(2,N)=0.
      XYZ111(3,N)=0.
      DO 42 I=1,3
   42 DXREC(I,N)=1.
      DO 43 I=1,2562
   43 DYREC(I,N)=1.
      DO 41 I=1,2562
   41 DZREC(I,N)=1.

      REF_GRID_SET = .FALSE.

! bag8
C      IF (DEALII) THEN
C        ! Set mesh widths of quadtree or octree mesh from dealii
C        DXREC=0; DYREC=0; DZREC=0
C        DO I=1,NLEV
C          XYZ111(1:3,I)=CV*XLOW(1:3)
C          DXREC(1:NX(I),I)=CV*(XHIGH(1)-XLOW(1))/NX(I)
C          DYREC(1:NY(I),I)=CV*(XHIGH(2)-XLOW(2))/NY(I)
C          DZREC(1:NZ(I),I)=CV*(XHIGH(3)-XLOW(3))/NZ(I)
C        ENDDO
C        NDUM1=1; NDUM2=1; NDUM3=1;  ! Go inside if-statement below
C      ELSE
      CALL DEFAULT(EXTDIST)
      CALL GETVAL('DX[ft] ',DXREC,'R4',3,10,0,0,NDUM1,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'DX'
      CALL DEFAULT(EXTDIST)
      CALL GETVAL('DY[ft] ',DYREC,'R4',2562,10,0,0,NDUM2,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'DY'
      CALL DEFAULT(EXTDIST)
      CALL GETVAL('DZ[ft] ',DZREC,'R4',2562,10,0,0,NDUM3,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'DZ'
C      ENDIF

      IF (NDUM1.GT.0.OR.NDUM2.GT.0.OR.NDUM3.GT.0) THEN

! bag8
C         REF_GRID_SET = .TRUE.
C         IF (LEVELC) WRITE(NFOUT,*)'REFERENCE GRID FOLLOWS:'

! bag8
C         IF (.NOT.DEALII) THEN
           CALL DEFAULT(EXTDIST)
           CALL GETVAL('XYZ111[ft] ',XYZ111,'R4',3,10,0,0,NDUM,NERR)
           IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'XYZ111'
C         ENDIF
         IF (LEVELC) THEN
            WRITE (NFOUT,55)
   55       FORMAT(/' COORDINATES OF GRID 1,1,1 CORNER:'/
     &      ' BLOCK',T15,'X',T30,'Y',T45,'Z')
            DO 56 N=1,NUMBLK
   56       WRITE (NFOUT,57) N,(XYZ111(M,N),M=1,3)
   57       FORMAT(I5,3G15.6)

            WRITE (NFOUT,58)
   58       FORMAT(/' MAJOR DIMENSIONS:'/
     &      ' BLOCK',T15,'X',T30,'Y',T45,'Z')
            DO 59 N=1,NBM
            DUB1=0.D0
            DO 60 I=1,NX(N)
   60       DUB1=DUB1+DXREC(I,N)
            DUB2=0.D0
            DO 61 I=1,NY(N)
   61       DUB2=DUB2+DYREC(I,N)
            DUB3=0.D0
            DO 62 I=1,NZ(N)
   62       DUB3=DUB3+DZREC(I,N)
   59       WRITE (NFOUT,63) N,DUB1,DUB2,DUB3
   63       FORMAT(I5,3G15.6)

            DO 44 N=1,NBM
            TITU='X INTERVAL LENGTHS FOR FAULT BLOCK'
            CALL MAKTIT (TITU,50,N)
            CALL PRTVEC4 (TITU,NX(N),DXREC(1,N))
            TITU='Y INTERVAL LENGTHS FOR FAULT BLOCK'
            CALL MAKTIT (TITU,50,N)
            CALL PRTVEC4 (TITU,NY(N),DYREC(1,N))
            TITU='Z INTERVAL LENGTHS FOR FAULT BLOCK'
            CALL MAKTIT (TITU,50,N)
   44       CALL PRTVEC4 (TITU,NZ(N),DZREC(1,N))
         ENDIF

         DO 93 N=1,NBM
         XREC(1,N)=XYZ111(1,N)
         DO 91 I=1,NX(N)
   91    XREC(I+1,N)=XREC(I,N)+DXREC(I,N)
         YREC(1,N)=XYZ111(2,N)
         DO 92 J=1,NY(N)
   92    YREC(J+1,N)=YREC(J,N)+DYREC(J,N)
         ZREC(1,N)=XYZ111(3,N)
         DO 93 K=1,NZ(N)
   93    ZREC(K+1,N)=ZREC(K,N)+DZREC(K,N)

      ENDIF

C  CREATE CORNER LOCATION ARRAYS FOR PRIMARY FAULT BLOCKS

C      CALL ALCMPFAGEA1('XC ',2,0,N_XC,EV_PRCBLK,KERR)
C      IF (KERR.GT.0) GO TO 13
C      CALL ALCMPFAGEA1('YC ',2,0,N_YC,EV_PRCBLK,KERR)
C      IF (KERR.GT.0) GO TO 13
C      CALL ALCMPFAGEA1('ZC ',2,0,N_ZC,EV_PRCBLK,KERR)
C      IF (KERR.GT.0) GO TO 13

C  READ IN COORDINATES OF PRIMARY FAULT BLOCK

      IF(KNDGRD.EQ.3) THEN
      IF(.NOT.MFMFE_BRICKS) THEN
         KERR = 0
         CALL GETGRDA ('XC[ft] ',3,N,KERR)
         IF (N.EQ.0.OR.KERR.GT.0) THEN
            IF (LEVELC) WRITE (NFOUT,5)
    5       FORMAT (/' ERROR 502; NO X LOCATIONS DEFINED')
            NERR=NERR+1
         ENDIF

         KERR = 0
         CALL GETGRDA ('YC[ft] ',3,N,KERR)
         IF (N.EQ.0.OR.KERR.GT.0) THEN
            IF (LEVELC) WRITE (NFOUT,6)
    6       FORMAT (/' ERROR 502; NO Y LOCATIONS DEFINED')
            NERR=NERR+1
         ENDIF

         KERR = 0
         CALL GETGRDA ('ZC[ft] ',3,N,KERR)
         IF (N.EQ.0.OR.KERR.GT.0) THEN
            IF (LEVELC) WRITE (NFOUT,7)
    7       FORMAT (/' ERROR 502; NO Z LOCATIONS DEFINED')
            NERR=NERR+1
         ENDIF

! bag8
C      ELSE  ! MFMFE_BRICKS is .TRUE.
C         IF (.NOT.REF_GRID_SET) THEN
C           WRITE(NFOUT,*)'ERROR: USING MFMFE_BRICKS WITHOUT DX,DY,DZ'
C           NERR=NERR+1
C         ELSE
C           CALL CALLWORK(SET_MFMFE_BRICKS,[3,N_XC,N_YC,N_ZC])
C           TITU='X GRID CORNER LOCATIONS FOR FAULT BLOCK'
C           CALL GEAOUT(N_XC,1,2)
C           TITU='Y GRID CORNER LOCATIONS FOR FAULT BLOCK'
C           CALL GEAOUT(N_YC,1,2)
C           TITU='Z GRID CORNER LOCATIONS FOR FAULT BLOCK'
C           CALL GEAOUT(N_ZC,1,2)
C         ENDIF

      ENDIF ! IF .NOT.MFMFE_BRICKS
      ENDIF ! IF KNDGRD.EQ.3

C  EXTRACT KEYOUT DATA FOR PRIMARY FAULT BLOCK

! bag8 - skip this for grid adaptivity case
!      KERR = 0
!      CALL GETGRDA ('KEYOUT ',1,N,KERR)
!      IF (KERR.GT.0) THEN
!         IF (LEVELC) WRITE (NFOUT,8)
!    8    FORMAT (/' ERROR 506; INPUT OF KEYOUT ARRAY FAILED')
!         NERR=NERR+1
!      ENDIF

C  READ IN MIDPOINT ARRAY; CONTAINS MIDPOINTS OF FLOW ELEMENTS
C  MPFA CORNER POINT OPTION

      IF (KNDGRD.EQ.3.AND..NOT.MFMFE_BRICKS) THEN

! bag8 - READ MIDPOINTS OF COORDINATES BEFORE ALLOCATING AND FILLING THE
!        GRID ELEMENT ARRAYS FOR XC,YC,ZC

      NOERASE=.TRUE.
      ! THIS WILL MAKE GETVAL2 NOT ERASE THINGS WHEN READING
      DO N=1,NBM
      IF (N.LE.EV_PRCBLK) CYCLE
      NBLKG=N
      IDIMG=NX(N)+1
      JDIMG=NY(N)+1
      KDIMG=NZ(N)+1
      IDIML=IDIMG+2*ILAY
      JDIML=JDIMG+2*JLAY
      KDIML=KDIMG+2*KLAY
      IGLT=-ILAY
      JGLT=-JLAY
      KGLT=-KLAY
      ND4GA=1
      ALLOCATE(XLOC(IDIML,JDIML,KDIML),STAT=NERR)
      IF (NERR.NE.0) STOP 'Problem allocating XLOC'
      ND=FLOOR(LOG(REAL(N))/LOG(10.D0))+1  ! Number of digits in N
      WRITE(STR,'(A2,I<ND>)')'YC',N
C      CALL GETVAL2(STR,XLOC,'R8',IDIMG,JDIMG,KDIMG,ND4GA,
C     &  NVALS,NERR)
      I=ILAY+1
      DO K=1,KDIMG-1   ! FILL Y COORDINATES OF MIDPOINT ARRAY
      DO J=1,JDIMG-1
        MIDPOINTS(N,1,J,K)=
     &    0.25D0*(XLOC(I,J+JLAY,K+KLAY)+
     &            XLOC(I,J+JLAY+1,K+KLAY) +
     &            XLOC(I,J+JLAY,K+KLAY+1) +
     &            XLOC(I,J+JLAY+1,K+KLAY+1))
      ENDDO
      ENDDO
      WRITE(STR,'(A2,I<ND>)')'ZC',N
C      CALL GETVAL2(STR,XLOC,'R8',IDIMG,JDIMG,KDIMG,ND4GA,
C     &  NVALS,NERR)
      I=ILAY+1
      DO K=1,KDIMG-1   ! FILL Z COORDINATES OF MIDPOINT ARRAY
      DO J=1,JDIMG-1
        MIDPOINTS(N,2,J,K)=
     &    0.25D0*(XLOC(I,J+JLAY,K+KLAY)+
     &            XLOC(I,J+JLAY+1,K+KLAY) +
     &            XLOC(I,J+JLAY,K+KLAY+1) +
     &            XLOC(I,J+JLAY+1,K+KLAY+1))
      ENDDO
      ENDDO
      DEALLOCATE(XLOC)
      ENDDO
      NOERASE=.FALSE.  ! IT IS IMPORTANT TO SET THIS BACK TO FALSE

! bag8 - FILL MIDPOINTS ARRAY FROM BRICK DATA STRUCTURES (EASY)
      ELSE

         DO N=1,NBM
         IF (N.LE.EV_PRCBLK) CYCLE
         DO J=1,NY(N)
         DO K=1,NZ(N)
           MIDPOINTS(N,1,J,K)=0.5D0*(YREC(J,N)+YREC(J+1,N))
           MIDPOINTS(N,2,J,K)=0.5D0*(ZREC(K,N)+ZREC(K+1,N))
         ENDDO
         ENDDO
         ENDDO

      ENDIF

C  APPEND PRCMAP USING COORDINATE ARRAY AND KEYOUT ARRAY OF
C  PRIMARY FAULT BLOCK AND MIDPOINT ARRAY OF OTHER BLOCKS

      START1 = 0
      DO NPAY = 1,NBM
         N=NY(NPAY)*NZ(NPAY)
         IF (NPAY.GT.EV_PRCBLK) THEN
           CALL CALLWORK(APPENDMAP,[3,N_XC,N_YC,N_ZC])
           ALLOCATE(TEMPMAP1(N),TEMPMAP2(N))
           TEMPMAP1(:)=PRCMAP(START1+1:START1+N)
           CALL MPI_ALLREDUCE(TEMPMAP1,TEMPMAP2,N,
     &        MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,NERR)
           PRCMAP(START1+1:START1+N)=TEMPMAP2(:)
           DEALLOCATE(TEMPMAP1,TEMPMAP2)
           MYBLK(NPAY)=FLAGBLK(NPAY)
           MODPROC(MODBLK(NPAY),MYPRC+1)=FLAGBLK(NPAY)
         ENDIF
         START1 = START1 + N
      ENDDO

C  SETUP COMMUNICATOR FOR FLOW COMPUTATIONS; USED IN FLOW HYPRE CODE

      ALLOCATE (FLOWPROCS(0:NUMPRC-1),FLOWPROCSVAL(0:NUMPRC-1))
      FLOW_COMM = 0
      ORIG_GROUP = 0
      NEW_GROUP = 0

      II=0
      DO I = EV_PRCBLK+1,NBM
! saumik - payzone counter
         II=II+1
         NEW_COMM = 0
         TEMP = 0
! saumik - temp = 1 if current process has elements of flow block
         IF(MYBLK(I)) TEMP = 1

! saumik - flowcount is number of processes participating in flow
         CALL MPI_ALLREDUCE(TEMP,FLOWCOUNT,1,MPI_INTEGER,MPI_SUM,
     &                      MPI_COMM_WORLD,NERR)

! saumik - flag = .true. for the special case of all processes
!          participating in flow
         CALL MPI_ALLREDUCE(MYBLK(I),FLAG,1,MPI_LOGICAL,MPI_LAND,
     &                      MPI_COMM_WORLD,NERR)

! saumik
!        temp = 0 : not all processes are participating in flow
!        temp = -1 : all processes are participating in flow
         IF (FLAG) THEN
            TEMP = -1
         ELSE
            TEMP = 0
         ENDIF

         FLOWPROCS = TEMP
         FLOWPROCSVAL = 0
         ALLOCATE(FLOWPROC(FLOWCOUNT))
         FLOWPROC = 0

! saumik - flowprocsval(rank of process doing flow) = rank + 1
!          use myprc+1 since we do not want to feed zero
!          flowprocsval = 0 would mean that current process
!          does not participate in flow
         IF(MYBLK(I)) FLOWPROCSVAL(MYPRC) = MYPRC+1

! saumik - flowprocsval is information local to each process
!          flowprocs is available to all processes
         CALL MPI_ALLREDUCE (FLOWPROCSVAL,FLOWPROCS,NUMPRC,MPI_INTEGER,
     &                       MPI_SUM,MPI_COMM_WORLD,NERR)

         ECOUNT = 0
         DO J = 0,NUMPRC-1
! saumik - flowprocs(j).eq.temp means that process with rank j does not
!          participate in flow
            IF(FLOWPROCS(J).EQ.TEMP) CYCLE
            ECOUNT = ECOUNT + 1
! saumik - flowproc array now has ranks of processes participating in flow
            FLOWPROC(ECOUNT) = FLOWPROCS(J) - 1
         ENDDO

C    --- CREATE SUBCOMMUNICATOR

! saumik - create out a group; name it orig_group
         CALL MPI_COMM_GROUP(MPI_COMM_WORLD,ORIG_GROUP(II),NERR)

! saumik - reorder orig_group and take only processes
!          participating in flow thus generating a new group;
!          name it new_group
         CALL MPI_GROUP_INCL(ORIG_GROUP(II),FLOWCOUNT,FLOWPROC,
     &                       NEW_GROUP(II),NERR)

! saumik - create a communicator from new_group;
!          name it new_comm
         CALL MPI_COMM_CREATE(MPI_COMM_WORLD,NEW_GROUP(II),
     &                        NEW_COMM,NERR)

! saumik - return the rank of calling processes in the group
!          new_group
         CALL MPI_GROUP_RANK(NEW_GROUP(II),NEW_RANK,NERR)

C    --- PRINT SCREEN OUTPUT

!         IF(MYPRC.EQ.0)THEN
!           WRITE(*,*)"-------------------------"
!           IF(MODBLK(I).EQ.17) WRITE(*,1000)II
!           IF(MODBLK(I).EQ.16) WRITE(*,2000)II
! 1000      FORMAT(' PAYZONE',I2,',SINGLE PHASE')
! 2000      FORMAT(' PAYZONE',I2,',COMPOSITIONAL')
!           WRITE(*,*)"-------------------------"
!         ENDIF

!         CALL MPI_BARRIER(MPI_COMM_WORLD,NERR)
!         IF(MYBLK(I)) WRITE(*,*)"OLD RANK IS",MYPRC,
!     &   ",NEWRANK IS",NEW_RANK,",SUBCOMMUNICATOR IS",NEW_COMM
!         CALL MPI_BARRIER(MPI_COMM_WORLD,NERR)

! saumik - flow_comm(II) is communicator used in the hypre code
         FLOW_COMM(II) = NEW_COMM
         CALL MPI_BARRIER(MPI_COMM_WORLD,NERR)
         DEALLOCATE(FLOWPROC)
      ENDDO

      CALL MPI_BARRIER(MPI_COMM_WORLD,NERR)
      DEALLOCATE(FLOWPROCS,FLOWPROCSVAL)

C  COMBINED PRCMAP ESTABLISHED; NOW DEFINE REMAINING BLOCKS

      DO I=1,NBM
      IF (I.LE.EV_PRCBLK) CYCLE
      IF (NX(I).GT.0.OR.NY(I).GT.0.OR.NZ(I).GT.0) THEN
         IF (NX(I).LT.1) THEN
            IF (LEVELC) WRITE (NFOUT,300) NX(I),I
  300       FORMAT(/' ERROR 507; NX =',I6,' FOR FAULT BLOCK',I4)
            GO TO 13
         ENDIF
         IF (NY(I).LT.1) THEN
            IF (LEVELC) WRITE (NFOUT,310) NY(I),I
  310       FORMAT(/' ERROR 507; NY =',I6,' FOR FAULT BLOCK',I4)
            GO TO 13
         ENDIF
         IF (NZ(I).LT.1) THEN
            IF (LEVELC) WRITE (NFOUT,320) NZ(I),I
  320       FORMAT(/' ERROR 507; NZ =',I6,' FOR FAULT BLOCK',I4)
            GO TO 13
         ENDIF
         KERR = 0
         CALL DEFBLK (NX(I),NY(I),NZ(I),BNAM(I),NUMBLK,NUMPRC,KERR)
         IF (KERR.GT.0) GO TO 13
      ENDIF
      ENDDO

C  CONSTRUCT PRCMAPN FOR NODAL BASED PROCESSOR ASSIGNMENT

      NFRE=1
      DO I=1,NUMBLK
         N0=NFRE-NY(I)-1
         N0MAP(I)=N0
         NYMAP(I)=NY(I)
         NCPB=NY(I)*NZ(I)
         NFRE=NFRE+NCPB
      ENDDO

C  INITIALIZE PRCMAPN AND N0MAPN FOR NODAL BASED COMMUNICATION

      NFRE=1
      DO I=1,NUMBLK
         N0=NFRE-(NY(I)+1)-1
         N0MAPN(I)=N0
         NFRE=NFRE+(NY(I)+1)*(NZ(I)+1)
      ENDDO

      DO I=1,NUMBLK
         N0=N0MAP(I)
         N0N=N0MAPN(I)
         NYM=NYMAP(I)
         NYMN=NYM+1
         DO K=1,NZ(I)
            DO J=1,NY(I)
               IF (PRCMAP(N0+K*NYM+J).GE.0) THEN
                  PRCMAPN(N0N+K*NYMN+J)=PRCMAP(N0+K*NYM+J)
                  PRCMAPN(N0N+K*NYMN+J+1)=PRCMAP(N0+K*NYM+J)
                  PRCMAPN(N0N+(K+1)*NYMN+J)=PRCMAP(N0+K*NYM+J)
                  PRCMAPN(N0N+(K+1)*NYMN+J+1)=PRCMAP(N0+K*NYM+J)
               ENDIF
            ENDDO
         ENDDO
      ENDDO

      KERR = 0
      CALL DEFGRD (MYPRC,ILAY,JLAY,KLAY,MAXREF,N0MAP,NYMAP,PRCMAP,KERR)
      IF (KERR.GT.0) GO TO 13

C  CREATE CORNER LOCATION ARRAYS (CORNER POINT OPTION) FOR FLOW BLOCK(S)

C      IF (KNDGRD.EQ.3) THEN
C      CALL ALCMPFAGEA2('XC ',2,0,N_XC,EV_PRCBLK,KERR)
C      IF (KERR.GT.0) GO TO 13
C      CALL ALCMPFAGEA2('YC ',2,0,N_YC,EV_PRCBLK,KERR)
C      IF (KERR.GT.0) GO TO 13
C      CALL ALCMPFAGEA2('ZC ',2,0,N_ZC,EV_PRCBLK,KERR)
C      IF (KERR.GT.0) GO TO 13
C      ENDIF

C  READ IN COORDINATES OF FLOW BLOCK(S)

      IF (KNDGRD.EQ.3) THEN
      IF(.NOT.MFMFE_BRICKS) THEN ! MFMFE_BRICKS IS FALSE
         KERR = 0
         CALL GETGRDA ('XC[ft] ',3,N,KERR)
         IF (N.EQ.0.OR.KERR.GT.0) THEN
            IF (LEVELC) WRITE (NFOUT,500)
  500       FORMAT (/' ERROR 502; NO X LOCATIONS DEFINED')
            NERR=NERR+1
         ENDIF

         KERR = 0
         CALL GETGRDA ('YC[ft] ',3,N,KERR)
         IF (N.EQ.0.OR.KERR.GT.0) THEN
            IF (LEVELC) WRITE (NFOUT,600)
  600       FORMAT (/' ERROR 502; NO Y LOCATIONS DEFINED')
            NERR=NERR+1
         ENDIF

         KERR = 0
         CALL GETGRDA ('ZC[ft] ',3,N,KERR)
         IF (N.EQ.0.OR.KERR.GT.0) THEN
            IF (LEVELC) WRITE (NFOUT,700)
  700       FORMAT (/' ERROR 502; NO Z LOCATIONS DEFINED')
            NERR=NERR+1
         ENDIF
      ELSE ! MFMFE_BRICKS IS TRUE

C         IF (.NOT.REF_GRID_SET) THEN
C           WRITE(NFOUT,*)'ERROR: USING MFMFE_BRICKS WITHOUT DX,DY,DZ'
C           NERR=NERR+1
C         ELSE
C           CALL CALLWORK(SET_MFMFE_BRICKS,[3,N_XC,N_YC,N_ZC])
C           TITU='X GRID CORNER LOCATIONS FOR FAULT BLOCK'
C           CALL GEAOUT(N_XC,1,2)
C           TITU='Y GRID CORNER LOCATIONS FOR FAULT BLOCK'
C           CALL GEAOUT(N_YC,1,2)
C           TITU='Z GRID CORNER LOCATIONS FOR FAULT BLOCK'
C           CALL GEAOUT(N_ZC,1,2)
C         ENDIF

      ENDIF ! IF .NOT.MFMFE_BRICKS
      ENDIF

C  EXTRACT KEYOUT DATA FOR BOTH BLOCKS COMBINED (GRID-ELEMENT ARRAY 0)

      KERR = 0
      CALL GETGRDA ('KEYOUT ',1,N,KERR)
      IF (KERR.GT.0) THEN
         IF (LEVELC) WRITE (NFOUT,800)
  800    FORMAT (/' ERROR 506; INPUT OF KEYOUT ARRAY FAILED')
         NERR=NERR+1
      ENDIF

C  ACTIVATE MODELS FOR CORRESPONDING GRID BLOCKS

      DO 35 M=1,19
   35 MODELON(M)=.FALSE.
      DO 36 N=1,NUMBLK
      IF (MYBLK(N)) THEN
         MODELON(MODBLK(N))=.TRUE.
         IF((MODBLK(N).EQ.14).OR.
     &      (MODBLK(N).EQ.7).OR.(MODBLK(N).EQ.15)) THEN
            MODELON(FMODBLK(N))=.TRUE.
         ENDIF
      ENDIF
   36 CONTINUE

C  SET INITIAL ARRAY PRINT INDEXES FOR USE IN GEAOUT

      DO 25 N=1,NUMBLK
      LDUM=1
      DO 25 L=1,MXR
      I1AP(N,L)=LDUM
      J1AP(N,L)=LDUM
      K1AP(N,L)=LDUM
      LDUM=0
      I2AP(N,L)=NX(N)
      J2AP(N,L)=NY(N)
      K2AP(N,L)=NZ(N)
! saumik - increasing the numbers in denominator increases the output range
!          on geaout
      ISAP(N,L)=1+(I2AP(N,L)-I1AP(N,L))/10
      JSAP(N,L)=1+(J2AP(N,L)-J1AP(N,L))/6
   25 KSAP(N,L)=1+(K2AP(N,L)-K1AP(N,L))/6
      CALL GETGAPI (.TRUE.,NERR)

C  CREATE GRID-ELEMENT ARRAYS BARRING CORNER POINT COORDINATE ARRAYS

      CALL CREATE(NERR)
      IF (NERR.NE.NERRO) GO TO 13

      IF (NUMBLK.EQ.0) THEN
         IF (LEVELC) WRITE (NFOUT,3)
    3    FORMAT (/' ERROR 501; NO GRID BLOCKS DEFINED')
         GO TO 13
      ENDIF

      IF (NBM.LT.NUMBLK) THEN
         IF (LEVELC) WRITE (NFOUT,9)
    9    FORMAT (/' ERROR 501; MODEL NOT SPECIFIED FOR ALL BLOCKS')
         GO TO 13
      ENDIF

C  PRINT COLUMN ASSIGNMENTS TO PROCESSORS

      PRCOUT=.FALSE.
      CALL GETVAL('PROCOUT ',PRCOUT,'FG',0,0,0,0,NDUM,NERR)
      IF (PRCOUT.AND.MYPRC.EQ.0) CALL PROCOUT ()
   77 FORMAT(/' Input file ERROR for ',A)

C  COMPUTE DEPTH ARRAY

      TOPSURF =.FALSE.
      CALL GETVAL('TOPSURF ',TOPSURF,'FG',0,0,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'TOPSURF'
      KERR = 0
      CALL GETGRDA ('DEPTHG ',1,N,KERR)
      IF ((KERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'DEPTHG'

      IF (KNDGRD.EQ.1) THEN
         NARG(1)=1
         NARG(2)=N_DEPTH
         IF (N.GT.0) THEN
           IF (TOPSURF.AND.DOWN(1,1).EQ.1.0) THEN
             CALL CALLWORK(DEPTH1_TOP,NARG)
           ENDIF
         ELSE
            CALL CALLWORK(DEPTH1,NARG)
         ENDIF

      ELSEIF (KNDGRD.EQ.2) THEN
         NARG(1)=4
         NARG(2)=N_DEPTH
         NARG(3)=N_XC
         NARG(4)=N_YC
         NARG(5)=N_ZC
         CALL CALLWORK(DEPTH2,NARG)

      ELSEIF (KNDGRD.EQ.3) THEN
         NARG(1)=4
         NARG(2)=N_DEPTH
         NARG(3)=N_XC
         NARG(4)=N_YC
         NARG(5)=N_ZC
C         CALL CALLWORK(DEPTH3,NARG)
      ELSE
         WRITE(NFOUT,*)'ERROR IN GRID SPECIFICATION'

      ENDIF

      TITU='ELEMENT DEPTH FOR FAULT BLOCK'
      CALL GEAOUT(N_DEPTH,1,1)

C  VOLUME - WEIGHTED PROJECTIONS FOR NONMATCHING GRIDS

C      IF(NONMATCHING) THEN ! SAUMIK,BGANIS
C! saumik - specify the last overburden layer and the first underburden layer
C!          to minimize intersection calculations
C         OB_LAYER = 0
C         UB_LAYER = NXDIM(1)+1
C         CALL GETVAL('OB_LAYER ',OB_LAYER,'I4',0,0,0,0,NDUM,NERR)
C         CALL GETVAL('UB_LAYER ',UB_LAYER,'I4',0,0,0,0,NDUM,NERR)
C         CALL PROJECTION_OPERATORS(NERR)
C         CALL MPI_BARRIER(MPI_COMM_WORLD,NERR)
C         IF(MYPRC.EQ.0)THEN
C            WRITE(*,*)"!...OPERATORS COMPUTED...!"
C         ENDIF
C      ENDIF
C
! bag8 - for visualizing processor assignment
      PLOT_MYPRC = .FALSE.
      CALL GETVAL('PLOT_MYPRC ',PLOT_MYPRC,'FG',0,0,0,0,NDUM,NERR)
      IF (PLOT_MYPRC) THEN
        CALL ALCGEA ('MYPRC ',2,0,N_MYPRC,KERR)
      ENDIF

C  EXITS

      IF (NERR.NE.NERRO.AND.LEVERR.LT.2) LEVERR=2
      RETURN

   13 NERR=NERR+1
      IF (LEVERR.LT.2) LEVERR=2
      IF (LEVELC) WRITE (NFOUT,14) KERR
   14 FORMAT (/' ERROR #',I4,'; MEMORY MANAGEMENT ERROR')
      END

C*********************************************************************
      SUBROUTINE SETGEOM (NERR)
C*********************************************************************

C  Extracts geometry data from the keyword super array, divides the
C  grid elements among the processors, and initializes memory management.

C  NERR = Error number steped by 1 on error (input & output, INTEGER)

C*********************************************************************
      PARAMETER (MXR=3)
C      INCLUDE 'msjunk.h'

      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'blkary.h'
      INCLUDE 'output.h'
      INCLUDE 'unitsex.h'

      CHARACTER*60 BNAM(10)
      INTEGER NARG(5),NX(10),NY(10),NZ(10)
      LOGICAL PRCOUT,TOPSURF,REF_GRID_SET

      EXTERNAL DEPTH1,DEPTH2,DEPTH1_TOP
C     &          ,DEPTH3,SET_MFMFE_BRICKS,DEBUG_MFMFE_BRICKS

      NERRO=NERR

      IF (LEVELE.AND.BUGKEY(1)) THEN
         WRITE (NFBUG,*)'PROC',MYPRC,' ENTERING SUBROUTINE SETGEOM'
         WRITE (*,*)'PROC',MYPRC,' ENTERING SUBROUTINE SETGEOM'
      ENDIF

      IF (LEVELC) THEN
         WRITE (NFOUT,*)
         TITU='******'
         CALL PRTTIT(TITU)
         TITU='GEOMETRY DATA'
         CALL PRTTIT(TITU)
      ENDIF

C  SET GRAVITY CONSTANT (PSI SQ-FT / LB)

      GRAV=.006944445D0

C bag8 - SET CONVERSION FACTOR ((CU-FT CP) / (PSI DAY))

      CONV_FACTOR = 6.3282864D-3
      CALL GETVAL('CONV_FACTOR ',CONV_FACTOR,'R8',0,0,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'CONV_FACTOR'
!      IF (LEVELC) WRITE(NFOUT,*)'CONV_FACTOR=',CONV_FACTOR
      IF (CONV_FACTOR.LE.0.D0) THEN
        STOP 'CONV_FACTOR must be greater than zero'
      ENDIF

C  PROCESS GRID BLOCK NAMES AND SIZES

      DO 1 I=1,10
      NX(I)=-1
      NY(I)=-1
      NZ(I)=-1
      DOWN(1,I)=1.D0
      DOWN(2,I)=0.D0
      DOWN(3,I)=0.D0
    1 WRITE (BNAM(I),33) I
   33 FORMAT ('FAULT BLOCK',I4)

      CALL GETVALS('BLOCKNAME ',BNAM,'CS',10,0,0,60,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'BLOCKNAME'
      CALL GETVAL('NX ',NX,'I4',10,0,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'NX'
      CALL GETVAL('NY ',NY,'I4',10,0,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'NY'
      CALL GETVAL('NZ ',NZ,'I4',10,0,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'NZ'
      CALL GETVAL('DOWN ',DOWN,'R8',3,10,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'DOWN'

      NBM=NUMBLK
      NUMBLK=0
      NUMCOL=0
      NUMZZZ=0
      DO 2 I=1,10
      IF (NX(I).GT.0.OR.NY(I).GT.0.OR.NZ(I).GT.0) THEN
         IF (NX(I).LT.1) THEN
            IF (LEVELC) WRITE (NFOUT,30) NX(I),I
   30       FORMAT(/' ERROR 507; NX =',I6,' FOR FAULT BLOCK',I4)
            GO TO 13
         ENDIF
         IF (NY(I).LT.1) THEN
            IF (LEVELC) WRITE (NFOUT,31) NY(I),I
   31       FORMAT(/' ERROR 507; NY =',I6,' FOR FAULT BLOCK',I4)
            GO TO 13
         ENDIF
         IF (NZ(I).LT.1) THEN
            IF (LEVELC) WRITE (NFOUT,32) NZ(I),I
   32       FORMAT(/' ERROR 507; NZ =',I6,' FOR FAULT BLOCK',I4)
            GO TO 13
         ENDIF
         KERR = 0
         CALL DEFBLK (NX(I),NY(I),NZ(I),BNAM(I),NUMBLK,NUMPRC,KERR)
         IF (KERR.GT.0) THEN
            IF (LEVELC) WRITE(NFOUT,78) 'DEFBLK'
            GO TO 13
         ENDIF
   78    FORMAT(/' Error in ',A)

C        Scaling down vector to unit vector

         GMAG(I)=SQRT(DOWN(1,I)**2+DOWN(2,I)**2
     &        +DOWN(3,I)**2)
         IF (GMAG(I).GT.0.D0) THEN
            DOWN(1,I)=DOWN(1,I)/GMAG(I)
            DOWN(2,I)=DOWN(2,I)/GMAG(I)
            DOWN(3,I)=DOWN(3,I)/GMAG(I)
         ENDIF

         NUMCOL=NUMCOL+NY(I)*NZ(I)
         NUMZZZ=NUMZZZ+NZ(I)
      ENDIF

CSGT - MAY NOT BE REQUIRED IN FUTURE
c bag8 - removed DUAL keyword
      NXDIM(I)=NX(I)
      NYDIM(I)=NY(I)
      NZDIM(I)=NZ(I)
CSGT

C bag8 - CRASH IF GRID IS TOO FINE FOR FRAME SIZE FILE
      IF ((NX(I)+2*ILAY.GT.3).OR.
     &    (NY(I)+2*JLAY.GT.2562).OR.
     &    (NZ(I)+2*KLAY.GT.2562)) THEN
        WRITE(*,*)'Error: grid too fine on block',I
        WRITE(*,*)'NX,NY,NZ=            ',NX(I),NY(I),NZ(I)
        WRITE(*,*)'MXRECX,MXRECY,MXRECZ=',3,2562,2562
        WRITE(NFOUT,*)'Error: grid too fine on block',I
        WRITE(NFOUT,*)'NX,NY,NZ=            ',NX(I),NY(I),NZ(I)
        WRITE(NFOUT,*)'MXRECX,MXRECY,MXRECZ=',3,2562,2562
        STOP 1
      ENDIF

    2 CONTINUE

      IF (NUMBLK.EQ.0) THEN
         IF (LEVELC) WRITE (NFOUT,3)
    3    FORMAT (/' ERROR 501; NO GRID BLOCKS DEFINED')
         GO TO 13
      ENDIF

      IF (NBM.LT.NUMBLK) THEN
         IF (LEVELC) WRITE (NFOUT,9)
    9    FORMAT (/' ERROR 501; MODEL NOT SPECIFIED FOR ALL BLOCKS')
         GO TO 13
      ENDIF

C  ENSURE THAT THE NUMBER OF GRID COLUMNS EQUALS OR EXCEEDS THE NUMBER
C  OF PROCESSORS

      IF (NUMPRC.GT.NUMCOL) THEN
         IF (LEVELC) WRITE (NFOUT,52)
   52    FORMAT (/' ERROR 512; MORE PROCESSORS THAN GRID COLUMNS')
         NERR=NERR+1
         IF (LEVERR.LT.2) LEVERR=2
         RETURN
      ENDIF

C  DEFINE AERIAL GRID CONFIGURATION

      CALL MAKEMAP(NUMCOL+NUMZZZ+NUMBLK,NERR)
      IF ((NERR.GT.0).AND.LEVELC) STOP 'Errors in MAKEMAP 2'

C  DIVIDE GRID ELEMENTS AMONG PROCESSORS AND COMPLETE GRID INDEXING

      CALL DIVIDE ()
      KERR = 0
      CALL DEFGRD (MYPRC,ILAY,JLAY,KLAY,MAXREF,N0MAP,NYMAP,PRCMAP,KERR)
      IF (KERR.GT.0) THEN
         IF (LEVELC) WRITE(NFOUT,78) 'DEFGRD'
         GO TO 13
      ENDIF

C  RESET MODELON() TO REFLECT ACTIVE PROCESSOR ASSIGNMENTS. NOTE: WHEN
C  TRCHEM IS DRIVING PHYSICAL MODEL, ONE CAN REPLACE OCCURRANCES OF
C  FLOWMODEL IN TRCHEM WITH MODELON(MOD) WHEN CHECKING FOR FLOW MODEL!

      DO 35 M=1,19
   35 MODELON(M)=.FALSE.
      DO 36 N=1,NUMBLK
      IF (MYBLK(N)) THEN
         MODELON(MODBLK(N))=.TRUE.
         IF((MODBLK(N).EQ.14).OR.
     &      (MODBLK(N).EQ.7).OR.(MODBLK(N).EQ.15)) THEN
            MODELON(FMODBLK(N))=.TRUE.
         ENDIF
      ENDIF
   36 CONTINUE

C  SET INITIAL ARRAY PRINT INDEXES

      DO 25 N=1,NUMBLK
C     NUMREG(N)=1
      LDUM=1
      DO 25 L=1,MXR
      I1AP(N,L)=LDUM
      J1AP(N,L)=LDUM
      K1AP(N,L)=LDUM
      LDUM=0
      I2AP(N,L)=NX(N)
      J2AP(N,L)=NY(N)
      K2AP(N,L)=NZ(N)
      ISAP(N,L)=1+(I2AP(N,L)-I1AP(N,L))/10
      JSAP(N,L)=1+(J2AP(N,L)-J1AP(N,L))/6
   25 KSAP(N,L)=1+(K2AP(N,L)-K1AP(N,L))/6

      CALL GETGAPI (.TRUE.,NERR)
      IF (NERR.GT.0) STOP 'Error in GETGAPI'

C  ORTHOGONAL GRID OPTION
      KNDGRD=1

C  MPFA CORNER POINT GEOMETRY
C      KNDGRD = 3

!bag8
      EVFEM_HEX=0
C      CALL GETVAL('EVFEM_HEX ',EVFEM_HEX,'I4',0,0,0,0,NDUM,NERR)
C      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'EVFEM_HEX'
C      WRITE(NFOUT,*)'EVFEM_HEX=',EVFEM_HEX
      MFMFE_BRICKS=.FALSE.
C      CALL GETVAL('MFMFE_BRICKS ',MFMFE_BRICKS,'FG',0,0,0,0,NDUM,NERR)

      DO 41 N=1,NUMBLK
      XYZ111(1,N)=0.
      XYZ111(2,N)=0.
      XYZ111(3,N)=0.
      DO 42 I=1,3
   42 DXREC(I,N)=1.
      DO 43 I=1,2562
   43 DYREC(I,N)=1.
      DO 41 I=1,2562
   41 DZREC(I,N)=1.

      REF_GRID_SET = .FALSE.
      CALL DEFAULT(EXTDIST)
      CALL GETVAL('DX[ft] ',DXREC,'R4',3,10,0,0,NDUM1,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'DX'
      CALL DEFAULT(EXTDIST)
      CALL GETVAL('DY[ft] ',DYREC,'R4',2562,10,0,0,NDUM2,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'DY'
      CALL DEFAULT(EXTDIST)
      CALL GETVAL('DZ[ft] ',DZREC,'R4',2562,10,0,0,NDUM3,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'DZ'
      IF (NDUM1.GT.0.OR.NDUM2.GT.0.OR.NDUM3.GT.0) THEN

! bag8
C         REF_GRID_SET = .TRUE.
C         IF (LEVELC) WRITE(NFOUT,*)'REFERENCE GRID FOLLOWS:'

         CALL DEFAULT(EXTDIST)
         CALL GETVAL('XYZ111[ft] ',XYZ111,'R4',3,10,0,0,NDUM,NERR)
         IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'XYZ111'
         IF (LEVELC) THEN
            WRITE (NFOUT,55)
   55       FORMAT(/' COORDINATES OF GRID 1,1,1 CORNER:'/
     &      ' BLOCK',T15,'X',T30,'Y',T45,'Z')
            DO 56 N=1,NUMBLK
   56       WRITE (NFOUT,57) N,(XYZ111(M,N),M=1,3)
   57       FORMAT(I5,3G15.6)

            WRITE (NFOUT,58)
   58       FORMAT(/' MAJOR DIMENSIONS:'/
     &      ' BLOCK',T15,'X',T30,'Y',T45,'Z')
            DO 59 N=1,NUMBLK
            DUB1=0.D0
            DO 60 I=1,NX(N)
   60       DUB1=DUB1+DXREC(I,N)
            DUB2=0.D0
            DO 61 I=1,NY(N)
   61       DUB2=DUB2+DYREC(I,N)
            DUB3=0.D0
            DO 62 I=1,NZ(N)
   62       DUB3=DUB3+DZREC(I,N)
   59       WRITE (NFOUT,63) N,DUB1,DUB2,DUB3
   63       FORMAT(I5,3G15.6)

            DO 44 N=1,NUMBLK
            TITU='X INTERVAL LENGTHS FOR FAULT BLOCK'
            CALL MAKTIT (TITU,50,N)
            CALL PRTVEC4 (TITU,NX(N),DXREC(1,N))
            TITU='Y INTERVAL LENGTHS FOR FAULT BLOCK'
            CALL MAKTIT (TITU,50,N)
            CALL PRTVEC4 (TITU,NY(N),DYREC(1,N))
            TITU='Z INTERVAL LENGTHS FOR FAULT BLOCK'
            CALL MAKTIT (TITU,50,N)
   44       CALL PRTVEC4 (TITU,NZ(N),DZREC(1,N))
         ENDIF

         DO 93 N=1,NUMBLK
         XREC(1,N)=XYZ111(1,N)
         DO 91 I=1,NX(N)
   91    XREC(I+1,N)=XREC(I,N)+DXREC(I,N)
         YREC(1,N)=XYZ111(2,N)
         DO 92 J=1,NY(N)
   92    YREC(J+1,N)=YREC(J,N)+DYREC(J,N)
         ZREC(1,N)=XYZ111(3,N)
         DO 93 K=1,NZ(N)
   93    ZREC(K+1,N)=ZREC(K,N)+DZREC(K,N)

      ENDIF

C  CREATE GRID-ELEMENT ARRAYS

      CALL CREATE (NERR)
      IF (NERR.NE.NERRO) GO TO 13

C  X,Y,Z CORNER POINT OPTION (NOT USED)

      IF (KNDGRD.EQ.2) THEN

      KERR = 0
      CALL GETGRDA ('XC[ft] ',2,N,KERR)
      IF (N.EQ.0.OR.KERR.GT.0) THEN
         IF (LEVELC) WRITE (NFOUT,15)
   15    FORMAT (/' ERROR 502; NO X LOCATIONS DEFINED')
         NERR=NERR+1
      ELSE
         TITU='X GRID CORNER LOCATIONS FOR FAULT BLOCK'
         CALL GEAOUT(N_XC,1,2)
      ENDIF

      KERR = 0
      CALL GETGRDA ('YC[ft] ',2,N,KERR)
      IF (N.EQ.0.OR.KERR.GT.0) THEN
         IF (LEVELC) WRITE (NFOUT,16)
   16    FORMAT (/' ERROR 502; NO Y LOCATIONS DEFINED')
         NERR=NERR+1
      ELSE
         TITU='Y GRID CORNER LOCATIONS FOR FAULT BLOCK'
         CALL GEAOUT(N_YC,1,2)
      ENDIF

      KERR = 0
      CALL GETGRDA ('ZC[ft] ',2,N,KERR)
      IF (N.EQ.0.OR.KERR.GT.0) THEN
         IF (LEVELC) WRITE (NFOUT,17)
   17    FORMAT (/' ERROR 502; NO Z LOCATIONS DEFINED')
         NERR=NERR+1
      ELSE
         TITU='Z GRID CORNER LOCATIONS FOR FAULT BLOCK'
         CALL GEAOUT(N_ZC,1,2)
      ENDIF

      ENDIF

C  MPFA CORNER POINT OPTION

      IF (KNDGRD.EQ.3) THEN
      IF (.NOT.MFMFE_BRICKS) THEN

      KERR = 0
      CALL GETGRDA ('XC[ft] ',3,N,KERR)
      IF (N.EQ.0.OR.KERR.GT.0) THEN
         IF (LEVELC) WRITE (NFOUT,5)
    5    FORMAT (/' ERROR 502; NO X LOCATIONS DEFINED')
         NERR=NERR+1
      ELSE
         TITU='X GRID CORNER LOCATIONS FOR FAULT BLOCK'
         CALL GEAOUT(N_XC,1,2)
      ENDIF

      KERR = 0
      CALL GETGRDA ('YC[ft] ',3,N,KERR)
      IF (N.EQ.0.OR.KERR.GT.0) THEN
         IF (LEVELC) WRITE (NFOUT,6)
    6    FORMAT (/' ERROR 502; NO Y LOCATIONS DEFINED')
         NERR=NERR+1
      ELSE
         TITU='Y GRID CORNER LOCATIONS FOR FAULT BLOCK'
         CALL GEAOUT(N_YC,1,2)
      ENDIF

      KERR = 0
      CALL GETGRDA ('ZC[ft] ',3,N,KERR)
      IF (N.EQ.0.OR.KERR.GT.0) THEN
         IF (LEVELC) WRITE (NFOUT,7)
    7    FORMAT (/' ERROR 502; NO Z LOCATIONS DEFINED')
         NERR=NERR+1
      ELSE
         TITU='Z GRID CORNER LOCATIONS FOR FAULT BLOCK'
         CALL GEAOUT(N_ZC,1,2)
      ENDIF

! bag8
C      ELSE  ! MFMFE_BRICKS is .TRUE.
C         IF (.NOT.REF_GRID_SET) THEN
C           WRITE(NFOUT,*)'ERROR: USING MFMFE_BRICKS WITHOUT DX,DY,DZ'
C           NERR=NERR+1
C         ELSE
C           CALL CALLWORK(SET_MFMFE_BRICKS,[3,N_XC,N_YC,N_ZC])
C           TITU='X GRID CORNER LOCATIONS FOR FAULT BLOCK'
C           CALL GEAOUT(N_XC,1,2)
C           TITU='Y GRID CORNER LOCATIONS FOR FAULT BLOCK'
C           CALL GEAOUT(N_YC,1,2)
C           TITU='Z GRID CORNER LOCATIONS FOR FAULT BLOCK'
C           CALL GEAOUT(N_ZC,1,2)
C         ENDIF

      ENDIF ! IF .NOT.MFMFE_BRICKS
      ENDIF ! IF KNDGRD.EQ.3

C  EXTRACT KEYOUT DATA (GRID-ELEMENT ARRAY 0)

      KERR = 0
      CALL GETGRDA ('KEYOUT ',1,N,KERR)
      IF (KERR.GT.0) THEN
         IF (LEVELC) WRITE (NFOUT,8)
    8    FORMAT (/' ERROR 506; INPUT OF KEYOUT ARRAY FAILED')
         NERR=NERR+1
      ELSE
         TITU='KEYOUT ARRAY FOR FAULT BLOCK'
         CALL GEAOUT(0,1,1)
      ENDIF

C  PRINT COLUMN ASSIGNMENTS TO PROCESSORS

      PRCOUT=.FALSE.
      CALL GETVAL('PROCOUT ',PRCOUT,'FG',0,0,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'PROCOUT'
      IF (PRCOUT.AND.MYPRC.EQ.0) CALL PROCOUT ()
   77 FORMAT(/' Input file ERROR for ',A)

C  COMPUTE DEPTH ARRAY

      TOPSURF =.FALSE.
      CALL GETVAL('TOPSURF ',TOPSURF,'FG',0,0,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'TOPSURF'
      KERR = 0
      CALL GETGRDA ('DEPTHG ',1,N,KERR)
      IF ((KERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'DEPTHG'

      IF (KNDGRD.EQ.1) THEN
         NARG(1)=1
         NARG(2)=N_DEPTH
         IF (N.GT.0) THEN
           IF (TOPSURF.AND.DOWN(1,1).EQ.1.0) THEN
             CALL CALLWORK(DEPTH1_TOP,NARG)
           ENDIF
         ELSE
            CALL CALLWORK(DEPTH1,NARG)
         ENDIF

      ELSEIF (KNDGRD.EQ.2) THEN
         NARG(1)=4
         NARG(2)=N_DEPTH
         NARG(3)=N_XC
         NARG(4)=N_YC
         NARG(5)=N_ZC
         CALL CALLWORK(DEPTH2,NARG)

      ELSEIF (KNDGRD.EQ.3) THEN
         NARG(1)=4
         NARG(2)=N_DEPTH
         NARG(3)=N_XC
         NARG(4)=N_YC
         NARG(5)=N_ZC
C         CALL CALLWORK(DEPTH3,NARG)
      ELSE
         WRITE(NFOUT,*)'ERROR IN GRID SPECIFICATION'

      ENDIF

      TITU='ELEMENT DEPTH FOR FAULT BLOCK'
      CALL GEAOUT(N_DEPTH,1,1)

! bag8 - for visualizing processor assignment
      PLOT_MYPRC = .FALSE.
      CALL GETVAL('PLOT_MYPRC ',PLOT_MYPRC,'FG',0,0,0,0,NDUM,NERR)
      IF (PLOT_MYPRC) THEN
        CALL ALCGEA ('MYPRC ',2,0,N_MYPRC,KERR)
      ENDIF

C  EXITS

      IF (NERR.NE.NERRO.AND.LEVERR.LT.2) LEVERR=2
      RETURN

   13 NERR=NERR+1
      IF (LEVERR.LT.2) LEVERR=2
      IF (LEVELC) WRITE (NFOUT,14) KERR
   14 FORMAT (/' ERROR #',I4,'; MEMORY MANAGEMENT ERROR')
      END

C*********************************************************************
      SUBROUTINE CREATE (NERR)
C*********************************************************************

C  Create grid-element arrays and boundary-element arrays

C  NERR = Error number steped by 1 on error (input & output, INTEGER)

C*********************************************************************
      USE adaptmod
      IMPLICIT NONE
C      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'blkary.h'
C      INCLUDE 'earydat.h'
      INTEGER NERR
      INTEGER KE,KERR
      EXTERNAL GETFINEDIM,SETARYR8

      IF (LEVELE.AND.BUGKEY(1)) THEN
         WRITE (NFBUG,*)'PROC',MYPRC,' ENTERING SUBROUTINE CREATE'
         WRITE (*,*)'PROC',MYPRC,' ENTERING SUBROUTINE CREATE'
      ENDIF

C  CREATE UTILITY VARIABLES FOR GRID-ELEMENT ARRAY OPERATIONS

      KE=1
      CALL PNTVARR8 (R8UTIL, N_R8U, KERR)
      IF (KERR.GT.0) GO TO 13
      CALL PNTVARR4 (R4UTIL, N_R4U, KERR)
      IF (KERR.GT.0) GO TO 13
      CALL PNTVAR (I4UTIL, N_I4U, KERR)
      IF (KERR.GT.0) GO TO 13
      CALL PNTVAR (I4UTIL1, N_I4U1, KERR)   ! bw
      IF (KERR.GT.0) GO TO 13
      CALL PNTVAR (I4UTIL2, N_I4U2, KERR)   ! bw
      IF (KERR.GT.0) GO TO 13
      CALL PNTVAR (KTU, N_KTU, KERR)
      IF (KERR.GT.0) GO TO 13
      CALL PNTVAR (KPU, N_KPU, KERR)
      IF (KERR.GT.0) GO TO 13

C  ALLOCATE SPACE FOR HYPRE

      CALL HYPRE_ALLOCATE(KERR)
         IF (KERR.GT.0) GO TO 13

C  CREATE CORNER LOCATION ARRAYS (CORNER POINT OPTION)

      IF (KNDGRD.EQ.2) THEN
         KE=KE+1
         CALL ALCGEA ('XC ',1,0,N_XC,KERR)
         IF (KERR.GT.0) GO TO 13
         CALL ALCGEA ('YC ',1,0,N_YC,KERR)
         IF (KERR.GT.0) GO TO 13
         CALL ALCGEA ('ZC ',1,0,N_ZC,KERR)
         IF (KERR.GT.0) GO TO 13
      ENDIF

C CREATE MPFA CORNER LOCATION ARRAYS

      IF (KNDGRD==3) THEN
         KE=KE+1
         IF(.NOT.MBPOROE) THEN
         ! SAUMIK,BGANIS
         ! IF MBPOROE IS TRUE, THESE WILL BE DONE INSIDE SETGEOMNEW
           CALL ALCMPFAGEA ('XC ',2,0,N_XC,KERR)
           IF (KERR.GT.0) GO TO 13
           CALL ALCMPFAGEA ('YC ',2,0,N_YC,KERR)
           IF (KERR.GT.0) GO TO 13
           CALL ALCMPFAGEA ('ZC ',2,0,N_ZC,KERR)
           IF (KERR.GT.0) GO TO 13
         ENDIF

C CREATE REAL*8 POROSITY AND VOLUMETRIC STRAIN ARRAY
         KE=KE+1
         CALL ALCGEA ('POROSITY ',2,0,N_POR,KERR)
         IF (KERR.GT.0) GO TO 13
C         IF(MBPOROE) THEN
C         ! SAUMIK,BGANIS
C         ! IF MBPOROE IS TRUE, THIS ARRAY IS USED IN UPSCALING THE
C         ! UPDATED POROSITIES AFTER FLOW SOLVE
C            CALL ALCGEA ('TRUEPOROSITY ',2,0,N_PORTRUE,KERR)
C            IF (KERR.GT.0) GO TO 13
C         ! IF MBPOROE IS TRUE, THIS ARRAY IS USED IN DOWNSCALING THE
C         ! UPDATED VOLUMETRIC STRAIN AFTER MECHANICS SOLVE
C            CALL ALCGEA ('VSTRAIN ',2,0,N_VSTRAIN,KERR)
C            IF (KERR.GT.0) GO TO 13
C         ENDIF
      ELSE
C CREATE REAL*4 POROSITY ARRAY
         KE=KE+1
         CALL ALCGEA ('POROSITY ',1,0,N_POR,KERR)
         IF (KERR.GT.0) GO TO 13
         CALL ALCGEA ('PORO ',2,0,N_PORO,KERR)
         IF (KERR.GT.0) GO TO 13
      ENDIF

C  CREATE ROCK TYPE ARRAY

      KE=KE+1
      CALL ALCGEA ('ROCK ',4,0,N_ROCK,KERR)
      IF (KERR.GT.0) GO TO 13

C  CREATE RELATIVE PORE VOLUME CHANGE ARRAY

      IF(MBPOROE) THEN
      ! SAUMIK,BGANIS
      ! IF MBPOROE IS TRUE, THIS ARRAY IS USED IN DOWNSCALING THE
      ! RELATIVE PORE VOLUME CHANGE AFTER MECHANICS SOLVE
        KE=KE+1
        CALL ALCGEA ('RC ',2,0,N_RC,KERR)
        IF (KERR.GT.0) GO TO 13
      ENDIF

C  CREATE PERMEABILITY AND TRANSMISSABILITY ARRAYS

      KE=KE+1
      CALL ALCGEA ('XPERM ',1,0,N_XPERM,KERR)
      IF (KERR.GT.0) GO TO 13
      CALL ALCGEA ('YPERM ',1,0,N_YPERM,KERR)
      IF (KERR.GT.0) GO TO 13
      CALL ALCGEA ('ZPERM ',1,0,N_ZPERM,KERR)
      IF (KERR.GT.0) GO TO 13
      CALL ALCGEA ('TCOFX ',2,0,N_TCOFX,KERR)
      IF (KERR.GT.0) GO TO 13
      CALL ALCGEA ('TCOFY ',2,0,N_TCOFY,KERR)
      IF (KERR.GT.0) GO TO 13
      CALL ALCGEA ('TCOFZ ',2,0,N_TCOFZ,KERR)
      IF (KERR.GT.0) GO TO 13

C  CREATE DEPTH ARRAY

      KE=KE+1
      CALL ALCGEA ('DEPTHG ',2,0,N_DEPTH,KERR)
      IF (KERR.GT.0) GO TO 13

C  CREATE VOLUME ARRAY - moved from mfarray - saumik

      KE=KE+1
      CALL ALCGEA ('EVOL ',2,0,N_EVOL,KERR)
      IF (KERR.GT.0) GO TO 13

C  CREATE MODEL SPECIFIC ARRAYS

      KE=KE+1

C      MODACT=15
C      IF (MODELON(15)) THEN
C         CALL EARRAY(KERR)
C         IF (KERR.GT.0) STOP 'Errors in EARRAY'
C         GOTO 12
C      ENDIF

C      MODACT=14
C      IF (MODELON(14)) THEN
C         CALL TRARRAY(KERR)
C         IF (KERR.GT.0) STOP 'Errors in TRARRAY'
C         GOTO 12
C      ENDIF

C      MODACT=7
C      IF (MODELON(7)) THEN
C         CALL MARRAY(KERR)
C         IF (KERR.GT.0) STOP 'Errors in MARRAY'
C         GOTO 12
C      ENDIF

C      MODACT=2
C      IF (MODELON(2)) THEN
C         CALL IARRAY(KERR)
C         IF (KERR.GT.0) STOP 'Errors in IARRAY'
C      ENDIF
C      MODACT=3
C      IF (MODELON(3)) THEN
C         CALL XARRAY(KERR)
C         IF (KERR.GT.0) STOP 'Errors in XARRAY'
C      ENDIF
C      MODACT=16
C      IF (MODELON(16)) THEN
C         CALL XARRAY(KERR)
C         IF (KERR.GT.0) STOP 'Errors in XARRAY'
C         CALL MFARRAY(KERR)
C         IF (KERR.GT.0) STOP 'Errors in MFARRAY'
C      ENDIF
C      MODACT=5
C      IF (MODELON(5)) THEN
C         CALL HARRAY(KERR)
C         IF (KERR.GT.0) STOP 'Errors in HARRAY'
C      ENDIF
C      MODACT=19
C      IF (MODELON(19)) THEN
C         CALL HARRAY(KERR)
C         IF (KERR.GT.0) STOP 'Errors in HARRAY'
C      ENDIF
C      MODACT=18
C      IF (MODELON(18)) THEN
C         CALL HARRAY(KERR)
C         IF (KERR.GT.0) STOP 'Errors in HARRAY'
C         CALL MFARRAY(KERR)
C         IF (KERR.GT.0) STOP 'Errors in MFARRAY'
C      ENDIF
      MODACT=13
      IF (MODELON(13)) THEN
         CALL TARRAY(KERR)
         IF (KERR.GT.0) STOP 'Errors in TARRAY'
      ENDIF
C      MODACT=17
C      IF (MODELON(17)) THEN
C         CALL TARRAY(KERR)
C         IF (KERR.GT.0) STOP 'Errors in TARRAY'
C         CALL MFARRAY(KERR)
C         IF (KERR.GT.0) STOP 'Errors in MFARRAY'
C      ENDIF

   12 MODACT=0

! bag8 - Special fine scale arrays for upscaling and downscaling
!        when using grid adaptivity capabilities.
      IF (ADAPTIVITY) THEN
        CALL CALLWORK(GETFINEDIM,0)
        ALLOCATE(FINELEV(IDIM_F,JDIM_F,KDIM_F),STAT=KERR)
        IF (KERR.NE.0) THEN
          CALL KILL_IPARS('Could not allocate FINELEV')
        ENDIF
        ALLOCATE(FINEARR(IDIM_F,JDIM_F,KDIM_F,LDIM_F),STAT=KERR)
        IF (KERR.NE.0) THEN
          CALL KILL_IPARS('Could not allocate FINEARR')
        ENDIF
        ALLOCATE(INDICATOR(IDIM_F,JDIM_F,KDIM_F),STAT=KERR)
        IF (KERR.NE.0) THEN
          CALL KILL_IPARS('Could not allocate INDICATOR')
        ENDIF

! bag8 - adapt evfem
        IF (ADAPT_MODE.GT.0) THEN
        CALL ALCGEA('MARK ',2,0,N_MARK,KERR)
        IF (KERR.NE.0) CALL KILL_IPARS('Could not allocate N_MARK')
        ALLOCATE(NEWLEV(IDIM_F,JDIM_F,KDIM_F),STAT=KERR)
        IF (KERR.NE.0) THEN
          CALL KILL_IPARS('Could not allocate NEWLEV')
        ENDIF
        ENDIF

      ENDIF

      IF (KERR.GT.0) GO TO 13

C  EXITS

      RETURN

   13 NERR=NERR+1
      IF (LEVERR.LT.3) LEVERR=3
      WRITE (*,14) KERR,KE,MYPRC
      IF (LEVELC) WRITE (NFOUT,14) KERR,KE,MYPRC
   14 FORMAT (/' ERROR #',I4,'; MEMORY MANAGEMENT ERROR AT LOCATION',
     & I3,', PROC',I4)
      END

! bag8
C*********************************************************************
      SUBROUTINE FREEADAPT()
C*********************************************************************
      USE adaptmod
      IMPLICIT NONE
      IF (ALLOCATED(FINELEV)) DEALLOCATE(FINELEV)
      IF (ALLOCATED(FINEARR)) DEALLOCATE(FINEARR)
      IF (ALLOCATED(NEWLEV))  DEALLOCATE(NEWLEV)
      IF (ALLOCATED(INDICATOR)) DEALLOCATE(INDICATOR)
      END

C*********************************************************************
      SUBROUTINE GETGAPI (PRT,NERR)
C*********************************************************************

C  Input and print output indexes for grid element arrays

C  PRT = .TRUE. ==> Print even if no change in indexes (input, LOGICAL)

C  NERR = Error number steped by 1 on error (input & output, INTEGER)

C*********************************************************************
C      INCLUDE 'msjunk.h'

      PARAMETER (MXR=3)
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'output.h'
      CHARACTER*60 BNAM
      LOGICAL PRT

      IF (LEVELE.AND.BUGKEY(1)) THEN
         WRITE (NFBUG,*)'PROC',MYPRC,' ENTERING SUBROUTINE GETGAPI'
         WRITE (*,*)'PROC',MYPRC,' ENTERING SUBROUTINE GETGAPI'
      ENDIF

C  READ THE INDEX DATA

      N=0
      IF (PRT) N=1
      CALL GETVAL('IFIRST ',I1AP,'I4',10,MXR,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'IFIRST'
      N=N+NDUM
      CALL GETVAL('ILAST ',I2AP,'I4',10,MXR,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'ILAST'
      N=N+NDUM
      CALL GETVAL('ISTEP ',ISAP,'I4',10,MXR,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'ISTEP'
      N=N+NDUM
      CALL GETVAL('JFIRST ',J1AP,'I4',10,MXR,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'JFIRST'
      N=N+NDUM
      CALL GETVAL('JLAST ',J2AP,'I4',10,MXR,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'JLAST'
      N=N+NDUM
      CALL GETVAL('JSTEP ',JSAP,'I4',10,MXR,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'JSTEP'
      N=N+NDUM
      CALL GETVAL('KFIRST ',K1AP,'I4',10,MXR,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'KFIRST'
      N=N+NDUM
      CALL GETVAL('KLAST ',K2AP,'I4',10,MXR,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'KLAST'
      N=N+NDUM
      CALL GETVAL('KSTEP ',KSAP,'I4',10,MXR,0,0,NDUM,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'KSTEP'
      N=N+NDUM
   77 FORMAT(/' Input file ERROR for ',A)

      IF (N.EQ.0) RETURN

      DO 9 I=1,NUMBLK
      NUMREG(I)=0
      DO 10 J=1,MXR
      IF (I1AP(I,J).LT.1.OR.J1AP(I,J).LT.1.OR.K1AP(I,J).LT.1)
     & GO TO 9
   10 NUMREG(I)=J
    9 CONTINUE

C  PRINT INDEX AND GRAVITY DATA

      IF (LEVELC) THEN
         DO 3 I=1,NUMBLK
         CALL BLKNAME(I,BNAM,IERR)
         WRITE (NFOUT,4) BNAM
    4    FORMAT(/1X,A60)
         IF (PRT) THEN
            CALL BLKDIM(I,NX,NY,NZ,IERR)
            WRITE (NFOUT,8) NX,NY,NZ
    8       FORMAT(5X,'NX =',I6,5X,'NY =',I6,5X,'NZ =',I6)
            WRITE (NFOUT,28) (DOWN(J,I),J=1,3)
   28       FORMAT(5X,'NORMALIZED GRAVITY VECTOR (DOWN)',5X,3F9.6)
         ENDIF
         DO 3 L=1,NUMREG(I)
         WRITE (NFOUT,11) L
   11    FORMAT('     PRINT REGION',I3,":")
         WRITE (NFOUT,5) I1AP(I,L),I2AP(I,L),ISAP(I,L)
    5    FORMAT(5X,'FIRST, LAST, AND STEP I FOR OUTPUT (IFIRST,ILAST,'
     &   ,'ISTEP)',3I5)
         WRITE (NFOUT,6) J1AP(I,L),J2AP(I,L),JSAP(I,L)
    6    FORMAT(5X,'FIRST, LAST, AND STEP J FOR OUTPUT (JFIRST,JLAST,'
     &   ,'JSTEP)',3I5)
         WRITE (NFOUT,7) K1AP(I,L),K2AP(I,L),KSAP(I,L)
    7    FORMAT(5X,'FIRST, LAST, AND STEP K FOR OUTPUT (KFIRST,KLAST,'
     &   ,'KSTEP)',3I5)
    3    CONTINUE
      ENDIF

      END
C*********************************************************************
      SUBROUTINE MAKEMAP (NC,NERR)
C*********************************************************************

C  Reads aerial grid map and initializes PRCMAP

C  NC = Number of characters required to read GRIDMAP

C  NERR = Error number steped by 1 on error (input & output, INTEGER)

C  NOTE:  PRCMAP() = -1 ==> Grid column in the system
C         PRCMAP() = -2 ==> Grid column not in the system

C*********************************************************************
C      INCLUDE 'msjunk.h'

      INCLUDE 'control.h'
      INCLUDE 'layout.h'

      CHARACTER*1 BLKBUF(NC),RECEND,TEXEND,BLANK,B
      CHARACTER*78 TT
      INTEGER LOCTA(50),LENTA(50)

      IF (LEVELE.AND.BUGKEY(1)) THEN
         WRITE (NFBUG,*)'PROC',MYPRC,' ENTERING SUBROUTINE MAKEMAP'
         WRITE (*,*)'PROC',MYPRC,' ENTERING SUBROUTINE MAKEMAP'
      ENDIF

      RECEND=CHAR(30)
      TEXEND=CHAR(31)
      BLANK=CHAR(32)

      DO 18 N=1,NUMBLK
      LOCTA(N)=0
   18 LENTA(N)=0

CBW INITIALIZE PRCMAPN AND N0MAPN FOR NODAL BASED COMMUNICATION
      NFRE=1
      DO N=1,NUMBLK
         CALL BLKDIM(N,NX,NY,NZ,KERR)
         N0=NFRE-(NY+1)-1
         N0MAPN(N)=N0
         NFRE=NFRE+(NY+1)*(NZ+1)
         DO K=1,NZ+1
            DO J=1,NY+1
               PRCMAPN(N0+K*(NY+1)+J)=-2
            ENDDO
         ENDDO
      ENDDO
CBW

      CALL GETBLK('GRIDMAP ',BLKBUF,NC,NUMBLK,LOCTA,LENTA,NERR)
      IF ((NERR.GT.0).AND.LEVELC) WRITE(NFOUT,77) 'GRIDMAP'
   77 FORMAT(/' Input file ERROR for ',A)

      NFRE=1
      DO 1 N=1,NUMBLK
      CALL BLKDIM (N,NX,NY,NZ,KERR)
      N0=NFRE-NY-1
      N0MAP(N)=N0
      NYMAP(N)=NY
      NCPB=NY*NZ

C  ASSUME NO KEYED OUT COLUMNS

      DO 2 I=1,NCPB
    2 PRCMAP(NFRE-1+I)=-1
      NFRE=NFRE+NCPB

      IF (LENTA(N).GT.0) THEN

C  USE INPUT TO KEY OUT COLUMNS IN PRCMAP

         L1=LOCTA(N)
         L2=L1+LENTA(N)-1
         K=1
         J=1
         DO 3 L=L1,L2
         B=BLKBUF(L)
         IF (B.EQ.TEXEND) GO TO 4
         IF (B.EQ.RECEND) THEN
            IF (J.LE.NY) THEN
               DO 5 JJ=J,NY
    5          PRCMAP(N0+NY*K+JJ)=-2
            ENDIF
            J=1
            K=K+1
            GO TO 3
         ENDIF
         IF (B.EQ.BLANK) PRCMAP(N0+NY*K+J)=-2
         J=J+1
    3    CONTINUE
    4    IF (K.LE.NZ) THEN
            DO 6 KK=K,NZ
            DO 6 JJ=1,NY
    6       PRCMAP(N0+NY*KK+JJ)=-2
         ENDIF
      ENDIF

    1 CONTINUE

C  PRINT COLUMN MAP

      IF (.NOT.LEVELC) RETURN

      DO 10 N=1,NUMBLK
      IF (LENTA(N).GT.0) THEN
         TT='GRID COLUMN PATTERN FOR FAULT BLOCK'
         CALL MAKTIT (TT,78,N)
         WRITE (NFOUT,11) TT
   11    FORMAT(/1X,A78)
         CALL BLKDIM (N,NX,NY,NZ,KERR)
         N0=N0MAP(N)
         J1=1
   12    J2=J1+73
         IF (J2.GT.NY) J2=NY
         WRITE (NFOUT,16) (JJ,JJ=J1,J2,5)
   16    FORMAT(/' ',15I5)
         DO 14 K=1,NZ
         NN=N0+K*NY
         L=0
         L2=1
         DO 15 J=J1,J2
         L=L+1
         IF (PRCMAP(NN+J).EQ.-1) THEN
            BLKBUF(L)='X'
            L2=L
         ELSE
            BLKBUF(L)=' '
         ENDIF
   15    CONTINUE
   14    WRITE (NFOUT,17)K,(BLKBUF(L),L=1,L2)
   17    FORMAT(I4,' ',74A1)
         IF (J2.LT.NY) THEN
            J1=J2+1
            GO TO 12
         ENDIF
      ENDIF
   10 CONTINUE

      END

C*********************************************************************
      SUBROUTINE SETBLKS(NERR)
C*********************************************************************

      INTEGER NERR
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INTEGER ALL

C FOR ALL THE MODELS EXCEPT MULTIMODEL SET THE UNIQUE MODEL NUMBER
C FOR EACH FAULTBLOCK

      DO I=1,10
         BLKMODEL(I) = MODBLK(I)
      ENDDO

C FOR MULTI MODEL GET THE INFO ABOUT MODELS FOR BLOCKS FROM INPUT FILE

C      IF (MODEL.EQ.7) CALL MSETBLKS(NERR)

C MAKE IT AVAILABLE TO THE C CODE

      CALL C_SETBLKS(BLKMODEL,MYPRC)

C FOR NON- MULTI MODEL SITUATION THE CURRENT MODEL IS SET ONCE ONLY
C TO THE VALUE OF MODEL, FOR MULTIMODEL THE MODEL CHANGES

      ALL = MODEL

C      IF (MODEL.EQ.7) ALL = 0

      CALL SETMODEL(ALL)

      END

C*********************************************************************
      SUBROUTINE SETMODEL(NMODEL)
C*********************************************************************

      INCLUDE 'control.h'

      CURRENT_MODEL = NMODEL

      CALL C_SETMODEL(NMODEL)

      END

